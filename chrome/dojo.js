//>>built

(function (userConfig, defaultConfig) {
    var noop = function () {
    }, isEmpty = function (it) {
        for (var p in it) {
            return 0;
        }
        return 1;
    }, toString = {}.toString, isFunction = function (it) {
        return toString.call(it) == "[object Function]";
    }, isString = function (it) {
        return toString.call(it) == "[object String]";
    }, isArray = function (it) {
        return toString.call(it) == "[object Array]";
    }, forEach = function (vector, callback) {
        if (vector) {
            for (var i = 0; i < vector.length; ) {
                callback(vector[i++]);
            }
        }
    }, mix = function (dest, src) {
        for (var p in src) {
            dest[p] = src[p];
        }
        return dest;
    }, makeError = function (error, info) {
        return mix(new Error(error), {src:"dojoLoader", info:info});
    }, uidSeed = 1, uid = function () {
        return "_" + uidSeed++;
    }, req = function (config, dependencies, callback) {
        return contextRequire(config, dependencies, callback, 0, req);
    }, global = this, doc = global.document, element = doc && doc.createElement("DiV"), has = req.has = function (name) {
        return isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];
    }, hasCache = has.cache = defaultConfig.hasCache;
    has.add = function (name, test, now, force) {
        (hasCache[name] === undefined || force) && (hasCache[name] = test);
        return now && has(name);
    };
    0 && has.add("host-node", userConfig.has && "host-node" in userConfig.has ? userConfig.has["host-node"] : (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
    if (0) {
        require("./_base/configNode.js").config(defaultConfig);
        defaultConfig.loaderPatch.nodeRequire = require;
    }
    0 && has.add("host-rhino", userConfig.has && "host-rhino" in userConfig.has ? userConfig.has["host-rhino"] : (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
    if (0) {
        for (var baseUrl = userConfig.baseUrl || ".", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length; ) {
            arg = (rhinoArgs[i++] + "").split("=");
            if (arg[0] == "baseUrl") {
                baseUrl = arg[1];
                break;
            }
        }
        load(baseUrl + "/_base/configRhino.js");
        rhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);
    }
    for (var p in userConfig.has) {
        has.add(p, userConfig.has[p], 0, 1);
    }
    var requested = 1, arrived = 2, nonmodule = 3, executing = 4, executed = 5;
    if (0) {
        requested = "requested";
        arrived = "arrived";
        nonmodule = "not-a-module";
        executing = "executing";
        executed = "executed";
    }
    var legacyMode = 0, sync = "sync", xd = "xd", syncExecStack = [], dojoRequirePlugin = 0, checkDojoRequirePlugin = noop, transformToAmd = noop, getXhr;
    if (1) {
        req.isXdUrl = noop;
        req.initSyncLoader = function (dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_) {
            if (!dojoRequirePlugin) {
                dojoRequirePlugin = dojoRequirePlugin_;
                checkDojoRequirePlugin = checkDojoRequirePlugin_;
                transformToAmd = transformToAmd_;
            }
            return {sync:sync, requested:requested, arrived:arrived, nonmodule:nonmodule, executing:executing, executed:executed, syncExecStack:syncExecStack, modules:modules, execQ:execQ, getModule:getModule, injectModule:injectModule, setArrived:setArrived, signal:signal, finishExec:finishExec, execModule:execModule, dojoRequirePlugin:dojoRequirePlugin, getLegacyMode:function () {
                return legacyMode;
            }, guardCheckComplete:guardCheckComplete};
        };
        if (1) {
            var locationProtocol = location.protocol, locationHost = location.host;
            req.isXdUrl = function (url) {
                if (/^\./.test(url)) {
                    return false;
                }
                if (/^\/\//.test(url)) {
                    return true;
                }
                var match = url.match(/^([^\/\:]+\:)\/+([^\/]+)/);
                return match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));
            };
            1 || has.add("dojo-xhr-factory", 1);
            has.add("dojo-force-activex-xhr", 1 && !doc.addEventListener && window.location.protocol == "file:");
            has.add("native-xhr", typeof XMLHttpRequest != "undefined");
            if (has("native-xhr") && !has("dojo-force-activex-xhr")) {
                getXhr = function () {
                    return new XMLHttpRequest();
                };
            } else {
                for (var XMLHTTP_PROGIDS = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"], progid, i = 0; i < 3; ) {
                    try {
                        progid = XMLHTTP_PROGIDS[i++];
                        if (new ActiveXObject(progid)) {
                            break;
                        }
                    }
                    catch (e) {
                    }
                }
                getXhr = function () {
                    return new ActiveXObject(progid);
                };
            }
            req.getXhr = getXhr;
            has.add("dojo-gettext-api", 1);
            req.getText = function (url, async, onLoad) {
                var xhr = getXhr();
                xhr.open("GET", fixupUrl(url), false);
                xhr.send(null);
                if (xhr.status == 200 || (!location.host && !xhr.status)) {
                    if (onLoad) {
                        onLoad(xhr.responseText, async);
                    }
                } else {
                    throw makeError("xhrFailed", xhr.status);
                }
                return xhr.responseText;
            };
        }
    } else {
        req.async = 1;
    }
    var eval_ = new Function("return eval(arguments[0]);");
    req.eval = function (text, hint) {
        return eval_(text + "\r\n////@ sourceURL=" + hint);
    };
    var listenerQueues = {}, error = "error", signal = req.signal = function (type, args) {
        var queue = listenerQueues[type];
        forEach(queue && queue.slice(0), function (listener) {
            listener.apply(null, isArray(args) ? args : [args]);
        });
    }, on = req.on = function (type, listener) {
        var queue = listenerQueues[type] || (listenerQueues[type] = []);
        queue.push(listener);
        return {remove:function () {
            for (var i = 0; i < queue.length; i++) {
                if (queue[i] === listener) {
                    queue.splice(i, 1);
                    return;
                }
            }
        }};
    };
    var aliases = [], paths = {}, pathsMapProg = [], packs = {}, map = req.map = {}, mapProgs = [], modules = {}, cacheBust = "", cache = {}, urlKeyPrefix = "url:", pendingCacheInsert = {}, dojoSniffConfig = {}, insertPointSibling = 0;
    if (1) {
        var consumePendingCacheInsert = function (referenceModule) {
            var p, item, match, now, m;
            for (p in pendingCacheInsert) {
                item = pendingCacheInsert[p];
                match = p.match(/^url\:(.+)/);
                if (match) {
                    cache[urlKeyPrefix + toUrl(match[1], referenceModule)] = item;
                } else {
                    if (p == "*now") {
                        now = item;
                    } else {
                        if (p != "*noref") {
                            m = getModuleInfo(p, referenceModule, true);
                            cache[m.mid] = cache[urlKeyPrefix + m.url] = item;
                        }
                    }
                }
            }
            if (now) {
                now(createRequire(referenceModule));
            }
            pendingCacheInsert = {};
        }, escapeString = function (s) {
            return s.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function (c) {
                return "\\" + c;
            });
        }, computeMapProg = function (map, dest) {
            dest.splice(0, dest.length);
            for (var p in map) {
                dest.push([p, map[p], new RegExp("^" + escapeString(p) + "(/|$)"), p.length]);
            }
            dest.sort(function (lhs, rhs) {
                return rhs[3] - lhs[3];
            });
            return dest;
        }, computeAliases = function (config, dest) {
            forEach(config, function (pair) {
                dest.push([isString(pair[0]) ? new RegExp("^" + escapeString(pair[0]) + "$") : pair[0], pair[1]]);
            });
        }, fixupPackageInfo = function (packageInfo) {
            var name = packageInfo.name;
            if (!name) {
                name = packageInfo;
                packageInfo = {name:name};
            }
            packageInfo = mix({main:"main"}, packageInfo);
            packageInfo.location = packageInfo.location ? packageInfo.location : name;
            if (packageInfo.packageMap) {
                map[name] = packageInfo.packageMap;
            }
            if (!packageInfo.main.indexOf("./")) {
                packageInfo.main = packageInfo.main.substring(2);
            }
            packs[name] = packageInfo;
        }, delayedModuleConfig = [], config = function (config, booting, referenceModule) {
            for (var p in config) {
                if (p == "waitSeconds") {
                    req.waitms = (config[p] || 0) * 1000;
                }
                if (p == "cacheBust") {
                    cacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + "") : "";
                }
                if (p == "baseUrl" || p == "combo") {
                    req[p] = config[p];
                }
                if (1 && p == "async") {
                    var mode = config[p];
                    req.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));
                    req.async = !legacyMode;
                }
                if (config[p] !== hasCache) {
                    req.rawConfig[p] = config[p];
                    p != "has" && has.add("config-" + p, config[p], 0, booting);
                }
            }
            if (!req.baseUrl) {
                req.baseUrl = "./";
            }
            if (!/\/$/.test(req.baseUrl)) {
                req.baseUrl += "/";
            }
            for (p in config.has) {
                has.add(p, config.has[p], 0, booting);
            }
            forEach(config.packages, fixupPackageInfo);
            for (baseUrl in config.packagePaths) {
                forEach(config.packagePaths[baseUrl], function (packageInfo) {
                    var location = baseUrl + "/" + packageInfo;
                    if (isString(packageInfo)) {
                        packageInfo = {name:packageInfo};
                    }
                    packageInfo.location = location;
                    fixupPackageInfo(packageInfo);
                });
            }
            computeMapProg(mix(map, config.map), mapProgs);
            forEach(mapProgs, function (item) {
                item[1] = computeMapProg(item[1], []);
                if (item[0] == "*") {
                    mapProgs.star = item;
                }
            });
            computeMapProg(mix(paths, config.paths), pathsMapProg);
            computeAliases(config.aliases, aliases);
            if (booting) {
                delayedModuleConfig.push({config:config.config});
            } else {
                for (p in config.config) {
                    var module = getModule(p, referenceModule);
                    module.config = mix(module.config || {}, config.config[p]);
                }
            }
            if (config.cache) {
                consumePendingCacheInsert();
                pendingCacheInsert = config.cache;
                if (config.cache["*noref"]) {
                    consumePendingCacheInsert();
                }
            }
            signal("config", [config, req.rawConfig]);
        };
        if (has("dojo-cdn") || 1) {
            var scripts = doc.getElementsByTagName("script"), i = 0, script, dojoDir, src, match;
            while (i < scripts.length) {
                script = scripts[i++];
                if ((src = script.getAttribute("src")) && (match = src.match(/(((.*)\/)|^)dojo\.js(\W|$)/i))) {
                    dojoDir = match[3] || "";
                    defaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;
                    insertPointSibling = script;
                }
                if ((src = (script.getAttribute("data-dojo-config") || script.getAttribute("djConfig")))) {
                    dojoSniffConfig = req.eval("({ " + src + " })", "data-dojo-config");
                    insertPointSibling = script;
                }
                if (0) {
                    if ((src = script.getAttribute("data-main"))) {
                        dojoSniffConfig.deps = dojoSniffConfig.deps || [src];
                    }
                }
            }
        }
        if (0) {
            try {
                if (window.parent != window && window.parent.require) {
                    var doh = window.parent.require("doh");
                    doh && mix(dojoSniffConfig, doh.testConfig);
                }
            }
            catch (e) {
            }
        }
        req.rawConfig = {};
        config(defaultConfig, 1);
        if (has("dojo-cdn")) {
            packs.dojo.location = dojoDir;
            if (dojoDir) {
                dojoDir += "/";
            }
            packs.dijit.location = dojoDir + "../dijit/";
            packs.dojox.location = dojoDir + "../dojox/";
        }
        config(userConfig, 1);
        config(dojoSniffConfig, 1);
    } else {
        paths = defaultConfig.paths;
        pathsMapProg = defaultConfig.pathsMapProg;
        packs = defaultConfig.packs;
        aliases = defaultConfig.aliases;
        mapProgs = defaultConfig.mapProgs;
        modules = defaultConfig.modules;
        cache = defaultConfig.cache;
        cacheBust = defaultConfig.cacheBust;
        req.rawConfig = defaultConfig;
    }
    if (0) {
        req.combo = req.combo || {add:noop};
        var comboPending = 0, combosPending = [], comboPendingTimer = null;
    }
    var injectDependencies = function (module) {
        guardCheckComplete(function () {
            forEach(module.deps, injectModule);
            if (0 && comboPending && !comboPendingTimer) {
                comboPendingTimer = setTimeout(function () {
                    comboPending = 0;
                    comboPendingTimer = null;
                    req.combo.done(function (mids, url) {
                        var onLoadCallback = function () {
                            runDefQ(0, mids);
                            checkComplete();
                        };
                        combosPending.push(mids);
                        injectingModule = mids;
                        req.injectUrl(url, onLoadCallback, mids);
                        injectingModule = 0;
                    }, req);
                }, 0);
            }
        });
    }, contextRequire = function (a1, a2, a3, referenceModule, contextRequire) {
        var module, syntheticMid;
        if (isString(a1)) {
            module = getModule(a1, referenceModule, true);
            if (module && module.executed) {
                return module.result;
            }
            throw makeError("undefinedModule", a1);
        }
        if (!isArray(a1)) {
            config(a1, 0, referenceModule);
            a1 = a2;
            a2 = a3;
        }
        if (isArray(a1)) {
            if (!a1.length) {
                a2 && a2();
            } else {
                syntheticMid = "require*" + uid();
                for (var mid, deps = [], i = 0; i < a1.length; ) {
                    mid = a1[i++];
                    deps.push(getModule(mid, referenceModule));
                }
                module = mix(makeModuleInfo("", syntheticMid, 0, ""), {injected:arrived, deps:deps, def:a2 || noop, require:referenceModule ? referenceModule.require : req, gc:1});
                modules[module.mid] = module;
                injectDependencies(module);
                var strict = checkCompleteGuard && legacyMode != sync;
                guardCheckComplete(function () {
                    execModule(module, strict);
                });
                if (!module.executed) {
                    execQ.push(module);
                }
                checkComplete();
            }
        }
        return contextRequire;
    }, createRequire = function (module) {
        if (!module) {
            return req;
        }
        var result = module.require;
        if (!result) {
            result = function (a1, a2, a3) {
                return contextRequire(a1, a2, a3, module, result);
            };
            module.require = mix(result, req);
            result.module = module;
            result.toUrl = function (name) {
                return toUrl(name, module);
            };
            result.toAbsMid = function (mid) {
                return toAbsMid(mid, module);
            };
            if (0) {
                result.undef = function (mid) {
                    req.undef(mid, module);
                };
            }
            if (1) {
                result.syncLoadNls = function (mid) {
                    var nlsModuleInfo = getModuleInfo(mid, module), nlsModule = modules[nlsModuleInfo.mid];
                    if (!nlsModule || !nlsModule.executed) {
                        cached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];
                        if (cached) {
                            evalModuleText(cached);
                            nlsModule = modules[nlsModuleInfo.mid];
                        }
                    }
                    return nlsModule && nlsModule.executed && nlsModule.result;
                };
            }
        }
        return result;
    }, execQ = [], defQ = [], waiting = {}, setRequested = function (module) {
        module.injected = requested;
        waiting[module.mid] = 1;
        if (module.url) {
            waiting[module.url] = module.pack || 1;
        }
        startTimer();
    }, setArrived = function (module) {
        module.injected = arrived;
        delete waiting[module.mid];
        if (module.url) {
            delete waiting[module.url];
        }
        if (isEmpty(waiting)) {
            clearTimer();
            1 && legacyMode == xd && (legacyMode = sync);
        }
    }, execComplete = req.idle = function () {
        return !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;
    }, runMapProg = function (targetMid, map) {
        if (map) {
            for (var i = 0; i < map.length; i++) {
                if (map[i][2].test(targetMid)) {
                    return map[i];
                }
            }
        }
        return 0;
    }, compactPath = function (path) {
        var result = [], segment, lastSegment;
        path = path.replace(/\\/g, "/").split("/");
        while (path.length) {
            segment = path.shift();
            if (segment == ".." && result.length && lastSegment != "..") {
                result.pop();
                lastSegment = result[result.length - 1];
            } else {
                if (segment != ".") {
                    result.push(lastSegment = segment);
                }
            }
        }
        return result.join("/");
    }, makeModuleInfo = function (pid, mid, pack, url) {
        if (1) {
            var xd = req.isXdUrl(url);
            return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};
        } else {
            return {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};
        }
    }, getModuleInfo_ = function (mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate) {
        var pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;
        requestedMid = mid;
        isRelative = /^\./.test(mid);
        if (/(^\/)|(\:)|(\.js$)/.test(mid) || (isRelative && !referenceModule)) {
            return makeModuleInfo(0, mid, 0, mid);
        } else {
            mid = compactPath(isRelative ? (referenceModule.mid + "/../" + mid) : mid);
            if (/^\./.test(mid)) {
                throw makeError("irrationalPath", mid);
            }
            if (referenceModule) {
                mapItem = runMapProg(referenceModule.mid, mapProgs);
            }
            mapItem = mapItem || mapProgs.star;
            mapItem = mapItem && runMapProg(mid, mapItem[1]);
            if (mapItem) {
                mid = mapItem[1] + mid.substring(mapItem[3]);
            }
            match = mid.match(/^([^\/]+)(\/(.+))?$/);
            pid = match ? match[1] : "";
            if ((pack = packs[pid])) {
                mid = pid + "/" + (midInPackage = (match[3] || pack.main));
            } else {
                pid = "";
            }
            var candidateLength = 0, candidate = 0;
            forEach(aliases, function (pair) {
                var match = mid.match(pair[0]);
                if (match && match.length > candidateLength) {
                    candidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];
                }
            });
            if (candidate) {
                return getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);
            }
            result = modules[mid];
            if (result) {
                return alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];
            }
        }
        mapItem = runMapProg(mid, pathsMapProg);
        if (mapItem) {
            url = mapItem[1] + mid.substring(mapItem[3]);
        } else {
            if (pid) {
                url = pack.location + "/" + midInPackage;
            } else {
                if (has("config-tlmSiblingOfDojo")) {
                    url = "../" + mid;
                } else {
                    url = mid;
                }
            }
        }
        if (!(/(^\/)|(\:)/.test(url))) {
            url = baseUrl + url;
        }
        url += ".js";
        return makeModuleInfo(pid, mid, pack, compactPath(url));
    }, getModuleInfo = function (mid, referenceModule, fromPendingCache) {
        return getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, fromPendingCache ? [] : mapProgs, fromPendingCache ? [] : pathsMapProg, fromPendingCache ? [] : aliases);
    }, resolvePluginResourceId = function (plugin, prid, referenceModule) {
        return plugin.normalize ? plugin.normalize(prid, function (mid) {
            return toAbsMid(mid, referenceModule);
        }) : toAbsMid(prid, referenceModule);
    }, dynamicPluginUidGenerator = 0, getModule = function (mid, referenceModule, immediate) {
        var match, plugin, prid, result;
        match = mid.match(/^(.+?)\!(.*)$/);
        if (match) {
            plugin = getModule(match[1], referenceModule, immediate);
            if (1 && legacyMode == sync && !plugin.executed) {
                injectModule(plugin);
                if (plugin.injected === arrived && !plugin.executed) {
                    guardCheckComplete(function () {
                        execModule(plugin);
                    });
                }
                if (plugin.executed) {
                    promoteModuleToPlugin(plugin);
                } else {
                    execQ.unshift(plugin);
                }
            }
            if (plugin.executed === executed && !plugin.load) {
                promoteModuleToPlugin(plugin);
            }
            if (plugin.load) {
                prid = resolvePluginResourceId(plugin, match[2], referenceModule);
                mid = (plugin.mid + "!" + (plugin.dynamic ? ++dynamicPluginUidGenerator + "!" : "") + prid);
            } else {
                prid = match[2];
                mid = plugin.mid + "!" + (++dynamicPluginUidGenerator) + "!waitingForPlugin";
            }
            result = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};
        } else {
            result = getModuleInfo(mid, referenceModule);
        }
        return modules[result.mid] || (!immediate && (modules[result.mid] = result));
    }, toAbsMid = req.toAbsMid = function (mid, referenceModule) {
        return getModuleInfo(mid, referenceModule).mid;
    }, toUrl = req.toUrl = function (name, referenceModule) {
        var moduleInfo = getModuleInfo(name + "/x", referenceModule), url = moduleInfo.url;
        return fixupUrl(moduleInfo.pid === 0 ? name : url.substring(0, url.length - 5));
    }, nonModuleProps = {injected:arrived, executed:executed, def:nonmodule, result:nonmodule}, makeCjs = function (mid) {
        return modules[mid] = mix({mid:mid}, nonModuleProps);
    }, cjsRequireModule = makeCjs("require"), cjsExportsModule = makeCjs("exports"), cjsModuleModule = makeCjs("module"), runFactory = function (module, args) {
        req.trace("loader-run-factory", [module.mid]);
        var factory = module.def, result;
        1 && syncExecStack.unshift(module);
        if (has("config-dojo-loader-catches")) {
            try {
                result = isFunction(factory) ? factory.apply(null, args) : factory;
            }
            catch (e) {
                signal(error, module.result = makeError("factoryThrew", [module, e]));
            }
        } else {
            result = isFunction(factory) ? factory.apply(null, args) : factory;
        }
        module.result = result === undefined && module.cjs ? module.cjs.exports : result;
        1 && syncExecStack.shift(module);
    }, abortExec = {}, defOrder = 0, promoteModuleToPlugin = function (pluginModule) {
        var plugin = pluginModule.result;
        pluginModule.dynamic = plugin.dynamic;
        pluginModule.normalize = plugin.normalize;
        pluginModule.load = plugin.load;
        return pluginModule;
    }, resolvePluginLoadQ = function (plugin) {
        var map = {};
        forEach(plugin.loadQ, function (pseudoPluginResource) {
            var prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module), mid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + "!" + prid), pluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});
            if (!modules[mid]) {
                injectPlugin(modules[mid] = pluginResource);
            }
            map[pseudoPluginResource.mid] = modules[mid];
            setArrived(pseudoPluginResource);
            delete modules[pseudoPluginResource.mid];
        });
        plugin.loadQ = 0;
        var substituteModules = function (module) {
            for (var replacement, deps = module.deps || [], i = 0; i < deps.length; i++) {
                replacement = map[deps[i].mid];
                if (replacement) {
                    deps[i] = replacement;
                }
            }
        };
        for (var p in modules) {
            substituteModules(modules[p]);
        }
        forEach(execQ, substituteModules);
    }, finishExec = function (module) {
        req.trace("loader-finish-exec", [module.mid]);
        module.executed = executed;
        module.defOrder = defOrder++;
        1 && forEach(module.provides, function (cb) {
            cb();
        });
        if (module.loadQ) {
            promoteModuleToPlugin(module);
            resolvePluginLoadQ(module);
        }
        for (i = 0; i < execQ.length; ) {
            if (execQ[i] === module) {
                execQ.splice(i, 1);
            } else {
                i++;
            }
        }
        if (/^require\*/.test(module.mid)) {
            delete modules[module.mid];
        }
    }, circleTrace = [], execModule = function (module, strict) {
        if (module.executed === executing) {
            req.trace("loader-circular-dependency", [circleTrace.concat(module.mid).join("->")]);
            return (!module.def || strict) ? abortExec : (module.cjs && module.cjs.exports);
        }
        if (!module.executed) {
            if (!module.def) {
                return abortExec;
            }
            var mid = module.mid, deps = module.deps || [], arg, argResult, args = [], i = 0;
            if (0) {
                circleTrace.push(mid);
                req.trace("loader-exec-module", ["exec", circleTrace.length, mid]);
            }
            module.executed = executing;
            while ((arg = deps[i++])) {
                argResult = ((arg === cjsRequireModule) ? createRequire(module) : ((arg === cjsExportsModule) ? module.cjs.exports : ((arg === cjsModuleModule) ? module.cjs : execModule(arg, strict))));
                if (argResult === abortExec) {
                    module.executed = 0;
                    req.trace("loader-exec-module", ["abort", mid]);
                    0 && circleTrace.pop();
                    return abortExec;
                }
                args.push(argResult);
            }
            runFactory(module, args);
            finishExec(module);
            0 && circleTrace.pop();
        }
        return module.result;
    }, checkCompleteGuard = 0, guardCheckComplete = function (proc) {
        try {
            checkCompleteGuard++;
            proc();
        }
        finally {
            checkCompleteGuard--;
        }
        if (execComplete()) {
            signal("idle", []);
        }
    }, checkComplete = function () {
        if (checkCompleteGuard) {
            return;
        }
        guardCheckComplete(function () {
            checkDojoRequirePlugin();
            for (var currentDefOrder, module, i = 0; i < execQ.length; ) {
                currentDefOrder = defOrder;
                module = execQ[i];
                execModule(module);
                if (currentDefOrder != defOrder) {
                    checkDojoRequirePlugin();
                    i = 0;
                } else {
                    i++;
                }
            }
        });
    };
    if (0) {
        req.undef = function (moduleId, referenceModule) {
            var module = getModule(moduleId, referenceModule);
            setArrived(module);
            mix(module, {def:0, executed:0, injected:0, node:0});
        };
    }
    if (1) {
        if (has("dojo-loader-eval-hint-url") === undefined) {
            has.add("dojo-loader-eval-hint-url", 1);
        }
        var fixupUrl = function (url) {
            url += "";
            return url + (cacheBust ? ((/\?/.test(url) ? "&" : "?") + cacheBust) : "");
        }, injectPlugin = function (module) {
            var plugin = module.plugin;
            if (plugin.executed === executed && !plugin.load) {
                promoteModuleToPlugin(plugin);
            }
            var onLoad = function (def) {
                module.result = def;
                setArrived(module);
                finishExec(module);
                checkComplete();
            };
            if (plugin.load) {
                plugin.load(module.prid, module.req, onLoad);
            } else {
                if (plugin.loadQ) {
                    plugin.loadQ.push(module);
                } else {
                    plugin.loadQ = [module];
                    execQ.unshift(plugin);
                    injectModule(plugin);
                }
            }
        }, cached = 0, injectingModule = 0, injectingCachedModule = 0, evalModuleText = function (text, module) {
            if (has("config-stripStrict")) {
                text = text.replace(/"use strict"/g, "");
            }
            injectingCachedModule = 1;
            if (has("config-dojo-loader-catches")) {
                try {
                    if (text === cached) {
                        cached.call(null);
                    } else {
                        req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
                    }
                }
                catch (e) {
                    signal(error, makeError("evalModuleThrew", module));
                }
            } else {
                if (text === cached) {
                    cached.call(null);
                } else {
                    req.eval(text, has("dojo-loader-eval-hint-url") ? module.url : module.mid);
                }
            }
            injectingCachedModule = 0;
        }, injectModule = function (module) {
            var mid = module.mid, url = module.url;
            if (module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url] === module.pack) || waiting[module.url] == 1))) {
                return;
            }
            setRequested(module);
            if (0) {
                var viaCombo = 0;
                if (module.plugin && module.plugin.isCombo) {
                    req.combo.add(module.plugin.mid, module.prid, 0, req);
                    viaCombo = 1;
                } else {
                    if (!module.plugin) {
                        viaCombo = req.combo.add(0, module.mid, module.url, req);
                    }
                }
                if (viaCombo) {
                    comboPending = 1;
                    return;
                }
            }
            if (module.plugin) {
                injectPlugin(module);
                return;
            }
            var onLoadCallback = function () {
                runDefQ(module);
                if (module.injected !== arrived) {
                    if (has("dojo-enforceDefine")) {
                        signal(error, makeError("noDefine", module));
                        return;
                    }
                    setArrived(module);
                    mix(module, nonModuleProps);
                    req.trace("loader-define-nonmodule", [module.url]);
                }
                if (1 && legacyMode) {
                    !syncExecStack.length && checkComplete();
                } else {
                    checkComplete();
                }
            };
            cached = cache[mid] || cache[urlKeyPrefix + module.url];
            if (cached) {
                req.trace("loader-inject", ["cache", module.mid, url]);
                evalModuleText(cached, module);
                onLoadCallback();
                return;
            }
            if (1 && legacyMode) {
                if (module.isXd) {
                    legacyMode == sync && (legacyMode = xd);
                } else {
                    if (module.isAmd && legacyMode != sync) {
                    } else {
                        var xhrCallback = function (text) {
                            if (legacyMode == sync) {
                                syncExecStack.unshift(module);
                                evalModuleText(text, module);
                                syncExecStack.shift();
                                runDefQ(module);
                                if (!module.cjs) {
                                    setArrived(module);
                                    finishExec(module);
                                }
                                if (module.finish) {
                                    var finishMid = mid + "*finish", finish = module.finish;
                                    delete module.finish;
                                    def(finishMid, ["dojo", ("dojo/require!" + finish.join(",")).replace(/\./g, "/")], function (dojo) {
                                        forEach(finish, function (mid) {
                                            dojo.require(mid);
                                        });
                                    });
                                    execQ.unshift(getModule(finishMid));
                                }
                                onLoadCallback();
                            } else {
                                text = transformToAmd(module, text);
                                if (text) {
                                    evalModuleText(text, module);
                                    onLoadCallback();
                                } else {
                                    injectingModule = module;
                                    req.injectUrl(fixupUrl(url), onLoadCallback, module);
                                    injectingModule = 0;
                                }
                            }
                        };
                        req.trace("loader-inject", ["xhr", module.mid, url, legacyMode != sync]);
                        if (has("config-dojo-loader-catches")) {
                            try {
                                req.getText(url, legacyMode != sync, xhrCallback);
                            }
                            catch (e) {
                                signal(error, makeError("xhrInjectFailed", [module, e]));
                            }
                        } else {
                            req.getText(url, legacyMode != sync, xhrCallback);
                        }
                        return;
                    }
                }
            }
            req.trace("loader-inject", ["script", module.mid, url]);
            injectingModule = module;
            req.injectUrl(fixupUrl(url), onLoadCallback, module);
            injectingModule = 0;
        }, defineModule = function (module, deps, def) {
            req.trace("loader-define-module", [module.mid, deps]);
            if (0 && module.plugin && module.plugin.isCombo) {
                module.result = isFunction(def) ? def() : def;
                setArrived(module);
                finishExec(module);
                return module;
            }
            var mid = module.mid;
            if (module.injected === arrived) {
                signal(error, makeError("multipleDefine", module));
                return module;
            }
            mix(module, {deps:deps, def:def, cjs:{id:module.mid, uri:module.url, exports:(module.result = {}), setExports:function (exports) {
                module.cjs.exports = exports;
            }, config:function () {
                return module.config;
            }}});
            for (var i = 0; deps[i]; i++) {
                deps[i] = getModule(deps[i], module);
            }
            if (1 && legacyMode && !waiting[mid]) {
                injectDependencies(module);
                execQ.push(module);
                checkComplete();
            }
            setArrived(module);
            if (!isFunction(def) && !deps.length) {
                module.result = def;
                finishExec(module);
            }
            return module;
        }, runDefQ = function (referenceModule, mids) {
            var definedModules = [], module, args;
            while (defQ.length) {
                args = defQ.shift();
                mids && (args[0] = mids.shift());
                module = (args[0] && getModule(args[0])) || referenceModule;
                definedModules.push([module, args[1], args[2]]);
            }
            consumePendingCacheInsert(referenceModule);
            forEach(definedModules, function (args) {
                injectDependencies(defineModule.apply(null, args));
            });
        };
    }
    var timerId = 0, clearTimer = noop, startTimer = noop;
    if (1) {
        clearTimer = function () {
            timerId && clearTimeout(timerId);
            timerId = 0;
        };
        startTimer = function () {
            clearTimer();
            if (req.waitms) {
                timerId = window.setTimeout(function () {
                    clearTimer();
                    signal(error, makeError("timeout", waiting));
                }, req.waitms);
            }
        };
    }
    if (1) {
        has.add("ie-event-behavior", doc.attachEvent && typeof Windows === "undefined" && (typeof opera === "undefined" || opera.toString() != "[object Opera]"));
    }
    if (1 && (1 || 1)) {
        var domOn = function (node, eventName, ieEventName, handler) {
            if (!has("ie-event-behavior")) {
                node.addEventListener(eventName, handler, false);
                return function () {
                    node.removeEventListener(eventName, handler, false);
                };
            } else {
                node.attachEvent(ieEventName, handler);
                return function () {
                    node.detachEvent(ieEventName, handler);
                };
            }
        }, windowOnLoadListener = domOn(window, "load", "onload", function () {
            req.pageLoaded = 1;
            doc.readyState != "complete" && (doc.readyState = "complete");
            windowOnLoadListener();
        });
        if (1) {
            var scripts = doc.getElementsByTagName("script"), i = 0, script;
            while (!insertPointSibling) {
                if (!/^dojo/.test((script = scripts[i++]) && script.type)) {
                    insertPointSibling = script;
                }
            }
            req.injectUrl = function (url, callback, owner) {
                var node = owner.node = doc.createElement("script"), onLoad = function (e) {
                    e = e || window.event;
                    var node = e.target || e.srcElement;
                    if (e.type === "load" || /complete|loaded/.test(node.readyState)) {
                        loadDisconnector();
                        errorDisconnector();
                        callback && callback();
                    }
                }, loadDisconnector = domOn(node, "load", "onreadystatechange", onLoad), errorDisconnector = domOn(node, "error", "onerror", function (e) {
                    loadDisconnector();
                    errorDisconnector();
                    signal(error, makeError("scriptError", [url, e]));
                });
                node.type = "text/javascript";
                node.charset = "utf-8";
                node.src = url;
                insertPointSibling.parentNode.insertBefore(node, insertPointSibling);
                return node;
            };
        }
    }
    if (1) {
        req.log = function () {
            try {
                for (var i = 0; i < arguments.length; i++) {
                    console.log(arguments[i]);
                }
            }
            catch (e) {
            }
        };
    } else {
        req.log = noop;
    }
    if (0) {
        var trace = req.trace = function (group, args) {
            if (trace.on && trace.group[group]) {
                signal("trace", [group, args]);
                for (var arg, dump = [], text = "trace:" + group + (args.length ? (":" + args[0]) : ""), i = 1; i < args.length; ) {
                    arg = args[i++];
                    if (isString(arg)) {
                        text += ", " + arg;
                    } else {
                        dump.push(arg);
                    }
                }
                req.log(text);
                dump.length && dump.push(".");
                req.log.apply(req, dump);
            }
        };
        mix(trace, {on:1, group:{}, set:function (group, value) {
            if (isString(group)) {
                trace.group[group] = value;
            } else {
                mix(trace.group, group);
            }
        }});
        trace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));
        on("config", function (config) {
            config.trace && trace.set(config.trace);
        });
    } else {
        req.trace = noop;
    }
    var def = function (mid, dependencies, factory) {
        var arity = arguments.length, defaultDeps = ["require", "exports", "module"], args = [0, mid, dependencies];
        if (arity == 1) {
            args = [0, (isFunction(mid) ? defaultDeps : []), mid];
        } else {
            if (arity == 2 && isString(mid)) {
                args = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];
            } else {
                if (arity == 3) {
                    args = [mid, dependencies, factory];
                }
            }
        }
        if (0 && args[1] === defaultDeps) {
            args[2].toString().replace(/(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg, "").replace(/require\(["']([\w\!\-_\.\/]+)["']\)/g, function (match, dep) {
                args[1].push(dep);
            });
        }
        req.trace("loader-define", args.slice(0, 2));
        var targetModule = args[0] && getModule(args[0]), module;
        if (targetModule && !waiting[targetModule.mid]) {
            injectDependencies(defineModule(targetModule, args[1], args[2]));
        } else {
            if (!has("ie-event-behavior") || !1 || injectingCachedModule) {
                defQ.push(args);
            } else {
                targetModule = targetModule || injectingModule;
                if (!targetModule) {
                    for (mid in waiting) {
                        module = modules[mid];
                        if (module && module.node && module.node.readyState === "interactive") {
                            targetModule = module;
                            break;
                        }
                    }
                    if (0 && !targetModule) {
                        for (var i = 0; i < combosPending.length; i++) {
                            targetModule = combosPending[i];
                            if (targetModule.node && targetModule.node.readyState === "interactive") {
                                break;
                            }
                            targetModule = 0;
                        }
                    }
                }
                if (0 && isArray(targetModule)) {
                    injectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));
                    if (!targetModule.length) {
                        combosPending.splice(i, 1);
                    }
                } else {
                    if (targetModule) {
                        consumePendingCacheInsert(targetModule);
                        injectDependencies(defineModule(targetModule, args[1], args[2]));
                    } else {
                        signal(error, makeError("ieDefineFailed", args[0]));
                    }
                }
                checkComplete();
            }
        }
    };
    def.amd = {vendor:"dojotoolkit.org"};
    if (0) {
        req.def = def;
    }
    mix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);
    on(error, function (arg) {
        try {
            console.error(arg);
            if (arg instanceof Error) {
                for (var p in arg) {
                    console.log(p + ":", arg[p]);
                }
                console.log(".");
            }
        }
        catch (e) {
        }
    });
    mix(req, {uid:uid, cache:cache, packs:packs});
    if (0) {
        mix(req, {paths:paths, aliases:aliases, modules:modules, legacyMode:legacyMode, execQ:execQ, defQ:defQ, waiting:waiting, packs:packs, mapProgs:mapProgs, pathsMapProg:pathsMapProg, listenerQueues:listenerQueues, computeMapProg:computeMapProg, computeAliases:computeAliases, runMapProg:runMapProg, compactPath:compactPath, getModuleInfo:getModuleInfo_});
    }
    if (global.define) {
        if (1) {
            signal(error, makeError("defineAlreadyDefined", 0));
        }
        return;
    } else {
        global.define = def;
        global.require = req;
        if (0) {
            require = req;
        }
    }
    if (0 && req.combo && req.combo.plugins) {
        var plugins = req.combo.plugins, pluginName;
        for (pluginName in plugins) {
            mix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:"executed", load:1});
        }
    }
    if (1) {
        forEach(delayedModuleConfig, function (c) {
            config(c);
        });
        var bootDeps = dojoSniffConfig.deps || userConfig.deps || defaultConfig.deps, bootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;
        req.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;
    }
    if (!1) {
        !req.async && req(["dojo"]);
        req.boot && req.apply(null, req.boot);
    }
})(this.dojoConfig || this.djConfig || this.require || {}, {async:0, hasCache:{"config-selectorEngine":"acme", "config-tlmSiblingOfDojo":1, "dojo-built":1, "dojo-loader":1, dom:1, "host-browser":1}, packages:[{location:"../dojox", name:"dojox"}, {location:"../dijit", name:"dijit"}, {location:"../pvd", name:"pvd"}, {location:".", name:"dojo"}, {location:"../pvr", name:"pvr"}, {location:"../ecm", name:"ecm"}, {location:"../gridx", main:"Grid", name:"gridx"}, {location:"../idx", name:"idx"}]});
require({cache:{"dojo/request/default":function () {
    define(["exports", "require", "../has"], function (exports, require, has) {
        var defId = has("config-requestProvider"), platformId;
        if (1) {
            platformId = "./xhr";
        } else {
            if (0) {
                platformId = "./node";
            }
        }
        if (!defId) {
            defId = platformId;
        }
        exports.getPlatformDefaultId = function () {
            return platformId;
        };
        exports.load = function (id, parentRequire, loaded, config) {
            require([id == "platform" ? platformId : defId], function (provider) {
                loaded(provider);
            });
        };
    });
}, "dojo/date":function () {
    define(["./has", "./_base/lang"], function (has, lang) {
        var date = {};
        date.getDaysInMonth = function (dateObject) {
            var month = dateObject.getMonth();
            var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            if (month == 1 && date.isLeapYear(dateObject)) {
                return 29;
            }
            return days[month];
        };
        date.isLeapYear = function (dateObject) {
            var year = dateObject.getFullYear();
            return !(year % 400) || (!(year % 4) && !!(year % 100));
        };
        date.getTimezoneName = function (dateObject) {
            var str = dateObject.toString();
            var tz = "";
            var match;
            var pos = str.indexOf("(");
            if (pos > -1) {
                tz = str.substring(++pos, str.indexOf(")"));
            } else {
                var pat = /([A-Z\/]+) \d{4}$/;
                if ((match = str.match(pat))) {
                    tz = match[1];
                } else {
                    str = dateObject.toLocaleString();
                    pat = / ([A-Z\/]+)$/;
                    if ((match = str.match(pat))) {
                        tz = match[1];
                    }
                }
            }
            return (tz == "AM" || tz == "PM") ? "" : tz;
        };
        date.compare = function (date1, date2, portion) {
            date1 = new Date(+date1);
            date2 = new Date(+(date2 || new Date()));
            if (portion == "date") {
                date1.setHours(0, 0, 0, 0);
                date2.setHours(0, 0, 0, 0);
            } else {
                if (portion == "time") {
                    date1.setFullYear(0, 0, 0);
                    date2.setFullYear(0, 0, 0);
                }
            }
            if (date1 > date2) {
                return 1;
            }
            if (date1 < date2) {
                return -1;
            }
            return 0;
        };
        date.add = function (date, interval, amount) {
            var sum = new Date(+date);
            var fixOvershoot = false;
            var property = "Date";
            switch (interval) {
              case "day":
                break;
              case "weekday":
                var days, weeks;
                var mod = amount % 5;
                if (!mod) {
                    days = (amount > 0) ? 5 : -5;
                    weeks = (amount > 0) ? ((amount - 5) / 5) : ((amount + 5) / 5);
                } else {
                    days = mod;
                    weeks = parseInt(amount / 5);
                }
                var strt = date.getDay();
                var adj = 0;
                if (strt == 6 && amount > 0) {
                    adj = 1;
                } else {
                    if (strt == 0 && amount < 0) {
                        adj = -1;
                    }
                }
                var trgt = strt + days;
                if (trgt == 0 || trgt == 6) {
                    adj = (amount > 0) ? 2 : -2;
                }
                amount = (7 * weeks) + days + adj;
                break;
              case "year":
                property = "FullYear";
                fixOvershoot = true;
                break;
              case "week":
                amount *= 7;
                break;
              case "quarter":
                amount *= 3;
              case "month":
                fixOvershoot = true;
                property = "Month";
                break;
              default:
                property = "UTC" + interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
            }
            if (property) {
                sum["set" + property](sum["get" + property]() + amount);
            }
            if (fixOvershoot && (sum.getDate() < date.getDate())) {
                sum.setDate(0);
            }
            return sum;
        };
        date.difference = function (date1, date2, interval) {
            date2 = date2 || new Date();
            interval = interval || "day";
            var yearDiff = date2.getFullYear() - date1.getFullYear();
            var delta = 1;
            switch (interval) {
              case "quarter":
                var m1 = date1.getMonth();
                var m2 = date2.getMonth();
                var q1 = Math.floor(m1 / 3) + 1;
                var q2 = Math.floor(m2 / 3) + 1;
                q2 += (yearDiff * 4);
                delta = q2 - q1;
                break;
              case "weekday":
                var days = Math.round(date.difference(date1, date2, "day"));
                var weeks = parseInt(date.difference(date1, date2, "week"));
                var mod = days % 7;
                if (mod == 0) {
                    days = weeks * 5;
                } else {
                    var adj = 0;
                    var aDay = date1.getDay();
                    var bDay = date2.getDay();
                    weeks = parseInt(days / 7);
                    mod = days % 7;
                    var dtMark = new Date(date1);
                    dtMark.setDate(dtMark.getDate() + (weeks * 7));
                    var dayMark = dtMark.getDay();
                    if (days > 0) {
                        switch (true) {
                          case aDay == 6:
                            adj = -1;
                            break;
                          case aDay == 0:
                            adj = 0;
                            break;
                          case bDay == 6:
                            adj = -1;
                            break;
                          case bDay == 0:
                            adj = -2;
                            break;
                          case (dayMark + mod) > 5:
                            adj = -2;
                        }
                    } else {
                        if (days < 0) {
                            switch (true) {
                              case aDay == 6:
                                adj = 0;
                                break;
                              case aDay == 0:
                                adj = 1;
                                break;
                              case bDay == 6:
                                adj = 2;
                                break;
                              case bDay == 0:
                                adj = 1;
                                break;
                              case (dayMark + mod) < 0:
                                adj = 2;
                            }
                        }
                    }
                    days += adj;
                    days -= (weeks * 2);
                }
                delta = days;
                break;
              case "year":
                delta = yearDiff;
                break;
              case "month":
                delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
                break;
              case "week":
                delta = parseInt(date.difference(date1, date2, "day") / 7);
                break;
              case "day":
                delta /= 24;
              case "hour":
                delta /= 60;
              case "minute":
                delta /= 60;
              case "second":
                delta /= 1000;
              case "millisecond":
                delta *= date2.getTime() - date1.getTime();
            }
            return Math.round(delta);
        };
        1 && lang.mixin(lang.getObject("dojo.date", true), date);
        return date;
    });
}, "dojo/_base/array":function () {
    define(["./kernel", "../has", "./lang"], function (dojo, has, lang) {
        var cache = {}, u;
        function buildFn(fn) {
            return cache[fn] = new Function("item", "index", "array", fn);
        }
        function everyOrSome(some) {
            var every = !some;
            return function (a, fn, o) {
                var i = 0, l = a && a.length || 0, result;
                if (l && typeof a == "string") {
                    a = a.split("");
                }
                if (typeof fn == "string") {
                    fn = cache[fn] || buildFn(fn);
                }
                if (o) {
                    for (; i < l; ++i) {
                        result = !fn.call(o, a[i], i, a);
                        if (some ^ result) {
                            return !result;
                        }
                    }
                } else {
                    for (; i < l; ++i) {
                        result = !fn(a[i], i, a);
                        if (some ^ result) {
                            return !result;
                        }
                    }
                }
                return every;
            };
        }
        function index(up) {
            var delta = 1, lOver = 0, uOver = 0;
            if (!up) {
                delta = lOver = uOver = -1;
            }
            return function (a, x, from, last) {
                if (last && delta > 0) {
                    return array.lastIndexOf(a, x, from);
                }
                var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
                if (from === u) {
                    i = up ? lOver : l + uOver;
                } else {
                    if (from < 0) {
                        i = l + from;
                        if (i < 0) {
                            i = lOver;
                        }
                    } else {
                        i = from >= l ? l + uOver : from;
                    }
                }
                if (l && typeof a == "string") {
                    a = a.split("");
                }
                for (; i != end; i += delta) {
                    if (a[i] == x) {
                        return i;
                    }
                }
                return -1;
            };
        }
        var array = {every:everyOrSome(false), some:everyOrSome(true), indexOf:index(true), lastIndexOf:index(false), forEach:function (arr, callback, thisObject) {
            var i = 0, l = arr && arr.length || 0;
            if (l && typeof arr == "string") {
                arr = arr.split("");
            }
            if (typeof callback == "string") {
                callback = cache[callback] || buildFn(callback);
            }
            if (thisObject) {
                for (; i < l; ++i) {
                    callback.call(thisObject, arr[i], i, arr);
                }
            } else {
                for (; i < l; ++i) {
                    callback(arr[i], i, arr);
                }
            }
        }, map:function (arr, callback, thisObject, Ctr) {
            var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
            if (l && typeof arr == "string") {
                arr = arr.split("");
            }
            if (typeof callback == "string") {
                callback = cache[callback] || buildFn(callback);
            }
            if (thisObject) {
                for (; i < l; ++i) {
                    out[i] = callback.call(thisObject, arr[i], i, arr);
                }
            } else {
                for (; i < l; ++i) {
                    out[i] = callback(arr[i], i, arr);
                }
            }
            return out;
        }, filter:function (arr, callback, thisObject) {
            var i = 0, l = arr && arr.length || 0, out = [], value;
            if (l && typeof arr == "string") {
                arr = arr.split("");
            }
            if (typeof callback == "string") {
                callback = cache[callback] || buildFn(callback);
            }
            if (thisObject) {
                for (; i < l; ++i) {
                    value = arr[i];
                    if (callback.call(thisObject, value, i, arr)) {
                        out.push(value);
                    }
                }
            } else {
                for (; i < l; ++i) {
                    value = arr[i];
                    if (callback(value, i, arr)) {
                        out.push(value);
                    }
                }
            }
            return out;
        }, clearCache:function () {
            cache = {};
        }};
        1 && lang.mixin(dojo, array);
        return array;
    });
}, "dojo/currency":function () {
    define(["./_base/array", "./_base/lang", "./number", "./i18n", "./i18n!./cldr/nls/currency", "./cldr/monetary"], function (darray, lang, dnumber, i18n, nlsCurrency, cldrMonetary) {
        var currency = {};
        lang.setObject("dojo.currency", currency);
        currency._mixInDefaults = function (options) {
            options = options || {};
            options.type = "currency";
            var bundle = i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};
            var iso = options.currency;
            var data = cldrMonetary.getData(iso);
            darray.forEach(["displayName", "symbol", "group", "decimal"], function (prop) {
                data[prop] = bundle[iso + "_" + prop];
            });
            data.fractional = [true, false];
            return lang.mixin(data, options);
        };
        currency.format = function (value, options) {
            return dnumber.format(value, currency._mixInDefaults(options));
        };
        currency.regexp = function (options) {
            return dnumber.regexp(currency._mixInDefaults(options));
        };
        currency.parse = function (expression, options) {
            return dnumber.parse(expression, currency._mixInDefaults(options));
        };
        return currency;
    });
}, "dojo/_firebug/firebug":function () {
    define(["../_base/kernel", "require", "../_base/html", "../sniff", "../_base/array", "../_base/lang", "../_base/event", "../_base/unload"], function (dojo, require, html, has) {
        var isNewIE = (/Trident/.test(window.navigator.userAgent));
        if (isNewIE) {
            var calls = ["log", "info", "debug", "warn", "error"];
            for (var i = 0; i < calls.length; i++) {
                var m = calls[i];
                if (!console[m] || console[m]._fake) {
                    continue;
                }
                var n = "_" + calls[i];
                console[n] = console[m];
                console[m] = (function () {
                    var type = n;
                    return function () {
                        console[type](Array.prototype.join.call(arguments, " "));
                    };
                })();
            }
            try {
                console.clear();
            }
            catch (e) {
            }
        }
        if (has("ff") || has("chrome") || has("safari") || isNewIE || window.firebug || (typeof console != "undefined" && console.firebug) || dojo.config.useCustomLogger || has("air")) {
            return;
        }
        try {
            if (window != window.parent) {
                if (window.parent["console"]) {
                    window.console = window.parent.console;
                }
                return;
            }
        }
        catch (e) {
        }
        var _firebugDoc = document;
        var _firebugWin = window;
        var __consoleAnchorId__ = 0;
        var consoleFrame = null;
        var consoleBody = null;
        var consoleObjectInspector = null;
        var fireBugTabs = null;
        var commandLine = null;
        var consoleToolbar = null;
        var frameVisible = false;
        var messageQueue = [];
        var groupStack = [];
        var timeMap = {};
        var countMap = {};
        var consoleDomInspector = null;
        var _inspectionMoveConnection;
        var _inspectionClickConnection;
        var _inspectionEnabled = false;
        var _inspectionTimer = null;
        var _inspectTempNode = document.createElement("div");
        var _inspectCurrentNode;
        var _restoreBorderStyle;
        window.console = {_connects:[], log:function () {
            logFormatted(arguments, "");
        }, debug:function () {
            logFormatted(arguments, "debug");
        }, info:function () {
            logFormatted(arguments, "info");
        }, warn:function () {
            logFormatted(arguments, "warning");
        }, error:function () {
            logFormatted(arguments, "error");
        }, assert:function (truth, message) {
            if (!truth) {
                var args = [];
                for (var i = 1; i < arguments.length; ++i) {
                    args.push(arguments[i]);
                }
                logFormatted(args.length ? args : ["Assertion Failure"], "error");
                throw message ? message : "Assertion Failure";
            }
        }, dir:function (obj) {
            var str = printObject(obj);
            str = str.replace(/\n/g, "<br />");
            str = str.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
            logRow([str], "dir");
        }, dirxml:function (node) {
            var html = [];
            appendNode(node, html);
            logRow(html, "dirxml");
        }, group:function () {
            logRow(arguments, "group", pushGroup);
        }, groupEnd:function () {
            logRow(arguments, "", popGroup);
        }, time:function (name) {
            timeMap[name] = new Date().getTime();
        }, timeEnd:function (name) {
            if (name in timeMap) {
                var delta = (new Date()).getTime() - timeMap[name];
                logFormatted([name + ":", delta + "ms"]);
                delete timeMap[name];
            }
        }, count:function (name) {
            if (!countMap[name]) {
                countMap[name] = 0;
            }
            countMap[name]++;
            logFormatted([name + ": " + countMap[name]]);
        }, trace:function (_value) {
            var stackAmt = _value || 3;
            var f = console.trace.caller;
            console.log(">>> console.trace(stack)");
            for (var i = 0; i < stackAmt; i++) {
                var func = f.toString();
                var args = [];
                for (var a = 0; a < f.arguments.length; a++) {
                    args.push(f.arguments[a]);
                }
                if (f.arguments.length) {
                    console.dir({"function":func, "arguments":args});
                } else {
                    console.dir({"function":func});
                }
                f = f.caller;
            }
        }, profile:function () {
            this.warn(["profile() not supported."]);
        }, profileEnd:function () {
        }, clear:function () {
            if (consoleBody) {
                while (consoleBody.childNodes.length) {
                    dojo.destroy(consoleBody.firstChild);
                }
            }
            dojo.forEach(this._connects, dojo.disconnect);
        }, open:function () {
            toggleConsole(true);
        }, close:function () {
            if (frameVisible) {
                toggleConsole();
            }
        }, _restoreBorder:function () {
            if (_inspectCurrentNode) {
                _inspectCurrentNode.style.border = _restoreBorderStyle;
            }
        }, openDomInspector:function () {
            _inspectionEnabled = true;
            consoleBody.style.display = "none";
            consoleDomInspector.style.display = "block";
            consoleObjectInspector.style.display = "none";
            document.body.style.cursor = "pointer";
            _inspectionMoveConnection = dojo.connect(document, "mousemove", function (evt) {
                if (!_inspectionEnabled) {
                    return;
                }
                if (!_inspectionTimer) {
                    _inspectionTimer = setTimeout(function () {
                        _inspectionTimer = null;
                    }, 50);
                } else {
                    return;
                }
                var node = evt.target;
                if (node && (_inspectCurrentNode !== node)) {
                    var parent = true;
                    console._restoreBorder();
                    var html = [];
                    appendNode(node, html);
                    consoleDomInspector.innerHTML = html.join("");
                    _inspectCurrentNode = node;
                    _restoreBorderStyle = _inspectCurrentNode.style.border;
                    _inspectCurrentNode.style.border = "#0000FF 1px solid";
                }
            });
            setTimeout(function () {
                _inspectionClickConnection = dojo.connect(document, "click", function (evt) {
                    document.body.style.cursor = "";
                    _inspectionEnabled = !_inspectionEnabled;
                    dojo.disconnect(_inspectionClickConnection);
                });
            }, 30);
        }, _closeDomInspector:function () {
            document.body.style.cursor = "";
            dojo.disconnect(_inspectionMoveConnection);
            dojo.disconnect(_inspectionClickConnection);
            _inspectionEnabled = false;
            console._restoreBorder();
        }, openConsole:function () {
            consoleBody.style.display = "block";
            consoleDomInspector.style.display = "none";
            consoleObjectInspector.style.display = "none";
            console._closeDomInspector();
        }, openObjectInspector:function () {
            consoleBody.style.display = "none";
            consoleDomInspector.style.display = "none";
            consoleObjectInspector.style.display = "block";
            console._closeDomInspector();
        }, recss:function () {
            var i, a, s;
            a = document.getElementsByTagName("link");
            for (i = 0; i < a.length; i++) {
                s = a[i];
                if (s.rel.toLowerCase().indexOf("stylesheet") >= 0 && s.href) {
                    var h = s.href.replace(/(&|%5C?)forceReload=\d+/, "");
                    s.href = h + (h.indexOf("?") >= 0 ? "&" : "?") + "forceReload=" + new Date().valueOf();
                }
            }
        }};
        function toggleConsole(forceOpen) {
            frameVisible = forceOpen || !frameVisible;
            if (consoleFrame) {
                consoleFrame.style.display = frameVisible ? "block" : "none";
            }
        }
        function focusCommandLine() {
            toggleConsole(true);
            if (commandLine) {
                commandLine.focus();
            }
        }
        function openWin(x, y, w, h) {
            var win = window.open("", "_firebug", "status=0,menubar=0,resizable=1,top=" + y + ",left=" + x + ",width=" + w + ",height=" + h + ",scrollbars=1,addressbar=0");
            if (!win) {
                var msg = "Firebug Lite could not open a pop-up window, most likely because of a blocker.\n" + "Either enable pop-ups for this domain, or change the djConfig to popup=false.";
                alert(msg);
            }
            createResizeHandler(win);
            var newDoc = win.document;
            var HTMLstring = "<html style=\"height:100%;\"><head><title>Firebug Lite</title></head>\n" + "<body bgColor=\"#ccc\" style=\"height:97%;\" onresize=\"opener.onFirebugResize()\">\n" + "<div id=\"fb\"></div>" + "</body></html>";
            newDoc.write(HTMLstring);
            newDoc.close();
            return win;
        }
        function createResizeHandler(wn) {
            var d = new Date();
            d.setTime(d.getTime() + (60 * 24 * 60 * 60 * 1000));
            d = d.toUTCString();
            var dc = wn.document, getViewport;
            if (wn.innerWidth) {
                getViewport = function () {
                    return {w:wn.innerWidth, h:wn.innerHeight};
                };
            } else {
                if (dc.documentElement && dc.documentElement.clientWidth) {
                    getViewport = function () {
                        return {w:dc.documentElement.clientWidth, h:dc.documentElement.clientHeight};
                    };
                } else {
                    if (dc.body) {
                        getViewport = function () {
                            return {w:dc.body.clientWidth, h:dc.body.clientHeight};
                        };
                    }
                }
            }
            window.onFirebugResize = function () {
                layout(getViewport().h);
                clearInterval(wn._firebugWin_resize);
                wn._firebugWin_resize = setTimeout(function () {
                    var x = wn.screenLeft, y = wn.screenTop, w = wn.outerWidth || wn.document.body.offsetWidth, h = wn.outerHeight || wn.document.body.offsetHeight;
                    document.cookie = "_firebugPosition=" + [x, y, w, h].join(",") + "; expires=" + d + "; path=/";
                }, 5000);
            };
        }
        function createFrame() {
            if (consoleFrame) {
                return;
            }
            toggleConsole(true);
            if (dojo.config.popup) {
                var containerHeight = "100%";
                var cookieMatch = document.cookie.match(/(?:^|; )_firebugPosition=([^;]*)/);
                var p = cookieMatch ? cookieMatch[1].split(",") : [2, 2, 320, 480];
                _firebugWin = openWin(p[0], p[1], p[2], p[3]);
                _firebugDoc = _firebugWin.document;
                dojo.config.debugContainerId = "fb";
                _firebugWin.console = window.console;
                _firebugWin.dojo = window.dojo;
            } else {
                _firebugDoc = document;
                containerHeight = (dojo.config.debugHeight || 300) + "px";
            }
            var styleElement = _firebugDoc.createElement("link");
            styleElement.href = require.toUrl("./firebug.css");
            styleElement.rel = "stylesheet";
            styleElement.type = "text/css";
            var styleParent = _firebugDoc.getElementsByTagName("head");
            if (styleParent) {
                styleParent = styleParent[0];
            }
            if (!styleParent) {
                styleParent = _firebugDoc.getElementsByTagName("html")[0];
            }
            if (has("ie")) {
                window.setTimeout(function () {
                    styleParent.appendChild(styleElement);
                }, 0);
            } else {
                styleParent.appendChild(styleElement);
            }
            if (dojo.config.debugContainerId) {
                consoleFrame = _firebugDoc.getElementById(dojo.config.debugContainerId);
            }
            if (!consoleFrame) {
                consoleFrame = _firebugDoc.createElement("div");
                _firebugDoc.body.appendChild(consoleFrame);
            }
            consoleFrame.className += " firebug";
            consoleFrame.id = "firebug";
            consoleFrame.style.height = containerHeight;
            consoleFrame.style.display = (frameVisible ? "block" : "none");
            var buildLink = function (label, title, method, _class) {
                return "<li class=\"" + _class + "\"><a href=\"javascript:void(0);\" onclick=\"console." + method + "(); return false;\" title=\"" + title + "\">" + label + "</a></li>";
            };
            consoleFrame.innerHTML = "<div id=\"firebugToolbar\">" + "  <ul id=\"fireBugTabs\" class=\"tabs\">" + buildLink("Clear", "Remove All Console Logs", "clear", "") + buildLink("ReCSS", "Refresh CSS without reloading page", "recss", "") + buildLink("Console", "Show Console Logs", "openConsole", "gap") + buildLink("DOM", "Show DOM Inspector", "openDomInspector", "") + buildLink("Object", "Show Object Inspector", "openObjectInspector", "") + ((dojo.config.popup) ? "" : buildLink("Close", "Close the console", "close", "gap")) + "\t</ul>" + "</div>" + "<input type=\"text\" id=\"firebugCommandLine\" />" + "<div id=\"firebugLog\"></div>" + "<div id=\"objectLog\" style=\"display:none;\">Click on an object in the Log display</div>" + "<div id=\"domInspect\" style=\"display:none;\">Hover over HTML elements in the main page. Click to hold selection.</div>";
            consoleToolbar = _firebugDoc.getElementById("firebugToolbar");
            commandLine = _firebugDoc.getElementById("firebugCommandLine");
            addEvent(commandLine, "keydown", onCommandLineKeyDown);
            addEvent(_firebugDoc, has("ie") || has("safari") ? "keydown" : "keypress", onKeyDown);
            consoleBody = _firebugDoc.getElementById("firebugLog");
            consoleObjectInspector = _firebugDoc.getElementById("objectLog");
            consoleDomInspector = _firebugDoc.getElementById("domInspect");
            fireBugTabs = _firebugDoc.getElementById("fireBugTabs");
            layout();
            flush();
        }
        dojo.addOnLoad(createFrame);
        function clearFrame() {
            _firebugDoc = null;
            if (_firebugWin.console) {
                _firebugWin.console.clear();
            }
            _firebugWin = null;
            consoleFrame = null;
            consoleBody = null;
            consoleObjectInspector = null;
            consoleDomInspector = null;
            commandLine = null;
            messageQueue = [];
            groupStack = [];
            timeMap = {};
        }
        function evalCommandLine() {
            var text = commandLine.value;
            commandLine.value = "";
            logRow([">  ", text], "command");
            var value;
            try {
                value = eval(text);
            }
            catch (e) {
                console.debug(e);
            }
            console.log(value);
        }
        function layout(h) {
            var tHeight = 25;
            var height = h ? h - (tHeight + commandLine.offsetHeight + 25 + (h * 0.01)) + "px" : (consoleFrame.offsetHeight - tHeight - commandLine.offsetHeight) + "px";
            consoleBody.style.top = tHeight + "px";
            consoleBody.style.height = height;
            consoleObjectInspector.style.height = height;
            consoleObjectInspector.style.top = tHeight + "px";
            consoleDomInspector.style.height = height;
            consoleDomInspector.style.top = tHeight + "px";
            commandLine.style.bottom = 0;
            dojo.addOnWindowUnload(clearFrame);
        }
        function logRow(message, className, handler) {
            if (consoleBody) {
                writeMessage(message, className, handler);
            } else {
                messageQueue.push([message, className, handler]);
            }
        }
        function flush() {
            var queue = messageQueue;
            messageQueue = [];
            for (var i = 0; i < queue.length; ++i) {
                writeMessage(queue[i][0], queue[i][1], queue[i][2]);
            }
        }
        function writeMessage(message, className, handler) {
            var isScrolledToBottom = consoleBody.scrollTop + consoleBody.offsetHeight >= consoleBody.scrollHeight;
            handler = handler || writeRow;
            handler(message, className);
            if (isScrolledToBottom) {
                consoleBody.scrollTop = consoleBody.scrollHeight - consoleBody.offsetHeight;
            }
        }
        function appendRow(row) {
            var container = groupStack.length ? groupStack[groupStack.length - 1] : consoleBody;
            container.appendChild(row);
        }
        function writeRow(message, className) {
            var row = consoleBody.ownerDocument.createElement("div");
            row.className = "logRow" + (className ? " logRow-" + className : "");
            row.innerHTML = message.join("");
            appendRow(row);
        }
        function pushGroup(message, className) {
            logFormatted(message, className);
            var groupRowBox = consoleBody.ownerDocument.createElement("div");
            groupRowBox.className = "logGroupBox";
            appendRow(groupRowBox);
            groupStack.push(groupRowBox);
        }
        function popGroup() {
            groupStack.pop();
        }
        function logFormatted(objects, className) {
            var html = [];
            var format = objects[0];
            var objIndex = 0;
            if (typeof (format) != "string") {
                format = "";
                objIndex = -1;
            }
            var parts = parseFormat(format);
            for (var i = 0; i < parts.length; ++i) {
                var part = parts[i];
                if (part && typeof part == "object") {
                    part.appender(objects[++objIndex], html);
                } else {
                    appendText(part, html);
                }
            }
            var ids = [];
            var obs = [];
            for (i = objIndex + 1; i < objects.length; ++i) {
                appendText(" ", html);
                var object = objects[i];
                if (object === undefined || object === null) {
                    appendNull(object, html);
                } else {
                    if (typeof (object) == "string") {
                        appendText(object, html);
                    } else {
                        if (object instanceof Date) {
                            appendText(object.toString(), html);
                        } else {
                            if (object.nodeType == 9) {
                                appendText("[ XmlDoc ]", html);
                            } else {
                                var id = "_a" + __consoleAnchorId__++;
                                ids.push(id);
                                obs.push(object);
                                var str = "<a id=\"" + id + "\" href=\"javascript:void(0);\">" + getObjectAbbr(object) + "</a>";
                                appendLink(str, html);
                            }
                        }
                    }
                }
            }
            logRow(html, className);
            for (i = 0; i < ids.length; i++) {
                var btn = _firebugDoc.getElementById(ids[i]);
                if (!btn) {
                    continue;
                }
                btn.obj = obs[i];
                _firebugWin.console._connects.push(dojo.connect(btn, "onclick", function () {
                    console.openObjectInspector();
                    try {
                        printObject(this.obj);
                    }
                    catch (e) {
                        this.obj = e;
                    }
                    consoleObjectInspector.innerHTML = "<pre>" + printObject(this.obj) + "</pre>";
                }));
            }
        }
        function parseFormat(format) {
            var parts = [];
            var reg = /((^%|[^\\]%)(\d+)?(\.)([a-zA-Z]))|((^%|[^\\]%)([a-zA-Z]))/;
            var appenderMap = {s:appendText, d:appendInteger, i:appendInteger, f:appendFloat};
            for (var m = reg.exec(format); m; m = reg.exec(format)) {
                var type = m[8] ? m[8] : m[5];
                var appender = type in appenderMap ? appenderMap[type] : appendObject;
                var precision = m[3] ? parseInt(m[3]) : (m[4] == "." ? -1 : 0);
                parts.push(format.substr(0, m[0][0] == "%" ? m.index : m.index + 1));
                parts.push({appender:appender, precision:precision});
                format = format.substr(m.index + m[0].length);
            }
            parts.push(format);
            return parts;
        }
        function escapeHTML(value) {
            function replaceChars(ch) {
                switch (ch) {
                  case "<":
                    return "&lt;";
                  case ">":
                    return "&gt;";
                  case "&":
                    return "&amp;";
                  case "'":
                    return "&#39;";
                  case "\"":
                    return "&quot;";
                }
                return "?";
            }
            return String(value).replace(/[<>&"']/g, replaceChars);
        }
        function objectToString(object) {
            try {
                return object + "";
            }
            catch (e) {
                return null;
            }
        }
        function appendLink(object, html) {
            html.push(objectToString(object));
        }
        function appendText(object, html) {
            html.push(escapeHTML(objectToString(object)));
        }
        function appendNull(object, html) {
            html.push("<span class=\"objectBox-null\">", escapeHTML(objectToString(object)), "</span>");
        }
        function appendString(object, html) {
            html.push("<span class=\"objectBox-string\">&quot;", escapeHTML(objectToString(object)), "&quot;</span>");
        }
        function appendInteger(object, html) {
            html.push("<span class=\"objectBox-number\">", escapeHTML(objectToString(object)), "</span>");
        }
        function appendFloat(object, html) {
            html.push("<span class=\"objectBox-number\">", escapeHTML(objectToString(object)), "</span>");
        }
        function appendFunction(object, html) {
            html.push("<span class=\"objectBox-function\">", getObjectAbbr(object), "</span>");
        }
        function appendObject(object, html) {
            try {
                if (object === undefined) {
                    appendNull("undefined", html);
                } else {
                    if (object === null) {
                        appendNull("null", html);
                    } else {
                        if (typeof object == "string") {
                            appendString(object, html);
                        } else {
                            if (typeof object == "number") {
                                appendInteger(object, html);
                            } else {
                                if (typeof object == "function") {
                                    appendFunction(object, html);
                                } else {
                                    if (object.nodeType == 1) {
                                        appendSelector(object, html);
                                    } else {
                                        if (typeof object == "object") {
                                            appendObjectFormatted(object, html);
                                        } else {
                                            appendText(object, html);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            catch (e) {
            }
        }
        function appendObjectFormatted(object, html) {
            var text = objectToString(object);
            var reObject = /\[object (.*?)\]/;
            var m = reObject.exec(text);
            html.push("<span class=\"objectBox-object\">", m ? m[1] : text, "</span>");
        }
        function appendSelector(object, html) {
            html.push("<span class=\"objectBox-selector\">");
            html.push("<span class=\"selectorTag\">", escapeHTML(object.nodeName.toLowerCase()), "</span>");
            if (object.id) {
                html.push("<span class=\"selectorId\">#", escapeHTML(object.id), "</span>");
            }
            if (object.className) {
                html.push("<span class=\"selectorClass\">.", escapeHTML(object.className), "</span>");
            }
            html.push("</span>");
        }
        function appendNode(node, html) {
            if (node.nodeType == 1) {
                html.push("<div class=\"objectBox-element\">", "&lt;<span class=\"nodeTag\">", node.nodeName.toLowerCase(), "</span>");
                for (var i = 0; i < node.attributes.length; ++i) {
                    var attr = node.attributes[i];
                    if (!attr.specified) {
                        continue;
                    }
                    html.push("&nbsp;<span class=\"nodeName\">", attr.nodeName.toLowerCase(), "</span>=&quot;<span class=\"nodeValue\">", escapeHTML(attr.nodeValue), "</span>&quot;");
                }
                if (node.firstChild) {
                    html.push("&gt;</div><div class=\"nodeChildren\">");
                    for (var child = node.firstChild; child; child = child.nextSibling) {
                        appendNode(child, html);
                    }
                    html.push("</div><div class=\"objectBox-element\">&lt;/<span class=\"nodeTag\">", node.nodeName.toLowerCase(), "&gt;</span></div>");
                } else {
                    html.push("/&gt;</div>");
                }
            } else {
                if (node.nodeType == 3) {
                    html.push("<div class=\"nodeText\">", escapeHTML(node.nodeValue), "</div>");
                }
            }
        }
        function addEvent(object, name, handler) {
            if (document.all) {
                object.attachEvent("on" + name, handler);
            } else {
                object.addEventListener(name, handler, false);
            }
        }
        function removeEvent(object, name, handler) {
            if (document.all) {
                object.detachEvent("on" + name, handler);
            } else {
                object.removeEventListener(name, handler, false);
            }
        }
        function cancelEvent(event) {
            if (document.all) {
                event.cancelBubble = true;
            } else {
                event.stopPropagation();
            }
        }
        function onError(msg, href, lineNo) {
            var lastSlash = href.lastIndexOf("/");
            var fileName = lastSlash == -1 ? href : href.substr(lastSlash + 1);
            var html = ["<span class=\"errorMessage\">", msg, "</span>", "<div class=\"objectBox-sourceLink\">", fileName, " (line ", lineNo, ")</div>"];
            logRow(html, "error");
        }
        var onKeyDownTime = new Date().getTime();
        function onKeyDown(event) {
            var timestamp = (new Date()).getTime();
            if (timestamp > onKeyDownTime + 200) {
                event = dojo.fixEvent(event);
                var keys = dojo.keys;
                var ekc = event.keyCode;
                onKeyDownTime = timestamp;
                if (ekc == keys.F12) {
                    toggleConsole();
                } else {
                    if ((ekc == keys.NUMPAD_ENTER || ekc == 76) && event.shiftKey && (event.metaKey || event.ctrlKey)) {
                        focusCommandLine();
                    } else {
                        return;
                    }
                }
                cancelEvent(event);
            }
        }
        function onCommandLineKeyDown(e) {
            var dk = dojo.keys;
            if (e.keyCode == 13 && commandLine.value) {
                addToHistory(commandLine.value);
                evalCommandLine();
            } else {
                if (e.keyCode == 27) {
                    commandLine.value = "";
                } else {
                    if (e.keyCode == dk.UP_ARROW || e.charCode == dk.UP_ARROW) {
                        navigateHistory("older");
                    } else {
                        if (e.keyCode == dk.DOWN_ARROW || e.charCode == dk.DOWN_ARROW) {
                            navigateHistory("newer");
                        } else {
                            if (e.keyCode == dk.HOME || e.charCode == dk.HOME) {
                                historyPosition = 1;
                                navigateHistory("older");
                            } else {
                                if (e.keyCode == dk.END || e.charCode == dk.END) {
                                    historyPosition = 999999;
                                    navigateHistory("newer");
                                }
                            }
                        }
                    }
                }
            }
        }
        var historyPosition = -1;
        var historyCommandLine = null;
        function addToHistory(value) {
            var history = cookie("firebug_history");
            history = (history) ? dojo.fromJson(history) : [];
            var pos = dojo.indexOf(history, value);
            if (pos != -1) {
                history.splice(pos, 1);
            }
            history.push(value);
            cookie("firebug_history", dojo.toJson(history), 30);
            while (history.length && !cookie("firebug_history")) {
                history.shift();
                cookie("firebug_history", dojo.toJson(history), 30);
            }
            historyCommandLine = null;
            historyPosition = -1;
        }
        function navigateHistory(direction) {
            var history = cookie("firebug_history");
            history = (history) ? dojo.fromJson(history) : [];
            if (!history.length) {
                return;
            }
            if (historyCommandLine === null) {
                historyCommandLine = commandLine.value;
            }
            if (historyPosition == -1) {
                historyPosition = history.length;
            }
            if (direction == "older") {
                --historyPosition;
                if (historyPosition < 0) {
                    historyPosition = 0;
                }
            } else {
                if (direction == "newer") {
                    ++historyPosition;
                    if (historyPosition > history.length) {
                        historyPosition = history.length;
                    }
                }
            }
            if (historyPosition == history.length) {
                commandLine.value = historyCommandLine;
                historyCommandLine = null;
            } else {
                commandLine.value = history[historyPosition];
            }
        }
        function cookie(name, value) {
            var c = document.cookie;
            if (arguments.length == 1) {
                var matches = c.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
                return matches ? decodeURIComponent(matches[1]) : undefined;
            } else {
                var d = new Date();
                d.setMonth(d.getMonth() + 1);
                document.cookie = name + "=" + encodeURIComponent(value) + ((d.toUtcString) ? "; expires=" + d.toUTCString() : "");
            }
        }
        function isArray(it) {
            return it && it instanceof Array || typeof it == "array";
        }
        function objectLength(o) {
            var cnt = 0;
            for (var nm in o) {
                cnt++;
            }
            return cnt;
        }
        function printObject(o, i, txt, used) {
            var ind = " \t";
            txt = txt || "";
            i = i || ind;
            used = used || [];
            var opnCls;
            if (o && o.nodeType == 1) {
                var html = [];
                appendNode(o, html);
                return html.join("");
            }
            var br = ",\n", cnt = 0, length = objectLength(o);
            if (o instanceof Date) {
                return i + o.toString() + br;
            }
        looking:
            for (var nm in o) {
                cnt++;
                if (cnt == length) {
                    br = "\n";
                }
                if (o[nm] === window || o[nm] === document) {
                } else {
                    if (o[nm] === null) {
                        txt += i + nm + " : NULL" + br;
                    } else {
                        if (o[nm] && o[nm].nodeType) {
                            if (o[nm].nodeType == 1) {
                            } else {
                                if (o[nm].nodeType == 3) {
                                    txt += i + nm + " : [ TextNode " + o[nm].data + " ]" + br;
                                }
                            }
                        } else {
                            if (typeof o[nm] == "object" && (o[nm] instanceof String || o[nm] instanceof Number || o[nm] instanceof Boolean)) {
                                txt += i + nm + " : " + o[nm] + "," + br;
                            } else {
                                if (o[nm] instanceof Date) {
                                    txt += i + nm + " : " + o[nm].toString() + br;
                                } else {
                                    if (typeof (o[nm]) == "object" && o[nm]) {
                                        for (var j = 0, seen; seen = used[j]; j++) {
                                            if (o[nm] === seen) {
                                                txt += i + nm + " : RECURSION" + br;
                                                continue looking;
                                            }
                                        }
                                        used.push(o[nm]);
                                        opnCls = (isArray(o[nm])) ? ["[", "]"] : ["{", "}"];
                                        txt += i + nm + " : " + opnCls[0] + "\n";
                                        txt += printObject(o[nm], i + ind, "", used);
                                        txt += i + opnCls[1] + br;
                                    } else {
                                        if (typeof o[nm] == "undefined") {
                                            txt += i + nm + " : undefined" + br;
                                        } else {
                                            if (nm == "toString" && typeof o[nm] == "function") {
                                                var toString = o[nm]();
                                                if (typeof toString == "string" && toString.match(/function ?(.*?)\(/)) {
                                                    toString = escapeHTML(getObjectAbbr(o[nm]));
                                                }
                                                txt += i + nm + " : " + toString + br;
                                            } else {
                                                txt += i + nm + " : " + escapeHTML(getObjectAbbr(o[nm])) + br;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return txt;
        }
        function getObjectAbbr(obj) {
            var isError = (obj instanceof Error);
            if (obj.nodeType == 1) {
                return escapeHTML("< " + obj.tagName.toLowerCase() + " id=\"" + obj.id + "\" />");
            }
            if (obj.nodeType == 3) {
                return escapeHTML("[TextNode: \"" + obj.nodeValue + "\"]");
            }
            var nm = (obj && (obj.id || obj.name || obj.ObjectID || obj.widgetId));
            if (!isError && nm) {
                return "{" + nm + "}";
            }
            var obCnt = 2;
            var arCnt = 4;
            var cnt = 0;
            if (isError) {
                nm = "[ Error: " + (obj.message || obj.description || obj) + " ]";
            } else {
                if (isArray(obj)) {
                    nm = "[" + obj.slice(0, arCnt).join(",");
                    if (obj.length > arCnt) {
                        nm += " ... (" + obj.length + " items)";
                    }
                    nm += "]";
                } else {
                    if (typeof obj == "function") {
                        nm = obj + "";
                        var reg = /function\s*([^\(]*)(\([^\)]*\))[^\{]*\{/;
                        var m = reg.exec(nm);
                        if (m) {
                            if (!m[1]) {
                                m[1] = "function";
                            }
                            nm = m[1] + m[2];
                        } else {
                            nm = "function()";
                        }
                    } else {
                        if (typeof obj != "object" || typeof obj == "string") {
                            nm = obj + "";
                        } else {
                            nm = "{";
                            for (var i in obj) {
                                cnt++;
                                if (cnt > obCnt) {
                                    break;
                                }
                                nm += i + ":" + escapeHTML(obj[i]) + "  ";
                            }
                            nm += "}";
                        }
                    }
                }
            }
            return nm;
        }
        addEvent(document, has("ie") || has("safari") ? "keydown" : "keypress", onKeyDown);
        if ((document.documentElement.getAttribute("debug") == "true") || (dojo.config.isDebug)) {
            toggleConsole(true);
        }
        dojo.addOnWindowUnload(function () {
            removeEvent(document, has("ie") || has("safari") ? "keydown" : "keypress", onKeyDown);
            window.onFirebugResize = null;
            window.console = null;
        });
    });
}, "dijit/selection":function () {
    define(["dojo/_base/array", "dojo/dom", "dojo/_base/lang", "dojo/sniff", "dojo/_base/window", "dijit/focus"], function (array, dom, lang, has, baseWindow, focus) {
        var SelectionManager = function (win) {
            var doc = win.document;
            this.getType = function () {
                if (doc.getSelection) {
                    var stype = "text";
                    var oSel;
                    try {
                        oSel = win.getSelection();
                    }
                    catch (e) {
                    }
                    if (oSel && oSel.rangeCount == 1) {
                        var oRange = oSel.getRangeAt(0);
                        if ((oRange.startContainer == oRange.endContainer) && ((oRange.endOffset - oRange.startOffset) == 1) && (oRange.startContainer.nodeType != 3)) {
                            stype = "control";
                        }
                    }
                    return stype;
                } else {
                    return doc.selection.type.toLowerCase();
                }
            };
            this.getSelectedText = function () {
                if (doc.getSelection) {
                    var selection = win.getSelection();
                    return selection ? selection.toString() : "";
                } else {
                    if (this.getType() == "control") {
                        return null;
                    }
                    return doc.selection.createRange().text;
                }
            };
            this.getSelectedHtml = function () {
                if (doc.getSelection) {
                    var selection = win.getSelection();
                    if (selection && selection.rangeCount) {
                        var i;
                        var html = "";
                        for (i = 0; i < selection.rangeCount; i++) {
                            var frag = selection.getRangeAt(i).cloneContents();
                            var div = doc.createElement("div");
                            div.appendChild(frag);
                            html += div.innerHTML;
                        }
                        return html;
                    }
                    return null;
                } else {
                    if (this.getType() == "control") {
                        return null;
                    }
                    return doc.selection.createRange().htmlText;
                }
            };
            this.getSelectedElement = function () {
                if (this.getType() == "control") {
                    if (doc.getSelection) {
                        var selection = win.getSelection();
                        return selection.anchorNode.childNodes[selection.anchorOffset];
                    } else {
                        var range = doc.selection.createRange();
                        if (range && range.item) {
                            return doc.selection.createRange().item(0);
                        }
                    }
                }
                return null;
            };
            this.getParentElement = function () {
                if (this.getType() == "control") {
                    var p = this.getSelectedElement();
                    if (p) {
                        return p.parentNode;
                    }
                } else {
                    if (doc.getSelection) {
                        var selection = doc.getSelection();
                        if (selection) {
                            var node = selection.anchorNode;
                            while (node && (node.nodeType != 1)) {
                                node = node.parentNode;
                            }
                            return node;
                        }
                    } else {
                        var r = doc.selection.createRange();
                        r.collapse(true);
                        return r.parentElement();
                    }
                }
                return null;
            };
            this.hasAncestorElement = function (tagName) {
                return this.getAncestorElement.apply(this, arguments) != null;
            };
            this.getAncestorElement = function (tagName) {
                var node = this.getSelectedElement() || this.getParentElement();
                return this.getParentOfType(node, arguments);
            };
            this.isTag = function (node, tags) {
                if (node && node.tagName) {
                    var _nlc = node.tagName.toLowerCase();
                    for (var i = 0; i < tags.length; i++) {
                        var _tlc = String(tags[i]).toLowerCase();
                        if (_nlc == _tlc) {
                            return _tlc;
                        }
                    }
                }
                return "";
            };
            this.getParentOfType = function (node, tags) {
                while (node) {
                    if (this.isTag(node, tags).length) {
                        return node;
                    }
                    node = node.parentNode;
                }
                return null;
            };
            this.collapse = function (beginning) {
                if (doc.getSelection) {
                    var selection = win.getSelection();
                    if (selection.removeAllRanges) {
                        if (beginning) {
                            selection.collapseToStart();
                        } else {
                            selection.collapseToEnd();
                        }
                    } else {
                        selection.collapse(beginning);
                    }
                } else {
                    var range = doc.selection.createRange();
                    range.collapse(beginning);
                    range.select();
                }
            };
            this.remove = function () {
                var sel = doc.selection;
                if (doc.getSelection) {
                    sel = win.getSelection();
                    sel.deleteFromDocument();
                    return sel;
                } else {
                    if (sel.type.toLowerCase() != "none") {
                        sel.clear();
                    }
                    return sel;
                }
            };
            this.selectElementChildren = function (element, nochangefocus) {
                var range;
                element = dom.byId(element);
                if (doc.getSelection) {
                    var selection = win.getSelection();
                    if (has("opera")) {
                        if (selection.rangeCount) {
                            range = selection.getRangeAt(0);
                        } else {
                            range = doc.createRange();
                        }
                        range.setStart(element, 0);
                        range.setEnd(element, (element.nodeType == 3) ? element.length : element.childNodes.length);
                        selection.addRange(range);
                    } else {
                        selection.selectAllChildren(element);
                    }
                } else {
                    range = element.ownerDocument.body.createTextRange();
                    range.moveToElementText(element);
                    if (!nochangefocus) {
                        try {
                            range.select();
                        }
                        catch (e) {
                        }
                    }
                }
            };
            this.selectElement = function (element, nochangefocus) {
                var range;
                element = dom.byId(element);
                if (doc.getSelection) {
                    var selection = doc.getSelection();
                    range = doc.createRange();
                    if (selection.removeAllRanges) {
                        if (has("opera")) {
                            if (selection.getRangeAt(0)) {
                                range = selection.getRangeAt(0);
                            }
                        }
                        range.selectNode(element);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                } else {
                    try {
                        var tg = element.tagName ? element.tagName.toLowerCase() : "";
                        if (tg === "img" || tg === "table") {
                            range = baseWindow.body(doc).createControlRange();
                        } else {
                            range = baseWindow.body(doc).createRange();
                        }
                        range.addElement(element);
                        if (!nochangefocus) {
                            range.select();
                        }
                    }
                    catch (e) {
                        this.selectElementChildren(element, nochangefocus);
                    }
                }
            };
            this.inSelection = function (node) {
                if (node) {
                    var newRange;
                    var range;
                    if (doc.getSelection) {
                        var sel = win.getSelection();
                        if (sel && sel.rangeCount > 0) {
                            range = sel.getRangeAt(0);
                        }
                        if (range && range.compareBoundaryPoints && doc.createRange) {
                            try {
                                newRange = doc.createRange();
                                newRange.setStart(node, 0);
                                if (range.compareBoundaryPoints(range.START_TO_END, newRange) === 1) {
                                    return true;
                                }
                            }
                            catch (e) {
                            }
                        }
                    } else {
                        range = doc.selection.createRange();
                        try {
                            newRange = node.ownerDocument.body.createTextRange();
                            newRange.moveToElementText(node);
                        }
                        catch (e2) {
                        }
                        if (range && newRange) {
                            if (range.compareEndPoints("EndToStart", newRange) === 1) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }, this.getBookmark = function () {
                var bm, rg, tg, sel = doc.selection, cf = focus.curNode;
                if (doc.getSelection) {
                    sel = win.getSelection();
                    if (sel) {
                        if (sel.isCollapsed) {
                            tg = cf ? cf.tagName : "";
                            if (tg) {
                                tg = tg.toLowerCase();
                                if (tg == "textarea" || (tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))) {
                                    sel = {start:cf.selectionStart, end:cf.selectionEnd, node:cf, pRange:true};
                                    return {isCollapsed:(sel.end <= sel.start), mark:sel};
                                }
                            }
                            bm = {isCollapsed:true};
                            if (sel.rangeCount) {
                                bm.mark = sel.getRangeAt(0).cloneRange();
                            }
                        } else {
                            rg = sel.getRangeAt(0);
                            bm = {isCollapsed:false, mark:rg.cloneRange()};
                        }
                    }
                } else {
                    if (sel) {
                        tg = cf ? cf.tagName : "";
                        tg = tg.toLowerCase();
                        if (cf && tg && (tg == "button" || tg == "textarea" || tg == "input")) {
                            if (sel.type && sel.type.toLowerCase() == "none") {
                                return {isCollapsed:true, mark:null};
                            } else {
                                rg = sel.createRange();
                                return {isCollapsed:rg.text && rg.text.length ? false : true, mark:{range:rg, pRange:true}};
                            }
                        }
                        bm = {};
                        try {
                            rg = sel.createRange();
                            bm.isCollapsed = !(sel.type == "Text" ? rg.htmlText.length : rg.length);
                        }
                        catch (e) {
                            bm.isCollapsed = true;
                            return bm;
                        }
                        if (sel.type.toUpperCase() == "CONTROL") {
                            if (rg.length) {
                                bm.mark = [];
                                var i = 0, len = rg.length;
                                while (i < len) {
                                    bm.mark.push(rg.item(i++));
                                }
                            } else {
                                bm.isCollapsed = true;
                                bm.mark = null;
                            }
                        } else {
                            bm.mark = rg.getBookmark();
                        }
                    } else {
                        console.warn("No idea how to store the current selection for this browser!");
                    }
                }
                return bm;
            };
            this.moveToBookmark = function (bookmark) {
                var mark = bookmark.mark;
                if (mark) {
                    if (doc.getSelection) {
                        var sel = win.getSelection();
                        if (sel && sel.removeAllRanges) {
                            if (mark.pRange) {
                                var n = mark.node;
                                n.selectionStart = mark.start;
                                n.selectionEnd = mark.end;
                            } else {
                                sel.removeAllRanges();
                                sel.addRange(mark);
                            }
                        } else {
                            console.warn("No idea how to restore selection for this browser!");
                        }
                    } else {
                        if (doc.selection && mark) {
                            var rg;
                            if (mark.pRange) {
                                rg = mark.range;
                            } else {
                                if (lang.isArray(mark)) {
                                    rg = doc.body.createControlRange();
                                    array.forEach(mark, function (n) {
                                        rg.addElement(n);
                                    });
                                } else {
                                    rg = doc.body.createTextRange();
                                    rg.moveToBookmark(mark);
                                }
                            }
                            rg.select();
                        }
                    }
                }
            };
            this.isCollapsed = function () {
                return this.getBookmark().isCollapsed;
            };
        };
        var selection = new SelectionManager(window);
        selection.SelectionManager = SelectionManager;
        return selection;
    });
}, "dojox/grid/DataGrid":function () {
    define(["../main", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/json", "dojo/_base/sniff", "dojo/_base/declare", "./_Grid", "./DataSelection", "dojo/_base/html", "dojo/has", "dojo/has!dojo-bidi?./bidi/_BidiMixin"], function (dojox, array, lang, json, has, declare, _Grid, DataSelection, html) {
        var DataGrid = declare("dojox.grid.DataGrid", _Grid, {store:null, query:null, queryOptions:null, fetchText:"...", sortFields:null, updateDelay:1, items:null, _store_connects:null, _by_idty:null, _by_idx:null, _cache:null, _pages:null, _pending_requests:null, _bop:-1, _eop:-1, _requests:0, rowCount:0, _isLoaded:false, _isLoading:false, keepSelection:false, postCreate:function () {
            this._pages = [];
            this._store_connects = [];
            this._by_idty = {};
            this._by_idx = [];
            this._cache = [];
            this._pending_requests = {};
            this._setStore(this.store);
            this.inherited(arguments);
        }, destroy:function () {
            this.selection.destroy();
            this.inherited(arguments);
        }, createSelection:function () {
            this.selection = new DataSelection(this);
        }, get:function (inRowIndex, inItem) {
            if (inItem && this.field == "_item" && !this.fields) {
                return inItem;
            } else {
                if (inItem && this.fields) {
                    var ret = [];
                    var s = this.grid.store;
                    array.forEach(this.fields, function (f) {
                        ret = ret.concat(s.getValues(inItem, f));
                    });
                    return ret;
                } else {
                    if (!inItem && typeof inRowIndex === "string") {
                        return this.inherited(arguments);
                    }
                }
            }
            return (!inItem ? this.defaultValue : (!this.field ? this.value : (this.field == "_item" ? inItem : this.grid.store.getValue(inItem, this.field))));
        }, _checkUpdateStatus:function () {
            if (this.updateDelay > 0) {
                var iStarted = false;
                if (this._endUpdateDelay) {
                    clearTimeout(this._endUpdateDelay);
                    delete this._endUpdateDelay;
                    iStarted = true;
                }
                if (!this.updating) {
                    this.beginUpdate();
                    iStarted = true;
                }
                if (iStarted) {
                    var _this = this;
                    this._endUpdateDelay = setTimeout(function () {
                        delete _this._endUpdateDelay;
                        _this.endUpdate();
                    }, this.updateDelay);
                }
            }
        }, _onSet:function (item, attribute, oldValue, newValue) {
            this._checkUpdateStatus();
            var idx = this.getItemIndex(item);
            if (idx > -1) {
                this.updateRow(idx);
            }
        }, _createItem:function (item, index) {
            var idty = this._hasIdentity ? this.store.getIdentity(item) : json.toJson(this.query) + ":idx:" + index + ":sort:" + json.toJson(this.getSortProps());
            var o = this._by_idty[idty] = {idty:idty, item:item};
            return o;
        }, _addItem:function (item, index, noUpdate) {
            this._by_idx[index] = this._createItem(item, index);
            if (!noUpdate) {
                this.updateRow(index);
            }
        }, _onNew:function (item, parentInfo) {
            this._checkUpdateStatus();
            var rowCount = this.get("rowCount");
            this._addingItem = true;
            this.updateRowCount(rowCount + 1);
            this._addingItem = false;
            this._addItem(item, rowCount);
            this.showMessage();
        }, _onDelete:function (item) {
            this._checkUpdateStatus();
            var idx = this._getItemIndex(item, true);
            if (idx >= 0) {
                this._pages = [];
                this._bop = -1;
                this._eop = -1;
                var o = this._by_idx[idx];
                this._by_idx.splice(idx, 1);
                delete this._by_idty[o.idty];
                this.updateRowCount(this.get("rowCount") - 1);
                if (this.get("rowCount") === 0) {
                    this.showMessage(this.noDataMessage);
                }
            }
            if (this.selection.isSelected(idx)) {
                this.selection.deselect(idx);
                this.selection.selected.splice(idx, 1);
            }
        }, _onRevert:function () {
            this._refresh();
        }, setStore:function (store, query, queryOptions) {
            if (this._requestsPending(0)) {
                return;
            }
            this._setQuery(query, queryOptions);
            this._setStore(store);
            this._refresh(true);
        }, setQuery:function (query, queryOptions) {
            if (this._requestsPending(0)) {
                return;
            }
            this._setQuery(query, queryOptions);
            this._refresh(true);
        }, setItems:function (items) {
            this.items = items;
            this._setStore(this.store);
            this._refresh(true);
        }, _setQuery:function (query, queryOptions) {
            this.query = query;
            this.queryOptions = queryOptions || this.queryOptions;
        }, _setStore:function (store) {
            if (this.store && this._store_connects) {
                array.forEach(this._store_connects, this.disconnect, this);
            }
            this.store = store;
            if (this.store) {
                var f = this.store.getFeatures();
                var h = [];
                this._canEdit = !!f["dojo.data.api.Write"] && !!f["dojo.data.api.Identity"];
                this._hasIdentity = !!f["dojo.data.api.Identity"];
                if (!!f["dojo.data.api.Notification"] && !this.items) {
                    h.push(this.connect(this.store, "onSet", "_onSet"));
                    h.push(this.connect(this.store, "onNew", "_onNew"));
                    h.push(this.connect(this.store, "onDelete", "_onDelete"));
                }
                if (this._canEdit) {
                    h.push(this.connect(this.store, "revert", "_onRevert"));
                }
                this._store_connects = h;
            }
        }, _onFetchBegin:function (size, req) {
            if (!this.scroller) {
                return;
            }
            if (this.rowCount != size) {
                if (req.isRender) {
                    this.scroller.init(size, this.keepRows, this.rowsPerPage);
                    this.rowCount = size;
                    this._setAutoHeightAttr(this.autoHeight, true);
                    this._skipRowRenormalize = true;
                    this.prerender();
                    this._skipRowRenormalize = false;
                } else {
                    this.updateRowCount(size);
                }
            }
            if (!size) {
                this.views.render();
                this._resize();
                this.showMessage(this.noDataMessage);
                this.focus.initFocusView();
            } else {
                this.showMessage();
            }
        }, _onFetchComplete:function (items, req) {
            if (!this.scroller) {
                return;
            }
            if (items && items.length > 0) {
                array.forEach(items, function (item, idx) {
                    this._addItem(item, req.start + idx, true);
                }, this);
                this.updateRows(req.start, items.length);
                if (req.isRender) {
                    this.setScrollTop(0);
                    this.postrender();
                } else {
                    if (this._lastScrollTop) {
                        this.setScrollTop(this._lastScrollTop);
                    }
                }
                if (has("ie")) {
                    html.setSelectable(this.domNode, this.selectable);
                }
            }
            delete this._lastScrollTop;
            if (!this._isLoaded) {
                this._isLoading = false;
                this._isLoaded = true;
            }
            this._pending_requests[req.start] = false;
        }, _onFetchError:function (err, req) {
            console.log(err);
            delete this._lastScrollTop;
            if (!this._isLoaded) {
                this._isLoading = false;
                this._isLoaded = true;
                this.showMessage(this.errorMessage);
            }
            this._pending_requests[req.start] = false;
            this.onFetchError(err, req);
        }, onFetchError:function (err, req) {
        }, _fetch:function (start, isRender) {
            start = start || 0;
            if (this.store && !this._pending_requests[start]) {
                if (!this._isLoaded && !this._isLoading) {
                    this._isLoading = true;
                    this.showMessage(this.loadingMessage);
                }
                this._pending_requests[start] = true;
                try {
                    if (this.items) {
                        var items = this.items;
                        var store = this.store;
                        this.rowsPerPage = items.length;
                        var req = {start:start, count:this.rowsPerPage, isRender:isRender};
                        this._onFetchBegin(items.length, req);
                        var waitCount = 0;
                        array.forEach(items, function (i) {
                            if (!store.isItemLoaded(i)) {
                                waitCount++;
                            }
                        });
                        if (waitCount === 0) {
                            this._onFetchComplete(items, req);
                        } else {
                            var onItem = function (item) {
                                waitCount--;
                                if (waitCount === 0) {
                                    this._onFetchComplete(items, req);
                                }
                            };
                            array.forEach(items, function (i) {
                                if (!store.isItemLoaded(i)) {
                                    store.loadItem({item:i, onItem:onItem, scope:this});
                                }
                            }, this);
                        }
                    } else {
                        this.store.fetch({start:start, count:this.rowsPerPage, query:this.query, sort:this.getSortProps(), queryOptions:this.queryOptions, isRender:isRender, onBegin:lang.hitch(this, "_onFetchBegin"), onComplete:lang.hitch(this, "_onFetchComplete"), onError:lang.hitch(this, "_onFetchError")});
                    }
                }
                catch (e) {
                    this._onFetchError(e, {start:start, count:this.rowsPerPage});
                }
            }
        }, _clearData:function () {
            this.updateRowCount(0);
            this._by_idty = {};
            this._by_idx = [];
            this._pages = [];
            this._bop = this._eop = -1;
            this._isLoaded = false;
            this._isLoading = false;
        }, getItem:function (idx) {
            var data = this._by_idx[idx];
            if (!data || (data && !data.item)) {
                this._preparePage(idx);
                return null;
            }
            return data.item;
        }, getItemIndex:function (item) {
            return this._getItemIndex(item, false);
        }, _getItemIndex:function (item, isDeleted) {
            if (!isDeleted && !this.store.isItem(item)) {
                return -1;
            }
            var idty = this._hasIdentity ? this.store.getIdentity(item) : null;
            for (var i = 0, l = this._by_idx.length; i < l; i++) {
                var d = this._by_idx[i];
                if (d && ((idty && d.idty == idty) || (d.item === item))) {
                    return i;
                }
            }
            return -1;
        }, filter:function (query, reRender) {
            this.query = query;
            if (reRender) {
                this._clearData();
            }
            this._fetch();
        }, _getItemAttr:function (idx, attr) {
            var item = this.getItem(idx);
            return (!item ? this.fetchText : this.store.getValue(item, attr));
        }, _render:function () {
            if (this.domNode.parentNode) {
                this.scroller.init(this.get("rowCount"), this.keepRows, this.rowsPerPage);
                this.prerender();
                this._fetch(0, true);
            }
        }, _requestsPending:function (inRowIndex) {
            return this._pending_requests[inRowIndex];
        }, _rowToPage:function (inRowIndex) {
            return (this.rowsPerPage ? Math.floor(inRowIndex / this.rowsPerPage) : inRowIndex);
        }, _pageToRow:function (inPageIndex) {
            return (this.rowsPerPage ? this.rowsPerPage * inPageIndex : inPageIndex);
        }, _preparePage:function (inRowIndex) {
            if ((inRowIndex < this._bop || inRowIndex >= this._eop) && !this._addingItem) {
                var pageIndex = this._rowToPage(inRowIndex);
                this._needPage(pageIndex);
                this._bop = pageIndex * this.rowsPerPage;
                this._eop = this._bop + (this.rowsPerPage || this.get("rowCount"));
            }
        }, _needPage:function (inPageIndex) {
            if (!this._pages[inPageIndex]) {
                this._pages[inPageIndex] = true;
                this._requestPage(inPageIndex);
            }
        }, _requestPage:function (inPageIndex) {
            var row = this._pageToRow(inPageIndex);
            var count = Math.min(this.rowsPerPage, this.get("rowCount") - row);
            if (count > 0) {
                this._requests++;
                if (!this._requestsPending(row)) {
                    setTimeout(lang.hitch(this, "_fetch", row, false), 1);
                }
            }
        }, getCellName:function (inCell) {
            return inCell.field;
        }, _refresh:function (isRender) {
            this._clearData();
            this._fetch(0, isRender);
        }, sort:function () {
            this.edit.apply();
            this._lastScrollTop = this.scrollTop;
            this._refresh();
        }, canSort:function () {
            return (!this._isLoading);
        }, getSortProps:function () {
            var c = this.getCell(this.getSortIndex());
            if (!c) {
                if (this.sortFields) {
                    return this.sortFields;
                }
                return null;
            } else {
                var desc = c["sortDesc"];
                var si = !(this.sortInfo > 0);
                if (typeof desc == "undefined") {
                    desc = si;
                } else {
                    desc = si ? !desc : desc;
                }
                return [{attribute:c.field, descending:desc}];
            }
        }, styleRowState:function (inRow) {
            if (this.store && this.store.getState) {
                var states = this.store.getState(inRow.index), c = "";
                for (var i = 0, ss = ["inflight", "error", "inserting"], s; s = ss[i]; i++) {
                    if (states[s]) {
                        c = " dojoxGridRow-" + s;
                        break;
                    }
                }
                inRow.customClasses += c;
            }
        }, onStyleRow:function (inRow) {
            this.styleRowState(inRow);
            this.inherited(arguments);
        }, canEdit:function (inCell, inRowIndex) {
            return this._canEdit;
        }, _copyAttr:function (idx, attr) {
            var row = {};
            var backstop = {};
            var src = this.getItem(idx);
            return this.store.getValue(src, attr);
        }, doStartEdit:function (inCell, inRowIndex) {
            if (!this._cache[inRowIndex]) {
                this._cache[inRowIndex] = this._copyAttr(inRowIndex, inCell.field);
            }
            this.onStartEdit(inCell, inRowIndex);
        }, doApplyCellEdit:function (inValue, inRowIndex, inAttrName) {
            this.store.fetchItemByIdentity({identity:this._by_idx[inRowIndex].idty, onItem:lang.hitch(this, function (item) {
                var oldValue = this.store.getValue(item, inAttrName);
                if (typeof oldValue == "number") {
                    inValue = isNaN(inValue) ? inValue : parseFloat(inValue);
                } else {
                    if (typeof oldValue == "boolean") {
                        inValue = inValue == "true" ? true : inValue == "false" ? false : inValue;
                    } else {
                        if (oldValue instanceof Date) {
                            var asDate = new Date(inValue);
                            inValue = isNaN(asDate.getTime()) ? inValue : asDate;
                        }
                    }
                }
                this.store.setValue(item, inAttrName, inValue);
                this.onApplyCellEdit(inValue, inRowIndex, inAttrName);
            })});
        }, doCancelEdit:function (inRowIndex) {
            var cache = this._cache[inRowIndex];
            if (cache) {
                this.updateRow(inRowIndex);
                delete this._cache[inRowIndex];
            }
            this.onCancelEdit.apply(this, arguments);
        }, doApplyEdit:function (inRowIndex, inDataAttr) {
            var cache = this._cache[inRowIndex];
            this.onApplyEdit(inRowIndex);
        }, removeSelectedRows:function () {
            if (this._canEdit) {
                this.edit.apply();
                var fx = lang.hitch(this, function (items) {
                    if (items.length) {
                        array.forEach(items, this.store.deleteItem, this.store);
                        this.selection.clear();
                    }
                });
                if (this.allItemsSelected) {
                    this.store.fetch({query:this.query, queryOptions:this.queryOptions, onComplete:fx});
                } else {
                    fx(this.selection.getSelected());
                }
            }
        }});
        DataGrid.cell_markupFactory = function (cellFunc, node, cellDef) {
            var field = lang.trim(html.attr(node, "field") || "");
            if (field) {
                cellDef.field = field;
            }
            cellDef.field = cellDef.field || cellDef.name;
            var fields = lang.trim(html.attr(node, "fields") || "");
            if (fields) {
                cellDef.fields = fields.split(",");
            }
            if (cellFunc) {
                cellFunc(node, cellDef);
            }
        };
        DataGrid.markupFactory = function (props, node, ctor, cellFunc) {
            return _Grid.markupFactory(props, node, ctor, lang.partial(DataGrid.cell_markupFactory, cellFunc));
        };
        return DataGrid;
    });
}, "dojo/dom-form":function () {
    define(["./_base/lang", "./dom", "./io-query", "./json"], function (lang, dom, ioq, json) {
        function setValue(obj, name, value) {
            if (value === null) {
                return;
            }
            var val = obj[name];
            if (typeof val == "string") {
                obj[name] = [val, value];
            } else {
                if (lang.isArray(val)) {
                    val.push(value);
                } else {
                    obj[name] = value;
                }
            }
        }
        var exclude = "file|submit|image|reset|button";
        var form = {fieldToObject:function fieldToObject(inputNode) {
            var ret = null;
            inputNode = dom.byId(inputNode);
            if (inputNode) {
                var _in = inputNode.name, type = (inputNode.type || "").toLowerCase();
                if (_in && type && !inputNode.disabled) {
                    if (type == "radio" || type == "checkbox") {
                        if (inputNode.checked) {
                            ret = inputNode.value;
                        }
                    } else {
                        if (inputNode.multiple) {
                            ret = [];
                            var nodes = [inputNode.firstChild];
                            while (nodes.length) {
                                for (var node = nodes.pop(); node; node = node.nextSibling) {
                                    if (node.nodeType == 1 && node.tagName.toLowerCase() == "option") {
                                        if (node.selected) {
                                            ret.push(node.value);
                                        }
                                    } else {
                                        if (node.nextSibling) {
                                            nodes.push(node.nextSibling);
                                        }
                                        if (node.firstChild) {
                                            nodes.push(node.firstChild);
                                        }
                                        break;
                                    }
                                }
                            }
                        } else {
                            ret = inputNode.value;
                        }
                    }
                }
            }
            return ret;
        }, toObject:function formToObject(formNode) {
            var ret = {}, elems = dom.byId(formNode).elements;
            for (var i = 0, l = elems.length; i < l; ++i) {
                var item = elems[i], _in = item.name, type = (item.type || "").toLowerCase();
                if (_in && type && exclude.indexOf(type) < 0 && !item.disabled) {
                    setValue(ret, _in, form.fieldToObject(item));
                    if (type == "image") {
                        ret[_in + ".x"] = ret[_in + ".y"] = ret[_in].x = ret[_in].y = 0;
                    }
                }
            }
            return ret;
        }, toQuery:function formToQuery(formNode) {
            return ioq.objectToQuery(form.toObject(formNode));
        }, toJson:function formToJson(formNode, prettyPrint) {
            return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0);
        }};
        return form;
    });
}, "dojox/grid/enhanced/plugins/_RowMapLayer":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/_base/kernel", "dojo/_base/lang", "./_StoreLayer"], function (array, declare, kernel, lang, layers) {
        var _devideToArrays = function (a) {
            a.sort(function (v1, v2) {
                return v1 - v2;
            });
            var arr = [[a[0]]];
            for (var i = 1, j = 0; i < a.length; ++i) {
                if (a[i] == a[i - 1] + 1) {
                    arr[j].push(a[i]);
                } else {
                    arr[++j] = [a[i]];
                }
            }
            return arr;
        }, hitchIfCan = function (scope, func) {
            return func ? lang.hitch(scope || kernel.global, func) : function () {
            };
        };
        return declare("dojox.grid.enhanced.plugins._RowMapLayer", layers._StoreLayer, {tags:["reorder"], constructor:function (grid) {
            this._map = {};
            this._revMap = {};
            this.grid = grid;
            this._oldOnDelete = grid._onDelete;
            var _this = this;
            grid._onDelete = function (item) {
                _this._onDelete(item);
                _this._oldOnDelete.call(grid, item);
            };
            this._oldSort = grid.sort;
            grid.sort = function () {
                _this.clearMapping();
                _this._oldSort.apply(grid, arguments);
            };
        }, uninitialize:function () {
            this.grid._onDelete = this._oldOnDelete;
            this.grid.sort = this._oldSort;
        }, setMapping:function (mapping) {
            this._store.forEachLayer(function (layer) {
                if (layer.name() === "rowmap") {
                    return false;
                } else {
                    if (layer.onRowMappingChange) {
                        layer.onRowMappingChange(mapping);
                    }
                }
                return true;
            }, false);
            var from, to, origin, revmap = {};
            for (from in mapping) {
                from = parseInt(from, 10);
                to = mapping[from];
                if (typeof to == "number") {
                    if (from in this._revMap) {
                        origin = this._revMap[from];
                        delete this._revMap[from];
                    } else {
                        origin = from;
                    }
                    if (origin == to) {
                        delete this._map[origin];
                        revmap[to] = "eq";
                    } else {
                        this._map[origin] = to;
                        revmap[to] = origin;
                    }
                }
            }
            for (to in revmap) {
                if (revmap[to] === "eq") {
                    delete this._revMap[parseInt(to, 10)];
                } else {
                    this._revMap[parseInt(to, 10)] = revmap[to];
                }
            }
        }, clearMapping:function () {
            this._map = {};
            this._revMap = {};
        }, _onDelete:function (item) {
            var idx = this.grid._getItemIndex(item, true);
            if (idx in this._revMap) {
                var rowIdxArr = [], r, i, origin = this._revMap[idx];
                delete this._map[origin];
                delete this._revMap[idx];
                for (r in this._revMap) {
                    r = parseInt(r, 10);
                    if (this._revMap[r] > origin) {
                        --this._revMap[r];
                    }
                }
                for (r in this._revMap) {
                    r = parseInt(r, 10);
                    if (r > idx) {
                        rowIdxArr.push(r);
                    }
                }
                rowIdxArr.sort(function (a, b) {
                    return b - a;
                });
                for (i = rowIdxArr.length - 1; i >= 0; --i) {
                    r = rowIdxArr[i];
                    this._revMap[r - 1] = this._revMap[r];
                    delete this._revMap[r];
                }
                this._map = {};
                for (r in this._revMap) {
                    this._map[this._revMap[r]] = r;
                }
            }
        }, _fetch:function (userRequest) {
            var mapCount = 0, r;
            var start = userRequest.start || 0;
            for (r in this._revMap) {
                r = parseInt(r, 10);
                if (r >= start) {
                    ++mapCount;
                }
            }
            if (mapCount > 0) {
                var rows = [], i, map = {}, count = userRequest.count > 0 ? userRequest.count : -1;
                if (count > 0) {
                    for (i = 0; i < count; ++i) {
                        r = start + i;
                        r = r in this._revMap ? this._revMap[r] : r;
                        map[r] = i;
                        rows.push(r);
                    }
                } else {
                    for (i = 0; ; ++i) {
                        r = start + i;
                        if (r in this._revMap) {
                            --mapCount;
                            r = this._revMap[r];
                        }
                        map[r] = i;
                        rows.push(r);
                        if (mapCount <= 0) {
                            break;
                        }
                    }
                }
                this._subFetch(userRequest, this._getRowArrays(rows), 0, [], map, userRequest.onComplete, start, count);
                return userRequest;
            } else {
                return lang.hitch(this._store, this._originFetch)(userRequest);
            }
        }, _getRowArrays:function (rows) {
            return _devideToArrays(rows);
        }, _subFetch:function (userRequest, rowArrays, index, result, map, oldOnComplete, start, count) {
            var arr = rowArrays[index], _this = this;
            var urstart = userRequest.start = arr[0];
            userRequest.count = arr[arr.length - 1] - arr[0] + 1;
            userRequest.onComplete = function (items) {
                array.forEach(items, function (item, i) {
                    var r = urstart + i;
                    if (r in map) {
                        result[map[r]] = item;
                    }
                });
                if (++index == rowArrays.length) {
                    if (count > 0) {
                        userRequest.start = start;
                        userRequest.count = count;
                        userRequest.onComplete = oldOnComplete;
                        hitchIfCan(userRequest.scope, oldOnComplete)(result, userRequest);
                    } else {
                        userRequest.start = userRequest.start + items.length;
                        delete userRequest.count;
                        userRequest.onComplete = function (items) {
                            result = result.concat(items);
                            userRequest.start = start;
                            userRequest.onComplete = oldOnComplete;
                            hitchIfCan(userRequest.scope, oldOnComplete)(result, userRequest);
                        };
                        _this.originFetch(userRequest);
                    }
                } else {
                    _this._subFetch(userRequest, rowArrays, index, result, map, oldOnComplete, start, count);
                }
            };
            _this.originFetch(userRequest);
        }});
    });
}, "dojox/collections/ArrayList":function () {
    define(["dojo/_base/kernel", "dojo/_base/array", "./_base"], function (dojo, darray, dxc) {
        dxc.ArrayList = function (arr) {
            var items = [];
            if (arr) {
                items = items.concat(arr);
            }
            this.count = items.length;
            this.add = function (obj) {
                items.push(obj);
                this.count = items.length;
            };
            this.addRange = function (a) {
                if (a.getIterator) {
                    var e = a.getIterator();
                    while (!e.atEnd()) {
                        this.add(e.get());
                    }
                    this.count = items.length;
                } else {
                    for (var i = 0; i < a.length; i++) {
                        items.push(a[i]);
                    }
                    this.count = items.length;
                }
            };
            this.clear = function () {
                items.splice(0, items.length);
                this.count = 0;
            };
            this.clone = function () {
                return new dxc.ArrayList(items);
            };
            this.contains = function (obj) {
                for (var i = 0; i < items.length; i++) {
                    if (items[i] == obj) {
                        return true;
                    }
                }
                return false;
            };
            this.forEach = function (fn, scope) {
                dojo.forEach(items, fn, scope);
            };
            this.getIterator = function () {
                return new dxc.Iterator(items);
            };
            this.indexOf = function (obj) {
                for (var i = 0; i < items.length; i++) {
                    if (items[i] == obj) {
                        return i;
                    }
                }
                return -1;
            };
            this.insert = function (i, obj) {
                items.splice(i, 0, obj);
                this.count = items.length;
            };
            this.item = function (i) {
                return items[i];
            };
            this.remove = function (obj) {
                var i = this.indexOf(obj);
                if (i >= 0) {
                    items.splice(i, 1);
                }
                this.count = items.length;
            };
            this.removeAt = function (i) {
                items.splice(i, 1);
                this.count = items.length;
            };
            this.reverse = function () {
                items.reverse();
            };
            this.sort = function (fn) {
                if (fn) {
                    items.sort(fn);
                } else {
                    items.sort();
                }
            };
            this.setByIndex = function (i, obj) {
                items[i] = obj;
                this.count = items.length;
            };
            this.toArray = function () {
                return [].concat(items);
            };
            this.toString = function (delim) {
                return items.join((delim || ","));
            };
        };
        return dxc.ArrayList;
    });
}, "dijit/Viewport":function () {
    define(["dojo/Evented", "dojo/on", "dojo/domReady", "dojo/sniff", "dojo/window"], function (Evented, on, domReady, has, winUtils) {
        var Viewport = new Evented();
        var focusedNode;
        domReady(function () {
            var oldBox = winUtils.getBox();
            Viewport._rlh = on(window, "resize", function () {
                var newBox = winUtils.getBox();
                if (oldBox.h == newBox.h && oldBox.w == newBox.w) {
                    return;
                }
                oldBox = newBox;
                Viewport.emit("resize");
            });
            if (has("ie") == 8) {
                var deviceXDPI = screen.deviceXDPI;
                setInterval(function () {
                    if (screen.deviceXDPI != deviceXDPI) {
                        deviceXDPI = screen.deviceXDPI;
                        Viewport.emit("resize");
                    }
                }, 500);
            }
            if (has("ios")) {
                on(document, "focusin", function (evt) {
                    focusedNode = evt.target;
                });
                on(document, "focusout", function (evt) {
                    focusedNode = null;
                });
            }
        });
        Viewport.getEffectiveBox = function (doc) {
            var box = winUtils.getBox(doc);
            var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
            if (has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" && /^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))) {
                box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.4);
                var rect = focusedNode.getBoundingClientRect();
                box.h = Math.max(box.h, rect.top + rect.height);
            }
            return box;
        };
        return Viewport;
    });
}, "dojox/grid/enhanced/plugins/Selector":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/event", "dojo/keys", "dojo/query", "dojo/_base/html", "dojo/_base/window", "dijit/focus", "../../_RowSelector", "../_Plugin", "../../EnhancedGrid", "../../cells/_base", "./AutoScroll"], function (dojo, lang, declare, array, event, keys, query, html, win, dijitFocus, _RowSelector, _Plugin, EnhancedGrid) {
        var DISABLED = 0, SINGLE = 1, MULTI = 2, _theOther = {col:"row", row:"col"}, _inRange = function (type, value, start, end, halfClose) {
            if (type !== "cell") {
                value = value[type];
                start = start[type];
                end = end[type];
                if (typeof value !== "number" || typeof start !== "number" || typeof end !== "number") {
                    return false;
                }
                return halfClose ? ((value >= start && value < end) || (value > end && value <= start)) : ((value >= start && value <= end) || (value >= end && value <= start));
            } else {
                return _inRange("col", value, start, end, halfClose) && _inRange("row", value, start, end, halfClose);
            }
        }, _isEqual = function (type, v1, v2) {
            try {
                if (v1 && v2) {
                    switch (type) {
                      case "col":
                      case "row":
                        return v1[type] == v2[type] && typeof v1[type] == "number" && !(_theOther[type] in v1) && !(_theOther[type] in v2);
                      case "cell":
                        return v1.col == v2.col && v1.row == v2.row && typeof v1.col == "number" && typeof v1.row == "number";
                    }
                }
            }
            catch (e) {
            }
            return false;
        }, _stopEvent = function (evt) {
            try {
                if (evt && evt.preventDefault) {
                    event.stop(evt);
                }
            }
            catch (e) {
            }
        }, _createItem = function (type, rowIndex, colIndex) {
            switch (type) {
              case "col":
                return {"col":typeof colIndex == "undefined" ? rowIndex : colIndex, "except":[]};
              case "row":
                return {"row":rowIndex, "except":[]};
              case "cell":
                return {"row":rowIndex, "col":colIndex};
            }
            return null;
        };
        var Selector = declare("dojox.grid.enhanced.plugins.Selector", _Plugin, {name:"selector", constructor:function (grid, args) {
            this.grid = grid;
            this._config = {row:MULTI, col:MULTI, cell:MULTI};
            this.noClear = args && args.noClear;
            this.setupConfig(args);
            if (grid.selectionMode === "single") {
                this._config.row = SINGLE;
            }
            this._enabled = true;
            this._selecting = {};
            this._selected = {"col":[], "row":[], "cell":[]};
            this._startPoint = {};
            this._currentPoint = {};
            this._lastAnchorPoint = {};
            this._lastEndPoint = {};
            this._lastSelectedAnchorPoint = {};
            this._lastSelectedEndPoint = {};
            this._keyboardSelect = {};
            this._lastType = null;
            this._selectedRowModified = {};
            this._hacks();
            this._initEvents();
            this._initAreas();
            this._mixinGrid();
        }, destroy:function () {
            this.inherited(arguments);
        }, setupConfig:function (config) {
            if (!config || !lang.isObject(config)) {
                return;
            }
            var types = ["row", "col", "cell"];
            for (var type in config) {
                if (array.indexOf(types, type) >= 0) {
                    if (!config[type] || config[type] == "disabled") {
                        this._config[type] = DISABLED;
                    } else {
                        if (config[type] == "single") {
                            this._config[type] = SINGLE;
                        } else {
                            this._config[type] = MULTI;
                        }
                    }
                }
            }
            var mode = ["none", "single", "extended"][this._config.row];
            this.grid.selection.setMode(mode);
        }, isSelected:function (type, rowIndex, colIndex) {
            return this._isSelected(type, _createItem(type, rowIndex, colIndex));
        }, toggleSelect:function (type, rowIndex, colIndex) {
            this._startSelect(type, _createItem(type, rowIndex, colIndex), this._config[type] === MULTI, false, false, !this.isSelected(type, rowIndex, colIndex));
            this._endSelect(type);
        }, select:function (type, rowIndex, colIndex) {
            if (!this.isSelected(type, rowIndex, colIndex)) {
                this.toggleSelect(type, rowIndex, colIndex);
            }
        }, deselect:function (type, rowIndex, colIndex) {
            if (this.isSelected(type, rowIndex, colIndex)) {
                this.toggleSelect(type, rowIndex, colIndex);
            }
        }, selectRange:function (type, start, end, toSelect) {
            this.grid._selectingRange = true;
            var startPoint = type == "cell" ? _createItem(type, start.row, start.col) : _createItem(type, start), endPoint = type == "cell" ? _createItem(type, end.row, end.col) : _createItem(type, end);
            this._startSelect(type, startPoint, false, false, false, toSelect);
            this._highlight(type, endPoint, toSelect === undefined ? true : toSelect);
            this._endSelect(type);
            this.grid._selectingRange = false;
        }, clear:function (type) {
            this._clearSelection(type || "all");
        }, isSelecting:function (type) {
            if (typeof type == "undefined") {
                return this._selecting.col || this._selecting.row || this._selecting.cell;
            }
            return this._selecting[type];
        }, selectEnabled:function (toEnable) {
            if (typeof toEnable != "undefined" && !this.isSelecting()) {
                this._enabled = !!toEnable;
            }
            return this._enabled;
        }, getSelected:function (type, includeExceptions) {
            switch (type) {
              case "cell":
                return array.map(this._selected[type], function (item) {
                    return item;
                });
              case "col":
              case "row":
                return array.map(includeExceptions ? this._selected[type] : array.filter(this._selected[type], function (item) {
                    return item.except.length === 0;
                }), function (item) {
                    return includeExceptions ? item : item[type];
                });
            }
            return [];
        }, getSelectedCount:function (type, includeExceptions) {
            switch (type) {
              case "cell":
                return this._selected[type].length;
              case "col":
              case "row":
                return (includeExceptions ? this._selected[type] : array.filter(this._selected[type], function (item) {
                    return item.except.length === 0;
                })).length;
            }
            return 0;
        }, getSelectedType:function () {
            var s = this._selected;
            return ["", "cell", "row", "row|cell", "col", "col|cell", "col|row", "col|row|cell"][(!!s.cell.length) | (!!s.row.length << 1) | (!!s.col.length << 2)];
        }, getLastSelectedRange:function (type) {
            return this._lastAnchorPoint[type] ? {"start":this._lastAnchorPoint[type], "end":this._lastEndPoint[type]} : null;
        }, _hacks:function () {
            var g = this.grid;
            var doContentMouseUp = function (e) {
                if (e.cellNode) {
                    g.onMouseUp(e);
                }
                g.onMouseUpRow(e);
            };
            var mouseUp = lang.hitch(g, "onMouseUp");
            var mouseDown = lang.hitch(g, "onMouseDown");
            var doRowSelectorFocus = function (e) {
                e.cellNode.style.border = "solid 1px";
            };
            array.forEach(g.views.views, function (view) {
                view.content.domouseup = doContentMouseUp;
                view.header.domouseup = mouseUp;
                if (view.declaredClass == "dojox.grid._RowSelector") {
                    view.domousedown = mouseDown;
                    view.domouseup = mouseUp;
                    view.dofocus = doRowSelectorFocus;
                }
            });
            g.selection.clickSelect = function () {
            };
            this._oldDeselectAll = g.selection.deselectAll;
            var _this = this;
            g.selection.selectRange = function (from, to) {
                _this.selectRange("row", from, to, true);
                if (g.selection.preserver) {
                    g.selection.preserver._updateMapping(true, true, false, from, to);
                }
                g.selection.onChanged();
            };
            g.selection.deselectRange = function (from, to) {
                _this.selectRange("row", from, to, false);
                if (g.selection.preserver) {
                    g.selection.preserver._updateMapping(true, false, false, from, to);
                }
                g.selection.onChanged();
            };
            g.selection.deselectAll = function () {
                g._selectingRange = true;
                _this._oldDeselectAll.apply(g.selection, arguments);
                _this._clearSelection("all");
                g._selectingRange = false;
                if (g.selection.preserver) {
                    g.selection.preserver._updateMapping(true, false, true);
                }
                g.selection.onChanged();
            };
            var rowSelector = g.views.views[0];
            if (rowSelector instanceof _RowSelector) {
                rowSelector.doStyleRowNode = function (inRowIndex, inRowNode) {
                    html.removeClass(inRowNode, "dojoxGridRow");
                    html.addClass(inRowNode, "dojoxGridRowbar");
                    html.addClass(inRowNode, "dojoxGridNonNormalizedCell");
                    html.toggleClass(inRowNode, "dojoxGridRowbarOver", g.rows.isOver(inRowIndex));
                    html.toggleClass(inRowNode, "dojoxGridRowbarSelected", !!g.selection.isSelected(inRowIndex));
                };
            }
            this.connect(g, "updateRow", function (rowIndex) {
                array.forEach(g.layout.cells, function (cell) {
                    if (this.isSelected("cell", rowIndex, cell.index)) {
                        this._highlightNode(cell.getNode(rowIndex), true);
                    }
                }, this);
            });
        }, _mixinGrid:function () {
            var g = this.grid;
            g.setupSelectorConfig = lang.hitch(this, this.setupConfig);
            g.onStartSelect = function () {
            };
            g.onEndSelect = function () {
            };
            g.onStartDeselect = function () {
            };
            g.onEndDeselect = function () {
            };
            g.onSelectCleared = function () {
            };
        }, _initEvents:function () {
            var g = this.grid, _this = this, dp = lang.partial, starter = function (type, e) {
                if (type === "row") {
                    _this._isUsingRowSelector = true;
                }
                if (_this.selectEnabled() && _this._config[type] && e.button != 2) {
                    if (_this._keyboardSelect.col || _this._keyboardSelect.row || _this._keyboardSelect.cell) {
                        _this._endSelect("all");
                        _this._keyboardSelect.col = _this._keyboardSelect.row = _this._keyboardSelect.cell = 0;
                    }
                    if (_this._usingKeyboard) {
                        _this._usingKeyboard = false;
                    }
                    var target = _createItem(type, e.rowIndex, e.cell && e.cell.index);
                    _this._startSelect(type, target, e.ctrlKey, e.shiftKey);
                }
            }, ender = lang.hitch(this, "_endSelect");
            this.connect(g, "onHeaderCellMouseDown", dp(starter, "col"));
            this.connect(g, "onHeaderCellMouseUp", dp(ender, "col"));
            this.connect(g, "onRowSelectorMouseDown", dp(starter, "row"));
            this.connect(g, "onRowSelectorMouseUp", dp(ender, "row"));
            this.connect(g, "onCellMouseDown", function (e) {
                if (e.cell && e.cell.isRowSelector) {
                    return;
                }
                if (g.singleClickEdit) {
                    _this._singleClickEdit = true;
                    g.singleClickEdit = false;
                }
                starter(_this._config["cell"] == DISABLED ? "row" : "cell", e);
            });
            this.connect(g, "onCellMouseUp", function (e) {
                if (_this._singleClickEdit) {
                    delete _this._singleClickEdit;
                    g.singleClickEdit = true;
                }
                ender("all", e);
            });
            this.connect(g, "onCellMouseOver", function (e) {
                if (_this._curType != "row" && _this._selecting[_this._curType] && _this._config[_this._curType] == MULTI) {
                    _this._highlight("col", _createItem("col", e.cell.index), _this._toSelect);
                    if (!_this._keyboardSelect.cell) {
                        _this._highlight("cell", _createItem("cell", e.rowIndex, e.cell.index), _this._toSelect);
                    }
                }
            });
            this.connect(g, "onHeaderCellMouseOver", function (e) {
                if (_this._selecting.col && _this._config.col == MULTI) {
                    _this._highlight("col", _createItem("col", e.cell.index), _this._toSelect);
                }
            });
            this.connect(g, "onRowMouseOver", function (e) {
                if (_this._selecting.row && _this._config.row == MULTI) {
                    _this._highlight("row", _createItem("row", e.rowIndex), _this._toSelect);
                }
            });
            this.connect(g, "onSelectedById", "_onSelectedById");
            this.connect(g, "_onFetchComplete", function () {
                if (!g._notRefreshSelection) {
                    this._refreshSelected(true);
                }
            });
            this.connect(g.scroller, "buildPage", function () {
                if (!g._notRefreshSelection) {
                    this._refreshSelected(true);
                }
            });
            this.connect(win.doc, "onmouseup", dp(ender, "all"));
            this.connect(g, "onEndAutoScroll", function (isVertical, isForward, view, target) {
                var selectCell = _this._selecting.cell, type, current, dir = isForward ? 1 : -1;
                if (isVertical && (selectCell || _this._selecting.row)) {
                    type = selectCell ? "cell" : "row";
                    current = _this._currentPoint[type];
                    _this._highlight(type, _createItem(type, current.row + dir, current.col), _this._toSelect);
                } else {
                    if (!isVertical && (selectCell || _this._selecting.col)) {
                        type = selectCell ? "cell" : "col";
                        current = _this._currentPoint[type];
                        _this._highlight(type, _createItem(type, current.row, target), _this._toSelect);
                    }
                }
            });
            this.subscribe("dojox/grid/rearrange/move/" + g.id, "_onInternalRearrange");
            this.subscribe("dojox/grid/rearrange/copy/" + g.id, "_onInternalRearrange");
            this.subscribe("dojox/grid/rearrange/change/" + g.id, "_onExternalChange");
            this.subscribe("dojox/grid/rearrange/insert/" + g.id, "_onExternalChange");
            this.subscribe("dojox/grid/rearrange/remove/" + g.id, "clear");
            this.connect(g, "onSelected", function (rowIndex) {
                if (this._selectedRowModified && this._isUsingRowSelector) {
                    delete this._selectedRowModified;
                } else {
                    if (!this.grid._selectingRange) {
                        this.select("row", rowIndex);
                    }
                }
            });
            this.connect(g, "onDeselected", function (rowIndex) {
                if (this._selectedRowModified && this._isUsingRowSelector) {
                    delete this._selectedRowModified;
                } else {
                    if (!this.grid._selectingRange) {
                        this.deselect("row", rowIndex);
                    }
                }
            });
        }, _onSelectedById:function (id, newIndex, isSelected) {
            if (this.grid._noInternalMapping) {
                return;
            }
            var pointSet = [this._lastAnchorPoint.row, this._lastEndPoint.row, this._lastSelectedAnchorPoint.row, this._lastSelectedEndPoint.row];
            pointSet = pointSet.concat(this._selected.row);
            var found = false;
            array.forEach(pointSet, function (item) {
                if (item) {
                    if (item.id === id) {
                        found = true;
                        item.row = newIndex;
                    } else {
                        if (item.row === newIndex && item.id) {
                            item.row = -1;
                        }
                    }
                }
            });
            if (!found && isSelected) {
                array.some(this._selected.row, function (item) {
                    if (item && !item.id && !item.except.length) {
                        item.id = id;
                        item.row = newIndex;
                        return true;
                    }
                    return false;
                });
            }
            found = false;
            pointSet = [this._lastAnchorPoint.cell, this._lastEndPoint.cell, this._lastSelectedAnchorPoint.cell, this._lastSelectedEndPoint.cell];
            pointSet = pointSet.concat(this._selected.cell);
            array.forEach(pointSet, function (item) {
                if (item) {
                    if (item.id === id) {
                        found = true;
                        item.row = newIndex;
                    } else {
                        if (item.row === newIndex && item.id) {
                            item.row = -1;
                        }
                    }
                }
            });
        }, onSetStore:function () {
            this._clearSelection("all");
        }, _onInternalRearrange:function (type, mapping) {
            try {
                this._refresh("col", false);
                array.forEach(this._selected.row, function (item) {
                    array.forEach(this.grid.layout.cells, function (cell) {
                        this._highlightNode(cell.getNode(item.row), false);
                    }, this);
                }, this);
                query(".dojoxGridRowSelectorSelected").forEach(function (node) {
                    html.removeClass(node, "dojoxGridRowSelectorSelected");
                    html.removeClass(node, "dojoxGridRowSelectorSelectedUp");
                    html.removeClass(node, "dojoxGridRowSelectorSelectedDown");
                });
                var cleanUp = function (item) {
                    if (item) {
                        delete item.converted;
                    }
                }, pointSet = [this._lastAnchorPoint[type], this._lastEndPoint[type], this._lastSelectedAnchorPoint[type], this._lastSelectedEndPoint[type]];
                if (type === "cell") {
                    this.selectRange("cell", mapping.to.min, mapping.to.max);
                    var cells = this.grid.layout.cells;
                    array.forEach(pointSet, function (item) {
                        if (item.converted) {
                            return;
                        }
                        for (var r = mapping.from.min.row, tr = mapping.to.min.row; r <= mapping.from.max.row; ++r, ++tr) {
                            for (var c = mapping.from.min.col, tc = mapping.to.min.col; c <= mapping.from.max.col; ++c, ++tc) {
                                while (cells[c].hidden) {
                                    ++c;
                                }
                                while (cells[tc].hidden) {
                                    ++tc;
                                }
                                if (item.row == r && item.col == c) {
                                    item.row = tr;
                                    item.col = tc;
                                    item.converted = true;
                                    return;
                                }
                            }
                        }
                    });
                } else {
                    pointSet = this._selected.cell.concat(this._selected[type]).concat(pointSet).concat([this._lastAnchorPoint.cell, this._lastEndPoint.cell, this._lastSelectedAnchorPoint.cell, this._lastSelectedEndPoint.cell]);
                    array.forEach(pointSet, function (item) {
                        if (item && !item.converted) {
                            var from = item[type];
                            if (from in mapping) {
                                item[type] = mapping[from];
                            }
                            item.converted = true;
                        }
                    });
                    array.forEach(this._selected[_theOther[type]], function (item) {
                        for (var i = 0, len = item.except.length; i < len; ++i) {
                            var from = item.except[i];
                            if (from in mapping) {
                                item.except[i] = mapping[from];
                            }
                        }
                    });
                }
                array.forEach(pointSet, cleanUp);
                this._refreshSelected(true);
                this._focusPoint(type, this._lastEndPoint);
            }
            catch (e) {
                console.warn("Selector._onInternalRearrange() error", e);
            }
        }, _onExternalChange:function (type, target) {
            var start = type == "cell" ? target.min : target[0], end = type == "cell" ? target.max : target[target.length - 1];
            this.selectRange(type, start, end);
        }, _refresh:function (type, toHighlight) {
            if (!this._keyboardSelect[type]) {
                array.forEach(this._selected[type], function (item) {
                    this._highlightSingle(type, toHighlight, item, undefined, true);
                }, this);
            }
        }, _refreshSelected:function () {
            this._refresh("col", true);
            this._refresh("row", true);
            this._refresh("cell", true);
        }, _initAreas:function () {
            var g = this.grid, f = g.focus, _this = this, keyboardSelectReady = 1, duringKeyboardSelect = 2, onmove = function (type, createNewEnd, rowStep, colStep, evt) {
                var ks = _this._keyboardSelect;
                if (evt.shiftKey && ks[type]) {
                    if (ks[type] === keyboardSelectReady) {
                        if (type === "cell") {
                            var item = _this._lastEndPoint[type];
                            if (f.cell != g.layout.cells[item.col + colStep] || f.rowIndex != item.row + rowStep) {
                                ks[type] = 0;
                                return;
                            }
                        }
                        _this._startSelect(type, _this._lastAnchorPoint[type], true, false, true);
                        _this._highlight(type, _this._lastEndPoint[type], _this._toSelect);
                        ks[type] = duringKeyboardSelect;
                    }
                    var newEnd = createNewEnd(type, rowStep, colStep, evt);
                    if (_this._isValid(type, newEnd, g)) {
                        _this._highlight(type, newEnd, _this._toSelect);
                    }
                    _stopEvent(evt);
                }
            }, onkeydown = function (type, getTarget, evt, isBubble) {
                if (isBubble && _this.selectEnabled() && _this._config[type] != DISABLED) {
                    switch (evt.keyCode) {
                      case keys.SPACE:
                        _this._startSelect(type, getTarget(), evt.ctrlKey, evt.shiftKey);
                        _this._endSelect(type);
                        break;
                      case keys.SHIFT:
                        if (_this._config[type] == MULTI && _this._isValid(type, _this._lastAnchorPoint[type], g)) {
                            _this._endSelect(type);
                            _this._keyboardSelect[type] = keyboardSelectReady;
                            _this._usingKeyboard = true;
                        }
                    }
                }
            }, onkeyup = function (type, evt, isBubble) {
                if (isBubble && evt.keyCode == keys.SHIFT && _this._keyboardSelect[type]) {
                    _this._endSelect(type);
                    _this._keyboardSelect[type] = 0;
                }
            };
            if (g.views.views[0] instanceof _RowSelector) {
                this._lastFocusedRowBarIdx = 0;
                f.addArea({name:"rowHeader", onFocus:function (evt, step) {
                    var view = g.views.views[0];
                    if (view instanceof _RowSelector) {
                        var rowBarNode = view.getCellNode(_this._lastFocusedRowBarIdx, 0);
                        if (rowBarNode) {
                            html.toggleClass(rowBarNode, f.focusClass, false);
                        }
                        if (evt && "rowIndex" in evt) {
                            if (evt.rowIndex >= 0) {
                                _this._lastFocusedRowBarIdx = evt.rowIndex;
                            } else {
                                if (!_this._lastFocusedRowBarIdx) {
                                    _this._lastFocusedRowBarIdx = 0;
                                }
                            }
                        }
                        rowBarNode = view.getCellNode(_this._lastFocusedRowBarIdx, 0);
                        if (rowBarNode) {
                            dijitFocus.focus(rowBarNode);
                            html.toggleClass(rowBarNode, f.focusClass, true);
                        }
                        f.rowIndex = _this._lastFocusedRowBarIdx;
                        _stopEvent(evt);
                        return true;
                    }
                    return false;
                }, onBlur:function (evt, step) {
                    var view = g.views.views[0];
                    if (view instanceof _RowSelector) {
                        var rowBarNode = view.getCellNode(_this._lastFocusedRowBarIdx, 0);
                        if (rowBarNode) {
                            html.toggleClass(rowBarNode, f.focusClass, false);
                        }
                        _stopEvent(evt);
                    }
                    return true;
                }, onMove:function (rowStep, colStep, evt) {
                    var view = g.views.views[0];
                    if (rowStep && view instanceof _RowSelector) {
                        var next = _this._lastFocusedRowBarIdx + rowStep;
                        if (next >= 0 && next < g.rowCount) {
                            _stopEvent(evt);
                            var rowBarNode = view.getCellNode(_this._lastFocusedRowBarIdx, 0);
                            html.toggleClass(rowBarNode, f.focusClass, false);
                            var sc = g.scroller;
                            var lastPageRow = sc.getLastPageRow(sc.page);
                            var rc = g.rowCount - 1, row = Math.min(rc, next);
                            if (next > lastPageRow) {
                                g.setScrollTop(g.scrollTop + sc.findScrollTop(row) - sc.findScrollTop(_this._lastFocusedRowBarIdx));
                            }
                            rowBarNode = view.getCellNode(next, 0);
                            dijitFocus.focus(rowBarNode);
                            html.toggleClass(rowBarNode, f.focusClass, true);
                            _this._lastFocusedRowBarIdx = next;
                            f.cell = rowBarNode;
                            f.cell.view = view;
                            f.cell.getNode = function (index) {
                                return f.cell;
                            };
                            f.rowIndex = _this._lastFocusedRowBarIdx;
                            f.scrollIntoView();
                            f.cell = null;
                        }
                    }
                }});
                f.placeArea("rowHeader", "before", "content");
            }
            f.addArea({name:"cellselect", onMove:lang.partial(onmove, "cell", function (type, rowStep, colStep, evt) {
                var current = _this._currentPoint[type];
                return _createItem("cell", current.row + rowStep, current.col + colStep);
            }), onKeyDown:lang.partial(onkeydown, "cell", function () {
                return _createItem("cell", f.rowIndex, f.cell.index);
            }), onKeyUp:lang.partial(onkeyup, "cell")});
            f.placeArea("cellselect", "below", "content");
            f.addArea({name:"colselect", onMove:lang.partial(onmove, "col", function (type, rowStep, colStep, evt) {
                var current = _this._currentPoint[type];
                return _createItem("col", current.col + colStep);
            }), onKeyDown:lang.partial(onkeydown, "col", function () {
                return _createItem("col", f.getHeaderIndex());
            }), onKeyUp:lang.partial(onkeyup, "col")});
            f.placeArea("colselect", "below", "header");
            f.addArea({name:"rowselect", onMove:lang.partial(onmove, "row", function (type, rowStep, colStep, evt) {
                return _createItem("row", f.rowIndex);
            }), onKeyDown:lang.partial(onkeydown, "row", function () {
                return _createItem("row", f.rowIndex);
            }), onKeyUp:lang.partial(onkeyup, "row")});
            f.placeArea("rowselect", "below", "rowHeader");
        }, _clearSelection:function (type, reservedItem) {
            if (type == "all") {
                this._clearSelection("cell", reservedItem);
                this._clearSelection("col", reservedItem);
                this._clearSelection("row", reservedItem);
                return;
            }
            this._isUsingRowSelector = true;
            array.forEach(this._selected[type], function (item) {
                if (!_isEqual(type, reservedItem, item)) {
                    this._highlightSingle(type, false, item);
                }
            }, this);
            this._blurPoint(type, this._currentPoint);
            this._selecting[type] = false;
            this._startPoint[type] = this._currentPoint[type] = null;
            this._selected[type] = [];
            if (type == "row" && !this.grid._selectingRange) {
                this._oldDeselectAll.call(this.grid.selection);
                this.grid.selection._selectedById = {};
            }
            this.grid.onEndDeselect(type, null, null, this._selected);
            this.grid.onSelectCleared(type);
        }, _startSelect:function (type, start, extending, isRange, mandatarySelect, toSelect) {
            if (!this._isValid(type, start)) {
                return;
            }
            var lastIsSelected = this._isSelected(type, this._lastEndPoint[type]), isSelected = this._isSelected(type, start);
            if (this.noClear && !extending) {
                this._toSelect = toSelect === undefined ? true : toSelect;
            } else {
                this._toSelect = mandatarySelect ? isSelected : !isSelected;
            }
            if (!extending || (!isSelected && this._config[type] == SINGLE)) {
                this._clearSelection("col", start);
                this._clearSelection("cell", start);
                if (!this.noClear || (type === "row" && this._config[type] == SINGLE)) {
                    this._clearSelection("row", start);
                }
                this._toSelect = toSelect === undefined ? true : toSelect;
            }
            this._selecting[type] = true;
            this._currentPoint[type] = null;
            if (isRange && this._lastType == type && lastIsSelected == this._toSelect && this._config[type] == MULTI) {
                if (type === "row") {
                    this._isUsingRowSelector = true;
                }
                this._startPoint[type] = this._lastAnchorPoint[type];
                this._highlight(type, this._startPoint[type]);
                this._isUsingRowSelector = false;
            } else {
                this._startPoint[type] = start;
            }
            this._curType = type;
            this._fireEvent("start", type);
            this._isStartFocus = true;
            this._isUsingRowSelector = true;
            this._highlight(type, start, this._toSelect);
            this._isStartFocus = false;
        }, _endSelect:function (type) {
            if (type === "row") {
                delete this._isUsingRowSelector;
            }
            if (type == "all") {
                this._endSelect("col");
                this._endSelect("row");
                this._endSelect("cell");
            } else {
                if (this._selecting[type]) {
                    this._addToSelected(type);
                    this._lastAnchorPoint[type] = this._startPoint[type];
                    this._lastEndPoint[type] = this._currentPoint[type];
                    if (this._toSelect) {
                        this._lastSelectedAnchorPoint[type] = this._lastAnchorPoint[type];
                        this._lastSelectedEndPoint[type] = this._lastEndPoint[type];
                    }
                    this._startPoint[type] = this._currentPoint[type] = null;
                    this._selecting[type] = false;
                    this._lastType = type;
                    this._fireEvent("end", type);
                }
            }
        }, _fireEvent:function (evtName, type) {
            switch (evtName) {
              case "start":
                this.grid[this._toSelect ? "onStartSelect" : "onStartDeselect"](type, this._startPoint[type], this._selected);
                break;
              case "end":
                this.grid[this._toSelect ? "onEndSelect" : "onEndDeselect"](type, this._lastAnchorPoint[type], this._lastEndPoint[type], this._selected);
                break;
            }
        }, _calcToHighlight:function (type, target, toHighlight, toSelect) {
            if (toSelect !== undefined) {
                var sltd;
                if (this._usingKeyboard && !toHighlight) {
                    var last = this._isInLastRange(this._lastType, target);
                    if (last) {
                        sltd = this._isSelected(type, target);
                        if (toSelect && sltd) {
                            return false;
                        }
                        if (!toSelect && !sltd && this._isInLastRange(this._lastType, target, true)) {
                            return true;
                        }
                    }
                }
                return toHighlight ? toSelect : (sltd || this._isSelected(type, target));
            }
            return toHighlight;
        }, _highlightNode:function (node, toHighlight) {
            if (node) {
                var selectCSSClass = "dojoxGridRowSelected";
                var selectCellClass = "dojoxGridCellSelected";
                html.toggleClass(node, selectCSSClass, toHighlight);
                html.toggleClass(node, selectCellClass, toHighlight);
            }
        }, _highlightHeader:function (colIdx, toHighlight) {
            var cells = this.grid.layout.cells;
            var node = cells[colIdx].getHeaderNode();
            var selectedClass = "dojoxGridHeaderSelected";
            html.toggleClass(node, selectedClass, toHighlight);
        }, _highlightRowSelector:function (rowIdx, toHighlight) {
            var rowSelector = this.grid.views.views[0];
            if (rowSelector instanceof _RowSelector) {
                var node = rowSelector.getRowNode(rowIdx);
                if (node) {
                    var selectedClass = "dojoxGridRowSelectorSelected";
                    html.toggleClass(node, selectedClass, toHighlight);
                }
            }
        }, _highlightSingle:function (type, toHighlight, target, toSelect, isRefresh) {
            var _this = this, toHL, g = _this.grid, cells = g.layout.cells;
            switch (type) {
              case "cell":
                toHL = this._calcToHighlight(type, target, toHighlight, toSelect);
                var c = cells[target.col];
                if (!c.hidden && !c.notselectable) {
                    this._highlightNode(target.node || c.getNode(target.row), toHL);
                }
                break;
              case "col":
                toHL = this._calcToHighlight(type, target, toHighlight, toSelect);
                this._highlightHeader(target.col, toHL);
                query("td[idx='" + target.col + "']", g.domNode).forEach(function (cellNode) {
                    var rowNode = cells[target.col].view.content.findRowTarget(cellNode);
                    if (rowNode) {
                        var rowIndex = rowNode[dojox.grid.util.rowIndexTag];
                        _this._highlightSingle("cell", toHL, {"row":rowIndex, "col":target.col, "node":cellNode});
                    }
                });
                break;
              case "row":
                toHL = this._calcToHighlight(type, target, toHighlight, toSelect);
                this._highlightRowSelector(target.row, toHL);
                if (this._config.cell) {
                    array.forEach(cells, function (cell) {
                        _this._highlightSingle("cell", toHL, {"row":target.row, "col":cell.index, "node":cell.getNode(target.row)});
                    });
                }
                this._selectedRowModified = true;
                if (!isRefresh) {
                    g.selection.setSelected(target.row, toHL);
                }
            }
        }, _highlight:function (type, target, toSelect) {
            if (this._selecting[type] && target !== null) {
                var start = this._startPoint[type], current = this._currentPoint[type], _this = this, highlight = function (from, to, toHL) {
                    _this._forEach(type, from, to, function (item) {
                        _this._highlightSingle(type, toHL, item, toSelect);
                    }, true);
                };
                switch (type) {
                  case "col":
                  case "row":
                    if (current !== null) {
                        if (_inRange(type, target, start, current, true)) {
                            highlight(current, target, false);
                        } else {
                            if (_inRange(type, start, target, current, true)) {
                                highlight(current, start, false);
                                current = start;
                            }
                            highlight(target, current, true);
                        }
                    } else {
                        this._highlightSingle(type, true, target, toSelect);
                    }
                    break;
                  case "cell":
                    if (current !== null) {
                        if (_inRange("row", target, start, current, true) || _inRange("col", target, start, current, true) || _inRange("row", start, target, current, true) || _inRange("col", start, target, current, true)) {
                            highlight(start, current, false);
                        }
                    }
                    highlight(start, target, true);
                }
                this._currentPoint[type] = target;
                this._focusPoint(type, this._currentPoint);
            }
        }, _focusPoint:function (type, point) {
            if (!this._isStartFocus) {
                var current = point[type], f = this.grid.focus;
                if (type == "col") {
                    f._colHeadFocusIdx = current.col;
                    f.focusArea("header");
                } else {
                    if (type == "row") {
                        f.focusArea("rowHeader", {"rowIndex":current.row});
                    } else {
                        if (type == "cell") {
                            f.setFocusIndex(current.row, current.col);
                        }
                    }
                }
            }
        }, _blurPoint:function (type, point) {
            var f = this.grid.focus;
            if (type == "cell") {
                f._blurContent();
            }
        }, _addToSelected:function (type) {
            var toSelect = this._toSelect, _this = this, toAdd = [], toRemove = [], start = this._startPoint[type], end = this._currentPoint[type];
            if (this._usingKeyboard) {
                this._forEach(type, this._lastAnchorPoint[type], this._lastEndPoint[type], function (item) {
                    if (!_inRange(type, item, start, end)) {
                        (toSelect ? toRemove : toAdd).push(item);
                    }
                });
            }
            this._forEach(type, start, end, function (item) {
                var isSelected = _this._isSelected(type, item);
                if (toSelect && !isSelected) {
                    toAdd.push(item);
                } else {
                    if (!toSelect) {
                        toRemove.push(item);
                    }
                }
            });
            this._add(type, toAdd);
            this._remove(type, toRemove);
            array.forEach(this._selected.row, function (item) {
                if (item.except.length > 0) {
                    this._selectedRowModified = true;
                    this.grid.selection.setSelected(item.row, false);
                }
            }, this);
        }, _forEach:function (type, start, end, func, halfClose) {
            if (!this._isValid(type, start, true) || !this._isValid(type, end, true)) {
                return;
            }
            switch (type) {
              case "col":
              case "row":
                start = start[type];
                end = end[type];
                var dir = end > start ? 1 : -1;
                if (!halfClose) {
                    end += dir;
                }
                for (; start != end; start += dir) {
                    func(_createItem(type, start));
                }
                break;
              case "cell":
                var colDir = end.col > start.col ? 1 : -1, rowDir = end.row > start.row ? 1 : -1;
                for (var i = start.row, p = end.row + rowDir; i != p; i += rowDir) {
                    for (var j = start.col, q = end.col + colDir; j != q; j += colDir) {
                        func(_createItem(type, i, j));
                    }
                }
            }
        }, _makeupForExceptions:function (type, newCellItems) {
            var makedUps = [];
            array.forEach(this._selected[type], function (v1) {
                array.forEach(newCellItems, function (v2) {
                    if (v1[type] == v2[type]) {
                        var pos = array.indexOf(v1.except, v2[_theOther[type]]);
                        if (pos >= 0) {
                            v1.except.splice(pos, 1);
                        }
                        makedUps.push(v2);
                    }
                });
            });
            return makedUps;
        }, _makeupForCells:function (type, newItems) {
            var toRemove = [];
            array.forEach(this._selected.cell, function (v1) {
                array.some(newItems, function (v2) {
                    if (v1[type] == v2[type]) {
                        toRemove.push(v1);
                        return true;
                    }
                    return false;
                });
            });
            this._remove("cell", toRemove);
            array.forEach(this._selected[_theOther[type]], function (v1) {
                array.forEach(newItems, function (v2) {
                    var pos = array.indexOf(v1.except, v2[type]);
                    if (pos >= 0) {
                        v1.except.splice(pos, 1);
                    }
                });
            });
        }, _addException:function (type, items) {
            array.forEach(this._selected[type], function (v1) {
                array.forEach(items, function (v2) {
                    v1.except.push(v2[_theOther[type]]);
                });
            });
        }, _addCellException:function (type, items) {
            array.forEach(this._selected[type], function (v1) {
                array.forEach(items, function (v2) {
                    if (v1[type] == v2[type]) {
                        v1.except.push(v2[_theOther[type]]);
                    }
                });
            });
        }, _add:function (type, items) {
            var cells = this.grid.layout.cells;
            if (type == "cell") {
                var colMakedup = this._makeupForExceptions("col", items);
                var rowMakedup = this._makeupForExceptions("row", items);
                items = array.filter(items, function (item) {
                    return array.indexOf(colMakedup, item) < 0 && array.indexOf(rowMakedup, item) < 0 && !cells[item.col].hidden && !cells[item.col].notselectable;
                });
            } else {
                if (type == "col") {
                    items = array.filter(items, function (item) {
                        return !cells[item.col].hidden && !cells[item.col].notselectable;
                    });
                }
                this._makeupForCells(type, items);
                this._selected[type] = array.filter(this._selected[type], function (v) {
                    return array.every(items, function (item) {
                        return v[type] !== item[type];
                    });
                });
            }
            if (type != "col" && this.grid._hasIdentity) {
                array.forEach(items, function (item) {
                    var record = this.grid._by_idx[item.row];
                    if (record) {
                        item.id = record.idty;
                    }
                }, this);
            }
            this._selected[type] = this._selected[type].concat(items);
        }, _remove:function (type, items) {
            var comp = lang.partial(_isEqual, type);
            this._selected[type] = array.filter(this._selected[type], function (v1) {
                return !array.some(items, function (v2) {
                    return comp(v1, v2);
                });
            });
            if (type == "cell") {
                this._addCellException("col", items);
                this._addCellException("row", items);
            } else {
                if (this._config.cell) {
                    this._addException(_theOther[type], items);
                }
            }
        }, _isCellNotInExcept:function (type, item) {
            var attr = item[type], corres = item[_theOther[type]];
            return array.some(this._selected[type], function (v) {
                return v[type] == attr && array.indexOf(v.except, corres) < 0;
            });
        }, _isSelected:function (type, item) {
            if (!item) {
                return false;
            }
            var res = array.some(this._selected[type], function (v) {
                var ret = _isEqual(type, item, v);
                if (ret && type !== "cell") {
                    return v.except.length === 0;
                }
                return ret;
            });
            if (!res && type === "cell") {
                res = (this._isCellNotInExcept("col", item) || this._isCellNotInExcept("row", item));
                if (type === "cell") {
                    res = res && !this.grid.layout.cells[item.col].notselectable;
                }
            }
            return res;
        }, _isInLastRange:function (type, item, isSelected) {
            var start = this[isSelected ? "_lastSelectedAnchorPoint" : "_lastAnchorPoint"][type], end = this[isSelected ? "_lastSelectedEndPoint" : "_lastEndPoint"][type];
            if (!item || !start || !end) {
                return false;
            }
            return _inRange(type, item, start, end);
        }, _isValid:function (type, item, allowNotSelectable) {
            if (!item) {
                return false;
            }
            try {
                var g = this.grid, index = item[type];
                switch (type) {
                  case "col":
                    return index >= 0 && index < g.layout.cells.length && lang.isArray(item.except) && (allowNotSelectable || !g.layout.cells[index].notselectable);
                  case "row":
                    return index >= 0 && index < g.rowCount && lang.isArray(item.except);
                  case "cell":
                    return item.col >= 0 && item.col < g.layout.cells.length && item.row >= 0 && item.row < g.rowCount && (allowNotSelectable || !g.layout.cells[item.col].notselectable);
                }
            }
            catch (e) {
            }
            return false;
        }});
        EnhancedGrid.registerPlugin(Selector, {"dependency":["autoScroll"]});
        return Selector;
    });
}, "dijit/_editor/range":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/_base/lang"], function (array, declare, lang) {
        var rangeapi = {getIndex:function (node, parent) {
            var ret = [], retR = [];
            var onode = node;
            var pnode, n;
            while (node != parent) {
                var i = 0;
                pnode = node.parentNode;
                while ((n = pnode.childNodes[i++])) {
                    if (n === node) {
                        --i;
                        break;
                    }
                }
                ret.unshift(i);
                retR.unshift(i - pnode.childNodes.length);
                node = pnode;
            }
            if (ret.length > 0 && onode.nodeType == 3) {
                n = onode.previousSibling;
                while (n && n.nodeType == 3) {
                    ret[ret.length - 1]--;
                    n = n.previousSibling;
                }
                n = onode.nextSibling;
                while (n && n.nodeType == 3) {
                    retR[retR.length - 1]++;
                    n = n.nextSibling;
                }
            }
            return {o:ret, r:retR};
        }, getNode:function (index, parent) {
            if (!lang.isArray(index) || index.length == 0) {
                return parent;
            }
            var node = parent;
            array.every(index, function (i) {
                if (i >= 0 && i < node.childNodes.length) {
                    node = node.childNodes[i];
                } else {
                    node = null;
                    return false;
                }
                return true;
            });
            return node;
        }, getCommonAncestor:function (n1, n2, root) {
            root = root || n1.ownerDocument.body;
            var getAncestors = function (n) {
                var as = [];
                while (n) {
                    as.unshift(n);
                    if (n !== root) {
                        n = n.parentNode;
                    } else {
                        break;
                    }
                }
                return as;
            };
            var n1as = getAncestors(n1);
            var n2as = getAncestors(n2);
            var m = Math.min(n1as.length, n2as.length);
            var com = n1as[0];
            for (var i = 1; i < m; i++) {
                if (n1as[i] === n2as[i]) {
                    com = n1as[i];
                } else {
                    break;
                }
            }
            return com;
        }, getAncestor:function (node, regex, root) {
            root = root || node.ownerDocument.body;
            while (node && node !== root) {
                var name = node.nodeName.toUpperCase();
                if (regex.test(name)) {
                    return node;
                }
                node = node.parentNode;
            }
            return null;
        }, BlockTagNames:/^(?:P|DIV|H1|H2|H3|H4|H5|H6|ADDRESS|PRE|OL|UL|LI|DT|DE)$/, getBlockAncestor:function (node, regex, root) {
            root = root || node.ownerDocument.body;
            regex = regex || rangeapi.BlockTagNames;
            var block = null, blockContainer;
            while (node && node !== root) {
                var name = node.nodeName.toUpperCase();
                if (!block && regex.test(name)) {
                    block = node;
                }
                if (!blockContainer && (/^(?:BODY|TD|TH|CAPTION)$/).test(name)) {
                    blockContainer = node;
                }
                node = node.parentNode;
            }
            return {blockNode:block, blockContainer:blockContainer || node.ownerDocument.body};
        }, atBeginningOfContainer:function (container, node, offset) {
            var atBeginning = false;
            var offsetAtBeginning = (offset == 0);
            if (!offsetAtBeginning && node.nodeType == 3) {
                if (/^[\s\xA0]+$/.test(node.nodeValue.substr(0, offset))) {
                    offsetAtBeginning = true;
                }
            }
            if (offsetAtBeginning) {
                var cnode = node;
                atBeginning = true;
                while (cnode && cnode !== container) {
                    if (cnode.previousSibling) {
                        atBeginning = false;
                        break;
                    }
                    cnode = cnode.parentNode;
                }
            }
            return atBeginning;
        }, atEndOfContainer:function (container, node, offset) {
            var atEnd = false;
            var offsetAtEnd = (offset == (node.length || node.childNodes.length));
            if (!offsetAtEnd && node.nodeType == 3) {
                if (/^[\s\xA0]+$/.test(node.nodeValue.substr(offset))) {
                    offsetAtEnd = true;
                }
            }
            if (offsetAtEnd) {
                var cnode = node;
                atEnd = true;
                while (cnode && cnode !== container) {
                    if (cnode.nextSibling) {
                        atEnd = false;
                        break;
                    }
                    cnode = cnode.parentNode;
                }
            }
            return atEnd;
        }, adjacentNoneTextNode:function (startnode, next) {
            var node = startnode;
            var len = (0 - startnode.length) || 0;
            var prop = next ? "nextSibling" : "previousSibling";
            while (node) {
                if (node.nodeType != 3) {
                    break;
                }
                len += node.length;
                node = node[prop];
            }
            return [node, len];
        }, create:function (win) {
            win = win || window;
            if (win.getSelection) {
                return win.document.createRange();
            } else {
                return new W3CRange();
            }
        }, getSelection:function (window, ignoreUpdate) {
            if (window.getSelection) {
                return window.getSelection();
            } else {
                var s = new ie.selection(window);
                if (!ignoreUpdate) {
                    s._getCurrentSelection();
                }
                return s;
            }
        }};
        if (!window.getSelection) {
            var ie = rangeapi.ie = {cachedSelection:{}, selection:function (window) {
                this._ranges = [];
                this.addRange = function (r, internal) {
                    this._ranges.push(r);
                    if (!internal) {
                        r._select();
                    }
                    this.rangeCount = this._ranges.length;
                };
                this.removeAllRanges = function () {
                    this._ranges = [];
                    this.rangeCount = 0;
                };
                var _initCurrentRange = function () {
                    var r = window.document.selection.createRange();
                    var type = window.document.selection.type.toUpperCase();
                    if (type == "CONTROL") {
                        return new W3CRange(ie.decomposeControlRange(r));
                    } else {
                        return new W3CRange(ie.decomposeTextRange(r));
                    }
                };
                this.getRangeAt = function (i) {
                    return this._ranges[i];
                };
                this._getCurrentSelection = function () {
                    this.removeAllRanges();
                    var r = _initCurrentRange();
                    if (r) {
                        this.addRange(r, true);
                        this.isCollapsed = r.collapsed;
                    } else {
                        this.isCollapsed = true;
                    }
                };
            }, decomposeControlRange:function (range) {
                var firstnode = range.item(0), lastnode = range.item(range.length - 1);
                var startContainer = firstnode.parentNode, endContainer = lastnode.parentNode;
                var startOffset = rangeapi.getIndex(firstnode, startContainer).o[0];
                var endOffset = rangeapi.getIndex(lastnode, endContainer).o[0] + 1;
                return [startContainer, startOffset, endContainer, endOffset];
            }, getEndPoint:function (range, end) {
                var atmrange = range.duplicate();
                atmrange.collapse(!end);
                var cmpstr = "EndTo" + (end ? "End" : "Start");
                var parentNode = atmrange.parentElement();
                var startnode, startOffset, lastNode;
                if (parentNode.childNodes.length > 0) {
                    array.every(parentNode.childNodes, function (node, i) {
                        var calOffset;
                        if (node.nodeType != 3) {
                            atmrange.moveToElementText(node);
                            if (atmrange.compareEndPoints(cmpstr, range) > 0) {
                                if (lastNode && lastNode.nodeType == 3) {
                                    startnode = lastNode;
                                    calOffset = true;
                                } else {
                                    startnode = parentNode;
                                    startOffset = i;
                                    return false;
                                }
                            } else {
                                if (i == parentNode.childNodes.length - 1) {
                                    startnode = parentNode;
                                    startOffset = parentNode.childNodes.length;
                                    return false;
                                }
                            }
                        } else {
                            if (i == parentNode.childNodes.length - 1) {
                                startnode = node;
                                calOffset = true;
                            }
                        }
                        if (calOffset && startnode) {
                            var prevnode = rangeapi.adjacentNoneTextNode(startnode)[0];
                            if (prevnode) {
                                startnode = prevnode.nextSibling;
                            } else {
                                startnode = parentNode.firstChild;
                            }
                            var prevnodeobj = rangeapi.adjacentNoneTextNode(startnode);
                            prevnode = prevnodeobj[0];
                            var lenoffset = prevnodeobj[1];
                            if (prevnode) {
                                atmrange.moveToElementText(prevnode);
                                atmrange.collapse(false);
                            } else {
                                atmrange.moveToElementText(parentNode);
                            }
                            atmrange.setEndPoint(cmpstr, range);
                            startOffset = atmrange.text.length - lenoffset;
                            return false;
                        }
                        lastNode = node;
                        return true;
                    });
                } else {
                    startnode = parentNode;
                    startOffset = 0;
                }
                if (!end && startnode.nodeType == 1 && startOffset == startnode.childNodes.length) {
                    var nextnode = startnode.nextSibling;
                    if (nextnode && nextnode.nodeType == 3) {
                        startnode = nextnode;
                        startOffset = 0;
                    }
                }
                return [startnode, startOffset];
            }, setEndPoint:function (range, container, offset) {
                var atmrange = range.duplicate(), node, len;
                if (container.nodeType != 3) {
                    if (offset > 0) {
                        node = container.childNodes[offset - 1];
                        if (node) {
                            if (node.nodeType == 3) {
                                container = node;
                                offset = node.length;
                            } else {
                                if (node.nextSibling && node.nextSibling.nodeType == 3) {
                                    container = node.nextSibling;
                                    offset = 0;
                                } else {
                                    atmrange.moveToElementText(node.nextSibling ? node : container);
                                    var parent = node.parentNode;
                                    var tempNode = parent.insertBefore(node.ownerDocument.createTextNode(" "), node.nextSibling);
                                    atmrange.collapse(false);
                                    parent.removeChild(tempNode);
                                }
                            }
                        }
                    } else {
                        atmrange.moveToElementText(container);
                        atmrange.collapse(true);
                    }
                }
                if (container.nodeType == 3) {
                    var prevnodeobj = rangeapi.adjacentNoneTextNode(container);
                    var prevnode = prevnodeobj[0];
                    len = prevnodeobj[1];
                    if (prevnode) {
                        atmrange.moveToElementText(prevnode);
                        atmrange.collapse(false);
                        if (prevnode.contentEditable != "inherit") {
                            len++;
                        }
                    } else {
                        atmrange.moveToElementText(container.parentNode);
                        atmrange.collapse(true);
                        atmrange.move("character", 1);
                        atmrange.move("character", -1);
                    }
                    offset += len;
                    if (offset > 0) {
                        if (atmrange.move("character", offset) != offset) {
                            console.error("Error when moving!");
                        }
                    }
                }
                return atmrange;
            }, decomposeTextRange:function (range) {
                var tmpary = ie.getEndPoint(range);
                var startContainer = tmpary[0], startOffset = tmpary[1];
                var endContainer = tmpary[0], endOffset = tmpary[1];
                if (range.htmlText.length) {
                    if (range.htmlText == range.text) {
                        endOffset = startOffset + range.text.length;
                    } else {
                        tmpary = ie.getEndPoint(range, true);
                        endContainer = tmpary[0], endOffset = tmpary[1];
                    }
                }
                return [startContainer, startOffset, endContainer, endOffset];
            }, setRange:function (range, startContainer, startOffset, endContainer, endOffset, collapsed) {
                var start = ie.setEndPoint(range, startContainer, startOffset);
                range.setEndPoint("StartToStart", start);
                if (!collapsed) {
                    var end = ie.setEndPoint(range, endContainer, endOffset);
                }
                range.setEndPoint("EndToEnd", end || start);
                return range;
            }};
            var W3CRange = rangeapi.W3CRange = declare(null, {constructor:function () {
                if (arguments.length > 0) {
                    this.setStart(arguments[0][0], arguments[0][1]);
                    this.setEnd(arguments[0][2], arguments[0][3]);
                } else {
                    this.commonAncestorContainer = null;
                    this.startContainer = null;
                    this.startOffset = 0;
                    this.endContainer = null;
                    this.endOffset = 0;
                    this.collapsed = true;
                }
            }, _updateInternal:function () {
                if (this.startContainer !== this.endContainer) {
                    this.commonAncestorContainer = rangeapi.getCommonAncestor(this.startContainer, this.endContainer);
                } else {
                    this.commonAncestorContainer = this.startContainer;
                }
                this.collapsed = (this.startContainer === this.endContainer) && (this.startOffset == this.endOffset);
            }, setStart:function (node, offset) {
                offset = parseInt(offset);
                if (this.startContainer === node && this.startOffset == offset) {
                    return;
                }
                delete this._cachedBookmark;
                this.startContainer = node;
                this.startOffset = offset;
                if (!this.endContainer) {
                    this.setEnd(node, offset);
                } else {
                    this._updateInternal();
                }
            }, setEnd:function (node, offset) {
                offset = parseInt(offset);
                if (this.endContainer === node && this.endOffset == offset) {
                    return;
                }
                delete this._cachedBookmark;
                this.endContainer = node;
                this.endOffset = offset;
                if (!this.startContainer) {
                    this.setStart(node, offset);
                } else {
                    this._updateInternal();
                }
            }, setStartAfter:function (node, offset) {
                this._setPoint("setStart", node, offset, 1);
            }, setStartBefore:function (node, offset) {
                this._setPoint("setStart", node, offset, 0);
            }, setEndAfter:function (node, offset) {
                this._setPoint("setEnd", node, offset, 1);
            }, setEndBefore:function (node, offset) {
                this._setPoint("setEnd", node, offset, 0);
            }, _setPoint:function (what, node, offset, ext) {
                var index = rangeapi.getIndex(node, node.parentNode).o;
                this[what](node.parentNode, index.pop() + ext);
            }, _getIERange:function () {
                var r = (this._body || this.endContainer.ownerDocument.body).createTextRange();
                ie.setRange(r, this.startContainer, this.startOffset, this.endContainer, this.endOffset, this.collapsed);
                return r;
            }, getBookmark:function () {
                this._getIERange();
                return this._cachedBookmark;
            }, _select:function () {
                var r = this._getIERange();
                r.select();
            }, deleteContents:function () {
                var s = this.startContainer, r = this._getIERange();
                if (s.nodeType === 3 && !this.startOffset) {
                    this.setStartBefore(s);
                }
                r.pasteHTML("");
                this.endContainer = this.startContainer;
                this.endOffset = this.startOffset;
                this.collapsed = true;
            }, cloneRange:function () {
                var r = new W3CRange([this.startContainer, this.startOffset, this.endContainer, this.endOffset]);
                r._body = this._body;
                return r;
            }, detach:function () {
                this._body = null;
                this.commonAncestorContainer = null;
                this.startContainer = null;
                this.startOffset = 0;
                this.endContainer = null;
                this.endOffset = 0;
                this.collapsed = true;
            }});
        }
        lang.setObject("dijit.range", rangeapi);
        return rangeapi;
    });
}, "dijit/Dialog":function () {
    define(["require", "dojo/_base/array", "dojo/aspect", "dojo/_base/declare", "dojo/Deferred", "dojo/dom", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/fx", "dojo/i18n", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/ready", "dojo/sniff", "dojo/window", "dojo/dnd/Moveable", "dojo/dnd/TimedMoveable", "./focus", "./_base/manager", "./_Widget", "./_TemplatedMixin", "./_CssStateMixin", "./form/_FormMixin", "./_DialogMixin", "./DialogUnderlay", "./layout/ContentPane", "dojo/text!./templates/Dialog.html", "dojo/i18n!./nls/common"], function (require, array, aspect, declare, Deferred, dom, domClass, domGeometry, domStyle, fx, i18n, keys, lang, on, ready, has, winUtils, Moveable, TimedMoveable, focus, manager, _Widget, _TemplatedMixin, _CssStateMixin, _FormMixin, _DialogMixin, DialogUnderlay, ContentPane, template) {
        var _DialogBase = declare("dijit._DialogBase" + (has("dojo-bidi") ? "_NoBidi" : ""), [_TemplatedMixin, _FormMixin, _DialogMixin, _CssStateMixin], {templateString:template, baseClass:"dijitDialog", cssStateNodes:{closeButtonNode:"dijitDialogCloseIcon"}, _setTitleAttr:{node:"titleNode", type:"innerHTML"}, open:false, duration:manager.defaultDuration, refocus:true, autofocus:true, _firstFocusItem:null, _lastFocusItem:null, doLayout:false, draggable:true, _setDraggableAttr:function (val) {
            this._set("draggable", val);
        }, maxRatio:0.9, closable:true, _setClosableAttr:function (val) {
            this.closeButtonNode.style.display = val ? "" : "none";
            this._set("closable", val);
        }, postMixInProperties:function () {
            var _nlsResources = i18n.getLocalization("dijit", "common");
            lang.mixin(this, _nlsResources);
            this.inherited(arguments);
        }, postCreate:function () {
            domStyle.set(this.domNode, {display:"none", position:"absolute"});
            this.ownerDocumentBody.appendChild(this.domNode);
            this.inherited(arguments);
            aspect.after(this, "onExecute", lang.hitch(this, "hide"), true);
            aspect.after(this, "onCancel", lang.hitch(this, "hide"), true);
            this._modalconnects = [];
        }, onLoad:function () {
            this._size();
            this._position();
            if (this.autofocus && DialogLevelManager.isTop(this)) {
                this._getFocusItems(this.domNode);
                focus.focus(this._firstFocusItem);
            }
            this.inherited(arguments);
        }, focus:function () {
            this._getFocusItems(this.domNode);
            focus.focus(this._firstFocusItem);
        }, _endDrag:function () {
            var nodePosition = domGeometry.position(this.domNode), viewport = winUtils.getBox(this.ownerDocument);
            nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));
            nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));
            this._relativePosition = nodePosition;
            this._position();
        }, _setup:function () {
            var node = this.domNode;
            if (this.titleBar && this.draggable) {
                this._moveable = new ((has("ie") == 6) ? TimedMoveable : Moveable)(node, {handle:this.titleBar});
                aspect.after(this._moveable, "onMoveStop", lang.hitch(this, "_endDrag"), true);
            } else {
                domClass.add(node, "dijitDialogFixed");
            }
            this.underlayAttrs = {dialogId:this.id, "class":array.map(this["class"].split(/\s/), function (s) {
                return s + "_underlay";
            }).join(" "), _onKeyDown:lang.hitch(this, "_onKey"), ownerDocument:this.ownerDocument};
        }, _size:function () {
            this._checkIfSingleChild();
            if (this._singleChild) {
                if (typeof this._singleChildOriginalStyle != "undefined") {
                    this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
                    delete this._singleChildOriginalStyle;
                }
            } else {
                domStyle.set(this.containerNode, {width:"auto", height:"auto"});
            }
            var bb = domGeometry.position(this.domNode);
            var viewport = winUtils.getBox(this.ownerDocument);
            viewport.w *= this.maxRatio;
            viewport.h *= this.maxRatio;
            if (bb.w >= viewport.w || bb.h >= viewport.h) {
                var containerSize = domGeometry.position(this.containerNode), w = Math.min(bb.w, viewport.w) - (bb.w - containerSize.w), h = Math.min(bb.h, viewport.h) - (bb.h - containerSize.h);
                if (this._singleChild && this._singleChild.resize) {
                    if (typeof this._singleChildOriginalStyle == "undefined") {
                        this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
                    }
                    this._singleChild.resize({w:w, h:h});
                } else {
                    domStyle.set(this.containerNode, {width:w + "px", height:h + "px", overflow:"auto", position:"relative"});
                }
            } else {
                if (this._singleChild && this._singleChild.resize) {
                    this._singleChild.resize();
                }
            }
        }, _position:function () {
            if (!domClass.contains(this.ownerDocumentBody, "dojoMove")) {
                var node = this.domNode, viewport = winUtils.getBox(this.ownerDocument), p = this._relativePosition, bb = p ? null : domGeometry.position(node), l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)), t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2));
                domStyle.set(node, {left:l + "px", top:t + "px"});
            }
        }, _onKey:function (evt) {
            if (evt.keyCode == keys.TAB) {
                this._getFocusItems(this.domNode);
                var node = evt.target;
                if (this._firstFocusItem == this._lastFocusItem) {
                    evt.stopPropagation();
                    evt.preventDefault();
                } else {
                    if (node == this._firstFocusItem && evt.shiftKey) {
                        focus.focus(this._lastFocusItem);
                        evt.stopPropagation();
                        evt.preventDefault();
                    } else {
                        if (node == this._lastFocusItem && !evt.shiftKey) {
                            focus.focus(this._firstFocusItem);
                            evt.stopPropagation();
                            evt.preventDefault();
                        }
                    }
                }
            } else {
                if (this.closable && evt.keyCode == keys.ESCAPE) {
                    this.onCancel();
                    evt.stopPropagation();
                    evt.preventDefault();
                }
            }
        }, show:function () {
            if (this.open) {
                return;
            }
            if (!this._started) {
                this.startup();
            }
            if (!this._alreadyInitialized) {
                this._setup();
                this._alreadyInitialized = true;
            }
            if (this._fadeOutDeferred) {
                this._fadeOutDeferred.cancel();
                DialogLevelManager.hide(this);
            }
            var win = winUtils.get(this.ownerDocument);
            this._modalconnects.push(on(win, "scroll", lang.hitch(this, "resize")));
            this._modalconnects.push(on(this.domNode, "keydown", lang.hitch(this, "_onKey")));
            domStyle.set(this.domNode, {opacity:0, display:""});
            this._set("open", true);
            this._onShow();
            this._size();
            this._position();
            var fadeIn;
            this._fadeInDeferred = new Deferred(lang.hitch(this, function () {
                fadeIn.stop();
                delete this._fadeInDeferred;
            }));
            var promise = this._fadeInDeferred.promise;
            fadeIn = fx.fadeIn({node:this.domNode, duration:this.duration, beforeBegin:lang.hitch(this, function () {
                DialogLevelManager.show(this, this.underlayAttrs);
            }), onEnd:lang.hitch(this, function () {
                if (this.autofocus && DialogLevelManager.isTop(this)) {
                    this._getFocusItems(this.domNode);
                    focus.focus(this._firstFocusItem);
                }
                this._fadeInDeferred.resolve(true);
                delete this._fadeInDeferred;
            })}).play();
            return promise;
        }, hide:function () {
            if (!this._alreadyInitialized || !this.open) {
                return;
            }
            if (this._fadeInDeferred) {
                this._fadeInDeferred.cancel();
            }
            var fadeOut;
            this._fadeOutDeferred = new Deferred(lang.hitch(this, function () {
                fadeOut.stop();
                delete this._fadeOutDeferred;
            }));
            this._fadeOutDeferred.then(lang.hitch(this, "onHide"));
            var promise = this._fadeOutDeferred.promise;
            fadeOut = fx.fadeOut({node:this.domNode, duration:this.duration, onEnd:lang.hitch(this, function () {
                this.domNode.style.display = "none";
                DialogLevelManager.hide(this);
                this._fadeOutDeferred.resolve(true);
                delete this._fadeOutDeferred;
            })}).play();
            if (this._scrollConnected) {
                this._scrollConnected = false;
            }
            var h;
            while (h = this._modalconnects.pop()) {
                h.remove();
            }
            if (this._relativePosition) {
                delete this._relativePosition;
            }
            this._set("open", false);
            return promise;
        }, resize:function () {
            if (this.domNode.style.display != "none") {
                this._size();
                if (!has("touch")) {
                    this._position();
                }
            }
        }, destroy:function () {
            if (this._fadeInDeferred) {
                this._fadeInDeferred.cancel();
            }
            if (this._fadeOutDeferred) {
                this._fadeOutDeferred.cancel();
            }
            if (this._moveable) {
                this._moveable.destroy();
            }
            var h;
            while (h = this._modalconnects.pop()) {
                h.remove();
            }
            DialogLevelManager.hide(this);
            this.inherited(arguments);
        }});
        if (has("dojo-bidi")) {
            _DialogBase = declare("dijit._DialogBase", _DialogBase, {_setTitleAttr:function (title) {
                this._set("title", title);
                this.titleNode.innerHTML = title;
                this.applyTextDir(this.titleNode);
            }, _setTextDirAttr:function (textDir) {
                if (this._created && this.textDir != textDir) {
                    this._set("textDir", textDir);
                    this.set("title", this.title);
                }
            }});
        }
        var Dialog = declare("dijit.Dialog", [ContentPane, _DialogBase], {});
        Dialog._DialogBase = _DialogBase;
        var DialogLevelManager = Dialog._DialogLevelManager = {_beginZIndex:950, show:function (dialog, underlayAttrs) {
            ds[ds.length - 1].focus = focus.curNode;
            var zIndex = ds[ds.length - 1].dialog ? ds[ds.length - 1].zIndex + 2 : Dialog._DialogLevelManager._beginZIndex;
            domStyle.set(dialog.domNode, "zIndex", zIndex);
            DialogUnderlay.show(underlayAttrs, zIndex - 1);
            ds.push({dialog:dialog, underlayAttrs:underlayAttrs, zIndex:zIndex});
        }, hide:function (dialog) {
            if (ds[ds.length - 1].dialog == dialog) {
                ds.pop();
                var pd = ds[ds.length - 1];
                if (ds.length == 1) {
                    DialogUnderlay.hide();
                } else {
                    DialogUnderlay.show(pd.underlayAttrs, pd.zIndex - 1);
                }
                if (dialog.refocus) {
                    var focus = pd.focus;
                    if (pd.dialog && (!focus || !dom.isDescendant(focus, pd.dialog.domNode))) {
                        pd.dialog._getFocusItems(pd.dialog.domNode);
                        focus = pd.dialog._firstFocusItem;
                    }
                    if (focus) {
                        try {
                            focus.focus();
                        }
                        catch (e) {
                        }
                    }
                }
            } else {
                var idx = array.indexOf(array.map(ds, function (elem) {
                    return elem.dialog;
                }), dialog);
                if (idx != -1) {
                    ds.splice(idx, 1);
                }
            }
        }, isTop:function (dialog) {
            return ds[ds.length - 1].dialog == dialog;
        }};
        var ds = Dialog._dialogStack = [{dialog:null, focus:null, underlayAttrs:null}];
        focus.watch("curNode", function (attr, oldNode, node) {
            var topDialog = ds[ds.length - 1].dialog;
            if (node && topDialog && !topDialog._fadeOutDeferred && node.ownerDocument == topDialog.ownerDocument) {
                do {
                    if (node == topDialog.domNode || domClass.contains(node, "dijitPopup")) {
                        return;
                    }
                } while (node = node.parentNode);
                topDialog.focus();
            }
        });
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/TooltipDialog"];
                require(requires);
            });
        }
        return Dialog;
    });
}, "dojox/grid/TreeGrid":function () {
    define(["dojo/_base/kernel", "../main", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/event", "dojo/dom-attr", "dojo/dom-class", "dojo/query", "dojo/keys", "dijit/tree/ForestStoreModel", "./DataGrid", "./_Layout", "./_FocusManager", "./_RowManager", "./_EditManager", "./TreeSelection", "./cells/tree", "./_TreeView"], function (dojo, dojox, declare, array, lang, event, domAttr, domClass, query, keys, ForestStoreModel, DataGrid, _Layout, _FocusManager, _RowManager, _EditManager, TreeSelection, TreeCell) {
        dojo.experimental("dojox.grid.TreeGrid");
        var _TreeAggregator = declare("dojox.grid._TreeAggregator", null, {cells:[], grid:null, childFields:[], constructor:function (kwArgs) {
            this.cells = kwArgs.cells || [];
            this.childFields = kwArgs.childFields || [];
            this.grid = kwArgs.grid;
            this.store = this.grid.store;
        }, _cacheValue:function (cache, id, value) {
            cache[id] = value;
            return value;
        }, clearSubtotalCache:function () {
            if (this.store) {
                delete this.store._cachedAggregates;
            }
        }, cnt:function (cell, level, item) {
            var total = 0;
            var store = this.store;
            var childFields = this.childFields;
            if (childFields[level]) {
                var children = store.getValues(item, childFields[level]);
                if (cell.index <= level + 1) {
                    total = children.length;
                } else {
                    array.forEach(children, function (c) {
                        total += this.getForCell(cell, level + 1, c, "cnt");
                    }, this);
                }
            } else {
                total = 1;
            }
            return total;
        }, sum:function (cell, level, item) {
            var total = 0;
            var store = this.store;
            var childFields = this.childFields;
            if (childFields[level]) {
                array.forEach(store.getValues(item, childFields[level]), function (c) {
                    total += this.getForCell(cell, level + 1, c, "sum");
                }, this);
            } else {
                total += store.getValue(item, cell.field);
            }
            return total;
        }, value:function (cell, level, item) {
        }, getForCell:function (cell, level, item, type) {
            var store = this.store;
            if (!store || !item || !store.isItem(item)) {
                return "";
            }
            var storeCache = store._cachedAggregates = store._cachedAggregates || {};
            var id = store.getIdentity(item);
            var itemCache = storeCache[id] = storeCache[id] || [];
            if (!cell.getOpenState) {
                cell = this.grid.getCell(cell.layoutIndex + level + 1);
            }
            var idx = cell.index;
            var idxCache = itemCache[idx] = itemCache[idx] || {};
            type = (type || (cell.parentCell ? cell.parentCell.aggregate : "sum")) || "sum";
            var attr = cell.field;
            if (attr == store.getLabelAttributes()[0]) {
                type = "cnt";
            }
            var typeCache = idxCache[type] = idxCache[type] || [];
            if (typeCache[level] != undefined) {
                return typeCache[level];
            }
            var field = ((cell.parentCell && cell.parentCell.itemAggregates) ? cell.parentCell.itemAggregates[cell.idxInParent] : "") || "";
            if (field && store.hasAttribute(item, field)) {
                return this._cacheValue(typeCache, level, store.getValue(item, field));
            } else {
                if (field) {
                    return this._cacheValue(typeCache, level, 0);
                }
            }
            return this._cacheValue(typeCache, level, this[type](cell, level, item));
        }});
        var _TreeLayout = declare("dojox.grid._TreeLayout", _Layout, {_isCollapsable:false, _getInternalStructure:function (inStructure) {
            var g = this.grid;
            var s = inStructure;
            var cells = s[0].cells[0];
            var tree = {type:"dojox.grid._TreeView", cells:[[]]};
            var cFields = [];
            var maxLevels = 0;
            var getTreeCells = function (parentCell, level) {
                var children = parentCell.children;
                var cloneTreeCell = function (originalCell, idx) {
                    var k, n = {};
                    for (k in originalCell) {
                        n[k] = originalCell[k];
                    }
                    n = lang.mixin(n, {level:level, idxInParent:level > 0 ? idx : -1, parentCell:level > 0 ? parentCell : null});
                    return n;
                };
                var ret = [];
                array.forEach(children, function (c, idx) {
                    if ("children" in c) {
                        cFields.push(c.field);
                        var last = ret[ret.length - 1];
                        last.isCollapsable = true;
                        c.level = level;
                        ret = ret.concat(getTreeCells(c, level + 1));
                    } else {
                        ret.push(cloneTreeCell(c, idx));
                    }
                });
                maxLevels = Math.max(maxLevels, level);
                return ret;
            };
            var tCell = {children:cells, itemAggregates:[]};
            tree.cells[0] = getTreeCells(tCell, 0);
            g.aggregator = new _TreeAggregator({cells:tree.cells[0], grid:g, childFields:cFields});
            if (g.scroller && g.defaultOpen) {
                g.scroller.defaultRowHeight = g.scroller._origDefaultRowHeight * (2 * maxLevels + 1);
            }
            return [tree];
        }, setStructure:function (inStructure) {
            var s = inStructure;
            var g = this.grid;
            if (g && g.treeModel && !array.every(s, function (i) {
                return ("cells" in i);
            })) {
                s = arguments[0] = [{cells:[s]}];
            }
            if (s.length == 1 && s[0].cells.length == 1) {
                if (g && g.treeModel) {
                    s[0].type = "dojox.grid._TreeView";
                    this._isCollapsable = true;
                    s[0].cells[0][(this.grid.treeModel ? this.grid.expandoCell : 0)].isCollapsable = true;
                } else {
                    var childCells = array.filter(s[0].cells[0], function (c) {
                        return ("children" in c);
                    });
                    if (childCells.length === 1) {
                        this._isCollapsable = true;
                    }
                }
            }
            if (this._isCollapsable && (!g || !g.treeModel)) {
                arguments[0] = this._getInternalStructure(s);
            }
            this.inherited(arguments);
        }, addCellDef:function (inRowIndex, inCellIndex, inDef) {
            var obj = this.inherited(arguments);
            return lang.mixin(obj, TreeCell);
        }});
        var TreePath = declare("dojox.grid.TreePath", null, {level:0, _str:"", _arr:null, grid:null, store:null, cell:null, item:null, constructor:function (path, grid) {
            if (lang.isString(path)) {
                this._str = path;
                this._arr = array.map(path.split("/"), function (item) {
                    return parseInt(item, 10);
                });
            } else {
                if (lang.isArray(path)) {
                    this._str = path.join("/");
                    this._arr = path.slice(0);
                } else {
                    if (typeof path == "number") {
                        this._str = String(path);
                        this._arr = [path];
                    } else {
                        this._str = path._str;
                        this._arr = path._arr.slice(0);
                    }
                }
            }
            this.level = this._arr.length - 1;
            this.grid = grid;
            this.store = this.grid.store;
            if (grid.treeModel) {
                this.cell = grid.layout.cells[grid.expandoCell];
            } else {
                this.cell = grid.layout.cells[this.level];
            }
        }, item:function () {
            if (!this._item) {
                this._item = this.grid.getItem(this._arr);
            }
            return this._item;
        }, compare:function (path) {
            if (lang.isString(path) || lang.isArray(path)) {
                if (this._str == path) {
                    return 0;
                }
                if (path.join && this._str == path.join("/")) {
                    return 0;
                }
                path = new TreePath(path, this.grid);
            } else {
                if (path instanceof TreePath) {
                    if (this._str == path._str) {
                        return 0;
                    }
                }
            }
            for (var i = 0, l = (this._arr.length < path._arr.length ? this._arr.length : path._arr.length); i < l; i++) {
                if (this._arr[i] < path._arr[i]) {
                    return -1;
                }
                if (this._arr[i] > path._arr[i]) {
                    return 1;
                }
            }
            if (this._arr.length < path._arr.length) {
                return -1;
            }
            if (this._arr.length > path._arr.length) {
                return 1;
            }
            return 0;
        }, isOpen:function () {
            return this.cell.openStates && this.cell.getOpenState(this.item());
        }, previous:function () {
            var new_path = this._arr.slice(0);
            if (this._str == "0") {
                return null;
            }
            var last = new_path.length - 1;
            if (new_path[last] === 0) {
                new_path.pop();
                return new TreePath(new_path, this.grid);
            }
            new_path[last]--;
            var path = new TreePath(new_path, this.grid);
            return path.lastChild(true);
        }, next:function () {
            var new_path = this._arr.slice(0);
            if (this.isOpen()) {
                new_path.push(0);
            } else {
                new_path[new_path.length - 1]++;
                for (var i = this.level; i >= 0; i--) {
                    var item = this.grid.getItem(new_path.slice(0, i + 1));
                    if (i > 0) {
                        if (!item) {
                            new_path.pop();
                            new_path[i - 1]++;
                        }
                    } else {
                        if (!item) {
                            return null;
                        }
                    }
                }
            }
            return new TreePath(new_path, this.grid);
        }, children:function (alwaysReturn) {
            if (!this.isOpen() && !alwaysReturn) {
                return null;
            }
            var items = [];
            var model = this.grid.treeModel;
            if (model) {
                var item = this.item();
                var store = model.store;
                if (!model.mayHaveChildren(item)) {
                    return null;
                }
                array.forEach(model.childrenAttrs, function (attr) {
                    items = items.concat(store.getValues(item, attr));
                });
            } else {
                items = this.store.getValues(this.item(), this.grid.layout.cells[this.cell.level + 1].parentCell.field);
                if (items.length > 1 && this.grid.sortChildItems) {
                    var sortProps = this.grid.getSortProps();
                    if (sortProps && sortProps.length) {
                        var attr = sortProps[0].attribute, grid = this.grid;
                        if (attr && items[0][attr]) {
                            var desc = !!sortProps[0].descending;
                            items = items.slice(0);
                            items.sort(function (a, b) {
                                return grid._childItemSorter(a, b, attr, desc);
                            });
                        }
                    }
                }
            }
            return items;
        }, childPaths:function () {
            var childItems = this.children();
            if (!childItems) {
                return [];
            }
            return array.map(childItems, function (item, index) {
                return new TreePath(this._str + "/" + index, this.grid);
            }, this);
        }, parent:function () {
            if (this.level === 0) {
                return null;
            }
            return new TreePath(this._arr.slice(0, this.level), this.grid);
        }, lastChild:function (traverse) {
            var children = this.children();
            if (!children || !children.length) {
                return this;
            }
            var path = new TreePath(this._str + "/" + String(children.length - 1), this.grid);
            if (!traverse) {
                return path;
            }
            return path.lastChild(true);
        }, toString:function () {
            return this._str;
        }});
        var _TreeFocusManager = declare("dojox.grid._TreeFocusManager", _FocusManager, {setFocusCell:function (inCell, inRowIndex) {
            if (inCell && inCell.getNode(inRowIndex)) {
                this.inherited(arguments);
            }
        }, isLastFocusCell:function () {
            if (this.cell && this.cell.index == this.grid.layout.cellCount - 1) {
                var path = new TreePath(this.grid.rowCount - 1, this.grid);
                path = path.lastChild(true);
                return this.rowIndex == path._str;
            }
            return false;
        }, next:function () {
            if (this.cell) {
                var row = this.rowIndex, col = this.cell.index + 1, cc = this.grid.layout.cellCount - 1;
                var path = new TreePath(this.rowIndex, this.grid);
                if (col > cc) {
                    var new_path = path.next();
                    if (!new_path) {
                        col--;
                    } else {
                        col = 0;
                        path = new_path;
                    }
                }
                if (this.grid.edit.isEditing()) {
                    var nextCell = this.grid.getCell(col);
                    if (!this.isLastFocusCell() && !nextCell.editable) {
                        this._focusifyCellNode(false);
                        this.cell = nextCell;
                        this.rowIndex = path._str;
                        this.next();
                        return;
                    }
                }
                this.setFocusIndex(path._str, col);
            }
        }, previous:function () {
            if (this.cell) {
                var row = (this.rowIndex || 0), col = (this.cell.index || 0) - 1;
                var path = new TreePath(row, this.grid);
                if (col < 0) {
                    var new_path = path.previous();
                    if (!new_path) {
                        col = 0;
                    } else {
                        col = this.grid.layout.cellCount - 1;
                        path = new_path;
                    }
                }
                if (this.grid.edit.isEditing()) {
                    var prevCell = this.grid.getCell(col);
                    if (!this.isFirstFocusCell() && !prevCell.editable) {
                        this._focusifyCellNode(false);
                        this.cell = prevCell;
                        this.rowIndex = path._str;
                        this.previous();
                        return;
                    }
                }
                this.setFocusIndex(path._str, col);
            }
        }, move:function (inRowDelta, inColDelta) {
            if (this.isNavHeader()) {
                this.inherited(arguments);
                return;
            }
            if (!this.cell) {
                return;
            }
            var sc = this.grid.scroller, r = this.rowIndex, rc = this.grid.rowCount - 1, path = new TreePath(this.rowIndex, this.grid);
            if (inRowDelta) {
                var row;
                if (inRowDelta > 0) {
                    path = path.next();
                    row = path._arr[0];
                    if (row > sc.getLastPageRow(sc.page)) {
                        this.grid.setScrollTop(this.grid.scrollTop + sc.findScrollTop(row) - sc.findScrollTop(r));
                    }
                } else {
                    if (inRowDelta < 0) {
                        path = path.previous();
                        row = path._arr[0];
                        if (row <= sc.getPageRow(sc.page)) {
                            this.grid.setScrollTop(this.grid.scrollTop - sc.findScrollTop(r) - sc.findScrollTop(row));
                        }
                    }
                }
            }
            var cc = this.grid.layout.cellCount - 1, i = this.cell.index, col = Math.min(cc, Math.max(0, i + inColDelta));
            var cell = this.grid.getCell(col);
            var colDir = inColDelta < 0 ? -1 : 1;
            while (col >= 0 && col < cc && cell && cell.hidden === true) {
                col += colDir;
                cell = this.grid.getCell(col);
            }
            if (!cell || cell.hidden === true) {
                col = i;
            }
            if (inRowDelta) {
                this.grid.updateRow(r);
            }
            this.setFocusIndex(path._str, col);
        }});
        var TreeGrid = declare("dojox.grid.TreeGrid", DataGrid, {defaultOpen:true, sortChildItems:false, openAtLevels:[], treeModel:null, expandoCell:0, aggregator:null, _layoutClass:_TreeLayout, createSelection:function () {
            this.selection = new TreeSelection(this);
        }, _childItemSorter:function (a, b, attribute, descending) {
            var av = this.store.getValue(a, attribute);
            var bv = this.store.getValue(b, attribute);
            if (av != bv) {
                return av < bv == descending ? 1 : -1;
            }
            return 0;
        }, _onNew:function (item, parentInfo) {
            if (!parentInfo || !parentInfo.item) {
                this.inherited(arguments);
            } else {
                var idx = this.getItemIndex(parentInfo.item);
                if (typeof idx == "string") {
                    this.updateRow(idx.split("/")[0]);
                } else {
                    if (idx > -1) {
                        this.updateRow(idx);
                    }
                }
            }
        }, _onSet:function (item, attribute, oldValue, newValue) {
            this._checkUpdateStatus();
            if (this.aggregator) {
                this.aggregator.clearSubtotalCache();
            }
            var idx = this.getItemIndex(item);
            if (typeof idx == "string") {
                this.updateRow(idx.split("/")[0]);
            } else {
                if (idx > -1) {
                    this.updateRow(idx);
                }
            }
        }, _onDelete:function (item) {
            this._cleanupExpandoCache(this._getItemIndex(item, true), this.store.getIdentity(item), item);
            this.inherited(arguments);
        }, _clearData:function () {
            this.inherited(arguments);
            this._by_idty_paths = {};
        }, _cleanupExpandoCache:function (index, identity, item) {
        }, _addItem:function (item, index, noUpdate, dontUpdateRoot) {
            if (!dontUpdateRoot && this.model && array.indexOf(this.model.root.children, item) == -1) {
                this.model.root.children[index] = item;
            }
            this.inherited(arguments);
        }, getItem:function (idx) {
            var isArray = lang.isArray(idx);
            if (lang.isString(idx) && idx.indexOf("/")) {
                idx = idx.split("/");
                isArray = true;
            }
            if (isArray && idx.length == 1) {
                idx = idx[0];
                isArray = false;
            }
            if (!isArray) {
                return DataGrid.prototype.getItem.call(this, idx);
            }
            var s = this.store;
            var itm = DataGrid.prototype.getItem.call(this, idx[0]);
            var cf, i, j;
            if (this.aggregator) {
                cf = this.aggregator.childFields || [];
                if (cf) {
                    for (i = 0; i < idx.length - 1 && itm; i++) {
                        if (cf[i]) {
                            itm = (s.getValues(itm, cf[i]) || [])[idx[i + 1]];
                        } else {
                            itm = null;
                        }
                    }
                }
            } else {
                if (this.treeModel) {
                    cf = this.treeModel.childrenAttrs || [];
                    if (cf && itm) {
                        for (i = 1, il = idx.length; (i < il) && itm; i++) {
                            for (j = 0, jl = cf.length; j < jl; j++) {
                                if (cf[j]) {
                                    itm = (s.getValues(itm, cf[j]) || [])[idx[i]];
                                } else {
                                    itm = null;
                                }
                                if (itm) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            return itm || null;
        }, _getItemIndex:function (item, isDeleted) {
            if (!isDeleted && !this.store.isItem(item)) {
                return -1;
            }
            var idx = this.inherited(arguments);
            if (idx == -1) {
                var idty = this.store.getIdentity(item);
                return this._by_idty_paths[idty] || -1;
            }
            return idx;
        }, postMixInProperties:function () {
            if (this.treeModel && !("defaultOpen" in this.params)) {
                this.defaultOpen = false;
            }
            var def = this.defaultOpen;
            this.openAtLevels = array.map(this.openAtLevels, function (l) {
                if (typeof l == "string") {
                    switch (l.toLowerCase()) {
                      case "true":
                        return true;
                        break;
                      case "false":
                        return false;
                        break;
                      default:
                        var r = parseInt(l, 10);
                        if (isNaN(r)) {
                            return def;
                        }
                        return r;
                        break;
                    }
                }
                return l;
            });
            this._by_idty_paths = {};
            this.inherited(arguments);
        }, postCreate:function () {
            this.inherited(arguments);
            if (this.treeModel) {
                this._setModel(this.treeModel);
            }
        }, setModel:function (treeModel) {
            this._setModel(treeModel);
            this._refresh(true);
        }, _setModel:function (treeModel) {
            if (treeModel && (!ForestStoreModel || !(treeModel instanceof ForestStoreModel))) {
                throw new Error("dojox.grid.TreeGrid: treeModel must be an instance of dijit.tree.ForestStoreModel");
            }
            this.treeModel = treeModel;
            domClass.toggle(this.domNode, "dojoxGridTreeModel", this.treeModel ? true : false);
            this._setQuery(treeModel ? treeModel.query : null);
            this._setStore(treeModel ? treeModel.store : null);
        }, createScroller:function () {
            this.inherited(arguments);
            this.scroller._origDefaultRowHeight = this.scroller.defaultRowHeight;
        }, createManagers:function () {
            this.rows = new _RowManager(this);
            this.focus = new _TreeFocusManager(this);
            this.edit = new _EditManager(this);
        }, _setStore:function (store) {
            this.inherited(arguments);
            if (this.treeModel && !this.treeModel.root.children) {
                this.treeModel.root.children = [];
            }
            if (this.aggregator) {
                this.aggregator.store = store;
            }
        }, getDefaultOpenState:function (cellDef, item) {
            var cf;
            var store = this.store;
            if (this.treeModel) {
                return this.defaultOpen;
            }
            if (!cellDef || !store || !store.isItem(item) || !(cf = this.aggregator.childFields[cellDef.level])) {
                return this.defaultOpen;
            }
            if (this.openAtLevels.length > cellDef.level) {
                var dVal = this.openAtLevels[cellDef.level];
                if (typeof dVal == "boolean") {
                    return dVal;
                } else {
                    if (typeof dVal == "number") {
                        return (store.getValues(item, cf).length <= dVal);
                    }
                }
            }
            return this.defaultOpen;
        }, onStyleRow:function (row) {
            if (!this.layout._isCollapsable) {
                this.inherited(arguments);
                return;
            }
            var base = domAttr.get(row.node, "dojoxTreeGridBaseClasses");
            if (base) {
                row.customClasses = base;
            }
            var i = row;
            var tagName = i.node.tagName.toLowerCase();
            i.customClasses += (i.odd ? " dojoxGridRowOdd" : "") + (i.selected && tagName == "tr" ? " dojoxGridRowSelected" : "") + (i.over && tagName == "tr" ? " dojoxGridRowOver" : "");
            this.focus.styleRow(i);
            this.edit.styleRow(i);
        }, styleRowNode:function (inRowIndex, inRowNode) {
            if (inRowNode) {
                if (inRowNode.tagName.toLowerCase() == "div" && this.aggregator) {
                    query("tr[dojoxTreeGridPath]", inRowNode).forEach(function (rowNode) {
                        this.rows.styleRowNode(domAttr.get(rowNode, "dojoxTreeGridPath"), rowNode);
                    }, this);
                }
                this.rows.styleRowNode(inRowIndex, inRowNode);
            }
        }, onCanSelect:function (inRowIndex) {
            var nodes = query("tr[dojoxTreeGridPath='" + inRowIndex + "']", this.domNode);
            if (nodes.length) {
                if (domClass.contains(nodes[0], "dojoxGridSummaryRow")) {
                    return false;
                }
            }
            return this.inherited(arguments);
        }, onKeyDown:function (e) {
            if (e.altKey || e.metaKey) {
                return;
            }
            switch (e.keyCode) {
              case keys.UP_ARROW:
                if (!this.edit.isEditing() && this.focus.rowIndex != "0") {
                    event.stop(e);
                    this.focus.move(-1, 0);
                }
                break;
              case keys.DOWN_ARROW:
                var currPath = new TreePath(this.focus.rowIndex, this);
                var lastPath = new TreePath(this.rowCount - 1, this);
                lastPath = lastPath.lastChild(true);
                if (!this.edit.isEditing() && currPath.toString() != lastPath.toString()) {
                    event.stop(e);
                    this.focus.move(1, 0);
                }
                break;
              default:
                this.inherited(arguments);
                break;
            }
        }, canEdit:function (inCell, inRowIndex) {
            var node = inCell.getNode(inRowIndex);
            return node && this._canEdit;
        }, doApplyCellEdit:function (inValue, inRowIndex, inAttrName) {
            var item = this.getItem(inRowIndex);
            var oldValue = this.store.getValue(item, inAttrName);
            if (typeof oldValue == "number") {
                inValue = isNaN(inValue) ? inValue : parseFloat(inValue);
            } else {
                if (typeof oldValue == "boolean") {
                    inValue = inValue == "true" ? true : inValue == "false" ? false : inValue;
                } else {
                    if (oldValue instanceof Date) {
                        var asDate = new Date(inValue);
                        inValue = isNaN(asDate.getTime()) ? inValue : asDate;
                    }
                }
            }
            this.store.setValue(item, inAttrName, inValue);
            this.onApplyCellEdit(inValue, inRowIndex, inAttrName);
        }});
        TreeGrid.markupFactory = function (props, node, ctor, cellFunc) {
            var widthFromAttr = function (n) {
                var w = domAttr.get(n, "width") || "auto";
                if ((w != "auto") && (w.slice(-2) != "em") && (w.slice(-1) != "%")) {
                    w = parseInt(w, 10) + "px";
                }
                return w;
            };
            var cellsFromMarkup = function (table) {
                var rows;
                if (table.nodeName.toLowerCase() == "table" && query("> colgroup", table).length === 0 && (rows = query("> thead > tr", table)).length == 1) {
                    var tr = rows[0];
                    return query("> th", rows[0]).map(function (th) {
                        var cell = {type:lang.trim(domAttr.get(th, "cellType") || ""), field:lang.trim(domAttr.get(th, "field") || "")};
                        if (cell.type) {
                            cell.type = lang.getObject(cell.type);
                        }
                        var subTable = query("> table", th)[0];
                        if (subTable) {
                            cell.name = "";
                            cell.children = cellsFromMarkup(subTable);
                            if (domAttr.has(th, "itemAggregates")) {
                                cell.itemAggregates = array.map(domAttr.get(th, "itemAggregates").split(","), function (v) {
                                    return lang.trim(v);
                                });
                            } else {
                                cell.itemAggregates = [];
                            }
                            if (domAttr.has(th, "aggregate")) {
                                cell.aggregate = domAttr.get(th, "aggregate");
                            }
                            cell.type = cell.type || dojox.grid.cells.SubtableCell;
                        } else {
                            cell.name = lang.trim(domAttr.get(th, "name") || th.innerHTML);
                            if (domAttr.has(th, "width")) {
                                cell.width = widthFromAttr(th);
                            }
                            if (domAttr.has(th, "relWidth")) {
                                cell.relWidth = window.parseInt(domAttr.get(th, "relWidth"), 10);
                            }
                            if (domAttr.has(th, "hidden")) {
                                cell.hidden = domAttr.get(th, "hidden") == "true";
                            }
                            cell.field = cell.field || cell.name;
                            DataGrid.cell_markupFactory(cellFunc, th, cell);
                            cell.type = cell.type || dojox.grid.cells.Cell;
                        }
                        if (cell.type && cell.type.markupFactory) {
                            cell.type.markupFactory(th, cell);
                        }
                        return cell;
                    });
                }
                return [];
            };
            var rows;
            if (!props.structure) {
                var row = cellsFromMarkup(node);
                if (row.length) {
                    props.structure = [{__span:Infinity, cells:[row]}];
                }
            }
            return DataGrid.markupFactory(props, node, ctor, cellFunc);
        };
        return TreeGrid;
    });
}, "dojox/html/metrics":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/sniff", "dojo/ready", "dojo/_base/unload", "dojo/_base/window", "dojo/dom-geometry"], function (kernel, lang, has, ready, UnloadUtil, Window, DOMGeom) {
        var dhm = lang.getObject("dojox.html.metrics", true);
        var dojox = lang.getObject("dojox");
        dhm.getFontMeasurements = function () {
            var heights = {"1em":0, "1ex":0, "100%":0, "12pt":0, "16px":0, "xx-small":0, "x-small":0, "small":0, "medium":0, "large":0, "x-large":0, "xx-large":0};
            if (has("ie")) {
                Window.doc.documentElement.style.fontSize = "100%";
            }
            var div = Window.doc.createElement("div");
            var ds = div.style;
            ds.position = "absolute";
            ds.left = "-100px";
            ds.top = "0";
            ds.width = "30px";
            ds.height = "1000em";
            ds.borderWidth = "0";
            ds.margin = "0";
            ds.padding = "0";
            ds.outline = "0";
            ds.lineHeight = "1";
            ds.overflow = "hidden";
            Window.body().appendChild(div);
            for (var p in heights) {
                ds.fontSize = p;
                heights[p] = Math.round(div.offsetHeight * 12 / 16) * 16 / 12 / 1000;
            }
            Window.body().removeChild(div);
            div = null;
            return heights;
        };
        var fontMeasurements = null;
        dhm.getCachedFontMeasurements = function (recalculate) {
            if (recalculate || !fontMeasurements) {
                fontMeasurements = dhm.getFontMeasurements();
            }
            return fontMeasurements;
        };
        var measuringNode = null, empty = {};
        dhm.getTextBox = function (text, style, className) {
            var m, s;
            if (!measuringNode) {
                m = measuringNode = Window.doc.createElement("div");
                var c = Window.doc.createElement("div");
                c.appendChild(m);
                s = c.style;
                s.overflow = "scroll";
                s.position = "absolute";
                s.left = "0px";
                s.top = "-10000px";
                s.width = "1px";
                s.height = "1px";
                s.visibility = "hidden";
                s.borderWidth = "0";
                s.margin = "0";
                s.padding = "0";
                s.outline = "0";
                Window.body().appendChild(c);
            } else {
                m = measuringNode;
            }
            m.className = "";
            s = m.style;
            s.borderWidth = "0";
            s.margin = "0";
            s.padding = "0";
            s.outline = "0";
            if (arguments.length > 1 && style) {
                for (var i in style) {
                    if (i in empty) {
                        continue;
                    }
                    s[i] = style[i];
                }
            }
            if (arguments.length > 2 && className) {
                m.className = className;
            }
            m.innerHTML = text;
            var box = DOMGeom.position(m);
            box.w = m.parentNode.scrollWidth;
            return box;
        };
        var scroll = {w:16, h:16};
        dhm.getScrollbar = function () {
            return {w:scroll.w, h:scroll.h};
        };
        dhm._fontResizeNode = null;
        dhm.initOnFontResize = function (interval) {
            var f = dhm._fontResizeNode = Window.doc.createElement("iframe");
            var fs = f.style;
            fs.position = "absolute";
            fs.width = "5em";
            fs.height = "10em";
            fs.top = "-10000px";
            fs.display = "none";
            if (has("ie")) {
                f.onreadystatechange = function () {
                    if (f.contentWindow.document.readyState == "complete") {
                        f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
                    }
                };
            } else {
                f.onload = function () {
                    f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
                };
            }
            f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
            Window.body().appendChild(f);
            dhm.initOnFontResize = function () {
            };
        };
        dhm.onFontResize = function () {
        };
        dhm._fontresize = function () {
            dhm.onFontResize();
        };
        UnloadUtil.addOnUnload(function () {
            var f = dhm._fontResizeNode;
            if (f) {
                if (has("ie") && f.onresize) {
                    f.onresize = null;
                } else {
                    if (f.contentWindow && f.contentWindow.onresize) {
                        f.contentWindow.onresize = null;
                    }
                }
                dhm._fontResizeNode = null;
            }
        });
        ready(function () {
            try {
                var n = Window.doc.createElement("div");
                n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
                Window.body().appendChild(n);
                scroll.w = n.offsetWidth - n.clientWidth;
                scroll.h = n.offsetHeight - n.clientHeight;
                Window.body().removeChild(n);
                delete n;
            }
            catch (e) {
            }
            if ("fontSizeWatch" in kernel.config && !!kernel.config.fontSizeWatch) {
                dhm.initOnFontResize();
            }
        });
        return dhm;
    });
}, "dojo/dom-construct":function () {
    define(["exports", "./_base/kernel", "./sniff", "./_base/window", "./dom", "./dom-attr"], function (exports, dojo, has, win, dom, attr) {
        var tagWrap = {option:["select"], tbody:["table"], thead:["table"], tfoot:["table"], tr:["table", "tbody"], td:["table", "tbody", "tr"], th:["table", "thead", "tr"], legend:["fieldset"], caption:["table"], colgroup:["table"], col:["table", "colgroup"], li:["ul"]}, reTag = /<\s*([\w\:]+)/, masterNode = {}, masterNum = 0, masterName = "__" + dojo._scopeName + "ToDomId";
        for (var param in tagWrap) {
            if (tagWrap.hasOwnProperty(param)) {
                var tw = tagWrap[param];
                tw.pre = param == "option" ? "<select multiple=\"multiple\">" : "<" + tw.join("><") + ">";
                tw.post = "</" + tw.reverse().join("></") + ">";
            }
        }
        var html5domfix;
        if (has("ie") <= 8) {
            html5domfix = function (doc) {
                doc.__dojo_html5_tested = "yes";
                var div = create("div", {innerHTML:"<nav>a</nav>", style:{visibility:"hidden"}}, doc.body);
                if (div.childNodes.length !== 1) {
                    ("abbr article aside audio canvas details figcaption figure footer header " + "hgroup mark meter nav output progress section summary time video").replace(/\b\w+\b/g, function (n) {
                        doc.createElement(n);
                    });
                }
                destroy(div);
            };
        }
        function _insertBefore(node, ref) {
            var parent = ref.parentNode;
            if (parent) {
                parent.insertBefore(node, ref);
            }
        }
        function _insertAfter(node, ref) {
            var parent = ref.parentNode;
            if (parent) {
                if (parent.lastChild == ref) {
                    parent.appendChild(node);
                } else {
                    parent.insertBefore(node, ref.nextSibling);
                }
            }
        }
        exports.toDom = function toDom(frag, doc) {
            doc = doc || win.doc;
            var masterId = doc[masterName];
            if (!masterId) {
                doc[masterName] = masterId = ++masterNum + "";
                masterNode[masterId] = doc.createElement("div");
            }
            if (has("ie") <= 8) {
                if (!doc.__dojo_html5_tested && doc.body) {
                    html5domfix(doc);
                }
            }
            frag += "";
            var match = frag.match(reTag), tag = match ? match[1].toLowerCase() : "", master = masterNode[masterId], wrap, i, fc, df;
            if (match && tagWrap[tag]) {
                wrap = tagWrap[tag];
                master.innerHTML = wrap.pre + frag + wrap.post;
                for (i = wrap.length; i; --i) {
                    master = master.firstChild;
                }
            } else {
                master.innerHTML = frag;
            }
            if (master.childNodes.length == 1) {
                return master.removeChild(master.firstChild);
            }
            df = doc.createDocumentFragment();
            while ((fc = master.firstChild)) {
                df.appendChild(fc);
            }
            return df;
        };
        exports.place = function place(node, refNode, position) {
            refNode = dom.byId(refNode);
            if (typeof node == "string") {
                node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
            }
            if (typeof position == "number") {
                var cn = refNode.childNodes;
                if (!cn.length || cn.length <= position) {
                    refNode.appendChild(node);
                } else {
                    _insertBefore(node, cn[position < 0 ? 0 : position]);
                }
            } else {
                switch (position) {
                  case "before":
                    _insertBefore(node, refNode);
                    break;
                  case "after":
                    _insertAfter(node, refNode);
                    break;
                  case "replace":
                    refNode.parentNode.replaceChild(node, refNode);
                    break;
                  case "only":
                    exports.empty(refNode);
                    refNode.appendChild(node);
                    break;
                  case "first":
                    if (refNode.firstChild) {
                        _insertBefore(node, refNode.firstChild);
                        break;
                    }
                  default:
                    refNode.appendChild(node);
                }
            }
            return node;
        };
        var create = exports.create = function create(tag, attrs, refNode, pos) {
            var doc = win.doc;
            if (refNode) {
                refNode = dom.byId(refNode);
                doc = refNode.ownerDocument;
            }
            if (typeof tag == "string") {
                tag = doc.createElement(tag);
            }
            if (attrs) {
                attr.set(tag, attrs);
            }
            if (refNode) {
                exports.place(tag, refNode, pos);
            }
            return tag;
        };
        function _empty(node) {
            if (node.canHaveChildren) {
                try {
                    node.innerHTML = "";
                    return;
                }
                catch (e) {
                }
            }
            for (var c; c = node.lastChild; ) {
                _destroy(c, node);
            }
        }
        exports.empty = function empty(node) {
            _empty(dom.byId(node));
        };
        function _destroy(node, parent) {
            if (node.firstChild) {
                _empty(node);
            }
            if (parent) {
                has("ie") && parent.canHaveChildren && "removeNode" in node ? node.removeNode(false) : parent.removeChild(node);
            }
        }
        var destroy = exports.destroy = function destroy(node) {
            node = dom.byId(node);
            if (!node) {
                return;
            }
            _destroy(node, node.parentNode);
        };
    });
}, "dojo/date/locale":function () {
    define(["../_base/lang", "../_base/array", "../date", "../cldr/supplemental", "../i18n", "../regexp", "../string", "../i18n!../cldr/nls/gregorian", "module"], function (lang, array, date, supplemental, i18n, regexp, string, gregorian, module) {
        var exports = {};
        lang.setObject(module.id.replace(/\//g, "."), exports);
        function formatPattern(dateObject, bundle, options, pattern) {
            return pattern.replace(/([a-z])\1*/ig, function (match) {
                var s, pad, c = match.charAt(0), l = match.length, widthList = ["abbr", "wide", "narrow"];
                switch (c) {
                  case "G":
                    s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
                    break;
                  case "y":
                    s = dateObject.getFullYear();
                    switch (l) {
                      case 1:
                        break;
                      case 2:
                        if (!options.fullYear) {
                            s = String(s);
                            s = s.substr(s.length - 2);
                            break;
                        }
                      default:
                        pad = true;
                    }
                    break;
                  case "Q":
                  case "q":
                    s = Math.ceil((dateObject.getMonth() + 1) / 3);
                    pad = true;
                    break;
                  case "M":
                  case "L":
                    var m = dateObject.getMonth();
                    if (l < 3) {
                        s = m + 1;
                        pad = true;
                    } else {
                        var propM = ["months", c == "L" ? "standAlone" : "format", widthList[l - 3]].join("-");
                        s = bundle[propM][m];
                    }
                    break;
                  case "w":
                    var firstDay = 0;
                    s = exports._getWeekOfYear(dateObject, firstDay);
                    pad = true;
                    break;
                  case "d":
                    s = dateObject.getDate();
                    pad = true;
                    break;
                  case "D":
                    s = exports._getDayOfYear(dateObject);
                    pad = true;
                    break;
                  case "e":
                  case "c":
                    var d = dateObject.getDay();
                    if (l < 2) {
                        s = (d - supplemental.getFirstDayOfWeek(options.locale) + 8) % 7;
                        break;
                    }
                  case "E":
                    d = dateObject.getDay();
                    if (l < 3) {
                        s = d + 1;
                        pad = true;
                    } else {
                        var propD = ["days", c == "c" ? "standAlone" : "format", widthList[l - 3]].join("-");
                        s = bundle[propD][d];
                    }
                    break;
                  case "a":
                    var timePeriod = dateObject.getHours() < 12 ? "am" : "pm";
                    s = options[timePeriod] || bundle["dayPeriods-format-wide-" + timePeriod];
                    break;
                  case "h":
                  case "H":
                  case "K":
                  case "k":
                    var h = dateObject.getHours();
                    switch (c) {
                      case "h":
                        s = (h % 12) || 12;
                        break;
                      case "H":
                        s = h;
                        break;
                      case "K":
                        s = (h % 12);
                        break;
                      case "k":
                        s = h || 24;
                        break;
                    }
                    pad = true;
                    break;
                  case "m":
                    s = dateObject.getMinutes();
                    pad = true;
                    break;
                  case "s":
                    s = dateObject.getSeconds();
                    pad = true;
                    break;
                  case "S":
                    s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l - 3));
                    pad = true;
                    break;
                  case "v":
                  case "z":
                    s = exports._getZone(dateObject, true, options);
                    if (s) {
                        break;
                    }
                    l = 4;
                  case "Z":
                    var offset = exports._getZone(dateObject, false, options);
                    var tz = [(offset <= 0 ? "+" : "-"), string.pad(Math.floor(Math.abs(offset) / 60), 2), string.pad(Math.abs(offset) % 60, 2)];
                    if (l == 4) {
                        tz.splice(0, 0, "GMT");
                        tz.splice(3, 0, ":");
                    }
                    s = tz.join("");
                    break;
                  default:
                    throw new Error("dojo.date.locale.format: invalid pattern char: " + pattern);
                }
                if (pad) {
                    s = string.pad(s, l);
                }
                return s;
            });
        }
        exports._getZone = function (dateObject, getName, options) {
            if (getName) {
                return date.getTimezoneName(dateObject);
            } else {
                return dateObject.getTimezoneOffset();
            }
        };
        exports.format = function (dateObject, options) {
            options = options || {};
            var locale = i18n.normalizeLocale(options.locale), formatLength = options.formatLength || "short", bundle = exports._getGregorianBundle(locale), str = [], sauce = lang.hitch(this, formatPattern, dateObject, bundle, options);
            if (options.selector == "year") {
                return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
            }
            var pattern;
            if (options.selector != "date") {
                pattern = options.timePattern || bundle["timeFormat-" + formatLength];
                if (pattern) {
                    str.push(_processPattern(pattern, sauce));
                }
            }
            if (options.selector != "time") {
                pattern = options.datePattern || bundle["dateFormat-" + formatLength];
                if (pattern) {
                    str.push(_processPattern(pattern, sauce));
                }
            }
            return str.length == 1 ? str[0] : bundle["dateTimeFormat-" + formatLength].replace(/\'/g, "").replace(/\{(\d+)\}/g, function (match, key) {
                return str[key];
            });
        };
        exports.regexp = function (options) {
            return exports._parseInfo(options).regexp;
        };
        exports._parseInfo = function (options) {
            options = options || {};
            var locale = i18n.normalizeLocale(options.locale), bundle = exports._getGregorianBundle(locale), formatLength = options.formatLength || "short", datePattern = options.datePattern || bundle["dateFormat-" + formatLength], timePattern = options.timePattern || bundle["timeFormat-" + formatLength], pattern;
            if (options.selector == "date") {
                pattern = datePattern;
            } else {
                if (options.selector == "time") {
                    pattern = timePattern;
                } else {
                    pattern = bundle["dateTimeFormat-" + formatLength].replace(/\{(\d+)\}/g, function (match, key) {
                        return [timePattern, datePattern][key];
                    });
                }
            }
            var tokens = [], re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));
            return {regexp:re, tokens:tokens, bundle:bundle};
        };
        exports.parse = function (value, options) {
            var controlChars = /[\u200E\u200F\u202A\u202E]/g, info = exports._parseInfo(options), tokens = info.tokens, bundle = info.bundle, re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$", info.strict ? "" : "i"), match = re.exec(value && value.replace(controlChars, ""));
            if (!match) {
                return null;
            }
            var widthList = ["abbr", "wide", "narrow"], result = [1970, 0, 1, 0, 0, 0, 0], amPm = "", valid = array.every(match, function (v, i) {
                if (!i) {
                    return true;
                }
                var token = tokens[i - 1], l = token.length, c = token.charAt(0);
                switch (c) {
                  case "y":
                    if (l != 2 && options.strict) {
                        result[0] = v;
                    } else {
                        if (v < 100) {
                            v = Number(v);
                            var year = "" + new Date().getFullYear(), century = year.substring(0, 2) * 100, cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
                            result[0] = (v < cutoff) ? century + v : century - 100 + v;
                        } else {
                            if (options.strict) {
                                return false;
                            }
                            result[0] = v;
                        }
                    }
                    break;
                  case "M":
                  case "L":
                    if (l > 2) {
                        var months = bundle["months-" + (c == "L" ? "standAlone" : "format") + "-" + widthList[l - 3]].concat();
                        if (!options.strict) {
                            v = v.replace(".", "").toLowerCase();
                            months = array.map(months, function (s) {
                                return s.replace(".", "").toLowerCase();
                            });
                        }
                        v = array.indexOf(months, v);
                        if (v == -1) {
                            return false;
                        }
                    } else {
                        v--;
                    }
                    result[1] = v;
                    break;
                  case "E":
                  case "e":
                  case "c":
                    var days = bundle["days-" + (c == "c" ? "standAlone" : "format") + "-" + widthList[l - 3]].concat();
                    if (!options.strict) {
                        v = v.toLowerCase();
                        days = array.map(days, function (d) {
                            return d.toLowerCase();
                        });
                    }
                    v = array.indexOf(days, v);
                    if (v == -1) {
                        return false;
                    }
                    break;
                  case "D":
                    result[1] = 0;
                  case "d":
                    result[2] = v;
                    break;
                  case "a":
                    var am = options.am || bundle["dayPeriods-format-wide-am"], pm = options.pm || bundle["dayPeriods-format-wide-pm"];
                    if (!options.strict) {
                        var period = /\./g;
                        v = v.replace(period, "").toLowerCase();
                        am = am.replace(period, "").toLowerCase();
                        pm = pm.replace(period, "").toLowerCase();
                    }
                    if (options.strict && v != am && v != pm) {
                        return false;
                    }
                    amPm = (v == pm) ? "p" : (v == am) ? "a" : "";
                    break;
                  case "K":
                    if (v == 24) {
                        v = 0;
                    }
                  case "h":
                  case "H":
                  case "k":
                    if (v > 23) {
                        return false;
                    }
                    result[3] = v;
                    break;
                  case "m":
                    result[4] = v;
                    break;
                  case "s":
                    result[5] = v;
                    break;
                  case "S":
                    result[6] = v;
                }
                return true;
            });
            var hours = +result[3];
            if (amPm === "p" && hours < 12) {
                result[3] = hours + 12;
            } else {
                if (amPm === "a" && hours == 12) {
                    result[3] = 0;
                }
            }
            var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]);
            if (options.strict) {
                dateObject.setFullYear(result[0]);
            }
            var allTokens = tokens.join(""), dateToken = allTokens.indexOf("d") != -1, monthToken = allTokens.indexOf("M") != -1;
            if (!valid || (monthToken && dateObject.getMonth() > result[1]) || (dateToken && dateObject.getDate() > result[2])) {
                return null;
            }
            if ((monthToken && dateObject.getMonth() < result[1]) || (dateToken && dateObject.getDate() < result[2])) {
                dateObject = date.add(dateObject, "hour", 1);
            }
            return dateObject;
        };
        function _processPattern(pattern, applyPattern, applyLiteral, applyAll) {
            var identity = function (x) {
                return x;
            };
            applyPattern = applyPattern || identity;
            applyLiteral = applyLiteral || identity;
            applyAll = applyAll || identity;
            var chunks = pattern.match(/(''|[^'])+/g), literal = pattern.charAt(0) == "'";
            array.forEach(chunks, function (chunk, i) {
                if (!chunk) {
                    chunks[i] = "";
                } else {
                    chunks[i] = (literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
                    literal = !literal;
                }
            });
            return applyAll(chunks.join(""));
        }
        function _buildDateTimeRE(tokens, bundle, options, pattern) {
            pattern = regexp.escapeString(pattern);
            if (!options.strict) {
                pattern = pattern.replace(" a", " ?a");
            }
            return pattern.replace(/([a-z])\1*/ig, function (match) {
                var s, c = match.charAt(0), l = match.length, p2 = "", p3 = "";
                if (options.strict) {
                    if (l > 1) {
                        p2 = "0" + "{" + (l - 1) + "}";
                    }
                    if (l > 2) {
                        p3 = "0" + "{" + (l - 2) + "}";
                    }
                } else {
                    p2 = "0?";
                    p3 = "0{0,2}";
                }
                switch (c) {
                  case "y":
                    s = "\\d{2,4}";
                    break;
                  case "M":
                  case "L":
                    s = (l > 2) ? "\\S+?" : "1[0-2]|" + p2 + "[1-9]";
                    break;
                  case "D":
                    s = "[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|" + p2 + "[1-9][0-9]|" + p3 + "[1-9]";
                    break;
                  case "d":
                    s = "3[01]|[12]\\d|" + p2 + "[1-9]";
                    break;
                  case "w":
                    s = "[1-4][0-9]|5[0-3]|" + p2 + "[1-9]";
                    break;
                  case "E":
                  case "e":
                  case "c":
                    s = ".+?";
                    break;
                  case "h":
                    s = "1[0-2]|" + p2 + "[1-9]";
                    break;
                  case "k":
                    s = "1[01]|" + p2 + "\\d";
                    break;
                  case "H":
                    s = "1\\d|2[0-3]|" + p2 + "\\d";
                    break;
                  case "K":
                    s = "1\\d|2[0-4]|" + p2 + "[1-9]";
                    break;
                  case "m":
                  case "s":
                    s = "[0-5]\\d";
                    break;
                  case "S":
                    s = "\\d{" + l + "}";
                    break;
                  case "a":
                    var am = options.am || bundle["dayPeriods-format-wide-am"], pm = options.pm || bundle["dayPeriods-format-wide-pm"];
                    s = am + "|" + pm;
                    if (!options.strict) {
                        if (am != am.toLowerCase()) {
                            s += "|" + am.toLowerCase();
                        }
                        if (pm != pm.toLowerCase()) {
                            s += "|" + pm.toLowerCase();
                        }
                        if (s.indexOf(".") != -1) {
                            s += "|" + s.replace(/\./g, "");
                        }
                    }
                    s = s.replace(/\./g, "\\.");
                    break;
                  default:
                    s = ".*";
                }
                if (tokens) {
                    tokens.push(match);
                }
                return "(" + s + ")";
            }).replace(/[\xa0 ]/g, "[\\s\\xa0]");
        }
        var _customFormats = [];
        exports.addCustomFormats = function (packageName, bundleName) {
            _customFormats.push({pkg:packageName, name:bundleName});
        };
        exports._getGregorianBundle = function (locale) {
            var gregorian = {};
            array.forEach(_customFormats, function (desc) {
                var bundle = i18n.getLocalization(desc.pkg, desc.name, locale);
                gregorian = lang.mixin(gregorian, bundle);
            }, this);
            return gregorian;
        };
        exports.addCustomFormats(module.id.replace(/\/date\/locale$/, ".cldr"), "gregorian");
        exports.getNames = function (item, type, context, locale) {
            var label, lookup = exports._getGregorianBundle(locale), props = [item, context, type];
            if (context == "standAlone") {
                var key = props.join("-");
                label = lookup[key];
                if (label[0] == 1) {
                    label = undefined;
                }
            }
            props[1] = "format";
            return (label || lookup[props.join("-")]).concat();
        };
        exports.isWeekend = function (dateObject, locale) {
            var weekend = supplemental.getWeekend(locale), day = (dateObject || new Date()).getDay();
            if (weekend.end < weekend.start) {
                weekend.end += 7;
                if (day < weekend.start) {
                    day += 7;
                }
            }
            return day >= weekend.start && day <= weekend.end;
        };
        exports._getDayOfYear = function (dateObject) {
            return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1;
        };
        exports._getWeekOfYear = function (dateObject, firstDayOfWeek) {
            if (arguments.length == 1) {
                firstDayOfWeek = 0;
            }
            var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(), adj = (firstDayOfYear - firstDayOfWeek + 7) % 7, week = Math.floor((exports._getDayOfYear(dateObject) + adj - 1) / 7);
            if (firstDayOfYear == firstDayOfWeek) {
                week++;
            }
            return week;
        };
        return exports;
    });
}, "dojox/collections/Queue":function () {
    define(["dojo/_base/kernel", "dojo/_base/array", "./_base"], function (dojo, darray, dxc) {
        dxc.Queue = function (arr) {
            var q = [];
            if (arr) {
                q = q.concat(arr);
            }
            this.count = q.length;
            this.clear = function () {
                q = [];
                this.count = q.length;
            };
            this.clone = function () {
                return new dxc.Queue(q);
            };
            this.contains = function (o) {
                for (var i = 0; i < q.length; i++) {
                    if (q[i] == o) {
                        return true;
                    }
                }
                return false;
            };
            this.copyTo = function (arr, i) {
                arr.splice(i, 0, q);
            };
            this.dequeue = function () {
                var r = q.shift();
                this.count = q.length;
                return r;
            };
            this.enqueue = function (o) {
                this.count = q.push(o);
            };
            this.forEach = function (fn, scope) {
                dojo.forEach(q, fn, scope);
            };
            this.getIterator = function () {
                return new dxc.Iterator(q);
            };
            this.peek = function () {
                return q[0];
            };
            this.toArray = function () {
                return [].concat(q);
            };
        };
        return dxc.Queue;
    });
}, "dijit/_Templated":function () {
    define(["./_WidgetBase", "./_TemplatedMixin", "./_WidgetsInTemplateMixin", "dojo/_base/array", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/kernel"], function (_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel) {
        lang.extend(_WidgetBase, {waiRole:"", waiState:""});
        return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {widgetsInTemplate:false, constructor:function () {
            kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
        }, _processNode:function (baseNode, getAttrFunc) {
            var ret = this.inherited(arguments);
            var role = getAttrFunc(baseNode, "waiRole");
            if (role) {
                baseNode.setAttribute("role", role);
            }
            var values = getAttrFunc(baseNode, "waiState");
            if (values) {
                array.forEach(values.split(/\s*,\s*/), function (stateValue) {
                    if (stateValue.indexOf("-") != -1) {
                        var pair = stateValue.split("-");
                        baseNode.setAttribute("aria-" + pair[0], pair[1]);
                    }
                });
            }
            return ret;
        }});
    });
}, "dojo/require":function () {
    define(["./_base/loader"], function (loader) {
        return {dynamic:0, normalize:function (id) {
            return id;
        }, load:loader.require};
    });
}, "dijit/_editor/RichText":function () {
    define(["dojo/_base/array", "dojo/_base/config", "dojo/_base/declare", "dojo/_base/Deferred", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/kernel", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/query", "dojo/domReady", "dojo/sniff", "dojo/topic", "dojo/_base/unload", "dojo/_base/url", "dojo/window", "../_Widget", "../_CssStateMixin", "../selection", "./range", "./html", "../focus", "../main"], function (array, config, declare, Deferred, dom, domAttr, domClass, domConstruct, domGeometry, domStyle, kernel, keys, lang, on, query, domReady, has, topic, unload, _Url, winUtils, _Widget, _CssStateMixin, selectionapi, rangeapi, htmlapi, focus, dijit) {
        var RichText = declare("dijit._editor.RichText", [_Widget, _CssStateMixin], {constructor:function (params) {
            this.contentPreFilters = [];
            this.contentPostFilters = [];
            this.contentDomPreFilters = [];
            this.contentDomPostFilters = [];
            this.editingAreaStyleSheets = [];
            this.events = [].concat(this.events);
            this._keyHandlers = {};
            if (params && lang.isString(params.value)) {
                this.value = params.value;
            }
            this.onLoadDeferred = new Deferred();
        }, baseClass:"dijitEditor", inheritWidth:false, focusOnLoad:false, name:"", styleSheets:"", height:"300px", minHeight:"1em", isClosed:true, isLoaded:false, _SEPARATOR:"@@**%%__RICHTEXTBOUNDRY__%%**@@", _NAME_CONTENT_SEP:"@@**%%:%%**@@", onLoadDeferred:null, isTabIndent:false, disableSpellCheck:false, postCreate:function () {
            if ("textarea" === this.domNode.tagName.toLowerCase()) {
                console.warn("RichText should not be used with the TEXTAREA tag.  See dijit._editor.RichText docs.");
            }
            this.contentPreFilters = [lang.trim, lang.hitch(this, "_preFixUrlAttributes")].concat(this.contentPreFilters);
            if (has("mozilla")) {
                this.contentPreFilters = [this._normalizeFontStyle].concat(this.contentPreFilters);
                this.contentPostFilters = [this._removeMozBogus].concat(this.contentPostFilters);
            }
            if (has("webkit")) {
                this.contentPreFilters = [this._removeWebkitBogus].concat(this.contentPreFilters);
                this.contentPostFilters = [this._removeWebkitBogus].concat(this.contentPostFilters);
            }
            if (has("ie") || has("trident")) {
                this.contentPostFilters = [this._normalizeFontStyle].concat(this.contentPostFilters);
                this.contentDomPostFilters = [lang.hitch(this, "_stripBreakerNodes")].concat(this.contentDomPostFilters);
            }
            this.contentDomPostFilters = [lang.hitch(this, "_stripTrailingEmptyNodes")].concat(this.contentDomPostFilters);
            this.inherited(arguments);
            topic.publish(dijit._scopeName + "._editor.RichText::init", this);
        }, startup:function () {
            this.inherited(arguments);
            this.open();
            this.setupDefaultShortcuts();
        }, setupDefaultShortcuts:function () {
            var exec = lang.hitch(this, function (cmd, arg) {
                return function () {
                    return !this.execCommand(cmd, arg);
                };
            });
            var ctrlKeyHandlers = {b:exec("bold"), i:exec("italic"), u:exec("underline"), a:exec("selectall"), s:function () {
                this.save(true);
            }, m:function () {
                this.isTabIndent = !this.isTabIndent;
            }, "1":exec("formatblock", "h1"), "2":exec("formatblock", "h2"), "3":exec("formatblock", "h3"), "4":exec("formatblock", "h4"), "\\":exec("insertunorderedlist")};
            if (!has("ie")) {
                ctrlKeyHandlers.Z = exec("redo");
            }
            var key;
            for (key in ctrlKeyHandlers) {
                this.addKeyHandler(key, true, false, ctrlKeyHandlers[key]);
            }
        }, events:["onKeyDown", "onKeyUp"], captureEvents:[], _editorCommandsLocalized:false, _localizeEditorCommands:function () {
            if (RichText._editorCommandsLocalized) {
                this._local2NativeFormatNames = RichText._local2NativeFormatNames;
                this._native2LocalFormatNames = RichText._native2LocalFormatNames;
                return;
            }
            RichText._editorCommandsLocalized = true;
            RichText._local2NativeFormatNames = {};
            RichText._native2LocalFormatNames = {};
            this._local2NativeFormatNames = RichText._local2NativeFormatNames;
            this._native2LocalFormatNames = RichText._native2LocalFormatNames;
            var formats = ["div", "p", "pre", "h1", "h2", "h3", "h4", "h5", "h6", "ol", "ul", "address"];
            var localhtml = "", format, i = 0;
            while ((format = formats[i++])) {
                if (format.charAt(1) !== "l") {
                    localhtml += "<" + format + "><span>content</span></" + format + "><br/>";
                } else {
                    localhtml += "<" + format + "><li>content</li></" + format + "><br/>";
                }
            }
            var style = {position:"absolute", top:"0px", zIndex:10, opacity:0.01};
            var div = domConstruct.create("div", {style:style, innerHTML:localhtml});
            this.ownerDocumentBody.appendChild(div);
            var inject = lang.hitch(this, function () {
                var node = div.firstChild;
                while (node) {
                    try {
                        this.selection.selectElement(node.firstChild);
                        var nativename = node.tagName.toLowerCase();
                        this._local2NativeFormatNames[nativename] = document.queryCommandValue("formatblock");
                        this._native2LocalFormatNames[this._local2NativeFormatNames[nativename]] = nativename;
                        node = node.nextSibling.nextSibling;
                    }
                    catch (e) {
                    }
                }
                domConstruct.destroy(div);
            });
            this.defer(inject);
        }, open:function (element) {
            if (!this.onLoadDeferred || this.onLoadDeferred.fired >= 0) {
                this.onLoadDeferred = new Deferred();
            }
            if (!this.isClosed) {
                this.close();
            }
            topic.publish(dijit._scopeName + "._editor.RichText::open", this);
            if (arguments.length === 1 && element.nodeName) {
                this.domNode = element;
            }
            var dn = this.domNode;
            var html;
            if (lang.isString(this.value)) {
                html = this.value;
                dn.innerHTML = "";
            } else {
                if (dn.nodeName && dn.nodeName.toLowerCase() == "textarea") {
                    var ta = (this.textarea = dn);
                    this.name = ta.name;
                    html = ta.value;
                    dn = this.domNode = this.ownerDocument.createElement("div");
                    dn.setAttribute("widgetId", this.id);
                    ta.removeAttribute("widgetId");
                    dn.cssText = ta.cssText;
                    dn.className += " " + ta.className;
                    domConstruct.place(dn, ta, "before");
                    var tmpFunc = lang.hitch(this, function () {
                        domStyle.set(ta, {display:"block", position:"absolute", top:"-1000px"});
                        if (has("ie")) {
                            var s = ta.style;
                            this.__overflow = s.overflow;
                            s.overflow = "hidden";
                        }
                    });
                    if (has("ie")) {
                        this.defer(tmpFunc, 10);
                    } else {
                        tmpFunc();
                    }
                    if (ta.form) {
                        var resetValue = ta.value;
                        this.reset = function () {
                            var current = this.getValue();
                            if (current !== resetValue) {
                                this.replaceValue(resetValue);
                            }
                        };
                        on(ta.form, "submit", lang.hitch(this, function () {
                            domAttr.set(ta, "disabled", this.disabled);
                            ta.value = this.getValue();
                        }));
                    }
                } else {
                    html = htmlapi.getChildrenHtml(dn);
                    dn.innerHTML = "";
                }
            }
            this.value = html;
            if (dn.nodeName && dn.nodeName === "LI") {
                dn.innerHTML = " <br>";
            }
            this.header = dn.ownerDocument.createElement("div");
            dn.appendChild(this.header);
            this.editingArea = dn.ownerDocument.createElement("div");
            dn.appendChild(this.editingArea);
            this.footer = dn.ownerDocument.createElement("div");
            dn.appendChild(this.footer);
            if (!this.name) {
                this.name = this.id + "_AUTOGEN";
            }
            if (this.name !== "" && (!config["useXDomain"] || config["allowXdRichTextSave"])) {
                var saveTextarea = dom.byId(dijit._scopeName + "._editor.RichText.value");
                if (saveTextarea && saveTextarea.value !== "") {
                    var datas = saveTextarea.value.split(this._SEPARATOR), i = 0, dat;
                    while ((dat = datas[i++])) {
                        var data = dat.split(this._NAME_CONTENT_SEP);
                        if (data[0] === this.name) {
                            html = data[1];
                            datas = datas.splice(i, 1);
                            saveTextarea.value = datas.join(this._SEPARATOR);
                            break;
                        }
                    }
                }
                if (!RichText._globalSaveHandler) {
                    RichText._globalSaveHandler = {};
                    unload.addOnUnload(function () {
                        var id;
                        for (id in RichText._globalSaveHandler) {
                            var f = RichText._globalSaveHandler[id];
                            if (lang.isFunction(f)) {
                                f();
                            }
                        }
                    });
                }
                RichText._globalSaveHandler[this.id] = lang.hitch(this, "_saveContent");
            }
            this.isClosed = false;
            var ifr = (this.editorObject = this.iframe = this.ownerDocument.createElement("iframe"));
            ifr.id = this.id + "_iframe";
            ifr.style.border = "none";
            ifr.style.width = "100%";
            if (this._layoutMode) {
                ifr.style.height = "100%";
            } else {
                if (has("ie") >= 7) {
                    if (this.height) {
                        ifr.style.height = this.height;
                    }
                    if (this.minHeight) {
                        ifr.style.minHeight = this.minHeight;
                    }
                } else {
                    ifr.style.height = this.height ? this.height : this.minHeight;
                }
            }
            ifr.frameBorder = 0;
            ifr._loadFunc = lang.hitch(this, function (w) {
                this.window = w;
                this.document = w.document;
                this.selection = new selectionapi.SelectionManager(w);
                if (has("ie")) {
                    this._localizeEditorCommands();
                }
                this.onLoad(html);
            });
            var src = this._getIframeDocTxt().replace(/\\/g, "\\\\").replace(/'/g, "\\'"), s;
            if (has("ie") < 11) {
                s = "javascript:document.open();try{parent.window;}catch(e){document.domain=\"" + document.domain + "\";}" + "document.write('" + src + "');document.close()";
            } else {
                s = "javascript: '" + src + "'";
            }
            if (has("ie") == 9) {
                this.editingArea.appendChild(ifr);
                ifr.src = s;
            } else {
                ifr.setAttribute("src", s);
                this.editingArea.appendChild(ifr);
            }
            if (dn.nodeName === "LI") {
                dn.lastChild.style.marginTop = "-1.2em";
            }
            domClass.add(this.domNode, this.baseClass);
        }, _local2NativeFormatNames:{}, _native2LocalFormatNames:{}, _getIframeDocTxt:function () {
            var _cs = domStyle.getComputedStyle(this.domNode);
            var html = "<div id='dijitEditorBody'></div>";
            var font = [_cs.fontWeight, _cs.fontSize, _cs.fontFamily].join(" ");
            var lineHeight = _cs.lineHeight;
            if (lineHeight.indexOf("px") >= 0) {
                lineHeight = parseFloat(lineHeight) / parseFloat(_cs.fontSize);
            } else {
                if (lineHeight.indexOf("em") >= 0) {
                    lineHeight = parseFloat(lineHeight);
                } else {
                    lineHeight = "normal";
                }
            }
            var userStyle = "";
            var self = this;
            this.style.replace(/(^|;)\s*(line-|font-?)[^;]+/ig, function (match) {
                match = match.replace(/^;/ig, "") + ";";
                var s = match.split(":")[0];
                if (s) {
                    s = lang.trim(s);
                    s = s.toLowerCase();
                    var i;
                    var sC = "";
                    for (i = 0; i < s.length; i++) {
                        var c = s.charAt(i);
                        switch (c) {
                          case "-":
                            i++;
                            c = s.charAt(i).toUpperCase();
                          default:
                            sC += c;
                        }
                    }
                    domStyle.set(self.domNode, sC, "");
                }
                userStyle += match + ";";
            });
            var label = query("label[for=\"" + this.id + "\"]");
            var title = "";
            if (label.length) {
                title = label[0].innerHTML;
            } else {
                if (this["aria-label"]) {
                    title = this["aria-label"];
                } else {
                    if (this["aria-labelledby"]) {
                        title = dom.byId(this["aria-labelledby"]).innerHTML;
                    }
                }
            }
            this.iframe.setAttribute("title", title);
            return ["<!DOCTYPE html>", this.isLeftToRight() ? "<html lang='" + this.lang + "'>\n<head>\n" : "<html dir='rtl' lang='" + this.lang + "'>\n<head>\n", title ? "<title>" + title + "</title>" : "", "<meta http-equiv='Content-Type' content='text/html'>\n", "<style>\n", "\tbody,html {\n", "\t\tbackground:transparent;\n", "\t\tpadding: 1px 0 0 0;\n", "\t\tmargin: -1px 0 0 0;\n", "\t}\n", "\tbody,html,#dijitEditorBody { outline: none; }", "html { height: 100%; width: 100%; overflow: hidden; }\n", this.height ? "\tbody,#dijitEditorBody { height: 100%; width: 100%; overflow: auto; }\n" : "\tbody,#dijitEditorBody { min-height: " + this.minHeight + "; width: 100%; overflow-x: auto; overflow-y: hidden; }\n", "\tbody{\n", "\t\ttop:0px;\n", "\t\tleft:0px;\n", "\t\tright:0px;\n", "\t\tfont:", font, ";\n", ((this.height || has("opera")) ? "" : "\t\tposition: fixed;\n"), "\t\tline-height:", lineHeight, ";\n", "\t}\n", "\tp{ margin: 1em 0; }\n", "\tli > ul:-moz-first-node, li > ol:-moz-first-node{ padding-top: 1.2em; }\n", (!has("ie") ? "\tli{ min-height:1.2em; }\n" : ""), "</style>\n", this._applyEditingAreaStyleSheets(), "\n", "</head>\n<body role='main' ", "onload='frameElement && frameElement._loadFunc(window,document)' ", "style='" + userStyle + "'>", html, "</body>\n</html>"].join("");
        }, _applyEditingAreaStyleSheets:function () {
            var files = [];
            if (this.styleSheets) {
                files = this.styleSheets.split(";");
                this.styleSheets = "";
            }
            files = files.concat(this.editingAreaStyleSheets);
            this.editingAreaStyleSheets = [];
            var text = "", i = 0, url, ownerWindow = winUtils.get(this.ownerDocument);
            while ((url = files[i++])) {
                var abstring = (new _Url(ownerWindow.location, url)).toString();
                this.editingAreaStyleSheets.push(abstring);
                text += "<link rel=\"stylesheet\" type=\"text/css\" href=\"" + abstring + "\"/>";
            }
            return text;
        }, addStyleSheet:function (uri) {
            var url = uri.toString(), ownerWindow = winUtils.get(this.ownerDocument);
            if (url.charAt(0) === "." || (url.charAt(0) !== "/" && !uri.host)) {
                url = (new _Url(ownerWindow.location, url)).toString();
            }
            if (array.indexOf(this.editingAreaStyleSheets, url) > -1) {
                return;
            }
            this.editingAreaStyleSheets.push(url);
            this.onLoadDeferred.then(lang.hitch(this, function () {
                if (this.document.createStyleSheet) {
                    this.document.createStyleSheet(url);
                } else {
                    var head = this.document.getElementsByTagName("head")[0];
                    var stylesheet = this.document.createElement("link");
                    stylesheet.rel = "stylesheet";
                    stylesheet.type = "text/css";
                    stylesheet.href = url;
                    head.appendChild(stylesheet);
                }
            }));
        }, removeStyleSheet:function (uri) {
            var url = uri.toString(), ownerWindow = winUtils.get(this.ownerDocument);
            if (url.charAt(0) === "." || (url.charAt(0) !== "/" && !uri.host)) {
                url = (new _Url(ownerWindow.location, url)).toString();
            }
            var index = array.indexOf(this.editingAreaStyleSheets, url);
            if (index === -1) {
                return;
            }
            delete this.editingAreaStyleSheets[index];
            query("link[href=\"" + url + "\"]", this.window.document).orphan();
        }, disabled:false, _mozSettingProps:{"styleWithCSS":false}, _setDisabledAttr:function (value) {
            value = !!value;
            this._set("disabled", value);
            if (!this.isLoaded) {
                return;
            }
            var preventIEfocus = has("ie") && (this.isLoaded || !this.focusOnLoad);
            if (preventIEfocus) {
                this.editNode.unselectable = "on";
            }
            this.editNode.contentEditable = !value;
            this.editNode.tabIndex = value ? "-1" : this.tabIndex;
            if (preventIEfocus) {
                this.defer(function () {
                    if (this.editNode) {
                        this.editNode.unselectable = "off";
                    }
                });
            }
            if (has("mozilla") && !value && this._mozSettingProps) {
                var ps = this._mozSettingProps;
                var n;
                for (n in ps) {
                    if (ps.hasOwnProperty(n)) {
                        try {
                            this.document.execCommand(n, false, ps[n]);
                        }
                        catch (e2) {
                        }
                    }
                }
            }
            this._disabledOK = true;
        }, onLoad:function (html) {
            if (!this.window.__registeredWindow) {
                this.window.__registeredWindow = true;
                this._iframeRegHandle = focus.registerIframe(this.iframe);
            }
            this.editNode = this.document.body.firstChild;
            var _this = this;
            this.beforeIframeNode = domConstruct.place("<div tabIndex=-1></div>", this.iframe, "before");
            this.afterIframeNode = domConstruct.place("<div tabIndex=-1></div>", this.iframe, "after");
            this.iframe.onfocus = this.document.onfocus = function () {
                _this.editNode.focus();
            };
            this.focusNode = this.editNode;
            var events = this.events.concat(this.captureEvents);
            var ap = this.iframe ? this.document : this.editNode;
            this.own(array.map(events, function (item) {
                var type = item.toLowerCase().replace(/^on/, "");
                on(ap, type, lang.hitch(this, item));
            }, this));
            this.own(on(ap, "mouseup", lang.hitch(this, "onClick")));
            if (has("ie")) {
                this.own(on(this.document, "mousedown", lang.hitch(this, "_onIEMouseDown")));
                this.editNode.style.zoom = 1;
            } else {
                this.own(on(this.document, "mousedown", lang.hitch(this, function () {
                    delete this._cursorToStart;
                })));
            }
            if (has("webkit")) {
                this._webkitListener = this.own(on(this.document, "mouseup", lang.hitch(this, "onDisplayChanged")))[0];
                this.own(on(this.document, "mousedown", lang.hitch(this, function (e) {
                    var t = e.target;
                    if (t && (t === this.document.body || t === this.document)) {
                        this.defer("placeCursorAtEnd");
                    }
                })));
            }
            if (has("ie")) {
                try {
                    this.document.execCommand("RespectVisibilityInDesign", true, null);
                }
                catch (e) {
                }
            }
            this.isLoaded = true;
            this.set("disabled", this.disabled);
            var setContent = lang.hitch(this, function () {
                this.setValue(html);
                if (this.onLoadDeferred) {
                    this.onLoadDeferred.resolve(true);
                }
                this.onDisplayChanged();
                if (this.focusOnLoad) {
                    domReady(lang.hitch(this, "defer", "focus", this.updateInterval));
                }
                this.value = this.getValue(true);
            });
            if (this.setValueDeferred) {
                this.setValueDeferred.then(setContent);
            } else {
                setContent();
            }
        }, onKeyDown:function (e) {
            if (e.keyCode === keys.SHIFT || e.keyCode === keys.ALT || e.keyCode === keys.META || e.keyCode === keys.CTRL) {
                return true;
            }
            if (e.keyCode === keys.TAB && this.isTabIndent) {
                e.stopPropagation();
                e.preventDefault();
                if (this.queryCommandEnabled((e.shiftKey ? "outdent" : "indent"))) {
                    this.execCommand((e.shiftKey ? "outdent" : "indent"));
                }
            }
            if (e.keyCode == keys.TAB && !this.isTabIndent && !e.ctrlKey && !e.altKey) {
                if (e.shiftKey) {
                    this.beforeIframeNode.focus();
                } else {
                    this.afterIframeNode.focus();
                }
                return true;
            }
            if (has("ie") < 9 && e.keyCode === keys.BACKSPACE && this.document.selection.type === "Control") {
                e.stopPropagation();
                e.preventDefault();
                this.execCommand("delete");
            }
            if (has("ff")) {
                if (e.keyCode === keys.PAGE_UP || e.keyCode === keys.PAGE_DOWN) {
                    if (this.editNode.clientHeight >= this.editNode.scrollHeight) {
                        e.preventDefault();
                    }
                }
            }
            var handlers = this._keyHandlers[e.keyCode], args = arguments;
            if (handlers && !e.altKey) {
                array.some(handlers, function (h) {
                    if (!(h.shift ^ e.shiftKey) && !(h.ctrl ^ (e.ctrlKey || e.metaKey))) {
                        if (!h.handler.apply(this, args)) {
                            e.preventDefault();
                        }
                        return true;
                    }
                }, this);
            }
            this.defer("onKeyPressed", 1);
            return true;
        }, onKeyUp:function () {
        }, setDisabled:function (disabled) {
            kernel.deprecated("dijit.Editor::setDisabled is deprecated", "use dijit.Editor::attr(\"disabled\",boolean) instead", 2);
            this.set("disabled", disabled);
        }, _setValueAttr:function (value) {
            this.setValue(value);
        }, _setDisableSpellCheckAttr:function (disabled) {
            if (this.document) {
                domAttr.set(this.document.body, "spellcheck", !disabled);
            } else {
                this.onLoadDeferred.then(lang.hitch(this, function () {
                    domAttr.set(this.document.body, "spellcheck", !disabled);
                }));
            }
            this._set("disableSpellCheck", disabled);
        }, addKeyHandler:function (key, ctrl, shift, handler) {
            if (typeof key == "string") {
                key = key.toUpperCase().charCodeAt(0);
            }
            if (!lang.isArray(this._keyHandlers[key])) {
                this._keyHandlers[key] = [];
            }
            this._keyHandlers[key].push({shift:shift || false, ctrl:ctrl || false, handler:handler});
        }, onKeyPressed:function () {
            this.onDisplayChanged();
        }, onClick:function (e) {
            this.onDisplayChanged(e);
        }, _onIEMouseDown:function () {
            if (!this.focused && !this.disabled) {
                this.focus();
            }
        }, _onBlur:function (e) {
            if (has("ie") || has("trident")) {
                this.defer(function () {
                    if (!focus.curNode) {
                        this.ownerDocumentBody.focus();
                    }
                });
            }
            this.inherited(arguments);
            var newValue = this.getValue(true);
            if (newValue !== this.value) {
                this.onChange(newValue);
            }
            this._set("value", newValue);
        }, _onFocus:function (e) {
            if (!this.disabled) {
                if (!this._disabledOK) {
                    this.set("disabled", false);
                }
                this.inherited(arguments);
            }
        }, blur:function () {
            if (!has("ie") && this.window.document.documentElement && this.window.document.documentElement.focus) {
                this.window.document.documentElement.focus();
            } else {
                if (this.ownerDocumentBody.focus) {
                    this.ownerDocumentBody.focus();
                }
            }
        }, focus:function () {
            if (!this.isLoaded) {
                this.focusOnLoad = true;
                return;
            }
            if (this._cursorToStart) {
                delete this._cursorToStart;
                if (this.editNode.childNodes) {
                    this.placeCursorAtStart();
                    return;
                }
            }
            if (has("ie") < 9) {
                this.iframe.fireEvent("onfocus", document.createEventObject());
            } else {
                this.editNode.focus();
            }
        }, updateInterval:200, _updateTimer:null, onDisplayChanged:function () {
            if (this._updateTimer) {
                this._updateTimer.remove();
            }
            this._updateTimer = this.defer("onNormalizedDisplayChanged", this.updateInterval);
        }, onNormalizedDisplayChanged:function () {
            delete this._updateTimer;
        }, onChange:function () {
        }, _normalizeCommand:function (cmd, argument) {
            var command = cmd.toLowerCase();
            if (command === "formatblock") {
                if (has("safari") && argument === undefined) {
                    command = "heading";
                }
            } else {
                if (command === "hilitecolor" && !has("mozilla")) {
                    command = "backcolor";
                }
            }
            return command;
        }, _qcaCache:{}, queryCommandAvailable:function (command) {
            var ca = this._qcaCache[command];
            if (ca !== undefined) {
                return ca;
            }
            return (this._qcaCache[command] = this._queryCommandAvailable(command));
        }, _queryCommandAvailable:function (command) {
            var ie = 1;
            var mozilla = 1 << 1;
            var webkit = 1 << 2;
            var opera = 1 << 3;
            function isSupportedBy(browsers) {
                return {ie:Boolean(browsers & ie), mozilla:Boolean(browsers & mozilla), webkit:Boolean(browsers & webkit), opera:Boolean(browsers & opera)};
            }
            var supportedBy = null;
            switch (command.toLowerCase()) {
              case "bold":
              case "italic":
              case "underline":
              case "subscript":
              case "superscript":
              case "fontname":
              case "fontsize":
              case "forecolor":
              case "hilitecolor":
              case "justifycenter":
              case "justifyfull":
              case "justifyleft":
              case "justifyright":
              case "delete":
              case "selectall":
              case "toggledir":
                supportedBy = isSupportedBy(mozilla | ie | webkit | opera);
                break;
              case "createlink":
              case "unlink":
              case "removeformat":
              case "inserthorizontalrule":
              case "insertimage":
              case "insertorderedlist":
              case "insertunorderedlist":
              case "indent":
              case "outdent":
              case "formatblock":
              case "inserthtml":
              case "undo":
              case "redo":
              case "strikethrough":
              case "tabindent":
                supportedBy = isSupportedBy(mozilla | ie | opera | webkit);
                break;
              case "blockdirltr":
              case "blockdirrtl":
              case "dirltr":
              case "dirrtl":
              case "inlinedirltr":
              case "inlinedirrtl":
                supportedBy = isSupportedBy(ie);
                break;
              case "cut":
              case "copy":
              case "paste":
                supportedBy = isSupportedBy(ie | mozilla | webkit | opera);
                break;
              case "inserttable":
                supportedBy = isSupportedBy(mozilla | ie);
                break;
              case "insertcell":
              case "insertcol":
              case "insertrow":
              case "deletecells":
              case "deletecols":
              case "deleterows":
              case "mergecells":
              case "splitcell":
                supportedBy = isSupportedBy(ie | mozilla);
                break;
              default:
                return false;
            }
            return ((has("ie") || has("trident")) && supportedBy.ie) || (has("mozilla") && supportedBy.mozilla) || (has("webkit") && supportedBy.webkit) || (has("opera") && supportedBy.opera);
        }, execCommand:function (command, argument) {
            var returnValue;
            if (this.focused) {
                this.focus();
            }
            command = this._normalizeCommand(command, argument);
            if (argument !== undefined) {
                if (command === "heading") {
                    throw new Error("unimplemented");
                } else {
                    if (command === "formatblock" && (has("ie") || has("trident"))) {
                        argument = "<" + argument + ">";
                    }
                }
            }
            var implFunc = "_" + command + "Impl";
            if (this[implFunc]) {
                returnValue = this[implFunc](argument);
            } else {
                argument = arguments.length > 1 ? argument : null;
                if (argument || command !== "createlink") {
                    returnValue = this.document.execCommand(command, false, argument);
                }
            }
            this.onDisplayChanged();
            return returnValue;
        }, queryCommandEnabled:function (command) {
            if (this.disabled || !this._disabledOK) {
                return false;
            }
            command = this._normalizeCommand(command);
            var implFunc = "_" + command + "EnabledImpl";
            if (this[implFunc]) {
                return this[implFunc](command);
            } else {
                return this._browserQueryCommandEnabled(command);
            }
        }, queryCommandState:function (command) {
            if (this.disabled || !this._disabledOK) {
                return false;
            }
            command = this._normalizeCommand(command);
            try {
                return this.document.queryCommandState(command);
            }
            catch (e) {
                return false;
            }
        }, queryCommandValue:function (command) {
            if (this.disabled || !this._disabledOK) {
                return false;
            }
            var r;
            command = this._normalizeCommand(command);
            if ((has("ie") || has("trident")) && command === "formatblock") {
                r = this._native2LocalFormatNames[this.document.queryCommandValue(command)];
            } else {
                if (has("mozilla") && command === "hilitecolor") {
                    var oldValue;
                    try {
                        oldValue = this.document.queryCommandValue("styleWithCSS");
                    }
                    catch (e) {
                        oldValue = false;
                    }
                    this.document.execCommand("styleWithCSS", false, true);
                    r = this.document.queryCommandValue(command);
                    this.document.execCommand("styleWithCSS", false, oldValue);
                } else {
                    r = this.document.queryCommandValue(command);
                }
            }
            return r;
        }, _sCall:function (name, args) {
            return this.selection[name].apply(this.selection, args);
        }, placeCursorAtStart:function () {
            this.focus();
            var isvalid = false;
            if (has("mozilla")) {
                var first = this.editNode.firstChild;
                while (first) {
                    if (first.nodeType === 3) {
                        if (first.nodeValue.replace(/^\s+|\s+$/g, "").length > 0) {
                            isvalid = true;
                            this.selection.selectElement(first);
                            break;
                        }
                    } else {
                        if (first.nodeType === 1) {
                            isvalid = true;
                            var tg = first.tagName ? first.tagName.toLowerCase() : "";
                            if (/br|input|img|base|meta|area|basefont|hr|link/.test(tg)) {
                                this.selection.selectElement(first);
                            } else {
                                this.selection.selectElementChildren(first);
                            }
                            break;
                        }
                    }
                    first = first.nextSibling;
                }
            } else {
                isvalid = true;
                this.selection.selectElementChildren(this.editNode);
            }
            if (isvalid) {
                this.selection.collapse(true);
            }
        }, placeCursorAtEnd:function () {
            this.focus();
            var isvalid = false;
            if (has("mozilla")) {
                var last = this.editNode.lastChild;
                while (last) {
                    if (last.nodeType === 3) {
                        if (last.nodeValue.replace(/^\s+|\s+$/g, "").length > 0) {
                            isvalid = true;
                            this.selection.selectElement(last);
                            break;
                        }
                    } else {
                        if (last.nodeType === 1) {
                            isvalid = true;
                            this.selection.selectElement(last.lastChild || last);
                            break;
                        }
                    }
                    last = last.previousSibling;
                }
            } else {
                isvalid = true;
                this.selection.selectElementChildren(this.editNode);
            }
            if (isvalid) {
                this.selection.collapse(false);
            }
        }, getValue:function (nonDestructive) {
            if (this.textarea) {
                if (this.isClosed || !this.isLoaded) {
                    return this.textarea.value;
                }
            }
            return this.isLoaded ? this._postFilterContent(null, nonDestructive) : this.value;
        }, _getValueAttr:function () {
            return this.getValue(true);
        }, setValue:function (html) {
            if (!this.isLoaded) {
                this.onLoadDeferred.then(lang.hitch(this, function () {
                    this.setValue(html);
                }));
                return;
            }
            this._cursorToStart = true;
            if (this.textarea && (this.isClosed || !this.isLoaded)) {
                this.textarea.value = html;
            } else {
                html = this._preFilterContent(html);
                var node = this.isClosed ? this.domNode : this.editNode;
                node.innerHTML = html;
                this._preDomFilterContent(node);
            }
            this.onDisplayChanged();
            this._set("value", this.getValue(true));
        }, replaceValue:function (html) {
            if (this.isClosed) {
                this.setValue(html);
            } else {
                if (this.window && this.window.getSelection && !has("mozilla")) {
                    this.setValue(html);
                } else {
                    if (this.window && this.window.getSelection) {
                        html = this._preFilterContent(html);
                        this.execCommand("selectall");
                        this.execCommand("inserthtml", html);
                        this._preDomFilterContent(this.editNode);
                    } else {
                        if (this.document && this.document.selection) {
                            this.setValue(html);
                        }
                    }
                }
            }
            this._set("value", this.getValue(true));
        }, _preFilterContent:function (html) {
            var ec = html;
            array.forEach(this.contentPreFilters, function (ef) {
                if (ef) {
                    ec = ef(ec);
                }
            });
            return ec;
        }, _preDomFilterContent:function (dom) {
            dom = dom || this.editNode;
            array.forEach(this.contentDomPreFilters, function (ef) {
                if (ef && lang.isFunction(ef)) {
                    ef(dom);
                }
            }, this);
        }, _postFilterContent:function (dom, nonDestructive) {
            var ec;
            if (!lang.isString(dom)) {
                dom = dom || this.editNode;
                if (this.contentDomPostFilters.length) {
                    if (nonDestructive) {
                        dom = lang.clone(dom);
                    }
                    array.forEach(this.contentDomPostFilters, function (ef) {
                        dom = ef(dom);
                    });
                }
                ec = htmlapi.getChildrenHtml(dom);
            } else {
                ec = dom;
            }
            if (!lang.trim(ec.replace(/^\xA0\xA0*/, "").replace(/\xA0\xA0*$/, "")).length) {
                ec = "";
            }
            array.forEach(this.contentPostFilters, function (ef) {
                ec = ef(ec);
            });
            return ec;
        }, _saveContent:function () {
            var saveTextarea = dom.byId(dijit._scopeName + "._editor.RichText.value");
            if (saveTextarea) {
                if (saveTextarea.value) {
                    saveTextarea.value += this._SEPARATOR;
                }
                saveTextarea.value += this.name + this._NAME_CONTENT_SEP + this.getValue(true);
            }
        }, escapeXml:function (str, noSingleQuotes) {
            str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
            if (!noSingleQuotes) {
                str = str.replace(/'/gm, "&#39;");
            }
            return str;
        }, getNodeHtml:function (node) {
            kernel.deprecated("dijit.Editor::getNodeHtml is deprecated", "use dijit/_editor/html::getNodeHtml instead", 2);
            return htmlapi.getNodeHtml(node);
        }, getNodeChildrenHtml:function (dom) {
            kernel.deprecated("dijit.Editor::getNodeChildrenHtml is deprecated", "use dijit/_editor/html::getChildrenHtml instead", 2);
            return htmlapi.getChildrenHtml(dom);
        }, close:function (save) {
            if (this.isClosed) {
                return;
            }
            if (!arguments.length) {
                save = true;
            }
            if (save) {
                this._set("value", this.getValue(true));
            }
            if (this.interval) {
                clearInterval(this.interval);
            }
            if (this._webkitListener) {
                this._webkitListener.remove();
                delete this._webkitListener;
            }
            if (has("ie")) {
                this.iframe.onfocus = null;
            }
            this.iframe._loadFunc = null;
            if (this._iframeRegHandle) {
                this._iframeRegHandle.remove();
                delete this._iframeRegHandle;
            }
            if (this.textarea) {
                var s = this.textarea.style;
                s.position = "";
                s.left = s.top = "";
                if (has("ie")) {
                    s.overflow = this.__overflow;
                    this.__overflow = null;
                }
                this.textarea.value = this.value;
                domConstruct.destroy(this.domNode);
                this.domNode = this.textarea;
            } else {
                this.domNode.innerHTML = this.value;
            }
            delete this.iframe;
            domClass.remove(this.domNode, this.baseClass);
            this.isClosed = true;
            this.isLoaded = false;
            delete this.editNode;
            delete this.focusNode;
            if (this.window && this.window._frameElement) {
                this.window._frameElement = null;
            }
            this.window = null;
            this.document = null;
            this.editingArea = null;
            this.editorObject = null;
        }, destroy:function () {
            if (!this.isClosed) {
                this.close(false);
            }
            if (this._updateTimer) {
                this._updateTimer.remove();
            }
            this.inherited(arguments);
            if (RichText._globalSaveHandler) {
                delete RichText._globalSaveHandler[this.id];
            }
        }, _removeMozBogus:function (html) {
            return html.replace(/\stype="_moz"/gi, "").replace(/\s_moz_dirty=""/gi, "").replace(/_moz_resizing="(true|false)"/gi, "");
        }, _removeWebkitBogus:function (html) {
            html = html.replace(/\sclass="webkit-block-placeholder"/gi, "");
            html = html.replace(/\sclass="apple-style-span"/gi, "");
            html = html.replace(/<meta charset=\"utf-8\" \/>/gi, "");
            return html;
        }, _normalizeFontStyle:function (html) {
            return html.replace(/<(\/)?strong([ \>])/gi, "<$1b$2").replace(/<(\/)?em([ \>])/gi, "<$1i$2");
        }, _preFixUrlAttributes:function (html) {
            return html.replace(/(?:(<a(?=\s).*?\shref=)("|')(.*?)\2)|(?:(<a\s.*?href=)([^"'][^ >]+))/gi, "$1$4$2$3$5$2 _djrealurl=$2$3$5$2").replace(/(?:(<img(?=\s).*?\ssrc=)("|')(.*?)\2)|(?:(<img\s.*?src=)([^"'][^ >]+))/gi, "$1$4$2$3$5$2 _djrealurl=$2$3$5$2");
        }, _browserQueryCommandEnabled:function (command) {
            if (!command) {
                return false;
            }
            var elem = has("ie") < 9 ? this.document.selection.createRange() : this.document;
            try {
                return elem.queryCommandEnabled(command);
            }
            catch (e) {
                return false;
            }
        }, _createlinkEnabledImpl:function () {
            var enabled = true;
            if (has("opera")) {
                var sel = this.window.getSelection();
                if (sel.isCollapsed) {
                    enabled = true;
                } else {
                    enabled = this.document.queryCommandEnabled("createlink");
                }
            } else {
                enabled = this._browserQueryCommandEnabled("createlink");
            }
            return enabled;
        }, _unlinkEnabledImpl:function () {
            var enabled = true;
            if (has("mozilla") || has("webkit")) {
                enabled = this.selection.hasAncestorElement("a");
            } else {
                enabled = this._browserQueryCommandEnabled("unlink");
            }
            return enabled;
        }, _inserttableEnabledImpl:function () {
            var enabled = true;
            if (has("mozilla") || has("webkit")) {
                enabled = true;
            } else {
                enabled = this._browserQueryCommandEnabled("inserttable");
            }
            return enabled;
        }, _cutEnabledImpl:function () {
            var enabled = true;
            if (has("webkit")) {
                var sel = this.window.getSelection();
                if (sel) {
                    sel = sel.toString();
                }
                enabled = !!sel;
            } else {
                enabled = this._browserQueryCommandEnabled("cut");
            }
            return enabled;
        }, _copyEnabledImpl:function () {
            var enabled = true;
            if (has("webkit")) {
                var sel = this.window.getSelection();
                if (sel) {
                    sel = sel.toString();
                }
                enabled = !!sel;
            } else {
                enabled = this._browserQueryCommandEnabled("copy");
            }
            return enabled;
        }, _pasteEnabledImpl:function () {
            var enabled = true;
            if (has("webkit")) {
                return true;
            } else {
                enabled = this._browserQueryCommandEnabled("paste");
            }
            return enabled;
        }, _inserthorizontalruleImpl:function (argument) {
            if (has("ie")) {
                return this._inserthtmlImpl("<hr>");
            }
            return this.document.execCommand("inserthorizontalrule", false, argument);
        }, _unlinkImpl:function (argument) {
            if ((this.queryCommandEnabled("unlink")) && (has("mozilla") || has("webkit"))) {
                var a = this.selection.getAncestorElement("a");
                this.selection.selectElement(a);
                return this.document.execCommand("unlink", false, null);
            }
            return this.document.execCommand("unlink", false, argument);
        }, _hilitecolorImpl:function (argument) {
            var returnValue;
            var isApplied = this._handleTextColorOrProperties("hilitecolor", argument);
            if (!isApplied) {
                if (has("mozilla")) {
                    this.document.execCommand("styleWithCSS", false, true);
                    console.log("Executing color command.");
                    returnValue = this.document.execCommand("hilitecolor", false, argument);
                    this.document.execCommand("styleWithCSS", false, false);
                } else {
                    returnValue = this.document.execCommand("hilitecolor", false, argument);
                }
            }
            return returnValue;
        }, _backcolorImpl:function (argument) {
            if (has("ie")) {
                argument = argument ? argument : null;
            }
            var isApplied = this._handleTextColorOrProperties("backcolor", argument);
            if (!isApplied) {
                isApplied = this.document.execCommand("backcolor", false, argument);
            }
            return isApplied;
        }, _forecolorImpl:function (argument) {
            if (has("ie")) {
                argument = argument ? argument : null;
            }
            var isApplied = false;
            isApplied = this._handleTextColorOrProperties("forecolor", argument);
            if (!isApplied) {
                isApplied = this.document.execCommand("forecolor", false, argument);
            }
            return isApplied;
        }, _inserthtmlImpl:function (argument) {
            argument = this._preFilterContent(argument);
            var rv = true;
            if (has("ie") < 9) {
                var insertRange = this.document.selection.createRange();
                if (this.document.selection.type.toUpperCase() === "CONTROL") {
                    var n = insertRange.item(0);
                    while (insertRange.length) {
                        insertRange.remove(insertRange.item(0));
                    }
                    n.outerHTML = argument;
                } else {
                    insertRange.pasteHTML(argument);
                }
                insertRange.select();
            } else {
                if (has("trident") < 8) {
                    var insertRange;
                    var selection = rangeapi.getSelection(this.window);
                    if (selection && selection.rangeCount && selection.getRangeAt) {
                        insertRange = selection.getRangeAt(0);
                        insertRange.deleteContents();
                        var div = domConstruct.create("div");
                        div.innerHTML = argument;
                        var node, lastNode;
                        var n = this.document.createDocumentFragment();
                        while ((node = div.firstChild)) {
                            lastNode = n.appendChild(node);
                        }
                        insertRange.insertNode(n);
                        if (lastNode) {
                            insertRange = insertRange.cloneRange();
                            insertRange.setStartAfter(lastNode);
                            insertRange.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(insertRange);
                        }
                    }
                } else {
                    if (has("mozilla") && !argument.length) {
                        this.selection.remove();
                    } else {
                        rv = this.document.execCommand("inserthtml", false, argument);
                    }
                }
            }
            return rv;
        }, _boldImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                this._adaptIESelection();
                applied = this._adaptIEFormatAreaAndExec("bold");
            }
            if (!applied) {
                applied = this.document.execCommand("bold", false, argument);
            }
            return applied;
        }, _italicImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                this._adaptIESelection();
                applied = this._adaptIEFormatAreaAndExec("italic");
            }
            if (!applied) {
                applied = this.document.execCommand("italic", false, argument);
            }
            return applied;
        }, _underlineImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                this._adaptIESelection();
                applied = this._adaptIEFormatAreaAndExec("underline");
            }
            if (!applied) {
                applied = this.document.execCommand("underline", false, argument);
            }
            return applied;
        }, _strikethroughImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                this._adaptIESelection();
                applied = this._adaptIEFormatAreaAndExec("strikethrough");
            }
            if (!applied) {
                applied = this.document.execCommand("strikethrough", false, argument);
            }
            return applied;
        }, _superscriptImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                this._adaptIESelection();
                applied = this._adaptIEFormatAreaAndExec("superscript");
            }
            if (!applied) {
                applied = this.document.execCommand("superscript", false, argument);
            }
            return applied;
        }, _subscriptImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                this._adaptIESelection();
                applied = this._adaptIEFormatAreaAndExec("subscript");
            }
            if (!applied) {
                applied = this.document.execCommand("subscript", false, argument);
            }
            return applied;
        }, _fontnameImpl:function (argument) {
            var isApplied;
            if (has("ie")) {
                isApplied = this._handleTextColorOrProperties("fontname", argument);
            }
            if (!isApplied) {
                isApplied = this.document.execCommand("fontname", false, argument);
            }
            return isApplied;
        }, _fontsizeImpl:function (argument) {
            var isApplied;
            if (has("ie")) {
                isApplied = this._handleTextColorOrProperties("fontsize", argument);
            }
            if (!isApplied) {
                isApplied = this.document.execCommand("fontsize", false, argument);
            }
            return isApplied;
        }, _insertorderedlistImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                applied = this._adaptIEList("insertorderedlist", argument);
            }
            if (!applied) {
                applied = this.document.execCommand("insertorderedlist", false, argument);
            }
            return applied;
        }, _insertunorderedlistImpl:function (argument) {
            var applied = false;
            if (has("ie")) {
                applied = this._adaptIEList("insertunorderedlist", argument);
            }
            if (!applied) {
                applied = this.document.execCommand("insertunorderedlist", false, argument);
            }
            return applied;
        }, getHeaderHeight:function () {
            return this._getNodeChildrenHeight(this.header);
        }, getFooterHeight:function () {
            return this._getNodeChildrenHeight(this.footer);
        }, _getNodeChildrenHeight:function (node) {
            var h = 0;
            if (node && node.childNodes) {
                var i;
                for (i = 0; i < node.childNodes.length; i++) {
                    var size = domGeometry.position(node.childNodes[i]);
                    h += size.h;
                }
            }
            return h;
        }, _isNodeEmpty:function (node, startOffset) {
            if (node.nodeType === 1) {
                if (node.childNodes.length > 0) {
                    return this._isNodeEmpty(node.childNodes[0], startOffset);
                }
                return true;
            } else {
                if (node.nodeType === 3) {
                    return (node.nodeValue.substring(startOffset) === "");
                }
            }
            return false;
        }, _removeStartingRangeFromRange:function (node, range) {
            if (node.nextSibling) {
                range.setStart(node.nextSibling, 0);
            } else {
                var parent = node.parentNode;
                while (parent && parent.nextSibling == null) {
                    parent = parent.parentNode;
                }
                if (parent) {
                    range.setStart(parent.nextSibling, 0);
                }
            }
            return range;
        }, _adaptIESelection:function () {
            var selection = rangeapi.getSelection(this.window);
            if (selection && selection.rangeCount && !selection.isCollapsed) {
                var range = selection.getRangeAt(0);
                var firstNode = range.startContainer;
                var startOffset = range.startOffset;
                while (firstNode.nodeType === 3 && startOffset >= firstNode.length && firstNode.nextSibling) {
                    startOffset = startOffset - firstNode.length;
                    firstNode = firstNode.nextSibling;
                }
                var lastNode = null;
                while (this._isNodeEmpty(firstNode, startOffset) && firstNode !== lastNode) {
                    lastNode = firstNode;
                    range = this._removeStartingRangeFromRange(firstNode, range);
                    firstNode = range.startContainer;
                    startOffset = 0;
                }
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }, _adaptIEFormatAreaAndExec:function (command) {
            var selection = rangeapi.getSelection(this.window);
            var doc = this.document;
            var rs, ret, range, txt, startNode, endNode, breaker, sNode;
            if (command && selection && selection.isCollapsed) {
                var isApplied = this.queryCommandValue(command);
                if (isApplied) {
                    var nNames = this._tagNamesForCommand(command);
                    range = selection.getRangeAt(0);
                    var fs = range.startContainer;
                    if (fs.nodeType === 3) {
                        var offset = range.endOffset;
                        if (fs.length < offset) {
                            ret = this._adjustNodeAndOffset(rs, offset);
                            fs = ret.node;
                            offset = ret.offset;
                        }
                    }
                    var topNode;
                    while (fs && fs !== this.editNode) {
                        var tName = fs.tagName ? fs.tagName.toLowerCase() : "";
                        if (array.indexOf(nNames, tName) > -1) {
                            topNode = fs;
                            break;
                        }
                        fs = fs.parentNode;
                    }
                    if (topNode) {
                        rs = range.startContainer;
                        var newblock = doc.createElement(topNode.tagName);
                        domConstruct.place(newblock, topNode, "after");
                        if (rs && rs.nodeType === 3) {
                            var nodeToMove, tNode;
                            var endOffset = range.endOffset;
                            if (rs.length < endOffset) {
                                ret = this._adjustNodeAndOffset(rs, endOffset);
                                rs = ret.node;
                                endOffset = ret.offset;
                            }
                            txt = rs.nodeValue;
                            startNode = doc.createTextNode(txt.substring(0, endOffset));
                            var endText = txt.substring(endOffset, txt.length);
                            if (endText) {
                                endNode = doc.createTextNode(endText);
                            }
                            domConstruct.place(startNode, rs, "before");
                            if (endNode) {
                                breaker = doc.createElement("span");
                                breaker.className = "ieFormatBreakerSpan";
                                domConstruct.place(breaker, rs, "after");
                                domConstruct.place(endNode, breaker, "after");
                                endNode = breaker;
                            }
                            domConstruct.destroy(rs);
                            var parentC = startNode.parentNode;
                            var tagList = [];
                            var tagData;
                            while (parentC !== topNode) {
                                var tg = parentC.tagName;
                                tagData = {tagName:tg};
                                tagList.push(tagData);
                                var newTg = doc.createElement(tg);
                                if (parentC.style) {
                                    if (newTg.style) {
                                        if (parentC.style.cssText) {
                                            newTg.style.cssText = parentC.style.cssText;
                                            tagData.cssText = parentC.style.cssText;
                                        }
                                    }
                                }
                                if (parentC.tagName === "FONT") {
                                    if (parentC.color) {
                                        newTg.color = parentC.color;
                                        tagData.color = parentC.color;
                                    }
                                    if (parentC.face) {
                                        newTg.face = parentC.face;
                                        tagData.face = parentC.face;
                                    }
                                    if (parentC.size) {
                                        newTg.size = parentC.size;
                                        tagData.size = parentC.size;
                                    }
                                }
                                if (parentC.className) {
                                    newTg.className = parentC.className;
                                    tagData.className = parentC.className;
                                }
                                if (endNode) {
                                    nodeToMove = endNode;
                                    while (nodeToMove) {
                                        tNode = nodeToMove.nextSibling;
                                        newTg.appendChild(nodeToMove);
                                        nodeToMove = tNode;
                                    }
                                }
                                if (newTg.tagName == parentC.tagName) {
                                    breaker = doc.createElement("span");
                                    breaker.className = "ieFormatBreakerSpan";
                                    domConstruct.place(breaker, parentC, "after");
                                    domConstruct.place(newTg, breaker, "after");
                                } else {
                                    domConstruct.place(newTg, parentC, "after");
                                }
                                startNode = parentC;
                                endNode = newTg;
                                parentC = parentC.parentNode;
                            }
                            if (endNode) {
                                nodeToMove = endNode;
                                if (nodeToMove.nodeType === 1 || (nodeToMove.nodeType === 3 && nodeToMove.nodeValue)) {
                                    newblock.innerHTML = "";
                                }
                                while (nodeToMove) {
                                    tNode = nodeToMove.nextSibling;
                                    newblock.appendChild(nodeToMove);
                                    nodeToMove = tNode;
                                }
                            }
                            var newrange;
                            if (tagList.length) {
                                tagData = tagList.pop();
                                var newContTag = doc.createElement(tagData.tagName);
                                if (tagData.cssText && newContTag.style) {
                                    newContTag.style.cssText = tagData.cssText;
                                }
                                if (tagData.className) {
                                    newContTag.className = tagData.className;
                                }
                                if (tagData.tagName === "FONT") {
                                    if (tagData.color) {
                                        newContTag.color = tagData.color;
                                    }
                                    if (tagData.face) {
                                        newContTag.face = tagData.face;
                                    }
                                    if (tagData.size) {
                                        newContTag.size = tagData.size;
                                    }
                                }
                                domConstruct.place(newContTag, newblock, "before");
                                while (tagList.length) {
                                    tagData = tagList.pop();
                                    var newTgNode = doc.createElement(tagData.tagName);
                                    if (tagData.cssText && newTgNode.style) {
                                        newTgNode.style.cssText = tagData.cssText;
                                    }
                                    if (tagData.className) {
                                        newTgNode.className = tagData.className;
                                    }
                                    if (tagData.tagName === "FONT") {
                                        if (tagData.color) {
                                            newTgNode.color = tagData.color;
                                        }
                                        if (tagData.face) {
                                            newTgNode.face = tagData.face;
                                        }
                                        if (tagData.size) {
                                            newTgNode.size = tagData.size;
                                        }
                                    }
                                    newContTag.appendChild(newTgNode);
                                    newContTag = newTgNode;
                                }
                                sNode = doc.createTextNode(".");
                                breaker.appendChild(sNode);
                                newContTag.appendChild(sNode);
                                newrange = rangeapi.create(this.window);
                                newrange.setStart(sNode, 0);
                                newrange.setEnd(sNode, sNode.length);
                                selection.removeAllRanges();
                                selection.addRange(newrange);
                                this.selection.collapse(false);
                                sNode.parentNode.innerHTML = "";
                            } else {
                                breaker = doc.createElement("span");
                                breaker.className = "ieFormatBreakerSpan";
                                sNode = doc.createTextNode(".");
                                breaker.appendChild(sNode);
                                domConstruct.place(breaker, newblock, "before");
                                newrange = rangeapi.create(this.window);
                                newrange.setStart(sNode, 0);
                                newrange.setEnd(sNode, sNode.length);
                                selection.removeAllRanges();
                                selection.addRange(newrange);
                                this.selection.collapse(false);
                                sNode.parentNode.innerHTML = "";
                            }
                            if (!newblock.firstChild) {
                                domConstruct.destroy(newblock);
                            }
                            return true;
                        }
                    }
                    return false;
                } else {
                    range = selection.getRangeAt(0);
                    rs = range.startContainer;
                    if (rs && rs.nodeType === 3) {
                        var offset = range.startOffset;
                        if (rs.length < offset) {
                            ret = this._adjustNodeAndOffset(rs, offset);
                            rs = ret.node;
                            offset = ret.offset;
                        }
                        txt = rs.nodeValue;
                        startNode = doc.createTextNode(txt.substring(0, offset));
                        var endText = txt.substring(offset);
                        if (endText !== "") {
                            endNode = doc.createTextNode(txt.substring(offset));
                        }
                        breaker = doc.createElement("span");
                        sNode = doc.createTextNode(".");
                        breaker.appendChild(sNode);
                        if (startNode.length) {
                            domConstruct.place(startNode, rs, "after");
                        } else {
                            startNode = rs;
                        }
                        domConstruct.place(breaker, startNode, "after");
                        if (endNode) {
                            domConstruct.place(endNode, breaker, "after");
                        }
                        domConstruct.destroy(rs);
                        var newrange = rangeapi.create(this.window);
                        newrange.setStart(sNode, 0);
                        newrange.setEnd(sNode, sNode.length);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                        doc.execCommand(command);
                        domConstruct.place(breaker.firstChild, breaker, "before");
                        domConstruct.destroy(breaker);
                        newrange.setStart(sNode, 0);
                        newrange.setEnd(sNode, sNode.length);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                        this.selection.collapse(false);
                        sNode.parentNode.innerHTML = "";
                        return true;
                    }
                }
            } else {
                return false;
            }
        }, _adaptIEList:function (command) {
            var selection = rangeapi.getSelection(this.window);
            if (selection.isCollapsed) {
                if (selection.rangeCount && !this.queryCommandValue(command)) {
                    var range = selection.getRangeAt(0);
                    var sc = range.startContainer;
                    if (sc && sc.nodeType == 3) {
                        if (!range.startOffset) {
                            var lType = "ul";
                            if (command === "insertorderedlist") {
                                lType = "ol";
                            }
                            var list = this.document.createElement(lType);
                            var li = domConstruct.create("li", null, list);
                            domConstruct.place(list, sc, "before");
                            li.appendChild(sc);
                            domConstruct.create("br", null, list, "after");
                            var newrange = rangeapi.create(this.window);
                            newrange.setStart(sc, 0);
                            newrange.setEnd(sc, sc.length);
                            selection.removeAllRanges();
                            selection.addRange(newrange);
                            this.selection.collapse(true);
                            return true;
                        }
                    }
                }
            }
            return false;
        }, _handleTextColorOrProperties:function (command, argument) {
            var selection = rangeapi.getSelection(this.window);
            var doc = this.document;
            var rs, ret, range, txt, startNode, endNode, breaker, sNode;
            argument = argument || null;
            if (command && selection && selection.isCollapsed) {
                if (selection.rangeCount) {
                    range = selection.getRangeAt(0);
                    rs = range.startContainer;
                    if (rs && rs.nodeType === 3) {
                        var offset = range.startOffset;
                        if (rs.length < offset) {
                            ret = this._adjustNodeAndOffset(rs, offset);
                            rs = ret.node;
                            offset = ret.offset;
                        }
                        txt = rs.nodeValue;
                        startNode = doc.createTextNode(txt.substring(0, offset));
                        var endText = txt.substring(offset);
                        if (endText !== "") {
                            endNode = doc.createTextNode(txt.substring(offset));
                        }
                        breaker = doc.createElement("span");
                        sNode = doc.createTextNode(".");
                        breaker.appendChild(sNode);
                        var extraSpan = doc.createElement("span");
                        breaker.appendChild(extraSpan);
                        if (startNode.length) {
                            domConstruct.place(startNode, rs, "after");
                        } else {
                            startNode = rs;
                        }
                        domConstruct.place(breaker, startNode, "after");
                        if (endNode) {
                            domConstruct.place(endNode, breaker, "after");
                        }
                        domConstruct.destroy(rs);
                        var newrange = rangeapi.create(this.window);
                        newrange.setStart(sNode, 0);
                        newrange.setEnd(sNode, sNode.length);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                        if (has("webkit")) {
                            var style = "color";
                            if (command === "hilitecolor" || command === "backcolor") {
                                style = "backgroundColor";
                            }
                            domStyle.set(breaker, style, argument);
                            this.selection.remove();
                            domConstruct.destroy(extraSpan);
                            breaker.innerHTML = "&#160;";
                            this.selection.selectElement(breaker);
                            this.focus();
                        } else {
                            this.execCommand(command, argument);
                            domConstruct.place(breaker.firstChild, breaker, "before");
                            domConstruct.destroy(breaker);
                            newrange.setStart(sNode, 0);
                            newrange.setEnd(sNode, sNode.length);
                            selection.removeAllRanges();
                            selection.addRange(newrange);
                            this.selection.collapse(false);
                            sNode.parentNode.removeChild(sNode);
                        }
                        return true;
                    }
                }
            }
            return false;
        }, _adjustNodeAndOffset:function (node, offset) {
            while (node.length < offset && node.nextSibling && node.nextSibling.nodeType === 3) {
                offset = offset - node.length;
                node = node.nextSibling;
            }
            return {"node":node, "offset":offset};
        }, _tagNamesForCommand:function (command) {
            if (command === "bold") {
                return ["b", "strong"];
            } else {
                if (command === "italic") {
                    return ["i", "em"];
                } else {
                    if (command === "strikethrough") {
                        return ["s", "strike"];
                    } else {
                        if (command === "superscript") {
                            return ["sup"];
                        } else {
                            if (command === "subscript") {
                                return ["sub"];
                            } else {
                                if (command === "underline") {
                                    return ["u"];
                                }
                            }
                        }
                    }
                }
            }
            return [];
        }, _stripBreakerNodes:function (node) {
            if (!this.isLoaded) {
                return;
            }
            query(".ieFormatBreakerSpan", node).forEach(function (b) {
                while (b.firstChild) {
                    domConstruct.place(b.firstChild, b, "before");
                }
                domConstruct.destroy(b);
            });
            return node;
        }, _stripTrailingEmptyNodes:function (node) {
            function isEmpty(node) {
                return (/^(p|div|br)$/i.test(node.nodeName) && node.children.length == 0 && /^[\s\xA0]*$/.test(node.textContent || node.innerText || "")) || (node.nodeType === 3 && /^[\s\xA0]*$/.test(node.nodeValue));
            }
            while (node.lastChild && isEmpty(node.lastChild)) {
                domConstruct.destroy(node.lastChild);
            }
            return node;
        }});
        return RichText;
    });
}, "dijit/ToolbarSeparator":function () {
    define(["dojo/_base/declare", "dojo/dom", "./_Widget", "./_TemplatedMixin"], function (declare, dom, _Widget, _TemplatedMixin) {
        return declare("dijit.ToolbarSeparator", [_Widget, _TemplatedMixin], {templateString:"<div class=\"dijitToolbarSeparator dijitInline\" role=\"presentation\"></div>", buildRendering:function () {
            this.inherited(arguments);
            dom.setSelectable(this.domNode, false);
        }, isFocusable:function () {
            return false;
        }});
    });
}, "dijit/form/RadioButton":function () {
    define(["dojo/_base/declare", "./CheckBox", "./_RadioButtonMixin"], function (declare, CheckBox, _RadioButtonMixin) {
        return declare("dijit.form.RadioButton", [CheckBox, _RadioButtonMixin], {baseClass:"dijitRadio"});
    });
}, "dijit/MenuSeparator":function () {
    define(["dojo/_base/declare", "dojo/dom", "./_WidgetBase", "./_TemplatedMixin", "./_Contained", "dojo/text!./templates/MenuSeparator.html"], function (declare, dom, _WidgetBase, _TemplatedMixin, _Contained, template) {
        return declare("dijit.MenuSeparator", [_WidgetBase, _TemplatedMixin, _Contained], {templateString:template, buildRendering:function () {
            this.inherited(arguments);
            dom.setSelectable(this.domNode, false);
        }, isFocusable:function () {
            return false;
        }});
    });
}, "dijit/form/ToggleButton":function () {
    define(["dojo/_base/declare", "dojo/_base/kernel", "./Button", "./_ToggleButtonMixin"], function (declare, kernel, Button, _ToggleButtonMixin) {
        return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {baseClass:"dijitToggleButton", setChecked:function (checked) {
            kernel.deprecated("setChecked(" + checked + ") is deprecated. Use set('checked'," + checked + ") instead.", "", "2.0");
            this.set("checked", checked);
        }});
    });
}, "dojo/dom-prop":function () {
    define(["exports", "./_base/kernel", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-construct", "./_base/connect"], function (exports, dojo, has, lang, dom, style, ctr, conn) {
        var _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + "attrid";
        exports.names = {"class":"className", "for":"htmlFor", tabindex:"tabIndex", readonly:"readOnly", colspan:"colSpan", frameborder:"frameBorder", rowspan:"rowSpan", valuetype:"valueType"};
        exports.get = function getProp(node, name) {
            node = dom.byId(node);
            var lc = name.toLowerCase(), propName = exports.names[lc] || name;
            return node[propName];
        };
        exports.set = function setProp(node, name, value) {
            node = dom.byId(node);
            var l = arguments.length;
            if (l == 2 && typeof name != "string") {
                for (var x in name) {
                    exports.set(node, x, name[x]);
                }
                return node;
            }
            var lc = name.toLowerCase(), propName = exports.names[lc] || name;
            if (propName == "style" && typeof value != "string") {
                style.set(node, value);
                return node;
            }
            if (propName == "innerHTML") {
                if (has("ie") && node.tagName.toLowerCase() in {col:1, colgroup:1, table:1, tbody:1, tfoot:1, thead:1, tr:1, title:1}) {
                    ctr.empty(node);
                    node.appendChild(ctr.toDom(value, node.ownerDocument));
                } else {
                    node[propName] = value;
                }
                return node;
            }
            if (lang.isFunction(value)) {
                var attrId = node[_attrId];
                if (!attrId) {
                    attrId = _ctr++;
                    node[_attrId] = attrId;
                }
                if (!_evtHdlrMap[attrId]) {
                    _evtHdlrMap[attrId] = {};
                }
                var h = _evtHdlrMap[attrId][propName];
                if (h) {
                    conn.disconnect(h);
                } else {
                    try {
                        delete node[propName];
                    }
                    catch (e) {
                    }
                }
                if (value) {
                    _evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
                } else {
                    node[propName] = null;
                }
                return node;
            }
            node[propName] = value;
            return node;
        };
    });
}, "dijit/CheckedMenuItem":function () {
    define(["dojo/_base/declare", "dojo/dom-class", "./MenuItem", "dojo/text!./templates/CheckedMenuItem.html", "./hccss"], function (declare, domClass, MenuItem, template) {
        return declare("dijit.CheckedMenuItem", MenuItem, {baseClass:"dijitMenuItem dijitCheckedMenuItem", templateString:template, checked:false, _setCheckedAttr:function (checked) {
            this.domNode.setAttribute("aria-checked", checked ? "true" : "false");
            this._set("checked", checked);
        }, iconClass:"", role:"menuitemcheckbox", checkedChar:"&#10003;", onChange:function () {
        }, _onClick:function (evt) {
            if (!this.disabled) {
                this.set("checked", !this.checked);
                this.onChange(this.checked);
            }
            this.onClick(evt);
        }});
    });
}, "dojox/grid/enhanced/plugins/Rearrange":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/connect", "../../EnhancedGrid", "../_Plugin", "./_RowMapLayer"], function (dojo, lang, declare, array, connect, EnhancedGrid, _Plugin, _RowMapLayer) {
        var Rearrange = declare("dojox.grid.enhanced.plugins.Rearrange", _Plugin, {name:"rearrange", constructor:function (grid, args) {
            this.grid = grid;
            this.setArgs(args);
            var rowMapLayer = new _RowMapLayer(grid);
            dojox.grid.enhanced.plugins.wrap(grid, "_storeLayerFetch", rowMapLayer);
        }, setArgs:function (args) {
            this.args = lang.mixin(this.args || {}, args || {});
            this.args.setIdentifierForNewItem = this.args.setIdentifierForNewItem || function (v) {
                return v;
            };
        }, destroy:function () {
            this.inherited(arguments);
            this.grid.unwrap("rowmap");
        }, onSetStore:function (store) {
            this.grid.layer("rowmap").clearMapping();
        }, _hasIdentity:function (points) {
            var g = this.grid, s = g.store, cells = g.layout.cells;
            if (s.getFeatures()["dojo.data.api.Identity"]) {
                if (array.some(points, function (point) {
                    return s.getIdentityAttributes(g._by_idx[point.r].item) == cells[point.c].field;
                })) {
                    return true;
                }
            }
            return false;
        }, moveColumns:function (colsToMove, targetPos) {
            var g = this.grid, layout = g.layout, cells = layout.cells, colIndex, i, delta = 0, before = true, tmp = {}, mapping = {};
            colsToMove.sort(function (a, b) {
                return a - b;
            });
            for (i = 0; i < colsToMove.length; ++i) {
                tmp[colsToMove[i]] = i;
                if (colsToMove[i] < targetPos) {
                    ++delta;
                }
            }
            var leftCount = 0, rightCount = 0;
            var maxCol = Math.max(colsToMove[colsToMove.length - 1], targetPos);
            if (maxCol == cells.length) {
                --maxCol;
            }
            var minCol = Math.min(colsToMove[0], targetPos);
            for (i = minCol; i <= maxCol; ++i) {
                var j = tmp[i];
                if (j >= 0) {
                    mapping[i] = targetPos - delta + j;
                } else {
                    if (i < targetPos) {
                        mapping[i] = minCol + leftCount;
                        ++leftCount;
                    } else {
                        if (i >= targetPos) {
                            mapping[i] = targetPos + colsToMove.length - delta + rightCount;
                            ++rightCount;
                        }
                    }
                }
            }
            delta = 0;
            if (targetPos == cells.length) {
                --targetPos;
                before = false;
            }
            g._notRefreshSelection = true;
            for (i = 0; i < colsToMove.length; ++i) {
                colIndex = colsToMove[i];
                if (colIndex < targetPos) {
                    colIndex -= delta;
                }
                ++delta;
                if (colIndex != targetPos) {
                    layout.moveColumn(cells[colIndex].view.idx, cells[targetPos].view.idx, colIndex, targetPos, before);
                    cells = layout.cells;
                }
                if (targetPos <= colIndex) {
                    ++targetPos;
                }
            }
            delete g._notRefreshSelection;
            connect.publish("dojox/grid/rearrange/move/" + g.id, ["col", mapping, colsToMove]);
        }, moveRows:function (rowsToMove, targetPos) {
            var g = this.grid, mapping = {}, preRowsToMove = [], postRowsToMove = [], len = rowsToMove.length, i, r, k, arr, rowMap, lastPos;
            for (i = 0; i < len; ++i) {
                r = rowsToMove[i];
                if (r >= targetPos) {
                    break;
                }
                preRowsToMove.push(r);
            }
            postRowsToMove = rowsToMove.slice(i);
            arr = preRowsToMove;
            len = arr.length;
            if (len) {
                rowMap = {};
                array.forEach(arr, function (r) {
                    rowMap[r] = true;
                });
                mapping[arr[0]] = targetPos - len;
                for (k = 0, i = arr[k] + 1, lastPos = i - 1; i < targetPos; ++i) {
                    if (!rowMap[i]) {
                        mapping[i] = lastPos;
                        ++lastPos;
                    } else {
                        ++k;
                        mapping[i] = targetPos - len + k;
                    }
                }
            }
            arr = postRowsToMove;
            len = arr.length;
            if (len) {
                rowMap = {};
                array.forEach(arr, function (r) {
                    rowMap[r] = true;
                });
                mapping[arr[len - 1]] = targetPos + len - 1;
                for (k = len - 1, i = arr[k] - 1, lastPos = i + 1; i >= targetPos; --i) {
                    if (!rowMap[i]) {
                        mapping[i] = lastPos;
                        --lastPos;
                    } else {
                        --k;
                        mapping[i] = targetPos + k;
                    }
                }
            }
            var tmpMapping = lang.clone(mapping);
            g.layer("rowmap").setMapping(mapping);
            g.forEachLayer(function (layer) {
                if (layer.name() != "rowmap") {
                    layer.invalidate();
                    return true;
                } else {
                    return false;
                }
            }, false);
            g.selection.selected = [];
            g._noInternalMapping = true;
            g._refresh();
            setTimeout(function () {
                connect.publish("dojox/grid/rearrange/move/" + g.id, ["row", tmpMapping, rowsToMove]);
                g._noInternalMapping = false;
            }, 0);
        }, moveCells:function (cellsToMove, target) {
            var g = this.grid, s = g.store;
            if (s.getFeatures()["dojo.data.api.Write"]) {
                if (cellsToMove.min.row == target.min.row && cellsToMove.min.col == target.min.col) {
                    return;
                }
                var cells = g.layout.cells, cnt = cellsToMove.max.row - cellsToMove.min.row + 1, r, c, tr, tc, sources = [], targets = [];
                for (r = cellsToMove.min.row, tr = target.min.row; r <= cellsToMove.max.row; ++r, ++tr) {
                    for (c = cellsToMove.min.col, tc = target.min.col; c <= cellsToMove.max.col; ++c, ++tc) {
                        while (cells[c] && cells[c].hidden) {
                            ++c;
                        }
                        while (cells[tc] && cells[tc].hidden) {
                            ++tc;
                        }
                        sources.push({"r":r, "c":c});
                        targets.push({"r":tr, "c":tc, "v":cells[c].get(r, g._by_idx[r].item)});
                    }
                }
                if (this._hasIdentity(sources.concat(targets))) {
                    console.warn("Can not write to identity!");
                    return;
                }
                array.forEach(sources, function (point) {
                    s.setValue(g._by_idx[point.r].item, cells[point.c].field, "");
                });
                array.forEach(targets, function (point) {
                    s.setValue(g._by_idx[point.r].item, cells[point.c].field, point.v);
                });
                s.save({onComplete:function () {
                    connect.publish("dojox/grid/rearrange/move/" + g.id, ["cell", {"from":cellsToMove, "to":target}]);
                }});
            }
        }, copyCells:function (cellsToMove, target) {
            var g = this.grid, s = g.store;
            if (s.getFeatures()["dojo.data.api.Write"]) {
                if (cellsToMove.min.row == target.min.row && cellsToMove.min.col == target.min.col) {
                    return;
                }
                var cells = g.layout.cells, cnt = cellsToMove.max.row - cellsToMove.min.row + 1, r, c, tr, tc, targets = [];
                for (r = cellsToMove.min.row, tr = target.min.row; r <= cellsToMove.max.row; ++r, ++tr) {
                    for (c = cellsToMove.min.col, tc = target.min.col; c <= cellsToMove.max.col; ++c, ++tc) {
                        while (cells[c] && cells[c].hidden) {
                            ++c;
                        }
                        while (cells[tc] && cells[tc].hidden) {
                            ++tc;
                        }
                        targets.push({"r":tr, "c":tc, "v":cells[c].get(r, g._by_idx[r].item)});
                    }
                }
                if (this._hasIdentity(targets)) {
                    console.warn("Can not write to identity!");
                    return;
                }
                array.forEach(targets, function (point) {
                    s.setValue(g._by_idx[point.r].item, cells[point.c].field, point.v);
                });
                s.save({onComplete:function () {
                    setTimeout(function () {
                        connect.publish("dojox/grid/rearrange/copy/" + g.id, ["cell", {"from":cellsToMove, "to":target}]);
                    }, 0);
                }});
            }
        }, changeCells:function (sourceGrid, cellsToMove, target) {
            var g = this.grid, s = g.store;
            if (s.getFeatures()["dojo.data.api.Write"]) {
                var srcg = sourceGrid, cells = g.layout.cells, srccells = srcg.layout.cells, cnt = cellsToMove.max.row - cellsToMove.min.row + 1, r, c, tr, tc, targets = [];
                for (r = cellsToMove.min.row, tr = target.min.row; r <= cellsToMove.max.row; ++r, ++tr) {
                    for (c = cellsToMove.min.col, tc = target.min.col; c <= cellsToMove.max.col; ++c, ++tc) {
                        while (srccells[c] && srccells[c].hidden) {
                            ++c;
                        }
                        while (cells[tc] && cells[tc].hidden) {
                            ++tc;
                        }
                        targets.push({"r":tr, "c":tc, "v":srccells[c].get(r, srcg._by_idx[r].item)});
                    }
                }
                if (this._hasIdentity(targets)) {
                    console.warn("Can not write to identity!");
                    return;
                }
                array.forEach(targets, function (point) {
                    s.setValue(g._by_idx[point.r].item, cells[point.c].field, point.v);
                });
                s.save({onComplete:function () {
                    connect.publish("dojox/grid/rearrange/change/" + g.id, ["cell", target]);
                }});
            }
        }, clearCells:function (cellsToClear) {
            var g = this.grid, s = g.store;
            if (s.getFeatures()["dojo.data.api.Write"]) {
                var cells = g.layout.cells, cnt = cellsToClear.max.row - cellsToClear.min.row + 1, r, c, targets = [];
                for (r = cellsToClear.min.row; r <= cellsToClear.max.row; ++r) {
                    for (c = cellsToClear.min.col; c <= cellsToClear.max.col; ++c) {
                        while (cells[c] && cells[c].hidden) {
                            ++c;
                        }
                        targets.push({"r":r, "c":c});
                    }
                }
                if (this._hasIdentity(targets)) {
                    console.warn("Can not write to identity!");
                    return;
                }
                array.forEach(targets, function (point) {
                    s.setValue(g._by_idx[point.r].item, cells[point.c].field, "");
                });
                s.save({onComplete:function () {
                    connect.publish("dojox/grid/rearrange/change/" + g.id, ["cell", cellsToClear]);
                }});
            }
        }, insertRows:function (sourceGrid, rowsToMove, targetPos) {
            try {
                var g = this.grid, s = g.store, rowCnt = g.rowCount, mapping = {}, obj = {idx:0}, newRows = [], i, emptyTarget = targetPos < 0, _this = this, len = rowsToMove.length;
                if (emptyTarget) {
                    targetPos = 0;
                } else {
                    for (i = targetPos; i < g.rowCount; ++i) {
                        mapping[i] = i + len;
                    }
                }
                if (s.getFeatures()["dojo.data.api.Write"]) {
                    if (sourceGrid) {
                        var srcg = sourceGrid, srcs = srcg.store, thisItem, attrs;
                        if (!emptyTarget) {
                            for (i = 0; !thisItem; ++i) {
                                thisItem = g._by_idx[i];
                            }
                            attrs = s.getAttributes(thisItem.item);
                        } else {
                            attrs = array.filter(array.map(g.layout.cells, function (cell) {
                                return cell.field;
                            }), function (field) {
                                return field;
                            });
                        }
                        var rowsToFetch = [];
                        array.forEach(rowsToMove, function (rowIndex, i) {
                            var item = {};
                            var srcItem = srcg._by_idx[rowIndex];
                            if (srcItem) {
                                array.forEach(attrs, function (attr) {
                                    item[attr] = srcs.getValue(srcItem.item, attr);
                                });
                                item = _this.args.setIdentifierForNewItem(item, s, rowCnt + obj.idx) || item;
                                try {
                                    s.newItem(item);
                                    newRows.push(targetPos + i);
                                    mapping[rowCnt + obj.idx] = targetPos + i;
                                    ++obj.idx;
                                }
                                catch (e) {
                                    console.log("insertRows newItem:", e, item);
                                }
                            } else {
                                rowsToFetch.push(rowIndex);
                            }
                        });
                    } else {
                        if (rowsToMove.length && lang.isObject(rowsToMove[0])) {
                            array.forEach(rowsToMove, function (rowData, i) {
                                var item = _this.args.setIdentifierForNewItem(rowData, s, rowCnt + obj.idx) || rowData;
                                try {
                                    s.newItem(item);
                                    newRows.push(targetPos + i);
                                    mapping[rowCnt + obj.idx] = targetPos + i;
                                    ++obj.idx;
                                }
                                catch (e) {
                                    console.log("insertRows newItem:", e, item);
                                }
                            });
                        } else {
                            return;
                        }
                    }
                    g.layer("rowmap").setMapping(mapping);
                    s.save({onComplete:function () {
                        g._refresh();
                        setTimeout(function () {
                            connect.publish("dojox/grid/rearrange/insert/" + g.id, ["row", newRows]);
                        }, 0);
                    }});
                }
            }
            catch (e) {
                console.log("insertRows:", e);
            }
        }, removeRows:function (rowsToRemove) {
            var g = this.grid;
            var s = g.store;
            try {
                array.forEach(array.map(rowsToRemove, function (rowIndex) {
                    return g._by_idx[rowIndex];
                }), function (row) {
                    if (row) {
                        s.deleteItem(row.item);
                    }
                });
                s.save({onComplete:function () {
                    connect.publish("dojox/grid/rearrange/remove/" + g.id, ["row", rowsToRemove]);
                }});
            }
            catch (e) {
                console.log("removeRows:", e);
            }
        }, _getPageInfo:function () {
            var scroller = this.grid.scroller, topPage = scroller.page, bottomPage = scroller.page, firstVisibleRow = scroller.firstVisibleRow, lastVisibleRow = scroller.lastVisibleRow, rowsPerPage = scroller.rowsPerPage, renderedPages = scroller.pageNodes[0], topRow, bottomRow, matched, invalidPages = [];
            array.forEach(renderedPages, function (page, pageIndex) {
                if (!page) {
                    return;
                }
                matched = false;
                topRow = pageIndex * rowsPerPage;
                bottomRow = (pageIndex + 1) * rowsPerPage - 1;
                if (firstVisibleRow >= topRow && firstVisibleRow <= bottomRow) {
                    topPage = pageIndex;
                    matched = true;
                }
                if (lastVisibleRow >= topRow && lastVisibleRow <= bottomRow) {
                    bottomPage = pageIndex;
                    matched = true;
                }
                if (!matched && (topRow > lastVisibleRow || bottomRow < firstVisibleRow)) {
                    invalidPages.push(pageIndex);
                }
            });
            return {topPage:topPage, bottomPage:bottomPage, invalidPages:invalidPages};
        }});
        EnhancedGrid.registerPlugin(Rearrange);
        return Rearrange;
    });
}, "dojox/html/_base":function () {
    define(["dojo/_base/declare", "dojo/Deferred", "dojo/dom-construct", "dojo/html", "dojo/_base/kernel", "dojo/_base/lang", "dojo/ready", "dojo/_base/sniff", "dojo/_base/url", "dojo/_base/xhr", "dojo/when", "dojo/_base/window"], function (declare, Deferred, domConstruct, htmlUtil, kernel, lang, ready, has, _Url, xhrUtil, when, windowUtil) {
        var html = kernel.getObject("dojox.html", true);
        if (has("ie")) {
            var alphaImageLoader = /(AlphaImageLoader\([^)]*?src=(['"]))(?![a-z]+:|\/)([^\r\n;}]+?)(\2[^)]*\)\s*[;}]?)/g;
        }
        var cssPaths = /(?:(?:@import\s*(['"])(?![a-z]+:|\/)([^\r\n;{]+?)\1)|url\(\s*(['"]?)(?![a-z]+:|\/)([^\r\n;]+?)\3\s*\))([a-z, \s]*[;}]?)/g;
        var adjustCssPaths = html._adjustCssPaths = function (cssUrl, cssText) {
            if (!cssText || !cssUrl) {
                return;
            }
            if (alphaImageLoader) {
                cssText = cssText.replace(alphaImageLoader, function (ignore, pre, delim, url, post) {
                    return pre + (new _Url(cssUrl, "./" + url).toString()) + post;
                });
            }
            return cssText.replace(cssPaths, function (ignore, delimStr, strUrl, delimUrl, urlUrl, media) {
                if (strUrl) {
                    return "@import \"" + (new _Url(cssUrl, "./" + strUrl).toString()) + "\"" + media;
                } else {
                    return "url(" + (new _Url(cssUrl, "./" + urlUrl).toString()) + ")" + media;
                }
            });
        };
        var htmlAttrPaths = /(<[a-z][a-z0-9]*\s[^>]*)(?:(href|src)=(['"]?)([^>]*?)\3|style=(['"]?)([^>]*?)\5)([^>]*>)/gi;
        var adjustHtmlPaths = html._adjustHtmlPaths = function (htmlUrl, cont) {
            var url = htmlUrl || "./";
            return cont.replace(htmlAttrPaths, function (tag, start, name, delim, relUrl, delim2, cssText, end) {
                return start + (name ? (name + "=" + delim + (new _Url(url, relUrl).toString()) + delim) : ("style=" + delim2 + adjustCssPaths(url, cssText) + delim2)) + end;
            });
        };
        var snarfStyles = html._snarfStyles = function (cssUrl, cont, styles) {
            styles.attributes = [];
            cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g, function (comment) {
                return comment.replace(/<(\/?)style\b/ig, "&lt;$1Style").replace(/<(\/?)link\b/ig, "&lt;$1Link").replace(/@import "/ig, "@ import \"");
            });
            return cont.replace(/(?:<style([^>]*)>([\s\S]*?)<\/style>|<link\s+(?=[^>]*rel=['"]?stylesheet)([^>]*?href=(['"])([^>]*?)\4[^>\/]*)\/?>)/gi, function (ignore, styleAttr, cssText, linkAttr, delim, href) {
                var i, attr = (styleAttr || linkAttr || "").replace(/^\s*([\s\S]*?)\s*$/i, "$1");
                if (cssText) {
                    i = styles.push(cssUrl ? adjustCssPaths(cssUrl, cssText) : cssText);
                } else {
                    i = styles.push("@import \"" + href + "\";");
                    attr = attr.replace(/\s*(?:rel|href)=(['"])?[^\s]*\1\s*/gi, "");
                }
                if (attr) {
                    attr = attr.split(/\s+/);
                    var atObj = {}, tmp;
                    for (var j = 0, e = attr.length; j < e; j++) {
                        tmp = attr[j].split("=");
                        atObj[tmp[0]] = tmp[1].replace(/^\s*['"]?([\s\S]*?)['"]?\s*$/, "$1");
                    }
                    styles.attributes[i - 1] = atObj;
                }
                return "";
            });
        };
        var snarfScripts = html._snarfScripts = function (cont, byRef) {
            byRef.code = "";
            cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g, function (comment) {
                return comment.replace(/<(\/?)script\b/ig, "&lt;$1Script");
            });
            function download(src) {
                if (byRef.downloadRemote) {
                    src = src.replace(/&([a-z0-9#]+);/g, function (m, name) {
                        switch (name) {
                          case "amp":
                            return "&";
                          case "gt":
                            return ">";
                          case "lt":
                            return "<";
                          default:
                            return name.charAt(0) == "#" ? String.fromCharCode(name.substring(1)) : "&" + name + ";";
                        }
                    });
                    xhrUtil.get({url:src, sync:true, load:function (code) {
                        byRef.code += code + ";";
                    }, error:byRef.errBack});
                }
            }
            return cont.replace(/<script\s*(?![^>]*type=['"]?(?:dojo\/|text\/html\b))[^>]*?(?:src=(['"]?)([^>]*?)\1[^>]*)?>([\s\S]*?)<\/script>/gi, function (ignore, delim, src, code) {
                if (src) {
                    download(src);
                } else {
                    byRef.code += code;
                }
                return "";
            });
        };
        var evalInGlobal = html.evalInGlobal = function (code, appendNode) {
            appendNode = appendNode || windowUtil.doc.body;
            var n = appendNode.ownerDocument.createElement("script");
            n.type = "text/javascript";
            appendNode.appendChild(n);
            n.text = code;
        };
        html._ContentSetter = declare(htmlUtil._ContentSetter, {adjustPaths:false, referencePath:".", renderStyles:false, executeScripts:false, scriptHasHooks:false, scriptHookReplacement:null, _renderStyles:function (styles) {
            this._styleNodes = [];
            var st, att, cssText, doc = this.node.ownerDocument;
            var head = doc.getElementsByTagName("head")[0];
            for (var i = 0, e = styles.length; i < e; i++) {
                cssText = styles[i];
                att = styles.attributes[i];
                st = doc.createElement("style");
                st.setAttribute("type", "text/css");
                for (var x in att) {
                    st.setAttribute(x, att[x]);
                }
                this._styleNodes.push(st);
                head.appendChild(st);
                if (st.styleSheet) {
                    st.styleSheet.cssText = cssText;
                } else {
                    st.appendChild(doc.createTextNode(cssText));
                }
            }
        }, empty:function () {
            this.inherited("empty", arguments);
            this._styles = [];
        }, onBegin:function () {
            this.inherited("onBegin", arguments);
            var cont = this.content, node = this.node;
            var styles = this._styles;
            if (lang.isString(cont)) {
                if (this.adjustPaths && this.referencePath) {
                    cont = adjustHtmlPaths(this.referencePath, cont);
                }
                if (this.renderStyles || this.cleanContent) {
                    cont = snarfStyles(this.referencePath, cont, styles);
                }
                if (this.executeScripts) {
                    var _t = this;
                    var byRef = {downloadRemote:true, errBack:function (e) {
                        _t._onError.call(_t, "Exec", "Error downloading remote script in \"" + _t.id + "\"", e);
                    }};
                    cont = snarfScripts(cont, byRef);
                    this._code = byRef.code;
                }
            }
            this.content = cont;
        }, onEnd:function () {
            var code = this._code, styles = this._styles;
            if (this._styleNodes && this._styleNodes.length) {
                while (this._styleNodes.length) {
                    domConstruct.destroy(this._styleNodes.pop());
                }
            }
            if (this.renderStyles && styles && styles.length) {
                this._renderStyles(styles);
            }
            var d = new Deferred();
            var superClassOnEndMethod = this.getInherited(arguments), args = arguments, callSuperclass = lang.hitch(this, function () {
                superClassOnEndMethod.apply(this, args);
                when(this.parseDeferred, function () {
                    d.resolve();
                });
            });
            if (this.executeScripts && code) {
                if (this.cleanContent) {
                    code = code.replace(/(<!--|(?:\/\/)?-->|<!\[CDATA\[|\]\]>)/g, "");
                }
                if (this.scriptHasHooks) {
                    code = code.replace(/_container_(?!\s*=[^=])/g, this.scriptHookReplacement);
                }
                try {
                    evalInGlobal(code, this.node);
                }
                catch (e) {
                    this._onError("Exec", "Error eval script in " + this.id + ", " + e.message, e);
                }
                ready(callSuperclass);
            } else {
                callSuperclass();
            }
            return d.promise;
        }, tearDown:function () {
            this.inherited(arguments);
            delete this._styles;
            if (this._styleNodes && this._styleNodes.length) {
                while (this._styleNodes.length) {
                    domConstruct.destroy(this._styleNodes.pop());
                }
            }
            delete this._styleNodes;
            lang.mixin(this, html._ContentSetter.prototype);
        }});
        html.set = function (node, cont, params) {
            if (!params) {
                return htmlUtil._setNodeContent(node, cont, true);
            } else {
                var op = new html._ContentSetter(lang.mixin(params, {content:cont, node:node}));
                return op.set();
            }
        };
        return html;
    });
}, "dojox/grid/enhanced/_Plugin":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/connect", "../EnhancedGrid"], function (dojo, lang, declare, array, connect) {
        return declare("dojox.grid.enhanced._Plugin", null, {name:"plugin", grid:null, option:{}, _connects:[], _subscribes:[], privates:{}, constructor:function (inGrid, option) {
            this.grid = inGrid;
            this.option = option;
            this._connects = [];
            this._subscribes = [];
            this.privates = lang.mixin({}, dojox.grid.enhanced._Plugin.prototype);
            this.init();
        }, init:function () {
        }, onPreInit:function () {
        }, onPostInit:function () {
        }, onStartUp:function () {
        }, connect:function (obj, event, method) {
            var conn = connect.connect(obj, event, this, method);
            this._connects.push(conn);
            return conn;
        }, disconnect:function (handle) {
            array.some(this._connects, function (conn, i, conns) {
                if (conn == handle) {
                    connect.disconnect(handle);
                    conns.splice(i, 1);
                    return true;
                }
                return false;
            });
        }, subscribe:function (topic, method) {
            var subscribe = connect.subscribe(topic, this, method);
            this._subscribes.push(subscribe);
            return subscribe;
        }, unsubscribe:function (handle) {
            array.some(this._subscribes, function (subscribe, i, subscribes) {
                if (subscribe == handle) {
                    connect.unsubscribe(handle);
                    subscribes.splice(i, 1);
                    return true;
                }
                return false;
            });
        }, onSetStore:function (store) {
        }, destroy:function () {
            array.forEach(this._connects, connect.disconnect);
            array.forEach(this._subscribes, connect.unsubscribe);
            delete this._connects;
            delete this._subscribes;
            delete this.option;
            delete this.privates;
        }});
    });
}, "dijit/_DialogMixin":function () {
    define(["dojo/_base/declare", "./a11y"], function (declare, a11y) {
        return declare("dijit._DialogMixin", null, {execute:function () {
        }, onCancel:function () {
        }, onExecute:function () {
        }, _onSubmit:function () {
            this.onExecute();
            this.execute(this.get("value"));
        }, _getFocusItems:function () {
            var elems = a11y._getTabNavigable(this.containerNode);
            this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
            this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
        }});
    });
}, "dijit/_Widget":function () {
    define(["dojo/aspect", "dojo/_base/config", "dojo/_base/connect", "dojo/_base/declare", "dojo/has", "dojo/_base/kernel", "dojo/_base/lang", "dojo/query", "dojo/ready", "./registry", "./_WidgetBase", "./_OnDijitClickMixin", "./_FocusMixin", "dojo/uacss", "./hccss"], function (aspect, config, connect, declare, has, kernel, lang, query, ready, registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin) {
        function connectToDomNode() {
        }
        function aroundAdvice(originalConnect) {
            return function (obj, event, scope, method) {
                if (obj && typeof event == "string" && obj[event] == connectToDomNode) {
                    return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
                }
                return originalConnect.apply(connect, arguments);
            };
        }
        aspect.around(connect, "connect", aroundAdvice);
        if (kernel.connect) {
            aspect.around(kernel, "connect", aroundAdvice);
        }
        var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {onClick:connectToDomNode, onDblClick:connectToDomNode, onKeyDown:connectToDomNode, onKeyPress:connectToDomNode, onKeyUp:connectToDomNode, onMouseDown:connectToDomNode, onMouseMove:connectToDomNode, onMouseOut:connectToDomNode, onMouseOver:connectToDomNode, onMouseLeave:connectToDomNode, onMouseEnter:connectToDomNode, onMouseUp:connectToDomNode, constructor:function (params) {
            this._toConnect = {};
            for (var name in params) {
                if (this[name] === connectToDomNode) {
                    this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
                    delete params[name];
                }
            }
        }, postCreate:function () {
            this.inherited(arguments);
            for (var name in this._toConnect) {
                this.on(name, this._toConnect[name]);
            }
            delete this._toConnect;
        }, on:function (type, func) {
            if (this[this._onMap(type)] === connectToDomNode) {
                return connect.connect(this.domNode, type.toLowerCase(), this, func);
            }
            return this.inherited(arguments);
        }, _setFocusedAttr:function (val) {
            this._focused = val;
            this._set("focused", val);
        }, setAttribute:function (attr, value) {
            kernel.deprecated(this.declaredClass + "::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
            this.set(attr, value);
        }, attr:function (name, value) {
            var args = arguments.length;
            if (args >= 2 || typeof name === "object") {
                return this.set.apply(this, arguments);
            } else {
                return this.get(name);
            }
        }, getDescendants:function () {
            kernel.deprecated(this.declaredClass + "::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
            return this.containerNode ? query("[widgetId]", this.containerNode).map(registry.byNode) : [];
        }, _onShow:function () {
            this.onShow();
        }, onShow:function () {
        }, onHide:function () {
        }, onClose:function () {
            return true;
        }});
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/_base"];
                require(requires);
            });
        }
        return _Widget;
    });
}, "dijit/form/_SearchMixin":function () {
    define(["dojo/_base/declare", "dojo/keys", "dojo/_base/lang", "dojo/query", "dojo/string", "dojo/when", "../registry"], function (declare, keys, lang, query, string, when, registry) {
        return declare("dijit.form._SearchMixin", null, {pageSize:Infinity, store:null, fetchProperties:{}, query:{}, searchDelay:200, searchAttr:"name", queryExpr:"${0}*", ignoreCase:true, _patternToRegExp:function (pattern) {
            return new RegExp("^" + pattern.replace(/(\\.)|(\*)|(\?)|\W/g, function (str, literal, star, question) {
                return star ? ".*" : question ? "." : literal ? literal : "\\" + str;
            }) + "$", this.ignoreCase ? "mi" : "m");
        }, _abortQuery:function () {
            if (this.searchTimer) {
                this.searchTimer = this.searchTimer.remove();
            }
            if (this._queryDeferHandle) {
                this._queryDeferHandle = this._queryDeferHandle.remove();
            }
            if (this._fetchHandle) {
                if (this._fetchHandle.abort) {
                    this._cancelingQuery = true;
                    this._fetchHandle.abort();
                    this._cancelingQuery = false;
                }
                if (this._fetchHandle.cancel) {
                    this._cancelingQuery = true;
                    this._fetchHandle.cancel();
                    this._cancelingQuery = false;
                }
                this._fetchHandle = null;
            }
        }, _processInput:function (evt) {
            if (this.disabled || this.readOnly) {
                return;
            }
            var key = evt.charOrCode;
            if ("type" in evt && evt.type.substring(0, 3) == "key" && (evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != "x" && key != "v")) || key == keys.SHIFT)) {
                return;
            }
            var doSearch = false;
            this._prev_key_backspace = false;
            switch (key) {
              case keys.DELETE:
              case keys.BACKSPACE:
                this._prev_key_backspace = true;
                this._maskValidSubsetError = true;
                doSearch = true;
                break;
              default:
                doSearch = typeof key == "string" || key == 229;
            }
            if (doSearch) {
                if (!this.store) {
                    this.onSearch();
                } else {
                    this.searchTimer = this.defer("_startSearchFromInput", 1);
                }
            }
        }, onSearch:function () {
        }, _startSearchFromInput:function () {
            this._startSearch(this.focusNode.value);
        }, _startSearch:function (text) {
            this._abortQuery();
            var _this = this, query = lang.clone(this.query), options = {start:0, count:this.pageSize, queryOptions:{ignoreCase:this.ignoreCase, deep:true}}, qs = string.substitute(this.queryExpr, [text.replace(/([\\\*\?])/g, "\\$1")]), q, startQuery = function () {
                var resPromise = _this._fetchHandle = _this.store.query(query, options);
                if (_this.disabled || _this.readOnly || (q !== _this._lastQuery)) {
                    return;
                }
                when(resPromise, function (res) {
                    _this._fetchHandle = null;
                    if (!_this.disabled && !_this.readOnly && (q === _this._lastQuery)) {
                        when(resPromise.total, function (total) {
                            res.total = total;
                            var pageSize = _this.pageSize;
                            if (isNaN(pageSize) || pageSize > res.total) {
                                pageSize = res.total;
                            }
                            res.nextPage = function (direction) {
                                options.direction = direction = direction !== false;
                                options.count = pageSize;
                                if (direction) {
                                    options.start += res.length;
                                    if (options.start >= res.total) {
                                        options.count = 0;
                                    }
                                } else {
                                    options.start -= pageSize;
                                    if (options.start < 0) {
                                        options.count = Math.max(pageSize + options.start, 0);
                                        options.start = 0;
                                    }
                                }
                                if (options.count <= 0) {
                                    res.length = 0;
                                    _this.onSearch(res, query, options);
                                } else {
                                    startQuery();
                                }
                            };
                            _this.onSearch(res, query, options);
                        });
                    }
                }, function (err) {
                    _this._fetchHandle = null;
                    if (!_this._cancelingQuery) {
                        console.error(_this.declaredClass + " " + err.toString());
                    }
                });
            };
            lang.mixin(options, this.fetchProperties);
            if (this.store._oldAPI) {
                q = qs;
            } else {
                q = this._patternToRegExp(qs);
                q.toString = function () {
                    return qs;
                };
            }
            this._lastQuery = query[this.searchAttr] = q;
            this._queryDeferHandle = this.defer(startQuery, this.searchDelay);
        }, constructor:function () {
            this.query = {};
            this.fetchProperties = {};
        }, postMixInProperties:function () {
            if (!this.store) {
                var list = this.list;
                if (list) {
                    this.store = registry.byId(list);
                }
            }
            this.inherited(arguments);
        }});
    });
}, "dijit/layout/AccordionContainer":function () {
    define(["require", "dojo/_base/array", "dojo/_base/declare", "dojo/_base/fx", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/keys", "dojo/_base/lang", "dojo/sniff", "dojo/topic", "../focus", "../_base/manager", "dojo/ready", "../_Widget", "../_Container", "../_TemplatedMixin", "../_CssStateMixin", "./StackContainer", "./ContentPane", "dojo/text!./templates/AccordionButton.html", "../a11yclick"], function (require, array, declare, fx, dom, domAttr, domClass, domConstruct, domGeometry, keys, lang, has, topic, focus, manager, ready, _Widget, _Container, _TemplatedMixin, _CssStateMixin, StackContainer, ContentPane, template) {
        var AccordionButton = declare("dijit.layout._AccordionButton", [_Widget, _TemplatedMixin, _CssStateMixin], {templateString:template, label:"", _setLabelAttr:{node:"titleTextNode", type:"innerHTML"}, title:"", _setTitleAttr:{node:"titleTextNode", type:"attribute", attribute:"title"}, iconClassAttr:"", _setIconClassAttr:{node:"iconNode", type:"class"}, baseClass:"dijitAccordionTitle", getParent:function () {
            return this.parent;
        }, buildRendering:function () {
            this.inherited(arguments);
            var titleTextNodeId = this.id.replace(" ", "_");
            domAttr.set(this.titleTextNode, "id", titleTextNodeId + "_title");
            this.focusNode.setAttribute("aria-labelledby", domAttr.get(this.titleTextNode, "id"));
            dom.setSelectable(this.domNode, false);
        }, getTitleHeight:function () {
            return domGeometry.getMarginSize(this.domNode).h;
        }, _onTitleClick:function () {
            var parent = this.getParent();
            parent.selectChild(this.contentWidget, true);
            focus.focus(this.focusNode);
        }, _onTitleKeyDown:function (evt) {
            return this.getParent()._onKeyDown(evt, this.contentWidget);
        }, _setSelectedAttr:function (isSelected) {
            this._set("selected", isSelected);
            this.focusNode.setAttribute("aria-expanded", isSelected ? "true" : "false");
            this.focusNode.setAttribute("aria-selected", isSelected ? "true" : "false");
            this.focusNode.setAttribute("tabIndex", isSelected ? "0" : "-1");
        }});
        if (has("dojo-bidi")) {
            AccordionButton.extend({_setLabelAttr:function (label) {
                this._set("label", label);
                domAttr.set(this.titleTextNode, "innerHTML", label);
                this.applyTextDir(this.titleTextNode);
            }, _setTitleAttr:function (title) {
                this._set("title", title);
                domAttr.set(this.titleTextNode, "title", title);
                this.applyTextDir(this.titleTextNode);
            }});
        }
        var AccordionInnerContainer = declare("dijit.layout._AccordionInnerContainer" + (has("dojo-bidi") ? "_NoBidi" : ""), [_Widget, _CssStateMixin], {baseClass:"dijitAccordionInnerContainer", isLayoutContainer:true, buildRendering:function () {
            this.domNode = domConstruct.place("<div class='" + this.baseClass + "' role='presentation'>", this.contentWidget.domNode, "after");
            var child = this.contentWidget, cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
            this.button = child._buttonWidget = (new cls({contentWidget:child, label:child.title, title:child.tooltip, dir:child.dir, lang:child.lang, textDir:child.textDir || this.textDir, iconClass:child.iconClass, id:child.id + "_button", parent:this.parent})).placeAt(this.domNode);
            this.containerNode = domConstruct.place("<div class='dijitAccordionChildWrapper' role='tabpanel' style='display:none'>", this.domNode);
            this.containerNode.setAttribute("aria-labelledby", this.button.id);
            domConstruct.place(this.contentWidget.domNode, this.containerNode);
        }, postCreate:function () {
            this.inherited(arguments);
            var button = this.button, cw = this.contentWidget;
            this._contentWidgetWatches = [cw.watch("title", lang.hitch(this, function (name, oldValue, newValue) {
                button.set("label", newValue);
            })), cw.watch("tooltip", lang.hitch(this, function (name, oldValue, newValue) {
                button.set("title", newValue);
            })), cw.watch("iconClass", lang.hitch(this, function (name, oldValue, newValue) {
                button.set("iconClass", newValue);
            }))];
        }, _setSelectedAttr:function (isSelected) {
            this._set("selected", isSelected);
            this.button.set("selected", isSelected);
            if (isSelected) {
                var cw = this.contentWidget;
                if (cw.onSelected) {
                    cw.onSelected();
                }
            }
        }, startup:function () {
            this.contentWidget.startup();
        }, destroy:function () {
            this.button.destroyRecursive();
            array.forEach(this._contentWidgetWatches || [], function (w) {
                w.unwatch();
            });
            delete this.contentWidget._buttonWidget;
            delete this.contentWidget._wrapperWidget;
            this.inherited(arguments);
        }, destroyDescendants:function (preserveDom) {
            this.contentWidget.destroyRecursive(preserveDom);
        }});
        if (has("dojo-bidi")) {
            AccordionInnerContainer = declare("dijit.layout._AccordionInnerContainer", AccordionInnerContainer, {postCreate:function () {
                this.inherited(arguments);
                var button = this.button;
                this._contentWidgetWatches.push(this.contentWidget.watch("textDir", function (name, oldValue, newValue) {
                    button.set("textDir", newValue);
                }));
            }});
        }
        var AccordionContainer = declare("dijit.layout.AccordionContainer", StackContainer, {duration:manager.defaultDuration, buttonWidget:AccordionButton, baseClass:"dijitAccordionContainer", buildRendering:function () {
            this.inherited(arguments);
            this.domNode.style.overflow = "hidden";
            this.domNode.setAttribute("role", "tablist");
        }, startup:function () {
            if (this._started) {
                return;
            }
            this.inherited(arguments);
            if (this.selectedChildWidget) {
                this.selectedChildWidget._wrapperWidget.set("selected", true);
            }
        }, layout:function () {
            var openPane = this.selectedChildWidget;
            if (!openPane) {
                return;
            }
            var wrapperDomNode = openPane._wrapperWidget.domNode, wrapperDomNodeMargin = domGeometry.getMarginExtents(wrapperDomNode), wrapperDomNodePadBorder = domGeometry.getPadBorderExtents(wrapperDomNode), wrapperContainerNode = openPane._wrapperWidget.containerNode, wrapperContainerNodeMargin = domGeometry.getMarginExtents(wrapperContainerNode), wrapperContainerNodePadBorder = domGeometry.getPadBorderExtents(wrapperContainerNode), mySize = this._contentBox;
            var totalCollapsedHeight = 0;
            array.forEach(this.getChildren(), function (child) {
                if (child != openPane) {
                    totalCollapsedHeight += domGeometry.getMarginSize(child._wrapperWidget.domNode).h;
                }
            });
            this._verticalSpace = mySize.h - totalCollapsedHeight - wrapperDomNodeMargin.h - wrapperDomNodePadBorder.h - wrapperContainerNodeMargin.h - wrapperContainerNodePadBorder.h - openPane._buttonWidget.getTitleHeight();
            this._containerContentBox = {h:this._verticalSpace, w:this._contentBox.w - wrapperDomNodeMargin.w - wrapperDomNodePadBorder.w - wrapperContainerNodeMargin.w - wrapperContainerNodePadBorder.w};
            if (openPane) {
                openPane.resize(this._containerContentBox);
            }
        }, _setupChild:function (child) {
            child._wrapperWidget = AccordionInnerContainer({contentWidget:child, buttonWidget:this.buttonWidget, id:child.id + "_wrapper", dir:child.dir, lang:child.lang, textDir:child.textDir || this.textDir, parent:this});
            this.inherited(arguments);
            domConstruct.place(child.domNode, child._wrapper, "replace");
        }, removeChild:function (child) {
            if (child._wrapperWidget) {
                domConstruct.place(child.domNode, child._wrapperWidget.domNode, "after");
                child._wrapperWidget.destroy();
                delete child._wrapperWidget;
            }
            domClass.remove(child.domNode, "dijitHidden");
            this.inherited(arguments);
        }, getChildren:function () {
            return array.map(this.inherited(arguments), function (child) {
                return child.declaredClass == "dijit.layout._AccordionInnerContainer" ? child.contentWidget : child;
            }, this);
        }, destroy:function () {
            if (this._animation) {
                this._animation.stop();
            }
            array.forEach(this.getChildren(), function (child) {
                if (child._wrapperWidget) {
                    child._wrapperWidget.destroy();
                } else {
                    child.destroyRecursive();
                }
            });
            this.inherited(arguments);
        }, _showChild:function (child) {
            child._wrapperWidget.containerNode.style.display = "block";
            return this.inherited(arguments);
        }, _hideChild:function (child) {
            child._wrapperWidget.containerNode.style.display = "none";
            this.inherited(arguments);
        }, _transition:function (newWidget, oldWidget, animate) {
            if (has("ie") < 8) {
                animate = false;
            }
            if (this._animation) {
                this._animation.stop(true);
                delete this._animation;
            }
            var self = this;
            if (newWidget) {
                newWidget._wrapperWidget.set("selected", true);
                var d = this._showChild(newWidget);
                if (this.doLayout && newWidget.resize) {
                    newWidget.resize(this._containerContentBox);
                }
            }
            if (oldWidget) {
                oldWidget._wrapperWidget.set("selected", false);
                if (!animate) {
                    this._hideChild(oldWidget);
                }
            }
            if (animate) {
                var newContents = newWidget._wrapperWidget.containerNode, oldContents = oldWidget._wrapperWidget.containerNode;
                var wrapperContainerNode = newWidget._wrapperWidget.containerNode, wrapperContainerNodeMargin = domGeometry.getMarginExtents(wrapperContainerNode), wrapperContainerNodePadBorder = domGeometry.getPadBorderExtents(wrapperContainerNode), animationHeightOverhead = wrapperContainerNodeMargin.h + wrapperContainerNodePadBorder.h;
                oldContents.style.height = (self._verticalSpace - animationHeightOverhead) + "px";
                this._animation = new fx.Animation({node:newContents, duration:this.duration, curve:[1, this._verticalSpace - animationHeightOverhead - 1], onAnimate:function (value) {
                    value = Math.floor(value);
                    newContents.style.height = value + "px";
                    oldContents.style.height = (self._verticalSpace - animationHeightOverhead - value) + "px";
                }, onEnd:function () {
                    delete self._animation;
                    newContents.style.height = "auto";
                    oldWidget._wrapperWidget.containerNode.style.display = "none";
                    oldContents.style.height = "auto";
                    self._hideChild(oldWidget);
                }});
                this._animation.onStop = this._animation.onEnd;
                this._animation.play();
            }
            return d;
        }, _onKeyDown:function (e, fromTitle) {
            if (this.disabled || e.altKey || !(fromTitle || e.ctrlKey)) {
                return;
            }
            var c = e.keyCode;
            if ((fromTitle && (c == keys.LEFT_ARROW || c == keys.UP_ARROW)) || (e.ctrlKey && c == keys.PAGE_UP)) {
                this._adjacent(false)._buttonWidget._onTitleClick();
                e.stopPropagation();
                e.preventDefault();
            } else {
                if ((fromTitle && (c == keys.RIGHT_ARROW || c == keys.DOWN_ARROW)) || (e.ctrlKey && (c == keys.PAGE_DOWN || c == keys.TAB))) {
                    this._adjacent(true)._buttonWidget._onTitleClick();
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        }});
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/layout/AccordionPane"];
                require(requires);
            });
        }
        AccordionContainer._InnerContainer = AccordionInnerContainer;
        AccordionContainer._Button = AccordionButton;
        return AccordionContainer;
    });
}, "dojo/_base/browser":function () {
    if (require.has) {
        require.has.add("config-selectorEngine", "acme");
    }
    define(["../ready", "./kernel", "./connect", "./unload", "./window", "./event", "./html", "./NodeList", "../query", "./xhr", "./fx"], function (dojo) {
        return dojo;
    });
}, "dijit/form/SimpleTextarea":function () {
    define(["dojo/_base/declare", "dojo/dom-class", "dojo/sniff", "./TextBox"], function (declare, domClass, has, TextBox) {
        return declare("dijit.form.SimpleTextarea", TextBox, {baseClass:"dijitTextBox dijitTextArea", rows:"3", cols:"20", templateString:"<textarea ${!nameAttrSetting} data-dojo-attach-point='focusNode,containerNode,textbox' autocomplete='off'></textarea>", postMixInProperties:function () {
            if (!this.value && this.srcNodeRef) {
                this.value = this.srcNodeRef.value;
            }
            this.inherited(arguments);
        }, buildRendering:function () {
            this.inherited(arguments);
            if (has("ie") && this.cols) {
                domClass.add(this.textbox, "dijitTextAreaCols");
            }
        }, filter:function (value) {
            if (value) {
                value = value.replace(/\r/g, "");
            }
            return this.inherited(arguments);
        }, _onInput:function (e) {
            if (this.maxLength) {
                var maxLength = parseInt(this.maxLength);
                var value = this.textbox.value.replace(/\r/g, "");
                var overflow = value.length - maxLength;
                if (overflow > 0) {
                    var textarea = this.textbox;
                    if (textarea.selectionStart) {
                        var pos = textarea.selectionStart;
                        var cr = 0;
                        if (has("opera")) {
                            cr = (this.textbox.value.substring(0, pos).match(/\r/g) || []).length;
                        }
                        this.textbox.value = value.substring(0, pos - overflow - cr) + value.substring(pos - cr);
                        textarea.setSelectionRange(pos - overflow, pos - overflow);
                    } else {
                        if (this.ownerDocument.selection) {
                            textarea.focus();
                            var range = this.ownerDocument.selection.createRange();
                            range.moveStart("character", -overflow);
                            range.text = "";
                            range.select();
                        }
                    }
                }
            }
            this.inherited(arguments);
        }});
    });
}, "dojox/grid/enhanced/plugins/AutoScroll":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/html", "dojo/_base/window", "../_Plugin", "../../_RowSelector", "../../EnhancedGrid"], function (declare, array, lang, html, win, _Plugin, _RowSelector, EnhancedGrid) {
        var AutoScroll = declare("dojox.grid.enhanced.plugins.AutoScroll", _Plugin, {name:"autoScroll", autoScrollInterval:1000, autoScrollMargin:30, constructor:function (grid, args) {
            this.grid = grid;
            this.readyForAutoScroll = false;
            this._scrolling = false;
            args = lang.isObject(args) ? args : {};
            if ("interval" in args) {
                this.autoScrollInterval = args.interval;
            }
            if ("margin" in args) {
                this.autoScrollMargin = args.margin;
            }
            this._initEvents();
            this._mixinGrid();
        }, _initEvents:function () {
            var g = this.grid;
            this.connect(g, "onCellMouseDown", function () {
                this.readyForAutoScroll = true;
            });
            this.connect(g, "onHeaderCellMouseDown", function () {
                this.readyForAutoScroll = true;
            });
            this.connect(g, "onRowSelectorMouseDown", function () {
                this.readyForAutoScroll = true;
            });
            this.connect(win.doc, "onmouseup", function (evt) {
                this._manageAutoScroll(true);
                this.readyForAutoScroll = false;
            });
            this.connect(win.doc, "onmousemove", function (evt) {
                if (this.readyForAutoScroll) {
                    this._event = evt;
                    var gridPos = html.position(g.domNode), hh = g._getHeaderHeight(), margin = this.autoScrollMargin, ey = evt.clientY, ex = evt.clientX, gy = gridPos.y, gx = gridPos.x, gh = gridPos.h, gw = gridPos.w;
                    if (ex >= gx && ex <= gx + gw) {
                        if (ey >= gy + hh && ey < gy + hh + margin) {
                            this._manageAutoScroll(false, true, false);
                            return;
                        } else {
                            if (ey > gy + gh - margin && ey <= gy + gh) {
                                this._manageAutoScroll(false, true, true);
                                return;
                            } else {
                                if (ey >= gy && ey <= gy + gh) {
                                    var withinSomeview = array.some(g.views.views, function (view, i) {
                                        if (view instanceof _RowSelector) {
                                            return false;
                                        }
                                        var viewPos = html.position(view.domNode);
                                        if (ex < viewPos.x + margin && ex >= viewPos.x) {
                                            this._manageAutoScroll(false, false, false, view);
                                            return true;
                                        } else {
                                            if (ex > viewPos.x + viewPos.w - margin && ex < viewPos.x + viewPos.w) {
                                                this._manageAutoScroll(false, false, true, view);
                                                return true;
                                            }
                                        }
                                        return false;
                                    }, this);
                                    if (withinSomeview) {
                                        return;
                                    }
                                }
                            }
                        }
                    }
                    this._manageAutoScroll(true);
                }
            });
        }, _mixinGrid:function () {
            var g = this.grid;
            g.onStartAutoScroll = function () {
            };
            g.onEndAutoScroll = function () {
            };
        }, _fireEvent:function (eventName, args) {
            var g = this.grid;
            switch (eventName) {
              case "start":
                g.onStartAutoScroll.apply(g, args);
                break;
              case "end":
                g.onEndAutoScroll.apply(g, args);
                break;
            }
        }, _manageAutoScroll:function (toStop, isVertical, isForward, view) {
            if (toStop) {
                this._scrolling = false;
                clearInterval(this._handler);
            } else {
                if (!this._scrolling) {
                    this._scrolling = true;
                    this._fireEvent("start", [isVertical, isForward, view]);
                    this._autoScroll(isVertical, isForward, view);
                    this._handler = setInterval(lang.hitch(this, "_autoScroll", isVertical, isForward, view), this.autoScrollInterval);
                }
            }
        }, _autoScroll:function (isVertical, isForward, view) {
            var g = this.grid, target = null;
            if (isVertical) {
                var targetRow = g.scroller.firstVisibleRow + (isForward ? 1 : -1);
                if (targetRow >= 0 && targetRow < g.rowCount) {
                    g.scrollToRow(targetRow);
                    target = targetRow;
                }
            } else {
                target = this._scrollColumn(isForward, view);
            }
            if (target !== null) {
                this._fireEvent("end", [isVertical, isForward, view, target, this._event]);
            }
        }, _scrollColumn:function (isForward, view) {
            var node = view.scrollboxNode, target = null;
            if (node.clientWidth < node.scrollWidth) {
                var cells = array.filter(this.grid.layout.cells, function (cell) {
                    return !cell.hidden;
                });
                var viewPos = html.position(view.domNode);
                var limit, edge, headerPos, i;
                if (isForward) {
                    limit = node.clientWidth;
                    for (i = 0; i < cells.length; ++i) {
                        headerPos = html.position(cells[i].getHeaderNode());
                        edge = headerPos.x - viewPos.x + headerPos.w;
                        if (edge > limit) {
                            target = cells[i].index;
                            node.scrollLeft += edge - limit + 10;
                            break;
                        }
                    }
                } else {
                    limit = 0;
                    for (i = cells.length - 1; i >= 0; --i) {
                        headerPos = html.position(cells[i].getHeaderNode());
                        edge = headerPos.x - viewPos.x;
                        if (edge < limit) {
                            target = cells[i].index;
                            node.scrollLeft += edge - limit - 10;
                            break;
                        }
                    }
                }
            }
            return target;
        }});
        EnhancedGrid.registerPlugin(AutoScroll);
        return AutoScroll;
    });
}, "dijit/Destroyable":function () {
    define(["dojo/_base/array", "dojo/aspect", "dojo/_base/declare"], function (array, aspect, declare) {
        return declare("dijit.Destroyable", null, {destroy:function (preserveDom) {
            this._destroyed = true;
        }, own:function () {
            array.forEach(arguments, function (handle) {
                var destroyMethodName = "destroyRecursive" in handle ? "destroyRecursive" : "destroy" in handle ? "destroy" : "remove";
                var odh = aspect.before(this, "destroy", function (preserveDom) {
                    handle[destroyMethodName](preserveDom);
                });
                var hdh = aspect.after(handle, destroyMethodName, function () {
                    odh.remove();
                    hdh.remove();
                }, true);
            }, this);
            return arguments;
        }});
    });
}, "dojo/request":function () {
    define(["./request/default!"], function (request) {
        return request;
    });
}, "dojo/_base/Deferred":function () {
    define(["./kernel", "../Deferred", "../promise/Promise", "../errors/CancelError", "../has", "./lang", "../when"], function (dojo, NewDeferred, Promise, CancelError, has, lang, when) {
        var mutator = function () {
        };
        var freeze = Object.freeze || function () {
        };
        var Deferred = dojo.Deferred = function (canceller) {
            var result, finished, canceled, fired, isError, head, nextListener;
            var promise = (this.promise = new Promise());
            function complete(value) {
                if (finished) {
                    throw new Error("This deferred has already been resolved");
                }
                result = value;
                finished = true;
                notify();
            }
            function notify() {
                var mutated;
                while (!mutated && nextListener) {
                    var listener = nextListener;
                    nextListener = nextListener.next;
                    if ((mutated = (listener.progress == mutator))) {
                        finished = false;
                    }
                    var func = (isError ? listener.error : listener.resolved);
                    if (has("config-useDeferredInstrumentation")) {
                        if (isError && NewDeferred.instrumentRejected) {
                            NewDeferred.instrumentRejected(result, !!func);
                        }
                    }
                    if (func) {
                        try {
                            var newResult = func(result);
                            if (newResult && typeof newResult.then === "function") {
                                newResult.then(lang.hitch(listener.deferred, "resolve"), lang.hitch(listener.deferred, "reject"), lang.hitch(listener.deferred, "progress"));
                                continue;
                            }
                            var unchanged = mutated && newResult === undefined;
                            if (mutated && !unchanged) {
                                isError = newResult instanceof Error;
                            }
                            listener.deferred[unchanged && isError ? "reject" : "resolve"](unchanged ? result : newResult);
                        }
                        catch (e) {
                            listener.deferred.reject(e);
                        }
                    } else {
                        if (isError) {
                            listener.deferred.reject(result);
                        } else {
                            listener.deferred.resolve(result);
                        }
                    }
                }
            }
            this.isResolved = promise.isResolved = function () {
                return fired == 0;
            };
            this.isRejected = promise.isRejected = function () {
                return fired == 1;
            };
            this.isFulfilled = promise.isFulfilled = function () {
                return fired >= 0;
            };
            this.isCanceled = promise.isCanceled = function () {
                return canceled;
            };
            this.resolve = this.callback = function (value) {
                this.fired = fired = 0;
                this.results = [value, null];
                complete(value);
            };
            this.reject = this.errback = function (error) {
                isError = true;
                this.fired = fired = 1;
                if (has("config-useDeferredInstrumentation")) {
                    if (NewDeferred.instrumentRejected) {
                        NewDeferred.instrumentRejected(error, !!nextListener);
                    }
                }
                complete(error);
                this.results = [null, error];
            };
            this.progress = function (update) {
                var listener = nextListener;
                while (listener) {
                    var progress = listener.progress;
                    progress && progress(update);
                    listener = listener.next;
                }
            };
            this.addCallbacks = function (callback, errback) {
                this.then(callback, errback, mutator);
                return this;
            };
            promise.then = this.then = function (resolvedCallback, errorCallback, progressCallback) {
                var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
                var listener = {resolved:resolvedCallback, error:errorCallback, progress:progressCallback, deferred:returnDeferred};
                if (nextListener) {
                    head = head.next = listener;
                } else {
                    nextListener = head = listener;
                }
                if (finished) {
                    notify();
                }
                return returnDeferred.promise;
            };
            var deferred = this;
            promise.cancel = this.cancel = function () {
                if (!finished) {
                    var error = canceller && canceller(deferred);
                    if (!finished) {
                        if (!(error instanceof Error)) {
                            error = new CancelError(error);
                        }
                        error.log = false;
                        deferred.reject(error);
                    }
                }
                canceled = true;
            };
            freeze(promise);
        };
        lang.extend(Deferred, {addCallback:function (callback) {
            return this.addCallbacks(lang.hitch.apply(dojo, arguments));
        }, addErrback:function (errback) {
            return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));
        }, addBoth:function (callback) {
            var enclosed = lang.hitch.apply(dojo, arguments);
            return this.addCallbacks(enclosed, enclosed);
        }, fired:-1});
        Deferred.when = dojo.when = when;
        return Deferred;
    });
}, "dojo/keys":function () {
    define(["./_base/kernel", "./sniff"], function (dojo, has) {
        return dojo.keys = {BACKSPACE:8, TAB:9, CLEAR:12, ENTER:13, SHIFT:16, CTRL:17, ALT:18, META:has("webkit") ? 91 : 224, PAUSE:19, CAPS_LOCK:20, ESCAPE:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT_ARROW:37, UP_ARROW:38, RIGHT_ARROW:39, DOWN_ARROW:40, INSERT:45, DELETE:46, HELP:47, LEFT_WINDOW:91, RIGHT_WINDOW:92, SELECT:93, NUMPAD_0:96, NUMPAD_1:97, NUMPAD_2:98, NUMPAD_3:99, NUMPAD_4:100, NUMPAD_5:101, NUMPAD_6:102, NUMPAD_7:103, NUMPAD_8:104, NUMPAD_9:105, NUMPAD_MULTIPLY:106, NUMPAD_PLUS:107, NUMPAD_ENTER:108, NUMPAD_MINUS:109, NUMPAD_PERIOD:110, NUMPAD_DIVIDE:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, F13:124, F14:125, F15:126, NUM_LOCK:144, SCROLL_LOCK:145, UP_DPAD:175, DOWN_DPAD:176, LEFT_DPAD:177, RIGHT_DPAD:178, copyKey:has("mac") && !has("air") ? (has("safari") ? 91 : 224) : 17};
    });
}, "dojox/grid/_RowSelector":function () {
    define(["dojo/_base/declare", "./_View"], function (declare, _View) {
        return declare("dojox.grid._RowSelector", _View, {defaultWidth:"2em", noscroll:true, padBorderWidth:2, buildRendering:function () {
            this.inherited("buildRendering", arguments);
            this.scrollboxNode.style.overflow = "hidden";
            this.headerNode.style.visibility = "hidden";
        }, getWidth:function () {
            return this.viewWidth || this.defaultWidth;
        }, buildRowContent:function (inRowIndex, inRowNode) {
            var w = this.contentWidth || 0;
            inRowNode.innerHTML = "<table class=\"dojoxGridRowbarTable\" style=\"width:" + w + "px;height:1px;\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" role=\"presentation\"><tr><td class=\"dojoxGridRowbarInner\">&nbsp;</td></tr></table>";
        }, renderHeader:function () {
        }, updateRow:function () {
        }, resize:function () {
            this.adaptHeight();
        }, adaptWidth:function () {
            if (!("contentWidth" in this) && this.contentNode && this.contentNode.offsetWidth > 0) {
                this.contentWidth = this.contentNode.offsetWidth - this.padBorderWidth;
            }
        }, doStyleRowNode:function (inRowIndex, inRowNode) {
            var n = ["dojoxGridRowbar dojoxGridNonNormalizedCell"];
            if (this.grid.rows.isOver(inRowIndex)) {
                n.push("dojoxGridRowbarOver");
            }
            if (this.grid.selection.isSelected(inRowIndex)) {
                n.push("dojoxGridRowbarSelected");
            }
            inRowNode.className = n.join(" ");
        }, domouseover:function (e) {
            this.grid.onMouseOverRow(e);
        }, domouseout:function (e) {
            if (!this.isIntraRowEvent(e)) {
                this.grid.onMouseOutRow(e);
            }
        }});
    });
}, "dijit/form/MultiSelect":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-geometry", "dojo/has", "dojo/query", "./_FormValueWidget"], function (array, declare, domGeometry, has, query, _FormValueWidget) {
        var MultiSelect = declare("dijit.form.MultiSelect" + (has("dojo-bidi") ? "_NoBidi" : ""), _FormValueWidget, {size:7, baseClass:"dijitMultiSelect", templateString:"<select multiple='true' ${!nameAttrSetting} data-dojo-attach-point='containerNode,focusNode' data-dojo-attach-event='onchange: _onChange'></select>", addSelected:function (select) {
            select.getSelected().forEach(function (n) {
                this.containerNode.appendChild(n);
                this.domNode.scrollTop = this.domNode.offsetHeight;
                var oldscroll = select.domNode.scrollTop;
                select.domNode.scrollTop = 0;
                select.domNode.scrollTop = oldscroll;
            }, this);
            this._set("value", this.get("value"));
        }, getSelected:function () {
            return query("option", this.containerNode).filter(function (n) {
                return n.selected;
            });
        }, _getValueAttr:function () {
            return array.map(this.getSelected(), function (n) {
                return n.value;
            });
        }, multiple:true, _setValueAttr:function (values, priorityChange) {
            query("option", this.containerNode).forEach(function (n) {
                n.selected = (array.indexOf(values, n.value) != -1);
            });
            this.inherited(arguments);
        }, invertSelection:function (onChange) {
            var val = [];
            query("option", this.containerNode).forEach(function (n) {
                if (!n.selected) {
                    val.push(n.value);
                }
            });
            this._setValueAttr(val, !(onChange === false || onChange == null));
        }, _onChange:function () {
            this._handleOnChange(this.get("value"), true);
        }, resize:function (size) {
            if (size) {
                domGeometry.setMarginBox(this.domNode, size);
            }
        }, postCreate:function () {
            this._set("value", this.get("value"));
            this.inherited(arguments);
        }});
        if (has("dojo-bidi")) {
            MultiSelect = declare("dijit.form.MultiSelect", MultiSelect, {addSelected:function (select) {
                select.getSelected().forEach(function (n) {
                    n.text = this.enforceTextDirWithUcc(this.restoreOriginalText(n), n.text);
                }, this);
                this.inherited(arguments);
            }, _setTextDirAttr:function (textDir) {
                if ((this.textDir != textDir || !this._created) && this.enforceTextDirWithUcc) {
                    this._set("textDir", textDir);
                    query("option", this.containerNode).forEach(function (option) {
                        if (!this._created && option.value === option.text) {
                            option.value = option.text;
                        }
                        option.text = this.enforceTextDirWithUcc(option, option.originalText || option.text);
                    }, this);
                }
            }});
        }
        return MultiSelect;
    });
}, "dojo/main":function () {
    define(["./_base/kernel", "./has", "require", "./sniff", "./_base/lang", "./_base/array", "./_base/config", "./ready", "./_base/declare", "./_base/connect", "./_base/Deferred", "./_base/json", "./_base/Color", "./has!dojo-firebug?./_firebug/firebug", "./_base/browser", "./_base/loader"], function (kernel, has, require, sniff, lang, array, config, ready) {
        if (config.isDebug) {
            require(["./_firebug/firebug"]);
        }
        1 || has.add("dojo-config-require", 1);
        if (1) {
            var deps = config.require;
            if (deps) {
                deps = array.map(lang.isArray(deps) ? deps : [deps], function (item) {
                    return item.replace(/\./g, "/");
                });
                if (kernel.isAsync) {
                    require(deps);
                } else {
                    ready(1, function () {
                        require(deps);
                    });
                }
            }
        }
        return kernel;
    });
}, "dojox/grid/_Layout":function () {
    define(["dojo/_base/kernel", "../main", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/dom-geometry", "./cells", "./_RowSelector"], function (dojo, dojox, declare, array, lang, domGeometry) {
        return declare("dojox.grid._Layout", null, {constructor:function (inGrid) {
            this.grid = inGrid;
        }, cells:[], structure:null, defaultWidth:"6em", moveColumn:function (sourceViewIndex, destViewIndex, cellIndex, targetIndex, before) {
            var source_cells = this.structure[sourceViewIndex].cells[0];
            var dest_cells = this.structure[destViewIndex].cells[0];
            var cell = null;
            var cell_ri = 0;
            var target_ri = 0;
            for (var i = 0, c; c = source_cells[i]; i++) {
                if (c.index == cellIndex) {
                    cell_ri = i;
                    break;
                }
            }
            cell = source_cells.splice(cell_ri, 1)[0];
            cell.view = this.grid.views.views[destViewIndex];
            for (i = 0, c = null; c = dest_cells[i]; i++) {
                if (c.index == targetIndex) {
                    target_ri = i;
                    break;
                }
            }
            if (!before) {
                target_ri += 1;
            }
            dest_cells.splice(target_ri, 0, cell);
            var sortedCell = this.grid.getCell(this.grid.getSortIndex());
            if (sortedCell) {
                sortedCell._currentlySorted = this.grid.getSortAsc();
            }
            this.cells = [];
            cellIndex = 0;
            var v;
            for (i = 0; v = this.structure[i]; i++) {
                for (var j = 0, cs; cs = v.cells[j]; j++) {
                    for (var k = 0; c = cs[k]; k++) {
                        c.index = cellIndex;
                        this.cells.push(c);
                        if ("_currentlySorted" in c) {
                            var si = cellIndex + 1;
                            si *= c._currentlySorted ? 1 : -1;
                            this.grid.sortInfo = si;
                            delete c._currentlySorted;
                        }
                        cellIndex++;
                    }
                }
            }
            array.forEach(this.cells, function (c) {
                var marks = c.markup[2].split(" ");
                var oldIdx = parseInt(marks[1].substring(5));
                if (oldIdx != c.index) {
                    marks[1] = "idx=\"" + c.index + "\"";
                    c.markup[2] = marks.join(" ");
                }
            });
            this.grid.setupHeaderMenu();
        }, setColumnVisibility:function (columnIndex, visible) {
            var cell = this.cells[columnIndex];
            if (cell.hidden == visible) {
                cell.hidden = !visible;
                var v = cell.view, w = v.viewWidth;
                if (w && w != "auto") {
                    v._togglingColumn = domGeometry.getMarginBox(cell.getHeaderNode()).w || 0;
                }
                v.update();
                return true;
            } else {
                return false;
            }
        }, addCellDef:function (inRowIndex, inCellIndex, inDef) {
            var self = this;
            var getCellWidth = function (inDef) {
                var w = 0;
                if (inDef.colSpan > 1) {
                    w = 0;
                } else {
                    w = inDef.width || self._defaultCellProps.width || self.defaultWidth;
                    if (!isNaN(w)) {
                        w = w + "em";
                    }
                }
                return w;
            };
            var props = {grid:this.grid, subrow:inRowIndex, layoutIndex:inCellIndex, index:this.cells.length};
            if (inDef && inDef instanceof dojox.grid.cells._Base) {
                var new_cell = lang.clone(inDef);
                props.unitWidth = getCellWidth(new_cell._props);
                new_cell = lang.mixin(new_cell, this._defaultCellProps, inDef._props, props);
                return new_cell;
            }
            var cell_type = inDef.type || inDef.cellType || this._defaultCellProps.type || this._defaultCellProps.cellType || dojox.grid.cells.Cell;
            if (lang.isString(cell_type)) {
                cell_type = lang.getObject(cell_type);
            }
            props.unitWidth = getCellWidth(inDef);
            return new cell_type(lang.mixin({}, this._defaultCellProps, inDef, props));
        }, addRowDef:function (inRowIndex, inDef) {
            var result = [];
            var relSum = 0, pctSum = 0, doRel = true;
            for (var i = 0, def, cell; (def = inDef[i]); i++) {
                cell = this.addCellDef(inRowIndex, i, def);
                result.push(cell);
                this.cells.push(cell);
                if (doRel && cell.relWidth) {
                    relSum += cell.relWidth;
                } else {
                    if (cell.width) {
                        var w = cell.width;
                        if (typeof w == "string" && w.slice(-1) == "%") {
                            pctSum += window.parseInt(w, 10);
                        } else {
                            if (w == "auto") {
                                doRel = false;
                            }
                        }
                    }
                }
            }
            if (relSum && doRel) {
                array.forEach(result, function (cell) {
                    if (cell.relWidth) {
                        cell.width = cell.unitWidth = ((cell.relWidth / relSum) * (100 - pctSum)) + "%";
                    }
                });
            }
            return result;
        }, addRowsDef:function (inDef) {
            var result = [];
            if (lang.isArray(inDef)) {
                if (lang.isArray(inDef[0])) {
                    for (var i = 0, row; inDef && (row = inDef[i]); i++) {
                        result.push(this.addRowDef(i, row));
                    }
                } else {
                    result.push(this.addRowDef(0, inDef));
                }
            }
            return result;
        }, addViewDef:function (inDef) {
            this._defaultCellProps = inDef.defaultCell || {};
            if (inDef.width && inDef.width == "auto") {
                delete inDef.width;
            }
            return lang.mixin({}, inDef, {cells:this.addRowsDef(inDef.rows || inDef.cells)});
        }, setStructure:function (inStructure) {
            this.fieldIndex = 0;
            this.cells = [];
            var s = this.structure = [];
            if (this.grid.rowSelector) {
                var sel = {type:dojox._scopeName + ".grid._RowSelector"};
                if (lang.isString(this.grid.rowSelector)) {
                    var width = this.grid.rowSelector;
                    if (width == "false") {
                        sel = null;
                    } else {
                        if (width != "true") {
                            sel["width"] = width;
                        }
                    }
                } else {
                    if (!this.grid.rowSelector) {
                        sel = null;
                    }
                }
                if (sel) {
                    s.push(this.addViewDef(sel));
                }
            }
            var isCell = function (def) {
                return ("name" in def || "field" in def || "get" in def);
            };
            var isRowDef = function (def) {
                if (lang.isArray(def)) {
                    if (lang.isArray(def[0]) || isCell(def[0])) {
                        return true;
                    }
                }
                return false;
            };
            var isView = function (def) {
                return (def !== null && lang.isObject(def) && ("cells" in def || "rows" in def || ("type" in def && !isCell(def))));
            };
            if (lang.isArray(inStructure)) {
                var hasViews = false;
                for (var i = 0, st; (st = inStructure[i]); i++) {
                    if (isView(st)) {
                        hasViews = true;
                        break;
                    }
                }
                if (!hasViews) {
                    s.push(this.addViewDef({cells:inStructure}));
                } else {
                    for (i = 0; (st = inStructure[i]); i++) {
                        if (isRowDef(st)) {
                            s.push(this.addViewDef({cells:st}));
                        } else {
                            if (isView(st)) {
                                s.push(this.addViewDef(st));
                            }
                        }
                    }
                }
            } else {
                if (isView(inStructure)) {
                    s.push(this.addViewDef(inStructure));
                }
            }
            this.cellCount = this.cells.length;
            this.grid.setupHeaderMenu();
        }});
    });
}, "dojo/data/util/filter":function () {
    define(["../../_base/lang"], function (lang) {
        var filter = {};
        lang.setObject("dojo.data.util.filter", filter);
        filter.patternToRegExp = function (pattern, ignoreCase) {
            var rxp = "^";
            var c = null;
            for (var i = 0; i < pattern.length; i++) {
                c = pattern.charAt(i);
                switch (c) {
                  case "\\":
                    rxp += c;
                    i++;
                    rxp += pattern.charAt(i);
                    break;
                  case "*":
                    rxp += ".*";
                    break;
                  case "?":
                    rxp += ".";
                    break;
                  case "$":
                  case "^":
                  case "/":
                  case "+":
                  case ".":
                  case "|":
                  case "(":
                  case ")":
                  case "{":
                  case "}":
                  case "[":
                  case "]":
                    rxp += "\\";
                  default:
                    rxp += c;
                }
            }
            rxp += "$";
            if (ignoreCase) {
                return new RegExp(rxp, "mi");
            } else {
                return new RegExp(rxp, "m");
            }
        };
        return filter;
    });
}, "dojo/dnd/common":function () {
    define(["../sniff", "../_base/kernel", "../_base/lang", "../dom"], function (has, kernel, lang, dom) {
        var exports = lang.getObject("dojo.dnd", true);
        exports.getCopyKeyState = function (evt) {
            return evt[has("mac") ? "metaKey" : "ctrlKey"];
        };
        exports._uniqueId = 0;
        exports.getUniqueId = function () {
            var id;
            do {
                id = kernel._scopeName + "Unique" + (++exports._uniqueId);
            } while (dom.byId(id));
            return id;
        };
        exports._empty = {};
        exports.isFormElement = function (e) {
            var t = e.target;
            if (t.nodeType == 3) {
                t = t.parentNode;
            }
            return " a button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;
        };
        return exports;
    });
}, "dojo/when":function () {
    define(["./Deferred", "./promise/Promise"], function (Deferred, Promise) {
        "use strict";
        return function when(valueOrPromise, callback, errback, progback) {
            var receivedPromise = valueOrPromise && typeof valueOrPromise.then === "function";
            var nativePromise = receivedPromise && valueOrPromise instanceof Promise;
            if (!receivedPromise) {
                if (arguments.length > 1) {
                    return callback ? callback(valueOrPromise) : valueOrPromise;
                } else {
                    return new Deferred().resolve(valueOrPromise);
                }
            } else {
                if (!nativePromise) {
                    var deferred = new Deferred(valueOrPromise.cancel);
                    valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
                    valueOrPromise = deferred.promise;
                }
            }
            if (callback || errback || progback) {
                return valueOrPromise.then(callback, errback, progback);
            }
            return valueOrPromise;
        };
    });
}, "dijit/tree/ForestStoreModel":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/_base/kernel", "dojo/_base/lang", "./TreeStoreModel"], function (array, declare, kernel, lang, TreeStoreModel) {
        return declare("dijit.tree.ForestStoreModel", TreeStoreModel, {rootId:"$root$", rootLabel:"ROOT", query:null, constructor:function (params) {
            this.root = {store:this, root:true, id:params.rootId, label:params.rootLabel, children:params.rootChildren};
        }, mayHaveChildren:function (item) {
            return item === this.root || this.inherited(arguments);
        }, getChildren:function (parentItem, callback, onError) {
            if (parentItem === this.root) {
                if (this.root.children) {
                    callback(this.root.children);
                } else {
                    this.store.fetch({query:this.query, onComplete:lang.hitch(this, function (items) {
                        this.root.children = items;
                        callback(items);
                    }), onError:onError});
                }
            } else {
                this.inherited(arguments);
            }
        }, isItem:function (something) {
            return (something === this.root) ? true : this.inherited(arguments);
        }, fetchItemByIdentity:function (keywordArgs) {
            if (keywordArgs.identity == this.root.id) {
                var scope = keywordArgs.scope || kernel.global;
                if (keywordArgs.onItem) {
                    keywordArgs.onItem.call(scope, this.root);
                }
            } else {
                this.inherited(arguments);
            }
        }, getIdentity:function (item) {
            return (item === this.root) ? this.root.id : this.inherited(arguments);
        }, getLabel:function (item) {
            return (item === this.root) ? this.root.label : this.inherited(arguments);
        }, newItem:function (args, parent, insertIndex) {
            if (parent === this.root) {
                this.onNewRootItem(args);
                return this.store.newItem(args);
            } else {
                return this.inherited(arguments);
            }
        }, onNewRootItem:function () {
        }, pasteItem:function (childItem, oldParentItem, newParentItem, bCopy, insertIndex) {
            if (oldParentItem === this.root) {
                if (!bCopy) {
                    this.onLeaveRoot(childItem);
                }
            }
            this.inherited(arguments, [childItem, oldParentItem === this.root ? null : oldParentItem, newParentItem === this.root ? null : newParentItem, bCopy, insertIndex]);
            if (newParentItem === this.root) {
                this.onAddToRoot(childItem);
            }
        }, onAddToRoot:function (item) {
            console.log(this, ": item ", item, " added to root");
        }, onLeaveRoot:function (item) {
            console.log(this, ": item ", item, " removed from root");
        }, _requeryTop:function () {
            var oldChildren = this.root.children || [];
            this.store.fetch({query:this.query, onComplete:lang.hitch(this, function (newChildren) {
                this.root.children = newChildren;
                if (oldChildren.length != newChildren.length || array.some(oldChildren, function (item, idx) {
                    return newChildren[idx] != item;
                })) {
                    this.onChildrenChange(this.root, newChildren);
                }
            })});
        }, onNewItem:function (item, parentInfo) {
            this._requeryTop();
            this.inherited(arguments);
        }, onDeleteItem:function (item) {
            if (array.indexOf(this.root.children, item) != -1) {
                this._requeryTop();
            }
            this.inherited(arguments);
        }, onSetItem:function (item, attribute, oldValue, newValue) {
            this._requeryTop();
            this.inherited(arguments);
        }});
    });
}, "dijit/form/TimeTextBox":function () {
    define(["dojo/_base/declare", "dojo/keys", "dojo/_base/lang", "../_TimePicker", "./_DateTimeTextBox"], function (declare, keys, lang, _TimePicker, _DateTimeTextBox) {
        return declare("dijit.form.TimeTextBox", _DateTimeTextBox, {baseClass:"dijitTextBox dijitComboBox dijitTimeTextBox", popupClass:_TimePicker, _selector:"time", value:new Date(""), maxHeight:-1, _onKey:function (evt) {
            if (this.disabled || this.readOnly) {
                return;
            }
            this.inherited(arguments);
            switch (evt.keyCode) {
              case keys.ENTER:
              case keys.TAB:
              case keys.ESCAPE:
              case keys.DOWN_ARROW:
              case keys.UP_ARROW:
                break;
              default:
                this.defer(function () {
                    var val = this.get("displayedValue");
                    this.filterString = (val && !this.parse(val, this.constraints)) ? val.toLowerCase() : "";
                    if (this._opened) {
                        this.closeDropDown();
                    }
                    this.openDropDown();
                });
            }
        }});
    });
}, "dijit/layout/SplitContainer":function () {
    define(["dojo/_base/array", "dojo/cookie", "dojo/_base/declare", "dojo/dom", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/event", "dojo/_base/kernel", "dojo/_base/lang", "dojo/on", "dojo/sniff", "../registry", "../_WidgetBase", "./_LayoutWidget"], function (array, cookie, declare, dom, domClass, domConstruct, domGeometry, domStyle, event, kernel, lang, on, has, registry, _WidgetBase, _LayoutWidget) {
        var SplitContainer = declare("dijit.layout.SplitContainer", _LayoutWidget, {constructor:function () {
            kernel.deprecated("dijit.layout.SplitContainer is deprecated", "use BorderContainer with splitter instead", 2);
        }, activeSizing:false, sizerWidth:7, orientation:"horizontal", persist:true, baseClass:"dijitSplitContainer", postMixInProperties:function () {
            this.inherited("postMixInProperties", arguments);
            this.isHorizontal = (this.orientation == "horizontal");
        }, postCreate:function () {
            this.inherited(arguments);
            this.sizers = [];
            if (has("mozilla")) {
                this.domNode.style.overflow = "-moz-scrollbars-none";
            }
            if (typeof this.sizerWidth == "object") {
                try {
                    this.sizerWidth = parseInt(this.sizerWidth.toString());
                }
                catch (e) {
                    this.sizerWidth = 7;
                }
            }
            var sizer = this.ownerDocument.createElement("div");
            this.virtualSizer = sizer;
            sizer.style.position = "relative";
            sizer.style.zIndex = 10;
            sizer.className = this.isHorizontal ? "dijitSplitContainerVirtualSizerH" : "dijitSplitContainerVirtualSizerV";
            this.domNode.appendChild(sizer);
            dom.setSelectable(sizer, false);
        }, destroy:function () {
            delete this.virtualSizer;
            if (this._ownconnects) {
                var h;
                while (h = this._ownconnects.pop()) {
                    h.remove();
                }
            }
            this.inherited(arguments);
        }, startup:function () {
            if (this._started) {
                return;
            }
            array.forEach(this.getChildren(), function (child, i, children) {
                this._setupChild(child);
                if (i < children.length - 1) {
                    this._addSizer();
                }
            }, this);
            if (this.persist) {
                this._restoreState();
            }
            this.inherited(arguments);
        }, _setupChild:function (child) {
            this.inherited(arguments);
            child.domNode.style.position = "absolute";
            domClass.add(child.domNode, "dijitSplitPane");
        }, _onSizerMouseDown:function (e) {
            if (e.target.id) {
                for (var i = 0; i < this.sizers.length; i++) {
                    if (this.sizers[i].id == e.target.id) {
                        break;
                    }
                }
                if (i < this.sizers.length) {
                    this.beginSizing(e, i);
                }
            }
        }, _addSizer:function (index) {
            index = index === undefined ? this.sizers.length : index;
            var sizer = this.ownerDocument.createElement("div");
            sizer.id = registry.getUniqueId("dijit_layout_SplitterContainer_Splitter");
            this.sizers.splice(index, 0, sizer);
            this.domNode.appendChild(sizer);
            sizer.className = this.isHorizontal ? "dijitSplitContainerSizerH" : "dijitSplitContainerSizerV";
            var thumb = this.ownerDocument.createElement("div");
            thumb.className = "thumb";
            sizer.appendChild(thumb);
            this.connect(sizer, "onmousedown", "_onSizerMouseDown");
            dom.setSelectable(sizer, false);
        }, removeChild:function (widget) {
            if (this.sizers.length) {
                var i = array.indexOf(this.getChildren(), widget);
                if (i != -1) {
                    if (i == this.sizers.length) {
                        i--;
                    }
                    domConstruct.destroy(this.sizers[i]);
                    this.sizers.splice(i, 1);
                }
            }
            this.inherited(arguments);
            if (this._started) {
                this.layout();
            }
        }, addChild:function (child, insertIndex) {
            if (typeof insertIndex == "undefined" || insertIndex == "last") {
                insertIndex = this.getChildren().length;
            }
            this.inherited(arguments, [child, insertIndex]);
            if (this._started) {
                var children = this.getChildren();
                if (children.length > 1) {
                    this._addSizer(insertIndex);
                }
                this.layout();
            }
        }, layout:function () {
            this.paneWidth = this._contentBox.w;
            this.paneHeight = this._contentBox.h;
            var children = this.getChildren();
            if (!children.length) {
                return;
            }
            var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
            if (children.length > 1) {
                space -= this.sizerWidth * (children.length - 1);
            }
            var outOf = 0;
            array.forEach(children, function (child) {
                outOf += child.sizeShare;
            });
            var pixPerUnit = space / outOf;
            var totalSize = 0;
            array.forEach(children.slice(0, children.length - 1), function (child) {
                var size = Math.round(pixPerUnit * child.sizeShare);
                child.sizeActual = size;
                totalSize += size;
            });
            children[children.length - 1].sizeActual = space - totalSize;
            this._checkSizes();
            var pos = 0;
            var size = children[0].sizeActual;
            this._movePanel(children[0], pos, size);
            children[0].position = pos;
            pos += size;
            if (!this.sizers) {
                return;
            }
            array.some(children.slice(1), function (child, i) {
                if (!this.sizers[i]) {
                    return true;
                }
                this._moveSlider(this.sizers[i], pos, this.sizerWidth);
                this.sizers[i].position = pos;
                pos += this.sizerWidth;
                size = child.sizeActual;
                this._movePanel(child, pos, size);
                child.position = pos;
                pos += size;
            }, this);
        }, _movePanel:function (panel, pos, size) {
            var box;
            if (this.isHorizontal) {
                panel.domNode.style.left = pos + "px";
                panel.domNode.style.top = 0;
                box = {w:size, h:this.paneHeight};
                if (panel.resize) {
                    panel.resize(box);
                } else {
                    domGeometry.setMarginBox(panel.domNode, box);
                }
            } else {
                panel.domNode.style.left = 0;
                panel.domNode.style.top = pos + "px";
                box = {w:this.paneWidth, h:size};
                if (panel.resize) {
                    panel.resize(box);
                } else {
                    domGeometry.setMarginBox(panel.domNode, box);
                }
            }
        }, _moveSlider:function (slider, pos, size) {
            if (this.isHorizontal) {
                slider.style.left = pos + "px";
                slider.style.top = 0;
                domGeometry.setMarginBox(slider, {w:size, h:this.paneHeight});
            } else {
                slider.style.left = 0;
                slider.style.top = pos + "px";
                domGeometry.setMarginBox(slider, {w:this.paneWidth, h:size});
            }
        }, _growPane:function (growth, pane) {
            if (growth > 0) {
                if (pane.sizeActual > pane.sizeMin) {
                    if ((pane.sizeActual - pane.sizeMin) > growth) {
                        pane.sizeActual = pane.sizeActual - growth;
                        growth = 0;
                    } else {
                        growth -= pane.sizeActual - pane.sizeMin;
                        pane.sizeActual = pane.sizeMin;
                    }
                }
            }
            return growth;
        }, _checkSizes:function () {
            var totalMinSize = 0;
            var totalSize = 0;
            var children = this.getChildren();
            array.forEach(children, function (child) {
                totalSize += child.sizeActual;
                totalMinSize += child.sizeMin;
            });
            if (totalMinSize <= totalSize) {
                var growth = 0;
                array.forEach(children, function (child) {
                    if (child.sizeActual < child.sizeMin) {
                        growth += child.sizeMin - child.sizeActual;
                        child.sizeActual = child.sizeMin;
                    }
                });
                if (growth > 0) {
                    var list = this.isDraggingLeft ? children.reverse() : children;
                    array.forEach(list, function (child) {
                        growth = this._growPane(growth, child);
                    }, this);
                }
            } else {
                array.forEach(children, function (child) {
                    child.sizeActual = Math.round(totalSize * (child.sizeMin / totalMinSize));
                });
            }
        }, beginSizing:function (e, i) {
            var children = this.getChildren();
            this.paneBefore = children[i];
            this.paneAfter = children[i + 1];
            this.paneBefore.sizeBeforeDrag = this.paneBefore.sizeActual;
            this.paneAfter.sizeBeforeDrag = this.paneAfter.sizeActual;
            this.paneAfter.positionBeforeDrag = this.paneAfter.position;
            this.isSizing = true;
            this.sizingSplitter = this.sizers[i];
            this.sizingSplitter.positionBeforeDrag = domStyle.get(this.sizingSplitter, (this.isHorizontal ? "left" : "top"));
            if (!this.cover) {
                this.cover = domConstruct.create("div", {style:{position:"absolute", zIndex:5, top:0, left:0, width:"100%", height:"100%"}}, this.domNode);
            } else {
                this.cover.style.zIndex = 5;
            }
            this.sizingSplitter.style.zIndex = 6;
            this.startPoint = this.lastPoint = (this.isHorizontal ? e.pageX : e.pageY);
            this.maxDelta = this.paneAfter.sizeActual - this.paneAfter.sizeMin;
            this.minDelta = -1 * (this.paneBefore.sizeActual - this.paneBefore.sizeMin);
            if (!this.activeSizing) {
                this._showSizingLine();
            }
            this._ownconnects = [on(this.ownerDocument.documentElement, "mousemove", lang.hitch(this, "changeSizing")), on(this.ownerDocument.documentElement, "mouseup", lang.hitch(this, "endSizing"))];
            event.stop(e);
        }, changeSizing:function (e) {
            if (!this.isSizing) {
                return;
            }
            this.lastPoint = this.isHorizontal ? e.pageX : e.pageY;
            var delta = Math.max(Math.min(this.lastPoint - this.startPoint, this.maxDelta), this.minDelta);
            if (this.activeSizing) {
                this._updateSize(delta);
            } else {
                this._moveSizingLine(delta);
            }
            event.stop(e);
        }, endSizing:function () {
            if (!this.isSizing) {
                return;
            }
            if (this.cover) {
                this.cover.style.zIndex = -1;
            }
            if (!this.activeSizing) {
                this._hideSizingLine();
            }
            var delta = Math.max(Math.min(this.lastPoint - this.startPoint, this.maxDelta), this.minDelta);
            this._updateSize(delta);
            this.isSizing = false;
            if (this.persist) {
                this._saveState(this);
            }
            var h;
            while (h = this._ownconnects.pop()) {
                h.remove();
            }
        }, _updateSize:function (delta) {
            this.paneBefore.sizeActual = this.paneBefore.sizeBeforeDrag + delta;
            this.paneAfter.position = this.paneAfter.positionBeforeDrag + delta;
            this.paneAfter.sizeActual = this.paneAfter.sizeBeforeDrag - delta;
            array.forEach(this.getChildren(), function (child) {
                child.sizeShare = child.sizeActual;
            });
            if (this._started) {
                this.layout();
            }
        }, _showSizingLine:function () {
            this._moveSizingLine(0);
            domGeometry.setMarginBox(this.virtualSizer, this.isHorizontal ? {w:this.sizerWidth, h:this.paneHeight} : {w:this.paneWidth, h:this.sizerWidth});
            this.virtualSizer.style.display = "block";
        }, _hideSizingLine:function () {
            this.virtualSizer.style.display = "none";
        }, _moveSizingLine:function (delta) {
            var pos = delta + this.sizingSplitter.positionBeforeDrag;
            domStyle.set(this.virtualSizer, (this.isHorizontal ? "left" : "top"), pos + "px");
        }, _getCookieName:function (i) {
            return this.id + "_" + i;
        }, _restoreState:function () {
            array.forEach(this.getChildren(), function (child, i) {
                var cookieName = this._getCookieName(i);
                var cookieValue = cookie(cookieName);
                if (cookieValue) {
                    var pos = parseInt(cookieValue);
                    if (typeof pos == "number") {
                        child.sizeShare = pos;
                    }
                }
            }, this);
        }, _saveState:function () {
            if (!this.persist) {
                return;
            }
            array.forEach(this.getChildren(), function (child, i) {
                cookie(this._getCookieName(i), child.sizeShare, {expires:365});
            }, this);
        }});
        SplitContainer.ChildWidgetProperties = {sizeMin:10, sizeShare:10};
        lang.extend(_WidgetBase, SplitContainer.ChildWidgetProperties);
        return SplitContainer;
    });
}, "dijit/Menu":function () {
    define(["require", "dojo/_base/array", "dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-geometry", "dojo/dom-style", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/sniff", "dojo/_base/window", "dojo/window", "./popup", "./DropDownMenu", "dojo/ready"], function (require, array, declare, dom, domAttr, domGeometry, domStyle, keys, lang, on, has, win, winUtils, pm, DropDownMenu, ready) {
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
                require(requires);
            });
        }
        return declare("dijit.Menu", DropDownMenu, {constructor:function () {
            this._bindings = [];
        }, targetNodeIds:[], selector:"", contextMenuForWindow:false, leftClickToOpen:false, refocus:true, postCreate:function () {
            if (this.contextMenuForWindow) {
                this.bindDomNode(this.ownerDocumentBody);
            } else {
                array.forEach(this.targetNodeIds, this.bindDomNode, this);
            }
            this.inherited(arguments);
        }, _iframeContentWindow:function (iframe_el) {
            return winUtils.get(this._iframeContentDocument(iframe_el)) || this._iframeContentDocument(iframe_el)["__parent__"] || (iframe_el.name && document.frames[iframe_el.name]) || null;
        }, _iframeContentDocument:function (iframe_el) {
            return iframe_el.contentDocument || (iframe_el.contentWindow && iframe_el.contentWindow.document) || (iframe_el.name && document.frames[iframe_el.name] && document.frames[iframe_el.name].document) || null;
        }, bindDomNode:function (node) {
            node = dom.byId(node, this.ownerDocument);
            var cn;
            if (node.tagName.toLowerCase() == "iframe") {
                var iframe = node, window = this._iframeContentWindow(iframe);
                cn = win.body(window.document);
            } else {
                cn = (node == win.body(this.ownerDocument) ? this.ownerDocument.documentElement : node);
            }
            var binding = {node:node, iframe:iframe};
            domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));
            var doConnects = lang.hitch(this, function (cn) {
                var selector = this.selector, delegatedEvent = selector ? function (eventType) {
                    return on.selector(selector, eventType);
                } : function (eventType) {
                    return eventType;
                }, self = this;
                return [on(cn, delegatedEvent(this.leftClickToOpen ? "click" : "contextmenu"), function (evt) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    if ((new Date()).getTime() < this._lastKeyDown + 500) {
                        return;
                    }
                    self._scheduleOpen(this, iframe, {x:evt.pageX, y:evt.pageY}, evt.target);
                }), on(cn, delegatedEvent("keydown"), function (evt) {
                    if (evt.keyCode == 93 || (evt.shiftKey && evt.keyCode == keys.F10) || (this.leftClickToOpen && evt.keyCode == keys.SPACE)) {
                        evt.stopPropagation();
                        evt.preventDefault();
                        self._scheduleOpen(this, iframe, null, evt.target);
                        this._lastKeyDown = (new Date()).getTime();
                    }
                })];
            });
            binding.connects = cn ? doConnects(cn) : [];
            if (iframe) {
                binding.onloadHandler = lang.hitch(this, function () {
                    var window = this._iframeContentWindow(iframe), cn = win.body(window.document);
                    binding.connects = doConnects(cn);
                });
                if (iframe.addEventListener) {
                    iframe.addEventListener("load", binding.onloadHandler, false);
                } else {
                    iframe.attachEvent("onload", binding.onloadHandler);
                }
            }
        }, unBindDomNode:function (nodeName) {
            var node;
            try {
                node = dom.byId(nodeName, this.ownerDocument);
            }
            catch (e) {
                return;
            }
            var attrName = "_dijitMenu" + this.id;
            if (node && domAttr.has(node, attrName)) {
                var bid = domAttr.get(node, attrName) - 1, b = this._bindings[bid], h;
                while ((h = b.connects.pop())) {
                    h.remove();
                }
                var iframe = b.iframe;
                if (iframe) {
                    if (iframe.removeEventListener) {
                        iframe.removeEventListener("load", b.onloadHandler, false);
                    } else {
                        iframe.detachEvent("onload", b.onloadHandler);
                    }
                }
                domAttr.remove(node, attrName);
                delete this._bindings[bid];
            }
        }, _scheduleOpen:function (delegatedTarget, iframe, coords, target) {
            if (!this._openTimer) {
                this._openTimer = this.defer(function () {
                    delete this._openTimer;
                    this._openMyself({target:target, delegatedTarget:delegatedTarget, iframe:iframe, coords:coords});
                }, 1);
            }
        }, _openMyself:function (args) {
            var target = args.target, iframe = args.iframe, coords = args.coords, byKeyboard = !coords;
            this.currentTarget = args.delegatedTarget;
            if (coords) {
                if (iframe) {
                    var ifc = domGeometry.position(iframe, true), window = this._iframeContentWindow(iframe), scroll = domGeometry.docScroll(window.document);
                    var cs = domStyle.getComputedStyle(iframe), tp = domStyle.toPixelValue, left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0), top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);
                    coords.x += ifc.x + left - scroll.x;
                    coords.y += ifc.y + top - scroll.y;
                }
            } else {
                coords = domGeometry.position(target, true);
                coords.x += 10;
                coords.y += 10;
            }
            var self = this;
            var prevFocusNode = this._focusManager.get("prevNode");
            var curFocusNode = this._focusManager.get("curNode");
            var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;
            function closeAndRestoreFocus() {
                if (self.refocus && savedFocusNode) {
                    savedFocusNode.focus();
                }
                pm.close(self);
            }
            pm.open({popup:this, x:coords.x, y:coords.y, onExecute:closeAndRestoreFocus, onCancel:closeAndRestoreFocus, orient:this.isLeftToRight() ? "L" : "R"});
            this.focus();
            if (!byKeyboard) {
                this.defer(function () {
                    this._cleanUp(true);
                });
            }
            this._onBlur = function () {
                this.inherited("_onBlur", arguments);
                pm.close(this);
            };
        }, destroy:function () {
            array.forEach(this._bindings, function (b) {
                if (b) {
                    this.unBindDomNode(b.node);
                }
            }, this);
            this.inherited(arguments);
        }});
    });
}, "dojo/dom-attr":function () {
    define(["exports", "./sniff", "./_base/lang", "./dom", "./dom-style", "./dom-prop"], function (exports, has, lang, dom, style, prop) {
        var forcePropNames = {innerHTML:1, className:1, htmlFor:has("ie"), value:1}, attrNames = {classname:"class", htmlfor:"for", tabindex:"tabIndex", readonly:"readOnly"};
        function _hasAttr(node, name) {
            var attr = node.getAttributeNode && node.getAttributeNode(name);
            return attr && attr.specified;
        }
        exports.has = function hasAttr(node, name) {
            var lc = name.toLowerCase();
            return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);
        };
        exports.get = function getAttr(node, name) {
            node = dom.byId(node);
            var lc = name.toLowerCase(), propName = prop.names[lc] || name, forceProp = forcePropNames[propName], value = node[propName];
            if (forceProp && typeof value != "undefined") {
                return value;
            }
            if (propName != "href" && (typeof value == "boolean" || lang.isFunction(value))) {
                return value;
            }
            var attrName = attrNames[lc] || name;
            return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null;
        };
        exports.set = function setAttr(node, name, value) {
            node = dom.byId(node);
            if (arguments.length == 2) {
                for (var x in name) {
                    exports.set(node, x, name[x]);
                }
                return node;
            }
            var lc = name.toLowerCase(), propName = prop.names[lc] || name, forceProp = forcePropNames[propName];
            if (propName == "style" && typeof value != "string") {
                style.set(node, value);
                return node;
            }
            if (forceProp || typeof value == "boolean" || lang.isFunction(value)) {
                return prop.set(node, name, value);
            }
            node.setAttribute(attrNames[lc] || name, value);
            return node;
        };
        exports.remove = function removeAttr(node, name) {
            dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
        };
        exports.getNodeProp = function getNodeProp(node, name) {
            node = dom.byId(node);
            var lc = name.toLowerCase(), propName = prop.names[lc] || name;
            if ((propName in node) && propName != "href") {
                return node[propName];
            }
            var attrName = attrNames[lc] || name;
            return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null;
        };
    });
}, "dijit/_base/window":function () {
    define(["dojo/window", "../main"], function (windowUtils, dijit) {
        dijit.getDocumentWindow = function (doc) {
            return windowUtils.get(doc);
        };
    });
}, "dojo/request/script":function () {
    define(["module", "./watch", "./util", "../_base/array", "../_base/lang", "../on", "../dom", "../dom-construct", "../has", "../_base/window"], function (module, watch, util, array, lang, on, dom, domConstruct, has, win) {
        has.add("script-readystatechange", function (global, document) {
            var script = document.createElement("script");
            return typeof script["onreadystatechange"] !== "undefined" && (typeof global["opera"] === "undefined" || global["opera"].toString() !== "[object Opera]");
        });
        var mid = module.id.replace(/[\/\.\-]/g, "_"), counter = 0, loadEvent = has("script-readystatechange") ? "readystatechange" : "load", readyRegExp = /complete|loaded/, callbacks = this[mid + "_callbacks"] = {}, deadScripts = [];
        function attach(id, url, frameDoc) {
            var doc = (frameDoc || win.doc), element = doc.createElement("script");
            element.type = "text/javascript";
            element.src = url;
            element.id = id;
            element.async = true;
            element.charset = "utf-8";
            return doc.getElementsByTagName("head")[0].appendChild(element);
        }
        function remove(id, frameDoc, cleanup) {
            domConstruct.destroy(dom.byId(id, frameDoc));
            if (callbacks[id]) {
                if (cleanup) {
                    callbacks[id] = function () {
                        delete callbacks[id];
                    };
                } else {
                    delete callbacks[id];
                }
            }
        }
        function _addDeadScript(dfd) {
            var options = dfd.response.options, frameDoc = options.ioArgs ? options.ioArgs.frameDoc : options.frameDoc;
            deadScripts.push({id:dfd.id, frameDoc:frameDoc});
            if (options.ioArgs) {
                options.ioArgs.frameDoc = null;
            }
            options.frameDoc = null;
        }
        function canceler(dfd, response) {
            if (dfd.canDelete) {
                script._remove(dfd.id, response.options.frameDoc, true);
            }
        }
        function isValid(response) {
            if (deadScripts && deadScripts.length) {
                array.forEach(deadScripts, function (_script) {
                    script._remove(_script.id, _script.frameDoc);
                    _script.frameDoc = null;
                });
                deadScripts = [];
            }
            return response.options.jsonp ? !response.data : true;
        }
        function isReadyScript(response) {
            return !!this.scriptLoaded;
        }
        function isReadyCheckString(response) {
            var checkString = response.options.checkString;
            return checkString && eval("typeof(" + checkString + ") !== \"undefined\"");
        }
        function handleResponse(response, error) {
            if (this.canDelete) {
                _addDeadScript(this);
            }
            if (error) {
                this.reject(error);
            } else {
                this.resolve(response);
            }
        }
        function script(url, options, returnDeferred) {
            var response = util.parseArgs(url, util.deepCopy({}, options));
            url = response.url;
            options = response.options;
            var dfd = util.deferred(response, canceler, isValid, options.jsonp ? null : (options.checkString ? isReadyCheckString : isReadyScript), handleResponse);
            lang.mixin(dfd, {id:mid + (counter++), canDelete:false});
            if (options.jsonp) {
                var queryParameter = new RegExp("[?&]" + options.jsonp + "=");
                if (!queryParameter.test(url)) {
                    url += (~url.indexOf("?") ? "&" : "?") + options.jsonp + "=" + (options.frameDoc ? "parent." : "") + mid + "_callbacks." + dfd.id;
                }
                dfd.canDelete = true;
                callbacks[dfd.id] = function (json) {
                    response.data = json;
                    dfd.handleResponse(response);
                };
            }
            if (util.notify) {
                util.notify.emit("send", response, dfd.promise.cancel);
            }
            if (!options.canAttach || options.canAttach(dfd)) {
                var node = script._attach(dfd.id, url, options.frameDoc);
                if (!options.jsonp && !options.checkString) {
                    var handle = on(node, loadEvent, function (evt) {
                        if (evt.type === "load" || readyRegExp.test(node.readyState)) {
                            handle.remove();
                            dfd.scriptLoaded = evt;
                        }
                    });
                }
            }
            watch(dfd);
            return returnDeferred ? dfd : dfd.promise;
        }
        script.get = script;
        script._attach = attach;
        script._remove = remove;
        script._callbacksProperty = mid + "_callbacks";
        return script;
    });
}, "dijit/form/MappedTextBox":function () {
    define(["dojo/_base/declare", "dojo/sniff", "dojo/dom-construct", "./ValidationTextBox"], function (declare, has, domConstruct, ValidationTextBox) {
        return declare("dijit.form.MappedTextBox", ValidationTextBox, {postMixInProperties:function () {
            this.inherited(arguments);
            this.nameAttrSetting = "";
        }, _setNameAttr:"valueNode", serialize:function (val) {
            return val.toString ? val.toString() : "";
        }, toString:function () {
            var val = this.filter(this.get("value"));
            return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : "";
        }, validate:function () {
            this.valueNode.value = this.toString();
            return this.inherited(arguments);
        }, buildRendering:function () {
            this.inherited(arguments);
            this.valueNode = domConstruct.place("<input type='hidden'" + ((this.name && !has("msapp")) ? " name=\"" + this.name.replace(/"/g, "&quot;") + "\"" : "") + "/>", this.textbox, "after");
        }, reset:function () {
            this.valueNode.value = "";
            this.inherited(arguments);
        }});
    });
}, "dojox/grid/util":function () {
    define(["../main", "dojo/_base/lang", "dojo/dom"], function (dojox, lang, dom) {
        var dgu = lang.getObject("grid.util", true, dojox);
        dgu.na = "...";
        dgu.rowIndexTag = "gridRowIndex";
        dgu.gridViewTag = "gridView";
        dgu.fire = function (ob, ev, args) {
            var fn = ob && ev && ob[ev];
            return fn && (args ? fn.apply(ob, args) : ob[ev]());
        };
        dgu.setStyleHeightPx = function (inElement, inHeight) {
            if (inHeight >= 0) {
                var s = inElement.style;
                var v = inHeight + "px";
                if (inElement && s["height"] != v) {
                    s["height"] = v;
                }
            }
        };
        dgu.mouseEvents = ["mouseover", "mouseout", "mousedown", "mouseup", "click", "dblclick", "contextmenu"];
        dgu.keyEvents = ["keyup", "keydown", "keypress"];
        dgu.funnelEvents = function (inNode, inObject, inMethod, inEvents) {
            var evts = (inEvents ? inEvents : dgu.mouseEvents.concat(dgu.keyEvents));
            for (var i = 0, l = evts.length; i < l; i++) {
                inObject.connect(inNode, "on" + evts[i], inMethod);
            }
        };
        dgu.removeNode = function (inNode) {
            inNode = dom.byId(inNode);
            inNode && inNode.parentNode && inNode.parentNode.removeChild(inNode);
            return inNode;
        };
        dgu.arrayCompare = function (inA, inB) {
            for (var i = 0, l = inA.length; i < l; i++) {
                if (inA[i] != inB[i]) {
                    return false;
                }
            }
            return (inA.length == inB.length);
        };
        dgu.arrayInsert = function (inArray, inIndex, inValue) {
            if (inArray.length <= inIndex) {
                inArray[inIndex] = inValue;
            } else {
                inArray.splice(inIndex, 0, inValue);
            }
        };
        dgu.arrayRemove = function (inArray, inIndex) {
            inArray.splice(inIndex, 1);
        };
        dgu.arraySwap = function (inArray, inI, inJ) {
            var cache = inArray[inI];
            inArray[inI] = inArray[inJ];
            inArray[inJ] = cache;
        };
        return dgu;
    });
}, "dojox/layout/ContentPane":function () {
    define(["dojo/_base/lang", "dojo/_base/xhr", "dijit/layout/ContentPane", "dojox/html/_base", "dojo/_base/declare"], function (lang, xhrUtil, ContentPane, htmlUtil, declare) {
        return declare("dojox.layout.ContentPane", ContentPane, {adjustPaths:false, cleanContent:false, renderStyles:false, executeScripts:true, scriptHasHooks:false, ioMethod:xhrUtil.get, ioArgs:{}, onExecError:function (e) {
        }, _setContent:function (cont) {
            var setter = this._contentSetter;
            if (!(setter && setter instanceof htmlUtil._ContentSetter)) {
                setter = this._contentSetter = new htmlUtil._ContentSetter({node:this.containerNode, _onError:lang.hitch(this, this._onError), onContentError:lang.hitch(this, function (e) {
                    var errMess = this.onContentError(e);
                    try {
                        this.containerNode.innerHTML = errMess;
                    }
                    catch (e) {
                        console.error("Fatal " + this.id + " could not change content due to " + e.message, e);
                    }
                })});
            }
            this._contentSetterParams = {adjustPaths:Boolean(this.adjustPaths && (this.href || this.referencePath)), referencePath:this.href || this.referencePath, renderStyles:this.renderStyles, executeScripts:this.executeScripts, scriptHasHooks:this.scriptHasHooks, scriptHookReplacement:"dijit.byId('" + this.id + "')"};
            this.inherited("_setContent", arguments);
        }});
    });
}, "dojox/grid/_RowManager":function () {
    define(["dojo/_base/declare", "dojo/_base/lang", "dojo/dom-class"], function (declare, lang, domClass) {
        var setStyleText = function (inNode, inStyleText) {
            if (inNode.style.cssText == undefined) {
                inNode.setAttribute("style", inStyleText);
            } else {
                inNode.style.cssText = inStyleText;
            }
        };
        return declare("dojox.grid._RowManager", null, {constructor:function (inGrid) {
            this.grid = inGrid;
        }, linesToEms:2, overRow:-2, prepareStylingRow:function (inRowIndex, inRowNode) {
            return {index:inRowIndex, node:inRowNode, odd:Boolean(inRowIndex & 1), selected:!!this.grid.selection.isSelected(inRowIndex), over:this.isOver(inRowIndex), customStyles:"", customClasses:"dojoxGridRow"};
        }, styleRowNode:function (inRowIndex, inRowNode) {
            var row = this.prepareStylingRow(inRowIndex, inRowNode);
            this.grid.onStyleRow(row);
            this.applyStyles(row);
        }, applyStyles:function (inRow) {
            var i = inRow;
            i.node.className = i.customClasses;
            var h = i.node.style.height;
            setStyleText(i.node, i.customStyles + ";" + (i.node._style || ""));
            i.node.style.height = h;
        }, updateStyles:function (inRowIndex) {
            this.grid.updateRowStyles(inRowIndex);
        }, setOverRow:function (inRowIndex) {
            var last = this.overRow;
            this.overRow = inRowIndex;
            if ((last != this.overRow) && (lang.isString(last) || last >= 0)) {
                this.updateStyles(last);
            }
            this.updateStyles(this.overRow);
        }, isOver:function (inRowIndex) {
            return (this.overRow == inRowIndex && !domClass.contains(this.grid.domNode, "dojoxGridColumnResizing"));
        }});
    });
}, "dojo/dnd/Moveable":function () {
    define(["../_base/array", "../_base/declare", "../_base/lang", "../dom", "../dom-class", "../Evented", "../on", "../topic", "../touch", "./common", "./Mover", "../_base/window"], function (array, declare, lang, dom, domClass, Evented, on, topic, touch, dnd, Mover, win) {
        var Moveable = declare("dojo.dnd.Moveable", [Evented], {handle:"", delay:0, skip:false, constructor:function (node, params) {
            this.node = dom.byId(node);
            if (!params) {
                params = {};
            }
            this.handle = params.handle ? dom.byId(params.handle) : null;
            if (!this.handle) {
                this.handle = this.node;
            }
            this.delay = params.delay > 0 ? params.delay : 0;
            this.skip = params.skip;
            this.mover = params.mover ? params.mover : Mover;
            this.events = [on(this.handle, touch.press, lang.hitch(this, "onMouseDown")), on(this.handle, "dragstart", lang.hitch(this, "onSelectStart")), on(this.handle, "selectstart", lang.hitch(this, "onSelectStart"))];
        }, markupFactory:function (params, node, Ctor) {
            return new Ctor(node, params);
        }, destroy:function () {
            array.forEach(this.events, function (handle) {
                handle.remove();
            });
            this.events = this.node = this.handle = null;
        }, onMouseDown:function (e) {
            if (this.skip && dnd.isFormElement(e)) {
                return;
            }
            if (this.delay) {
                this.events.push(on(this.handle, touch.move, lang.hitch(this, "onMouseMove")), on(this.handle, touch.release, lang.hitch(this, "onMouseUp")));
                this._lastX = e.pageX;
                this._lastY = e.pageY;
            } else {
                this.onDragDetected(e);
            }
            e.stopPropagation();
            e.preventDefault();
        }, onMouseMove:function (e) {
            if (Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay) {
                this.onMouseUp(e);
                this.onDragDetected(e);
            }
            e.stopPropagation();
            e.preventDefault();
        }, onMouseUp:function (e) {
            for (var i = 0; i < 2; ++i) {
                this.events.pop().remove();
            }
            e.stopPropagation();
            e.preventDefault();
        }, onSelectStart:function (e) {
            if (!this.skip || !dnd.isFormElement(e)) {
                e.stopPropagation();
                e.preventDefault();
            }
        }, onDragDetected:function (e) {
            new this.mover(this.node, e, this);
        }, onMoveStart:function (mover) {
            topic.publish("/dnd/move/start", mover);
            domClass.add(win.body(), "dojoMove");
            domClass.add(this.node, "dojoMoveItem");
        }, onMoveStop:function (mover) {
            topic.publish("/dnd/move/stop", mover);
            domClass.remove(win.body(), "dojoMove");
            domClass.remove(this.node, "dojoMoveItem");
        }, onFirstMove:function () {
        }, onMove:function (mover, leftTop) {
            this.onMoving(mover, leftTop);
            var s = mover.node.style;
            s.left = leftTop.l + "px";
            s.top = leftTop.t + "px";
            this.onMoved(mover, leftTop);
        }, onMoving:function () {
        }, onMoved:function () {
        }});
        return Moveable;
    });
}, "dojo/store/util/QueryResults":function () {
    define(["../../_base/array", "../../_base/lang", "../../when"], function (array, lang, when) {
        var QueryResults = function (results) {
            if (!results) {
                return results;
            }
            var isPromise = !!results.then;
            if (isPromise) {
                results = lang.delegate(results);
            }
            function addIterativeMethod(method) {
                results[method] = function () {
                    var args = arguments;
                    var result = when(results, function (results) {
                        Array.prototype.unshift.call(args, results);
                        return QueryResults(array[method].apply(array, args));
                    });
                    if (method !== "forEach" || isPromise) {
                        return result;
                    }
                };
            }
            addIterativeMethod("forEach");
            addIterativeMethod("filter");
            addIterativeMethod("map");
            if (results.total == null) {
                results.total = when(results, function (results) {
                    return results.length;
                });
            }
            return results;
        };
        lang.setObject("dojo.store.util.QueryResults", QueryResults);
        return QueryResults;
    });
}, "dojox/uuid":function () {
    define(["dojox/uuid/_base"], function (uuid) {
        return uuid;
    });
}, "dijit/form/CheckBox":function () {
    define(["require", "dojo/_base/declare", "dojo/dom-attr", "dojo/has", "dojo/query", "dojo/ready", "./ToggleButton", "./_CheckBoxMixin", "dojo/text!./templates/CheckBox.html", "dojo/NodeList-dom", "../a11yclick"], function (require, declare, domAttr, has, query, ready, ToggleButton, _CheckBoxMixin, template) {
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/form/RadioButton"];
                require(requires);
            });
        }
        return declare("dijit.form.CheckBox", [ToggleButton, _CheckBoxMixin], {templateString:template, baseClass:"dijitCheckBox", _setValueAttr:function (newValue, priorityChange) {
            if (typeof newValue == "string") {
                this.inherited(arguments);
                newValue = true;
            }
            if (this._created) {
                this.set("checked", newValue, priorityChange);
            }
        }, _getValueAttr:function () {
            return this.checked && this._get("value");
        }, _setIconClassAttr:null, _setNameAttr:"focusNode", postMixInProperties:function () {
            this.inherited(arguments);
            this.checkedAttrSetting = "";
        }, _fillContent:function () {
        }, _onFocus:function () {
            if (this.id) {
                query("label[for='" + this.id + "']").addClass("dijitFocusedLabel");
            }
            this.inherited(arguments);
        }, _onBlur:function () {
            if (this.id) {
                query("label[for='" + this.id + "']").removeClass("dijitFocusedLabel");
            }
            this.inherited(arguments);
        }});
    });
}, "dijit/form/Textarea":function () {
    define(["dojo/_base/declare", "dojo/dom-style", "./_ExpandingTextAreaMixin", "./SimpleTextarea"], function (declare, domStyle, _ExpandingTextAreaMixin, SimpleTextarea) {
        return declare("dijit.form.Textarea", [SimpleTextarea, _ExpandingTextAreaMixin], {baseClass:"dijitTextBox dijitTextArea dijitExpandingTextArea", cols:"", buildRendering:function () {
            this.inherited(arguments);
            domStyle.set(this.textbox, {overflowY:"hidden", overflowX:"auto", boxSizing:"border-box", MsBoxSizing:"border-box", WebkitBoxSizing:"border-box", MozBoxSizing:"border-box"});
        }});
    });
}, "dijit/form/DropDownButton":function () {
    define(["dojo/_base/declare", "dojo/_base/lang", "dojo/query", "../registry", "../popup", "./Button", "../_Container", "../_HasDropDown", "dojo/text!./templates/DropDownButton.html"], function (declare, lang, query, registry, popup, Button, _Container, _HasDropDown, template) {
        return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {baseClass:"dijitDropDownButton", templateString:template, _fillContent:function () {
            if (this.srcNodeRef) {
                var nodes = query("*", this.srcNodeRef);
                this.inherited(arguments, [nodes[0]]);
                this.dropDownContainer = this.srcNodeRef;
            }
        }, startup:function () {
            if (this._started) {
                return;
            }
            if (!this.dropDown && this.dropDownContainer) {
                var dropDownNode = query("[widgetId]", this.dropDownContainer)[0];
                if (dropDownNode) {
                    this.dropDown = registry.byNode(dropDownNode);
                }
                delete this.dropDownContainer;
            }
            if (this.dropDown) {
                popup.hide(this.dropDown);
            }
            this.inherited(arguments);
        }, isLoaded:function () {
            var dropDown = this.dropDown;
            return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
        }, loadDropDown:function (callback) {
            var dropDown = this.dropDown;
            var handler = dropDown.on("load", lang.hitch(this, function () {
                handler.remove();
                callback();
            }));
            dropDown.refresh();
        }, isFocusable:function () {
            return this.inherited(arguments) && !this._mouseDown;
        }});
    });
}, "dijit/_base/scroll":function () {
    define(["dojo/window", "../main"], function (windowUtils, dijit) {
        dijit.scrollIntoView = function (node, pos) {
            windowUtils.scrollIntoView(node, pos);
        };
    });
}, "dojo/regexp":function () {
    define(["./_base/kernel", "./_base/lang"], function (dojo, lang) {
        var regexp = {};
        lang.setObject("dojo.regexp", regexp);
        regexp.escapeString = function (str, except) {
            return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function (ch) {
                if (except && except.indexOf(ch) != -1) {
                    return ch;
                }
                return "\\" + ch;
            });
        };
        regexp.buildGroupRE = function (arr, re, nonCapture) {
            if (!(arr instanceof Array)) {
                return re(arr);
            }
            var b = [];
            for (var i = 0; i < arr.length; i++) {
                b.push(re(arr[i]));
            }
            return regexp.group(b.join("|"), nonCapture);
        };
        regexp.group = function (expression, nonCapture) {
            return "(" + (nonCapture ? "?:" : "") + expression + ")";
        };
        return regexp;
    });
}, "dojo/_base/config":function () {
    define(["../has", "require"], function (has, require) {
        var result = {};
        if (1) {
            var src = require.rawConfig, p;
            for (p in src) {
                result[p] = src[p];
            }
        } else {
            var adviseHas = function (featureSet, prefix, booting) {
                for (p in featureSet) {
                    p != "has" && has.add(prefix + p, featureSet[p], 0, booting);
                }
            };
            result = 1 ? require.rawConfig : this.dojoConfig || this.djConfig || {};
            adviseHas(result, "config", 1);
            adviseHas(result.has, "", 1);
        }
        if (!result.locale && typeof navigator != "undefined") {
            result.locale = (navigator.language || navigator.userLanguage).toLowerCase();
        }
        return result;
    });
}, "dojox/grid/_FocusManager":function () {
    define(["dojo/_base/array", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/event", "dojo/_base/sniff", "dojo/query", "./util", "dojo/_base/html"], function (array, lang, declare, connect, event, has, query, util, html) {
        return declare("dojox.grid._FocusManager", null, {constructor:function (inGrid) {
            this.grid = inGrid;
            this.cell = null;
            this.rowIndex = -1;
            this._connects = [];
            this._headerConnects = [];
            this.headerMenu = this.grid.headerMenu;
            this._connects.push(connect.connect(this.grid.domNode, "onfocus", this, "doFocus"));
            this._connects.push(connect.connect(this.grid.domNode, "onblur", this, "doBlur"));
            this._connects.push(connect.connect(this.grid.domNode, "mousedown", this, "_mouseDown"));
            this._connects.push(connect.connect(this.grid.domNode, "mouseup", this, "_mouseUp"));
            this._connects.push(connect.connect(this.grid.domNode, "oncontextmenu", this, "doContextMenu"));
            this._connects.push(connect.connect(this.grid.lastFocusNode, "onfocus", this, "doLastNodeFocus"));
            this._connects.push(connect.connect(this.grid.lastFocusNode, "onblur", this, "doLastNodeBlur"));
            this._connects.push(connect.connect(this.grid, "_onFetchComplete", this, "_delayedCellFocus"));
            this._connects.push(connect.connect(this.grid, "postrender", this, "_delayedHeaderFocus"));
        }, destroy:function () {
            array.forEach(this._connects, connect.disconnect);
            array.forEach(this._headerConnects, connect.disconnect);
            delete this.grid;
            delete this.cell;
        }, _colHeadNode:null, _colHeadFocusIdx:null, _contextMenuBindNode:null, tabbingOut:false, focusClass:"dojoxGridCellFocus", focusView:null, initFocusView:function () {
            this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
            this._initColumnHeaders();
        }, isFocusCell:function (inCell, inRowIndex) {
            return (this.cell == inCell) && (this.rowIndex == inRowIndex);
        }, isLastFocusCell:function () {
            if (this.cell) {
                return (this.rowIndex == this.grid.rowCount - 1) && (this.cell.index == this.grid.layout.cellCount - 1);
            }
            return false;
        }, isFirstFocusCell:function () {
            if (this.cell) {
                return (this.rowIndex === 0) && (this.cell.index === 0);
            }
            return false;
        }, isNoFocusCell:function () {
            return (this.rowIndex < 0) || !this.cell;
        }, isNavHeader:function () {
            return (!!this._colHeadNode);
        }, getHeaderIndex:function () {
            if (this._colHeadNode) {
                return array.indexOf(this._findHeaderCells(), this._colHeadNode);
            } else {
                return -1;
            }
        }, _focusifyCellNode:function (inBork) {
            var n = this.cell && this.cell.getNode(this.rowIndex);
            if (n) {
                html.toggleClass(n, this.focusClass, inBork);
                if (inBork) {
                    var sl = this.scrollIntoView();
                    try {
                        if (has("webkit") || !this.grid.edit.isEditing()) {
                            util.fire(n, "focus");
                            if (sl) {
                                this.cell.view.scrollboxNode.scrollLeft = sl;
                            }
                        }
                    }
                    catch (e) {
                    }
                }
            }
        }, _delayedCellFocus:function () {
            if (this.isNavHeader() || !this.grid.focused) {
                return;
            }
            var n = this.cell && this.cell.getNode(this.rowIndex);
            if (n) {
                try {
                    if (!this.grid.edit.isEditing()) {
                        html.toggleClass(n, this.focusClass, true);
                        if (this._colHeadNode) {
                            this.blurHeader();
                        }
                        util.fire(n, "focus");
                    }
                }
                catch (e) {
                }
            }
        }, _delayedHeaderFocus:function () {
            if (this.isNavHeader()) {
                this.focusHeader();
            }
        }, _initColumnHeaders:function () {
            array.forEach(this._headerConnects, connect.disconnect);
            this._headerConnects = [];
            var headers = this._findHeaderCells();
            for (var i = 0; i < headers.length; i++) {
                this._headerConnects.push(connect.connect(headers[i], "onfocus", this, "doColHeaderFocus"));
                this._headerConnects.push(connect.connect(headers[i], "onblur", this, "doColHeaderBlur"));
            }
        }, _findHeaderCells:function () {
            var allHeads = query("th", this.grid.viewsHeaderNode);
            var headers = [];
            for (var i = 0; i < allHeads.length; i++) {
                var aHead = allHeads[i];
                var hasTabIdx = html.hasAttr(aHead, "tabIndex");
                var tabindex = html.attr(aHead, "tabIndex");
                if (hasTabIdx && tabindex < 0) {
                    headers.push(aHead);
                }
            }
            return headers;
        }, _setActiveColHeader:function (colHeaderNode, colFocusIdx, prevColFocusIdx) {
            this.grid.domNode.setAttribute("aria-activedescendant", colHeaderNode.id);
            if (prevColFocusIdx != null && prevColFocusIdx >= 0 && prevColFocusIdx != colFocusIdx) {
                html.toggleClass(this._findHeaderCells()[prevColFocusIdx], this.focusClass, false);
            }
            html.toggleClass(colHeaderNode, this.focusClass, true);
            this._colHeadNode = colHeaderNode;
            this._colHeadFocusIdx = colFocusIdx;
            this._scrollHeader(this._colHeadFocusIdx);
        }, scrollIntoView:function () {
            var info = (this.cell ? this._scrollInfo(this.cell) : null);
            if (!info || !info.s) {
                return null;
            }
            var rt = this.grid.scroller.findScrollTop(this.rowIndex);
            if (info.n && info.sr) {
                if (info.n.offsetLeft + info.n.offsetWidth > info.sr.l + info.sr.w) {
                    info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
                } else {
                    if (info.n.offsetLeft < info.sr.l) {
                        info.s.scrollLeft = info.n.offsetLeft;
                    }
                }
            }
            if (info.r && info.sr) {
                if (rt + info.r.offsetHeight > info.sr.t + info.sr.h) {
                    this.grid.setScrollTop(rt + info.r.offsetHeight - info.sr.h);
                } else {
                    if (rt < info.sr.t) {
                        this.grid.setScrollTop(rt);
                    }
                }
            }
            return info.s.scrollLeft;
        }, _scrollInfo:function (cell, domNode) {
            if (cell) {
                var cl = cell, sbn = cl.view.scrollboxNode, sbnr = {w:sbn.clientWidth, l:sbn.scrollLeft, t:sbn.scrollTop, h:sbn.clientHeight}, rn = cl.view.getRowNode(this.rowIndex);
                return {c:cl, s:sbn, sr:sbnr, n:(domNode ? domNode : cell.getNode(this.rowIndex)), r:rn};
            }
            return null;
        }, _scrollHeader:function (currentIdx) {
            var info = null;
            if (this._colHeadNode) {
                var cell = this.grid.getCell(currentIdx);
                if (!cell) {
                    return;
                }
                info = this._scrollInfo(cell, cell.getNode(0));
            }
            if (info && info.s && info.sr && info.n) {
                var scroll = info.sr.l + info.sr.w;
                if (info.n.offsetLeft + info.n.offsetWidth > scroll) {
                    info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
                } else {
                    if (info.n.offsetLeft < info.sr.l) {
                        info.s.scrollLeft = info.n.offsetLeft;
                    } else {
                        if (has("ie") <= 7 && cell && cell.view.headerNode) {
                            cell.view.headerNode.scrollLeft = info.s.scrollLeft;
                        }
                    }
                }
            }
        }, _isHeaderHidden:function () {
            var curView = this.focusView;
            if (!curView) {
                for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
                    if (cView.headerNode) {
                        curView = cView;
                        break;
                    }
                }
            }
            return (curView && html.getComputedStyle(curView.headerNode).display == "none");
        }, colSizeAdjust:function (e, colIdx, delta) {
            var headers = this._findHeaderCells();
            var view = this.focusView;
            if (!view || !view.header.tableMap.map) {
                for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
                    if (cView.header.tableMap.map) {
                        view = cView;
                        break;
                    }
                }
            }
            var curHeader = headers[colIdx];
            if (!view || (colIdx == headers.length - 1 && colIdx === 0)) {
                return;
            }
            view.content.baseDecorateEvent(e);
            e.cellNode = curHeader;
            e.cellIndex = view.content.getCellNodeIndex(e.cellNode);
            e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
            if (view.header.canResize(e)) {
                var deltaObj = {l:delta};
                var drag = view.header.colResizeSetup(e, false);
                view.header.doResizeColumn(drag, null, deltaObj);
                view.update();
            }
        }, styleRow:function (inRow) {
            return;
        }, setFocusIndex:function (inRowIndex, inCellIndex) {
            this.setFocusCell(this.grid.getCell(inCellIndex), inRowIndex);
        }, setFocusCell:function (inCell, inRowIndex) {
            if (inCell && !this.isFocusCell(inCell, inRowIndex)) {
                this.tabbingOut = false;
                if (this._colHeadNode) {
                    this.blurHeader();
                }
                this._colHeadNode = this._colHeadFocusIdx = null;
                this.focusGridView();
                this._focusifyCellNode(false);
                this.cell = inCell;
                this.rowIndex = inRowIndex;
                this._focusifyCellNode(true);
            }
            if (has("opera")) {
                setTimeout(lang.hitch(this.grid, "onCellFocus", this.cell, this.rowIndex), 1);
            } else {
                this.grid.onCellFocus(this.cell, this.rowIndex);
            }
        }, next:function () {
            if (this.cell) {
                var row = this.rowIndex, col = this.cell.index + 1, cc = this.grid.layout.cellCount - 1, rc = this.grid.rowCount - 1;
                if (col > cc) {
                    col = 0;
                    row++;
                }
                if (row > rc) {
                    col = cc;
                    row = rc;
                }
                if (this.grid.edit.isEditing()) {
                    var nextCell = this.grid.getCell(col);
                    if (!this.isLastFocusCell() && (!nextCell.editable || this.grid.canEdit && !this.grid.canEdit(nextCell, row))) {
                        this.cell = nextCell;
                        this.rowIndex = row;
                        this.next();
                        return;
                    }
                }
                this.setFocusIndex(row, col);
            }
        }, previous:function () {
            if (this.cell) {
                var row = (this.rowIndex || 0), col = (this.cell.index || 0) - 1;
                if (col < 0) {
                    col = this.grid.layout.cellCount - 1;
                    row--;
                }
                if (row < 0) {
                    row = 0;
                    col = 0;
                }
                if (this.grid.edit.isEditing()) {
                    var prevCell = this.grid.getCell(col);
                    if (!this.isFirstFocusCell() && !prevCell.editable) {
                        this.cell = prevCell;
                        this.rowIndex = row;
                        this.previous();
                        return;
                    }
                }
                this.setFocusIndex(row, col);
            }
        }, move:function (inRowDelta, inColDelta) {
            var colDir = inColDelta < 0 ? -1 : 1;
            if (this.isNavHeader()) {
                var headers = this._findHeaderCells();
                var savedIdx = currentIdx = array.indexOf(headers, this._colHeadNode);
                currentIdx += inColDelta;
                while (currentIdx >= 0 && currentIdx < headers.length && headers[currentIdx].style.display == "none") {
                    currentIdx += colDir;
                }
                if ((currentIdx >= 0) && (currentIdx < headers.length)) {
                    this._setActiveColHeader(headers[currentIdx], currentIdx, savedIdx);
                }
            } else {
                if (this.cell) {
                    var sc = this.grid.scroller, r = this.rowIndex, rc = this.grid.rowCount - 1, row = Math.min(rc, Math.max(0, r + inRowDelta));
                    if (inRowDelta) {
                        if (inRowDelta > 0) {
                            if (row > sc.getLastPageRow(sc.page)) {
                                this.grid.setScrollTop(this.grid.scrollTop + sc.findScrollTop(row) - sc.findScrollTop(r));
                            }
                        } else {
                            if (inRowDelta < 0) {
                                if (row <= sc.getPageRow(sc.page)) {
                                    this.grid.setScrollTop(this.grid.scrollTop - sc.findScrollTop(r) - sc.findScrollTop(row));
                                }
                            }
                        }
                    }
                    var cc = this.grid.layout.cellCount - 1, i = this.cell.index, col = Math.min(cc, Math.max(0, i + inColDelta));
                    var cell = this.grid.getCell(col);
                    while (col >= 0 && col < cc && cell && cell.hidden === true) {
                        col += colDir;
                        cell = this.grid.getCell(col);
                    }
                    if (!cell || cell.hidden === true) {
                        col = i;
                    }
                    var n = cell.getNode(row);
                    if (!n && inRowDelta) {
                        if ((row + inRowDelta) >= 0 && (row + inRowDelta) <= rc) {
                            this.move(inRowDelta > 0 ? ++inRowDelta : --inRowDelta, inColDelta);
                        }
                        return;
                    } else {
                        if ((!n || html.style(n, "display") === "none") && inColDelta) {
                            if ((col + inColDelta) >= 0 && (col + inColDelta) <= cc) {
                                this.move(inRowDelta, inColDelta > 0 ? ++inColDelta : --inColDelta);
                            }
                            return;
                        }
                    }
                    this.setFocusIndex(row, col);
                    if (inRowDelta) {
                        this.grid.updateRow(r);
                    }
                }
            }
        }, previousKey:function (e) {
            if (this.grid.edit.isEditing()) {
                event.stop(e);
                this.previous();
            } else {
                if (!this.isNavHeader() && !this._isHeaderHidden()) {
                    this.grid.domNode.focus();
                    event.stop(e);
                } else {
                    this.tabOut(this.grid.domNode);
                    if (this._colHeadFocusIdx != null) {
                        html.toggleClass(this._findHeaderCells()[this._colHeadFocusIdx], this.focusClass, false);
                        this._colHeadFocusIdx = null;
                    }
                    this._focusifyCellNode(false);
                }
            }
        }, nextKey:function (e) {
            var isEmpty = (this.grid.rowCount === 0);
            if (e.target === this.grid.domNode && this._colHeadFocusIdx == null) {
                this.focusHeader();
                event.stop(e);
            } else {
                if (this.isNavHeader()) {
                    this.blurHeader();
                    if (!this.findAndFocusGridCell()) {
                        this.tabOut(this.grid.lastFocusNode);
                    }
                    this._colHeadNode = this._colHeadFocusIdx = null;
                } else {
                    if (this.grid.edit.isEditing()) {
                        event.stop(e);
                        this.next();
                    } else {
                        this.tabOut(this.grid.lastFocusNode);
                    }
                }
            }
        }, tabOut:function (inFocusNode) {
            this.tabbingOut = true;
            inFocusNode.focus();
        }, focusGridView:function () {
            util.fire(this.focusView, "focus");
        }, focusGrid:function (inSkipFocusCell) {
            this.focusGridView();
            this._focusifyCellNode(true);
        }, findAndFocusGridCell:function () {
            var didFocus = true;
            var isEmpty = (this.grid.rowCount === 0);
            if (this.isNoFocusCell() && !isEmpty) {
                var cellIdx = 0;
                var cell = this.grid.getCell(cellIdx);
                if (cell.hidden) {
                    cellIdx = this.isNavHeader() ? this._colHeadFocusIdx : 0;
                }
                this.setFocusIndex(0, cellIdx);
            } else {
                if (this.cell && !isEmpty) {
                    if (this.focusView && !this.focusView.rowNodes[this.rowIndex]) {
                        this.grid.scrollToRow(this.rowIndex);
                    }
                    this.focusGrid();
                } else {
                    didFocus = false;
                }
            }
            this._colHeadNode = this._colHeadFocusIdx = null;
            return didFocus;
        }, focusHeader:function () {
            var headerNodes = this._findHeaderCells();
            var saveColHeadFocusIdx = this._colHeadFocusIdx;
            if (this._isHeaderHidden()) {
                this.findAndFocusGridCell();
            } else {
                if (!this._colHeadFocusIdx) {
                    if (this.isNoFocusCell()) {
                        this._colHeadFocusIdx = 0;
                    } else {
                        this._colHeadFocusIdx = this.cell.index;
                    }
                }
            }
            this._colHeadNode = headerNodes[this._colHeadFocusIdx];
            while (this._colHeadNode && this._colHeadFocusIdx >= 0 && this._colHeadFocusIdx < headerNodes.length && this._colHeadNode.style.display == "none") {
                this._colHeadFocusIdx++;
                this._colHeadNode = headerNodes[this._colHeadFocusIdx];
            }
            if (this._colHeadNode && this._colHeadNode.style.display != "none") {
                if (this.headerMenu && this._contextMenuBindNode != this.grid.domNode) {
                    this.headerMenu.unBindDomNode(this.grid.viewsHeaderNode);
                    this.headerMenu.bindDomNode(this.grid.domNode);
                    this._contextMenuBindNode = this.grid.domNode;
                }
                this._setActiveColHeader(this._colHeadNode, this._colHeadFocusIdx, saveColHeadFocusIdx);
                this._scrollHeader(this._colHeadFocusIdx);
                this._focusifyCellNode(false);
            } else {
                this.findAndFocusGridCell();
            }
        }, blurHeader:function () {
            html.removeClass(this._colHeadNode, this.focusClass);
            html.removeAttr(this.grid.domNode, "aria-activedescendant");
            if (this.headerMenu && this._contextMenuBindNode == this.grid.domNode) {
                var viewsHeader = this.grid.viewsHeaderNode;
                this.headerMenu.unBindDomNode(this.grid.domNode);
                this.headerMenu.bindDomNode(viewsHeader);
                this._contextMenuBindNode = viewsHeader;
            }
        }, doFocus:function (e) {
            if (e && e.target != e.currentTarget) {
                event.stop(e);
                return;
            }
            if (this._clickFocus) {
                return;
            }
            if (!this.tabbingOut) {
                this.focusHeader();
            }
            this.tabbingOut = false;
            event.stop(e);
        }, doBlur:function (e) {
            event.stop(e);
        }, doContextMenu:function (e) {
            if (!this.headerMenu) {
                event.stop(e);
            }
        }, doLastNodeFocus:function (e) {
            if (this.tabbingOut) {
                this._focusifyCellNode(false);
            } else {
                if (this.grid.rowCount > 0) {
                    if (this.isNoFocusCell()) {
                        this.setFocusIndex(0, 0);
                    }
                    this._focusifyCellNode(true);
                } else {
                    this.focusHeader();
                }
            }
            this.tabbingOut = false;
            event.stop(e);
        }, doLastNodeBlur:function (e) {
            event.stop(e);
        }, doColHeaderFocus:function (e) {
            this._setActiveColHeader(e.target, html.attr(e.target, "idx"), this._colHeadFocusIdx);
            this._scrollHeader(this.getHeaderIndex());
            event.stop(e);
        }, doColHeaderBlur:function (e) {
            html.toggleClass(e.target, this.focusClass, false);
        }, _mouseDown:function (e) {
            this._clickFocus = dojo.some(this.grid.views.views, function (v) {
                return v.scrollboxNode === e.target;
            });
        }, _mouseUp:function (e) {
            this._clickFocus = false;
        }});
    });
}, "dojo/io/script":function () {
    define(["../_base/connect", "../_base/kernel", "../_base/lang", "../sniff", "../_base/window", "../_base/xhr", "../dom", "../dom-construct", "../request/script", "../aspect"], function (connect, kernel, lang, has, win, xhr, dom, domConstruct, _script, aspect) {
        kernel.deprecated("dojo/io/script", "Use dojo/request/script.", "2.0");
        var script = {get:function (args) {
            var rDfd;
            var dfd = this._makeScriptDeferred(args, function (dfd) {
                rDfd && rDfd.cancel();
            });
            var ioArgs = dfd.ioArgs;
            xhr._ioAddQueryToUrl(ioArgs);
            xhr._ioNotifyStart(dfd);
            rDfd = _script.get(ioArgs.url, {timeout:args.timeout, jsonp:ioArgs.jsonp, checkString:args.checkString, ioArgs:ioArgs, frameDoc:args.frameDoc, canAttach:function (rDfd) {
                ioArgs.requestId = rDfd.id;
                ioArgs.scriptId = rDfd.scriptId;
                ioArgs.canDelete = rDfd.canDelete;
                return script._canAttach(ioArgs);
            }}, true);
            aspect.around(rDfd, "isValid", function (isValid) {
                return function (response) {
                    script._validCheck(dfd);
                    return isValid.call(this, response);
                };
            });
            rDfd.then(function () {
                dfd.resolve(dfd);
            }).otherwise(function (error) {
                dfd.ioArgs.error = error;
                dfd.reject(error);
            });
            return dfd;
        }, attach:_script._attach, remove:_script._remove, _makeScriptDeferred:function (args, cancel) {
            var dfd = xhr._ioSetArgs(args, cancel || this._deferredCancel, this._deferredOk, this._deferredError);
            var ioArgs = dfd.ioArgs;
            ioArgs.id = kernel._scopeName + "IoScript" + (this._counter++);
            ioArgs.canDelete = false;
            ioArgs.jsonp = args.callbackParamName || args.jsonp;
            if (ioArgs.jsonp) {
                ioArgs.query = ioArgs.query || "";
                if (ioArgs.query.length > 0) {
                    ioArgs.query += "&";
                }
                ioArgs.query += ioArgs.jsonp + "=" + (args.frameDoc ? "parent." : "") + kernel._scopeName + ".io.script.jsonp_" + ioArgs.id + "._jsonpCallback";
                ioArgs.frameDoc = args.frameDoc;
                ioArgs.canDelete = true;
                dfd._jsonpCallback = this._jsonpCallback;
                this["jsonp_" + ioArgs.id] = dfd;
            }
            dfd.addBoth(function (value) {
                if (ioArgs.canDelete) {
                    if (value instanceof Error) {
                        script["jsonp_" + ioArgs.id]._jsonpCallback = function () {
                            delete script["jsonp_" + ioArgs.id];
                            if (ioArgs.requestId) {
                                kernel.global[_script._callbacksProperty][ioArgs.requestId]();
                            }
                        };
                    } else {
                        script._addDeadScript(ioArgs);
                    }
                }
            });
            return dfd;
        }, _deferredCancel:function (dfd) {
            dfd.canceled = true;
        }, _deferredOk:function (dfd) {
            var ioArgs = dfd.ioArgs;
            return ioArgs.json || ioArgs.scriptLoaded || ioArgs;
        }, _deferredError:function (error, dfd) {
            console.log("dojo.io.script error", error);
            return error;
        }, _deadScripts:[], _counter:1, _addDeadScript:function (ioArgs) {
            script._deadScripts.push({id:ioArgs.id, frameDoc:ioArgs.frameDoc});
            ioArgs.frameDoc = null;
        }, _validCheck:function (dfd) {
            var deadScripts = script._deadScripts;
            if (deadScripts && deadScripts.length > 0) {
                for (var i = 0; i < deadScripts.length; i++) {
                    script.remove(deadScripts[i].id, deadScripts[i].frameDoc);
                    delete script["jsonp_" + deadScripts[i].id];
                    deadScripts[i].frameDoc = null;
                }
                script._deadScripts = [];
            }
            return true;
        }, _ioCheck:function (dfd) {
            var ioArgs = dfd.ioArgs;
            if (ioArgs.json || (ioArgs.scriptLoaded && !ioArgs.args.checkString)) {
                return true;
            }
            var checkString = ioArgs.args.checkString;
            return checkString && eval("typeof(" + checkString + ") != 'undefined'");
        }, _resHandle:function (dfd) {
            if (script._ioCheck(dfd)) {
                dfd.callback(dfd);
            } else {
                dfd.errback(new Error("inconceivable dojo.io.script._resHandle error"));
            }
        }, _canAttach:function () {
            return true;
        }, _jsonpCallback:function (json) {
            this.ioArgs.json = json;
            if (this.ioArgs.requestId) {
                kernel.global[_script._callbacksProperty][this.ioArgs.requestId](json);
            }
        }};
        lang.setObject("dojo.io.script", script);
        return script;
    });
}, "dijit/_TimePicker":function () {
    define(["dojo/_base/array", "dojo/date", "dojo/date/locale", "dojo/date/stamp", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-construct", "dojo/_base/kernel", "dojo/keys", "dojo/_base/lang", "dojo/sniff", "dojo/query", "dojo/mouse", "dojo/on", "./_WidgetBase", "./form/_ListMouseMixin"], function (array, ddate, locale, stamp, declare, domClass, domConstruct, kernel, keys, lang, has, query, mouse, on, _WidgetBase, _ListMouseMixin) {
        var TimePicker = declare("dijit._TimePicker", [_WidgetBase, _ListMouseMixin], {baseClass:"dijitTimePicker", clickableIncrement:"T00:15:00", visibleIncrement:"T01:00:00", value:new Date(), _visibleIncrement:2, _clickableIncrement:1, _totalIncrements:10, constraints:{}, serialize:stamp.toISOString, buildRendering:function () {
            this.inherited(arguments);
            this.containerNode = this.domNode;
            this.timeMenu = this.domNode;
        }, setValue:function (value) {
            kernel.deprecated("dijit._TimePicker:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
            this.set("value", value);
        }, _setValueAttr:function (date) {
            this._set("value", date);
            this._showText();
        }, _setFilterStringAttr:function (val) {
            this._set("filterString", val);
            this._showText();
        }, isDisabledDate:function () {
            return false;
        }, _getFilteredNodes:function (start, maxNum, before, lastNode) {
            var nodes = [];
            for (var i = 0; i < this._maxIncrement; i++) {
                var n = this._createOption(i);
                if (n) {
                    nodes.push(n);
                }
            }
            return nodes;
        }, _showText:function () {
            var fromIso = stamp.fromISOString;
            this.domNode.innerHTML = "";
            this._clickableIncrementDate = fromIso(this.clickableIncrement);
            this._visibleIncrementDate = fromIso(this.visibleIncrement);
            var sinceMidnight = function (date) {
                return date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds();
            }, clickableIncrementSeconds = sinceMidnight(this._clickableIncrementDate), visibleIncrementSeconds = sinceMidnight(this._visibleIncrementDate), time = (this.value || this.currentFocus).getTime();
            this._refDate = fromIso("T00:00:00");
            this._refDate.setFullYear(1970, 0, 1);
            this._clickableIncrement = 1;
            this._visibleIncrement = visibleIncrementSeconds / clickableIncrementSeconds;
            this._maxIncrement = (60 * 60 * 24) / clickableIncrementSeconds;
            var nodes = this._getFilteredNodes();
            array.forEach(nodes, function (n) {
                this.domNode.appendChild(n);
            }, this);
            if (!nodes.length && this.filterString) {
                this.filterString = "";
                this._showText();
            }
        }, constructor:function () {
            this.constraints = {};
        }, postMixInProperties:function () {
            this.inherited(arguments);
            this._setConstraintsAttr(this.constraints);
        }, _setConstraintsAttr:function (constraints) {
            for (var key in {clickableIncrement:1, visibleIncrement:1}) {
                if (key in constraints) {
                    this[key] = constraints[key];
                }
            }
            if (!constraints.locale) {
                constraints.locale = this.lang;
            }
        }, _createOption:function (index) {
            var date = new Date(this._refDate);
            var incrementDate = this._clickableIncrementDate;
            date.setHours(date.getHours() + incrementDate.getHours() * index, date.getMinutes() + incrementDate.getMinutes() * index, date.getSeconds() + incrementDate.getSeconds() * index);
            if (this.constraints.selector == "time") {
                date.setFullYear(1970, 0, 1);
            }
            var dateString = locale.format(date, this.constraints);
            if (this.filterString && dateString.toLowerCase().indexOf(this.filterString) !== 0) {
                return null;
            }
            var div = this.ownerDocument.createElement("div");
            div.className = this.baseClass + "Item";
            div.date = date;
            div.idx = index;
            domConstruct.create("div", {"class":this.baseClass + "ItemInner", innerHTML:dateString}, div);
            if (index % this._visibleIncrement < 1 && index % this._visibleIncrement > -1) {
                domClass.add(div, this.baseClass + "Marker");
            } else {
                if (!(index % this._clickableIncrement)) {
                    domClass.add(div, this.baseClass + "Tick");
                }
            }
            if (this.isDisabledDate(date)) {
                domClass.add(div, this.baseClass + "ItemDisabled");
            }
            if (this.value && !ddate.compare(this.value, date, this.constraints.selector)) {
                div.selected = true;
                domClass.add(div, this.baseClass + "ItemSelected");
                this._selectedDiv = div;
                if (domClass.contains(div, this.baseClass + "Marker")) {
                    domClass.add(div, this.baseClass + "MarkerSelected");
                } else {
                    domClass.add(div, this.baseClass + "TickSelected");
                }
                this._highlightOption(div, true);
            }
            return div;
        }, onOpen:function () {
            this.inherited(arguments);
            this.set("selected", this._selectedDiv);
        }, _onOptionSelected:function (tgt) {
            var tdate = tgt.target.date || tgt.target.parentNode.date;
            if (!tdate || this.isDisabledDate(tdate)) {
                return;
            }
            this._highlighted_option = null;
            this.set("value", tdate);
            this.onChange(tdate);
        }, onChange:function () {
        }, _highlightOption:function (node, highlight) {
            if (!node) {
                return;
            }
            if (highlight) {
                if (this._highlighted_option) {
                    this._highlightOption(this._highlighted_option, false);
                }
                this._highlighted_option = node;
            } else {
                if (this._highlighted_option !== node) {
                    return;
                } else {
                    this._highlighted_option = null;
                }
            }
            domClass.toggle(node, this.baseClass + "ItemHover", highlight);
            if (domClass.contains(node, this.baseClass + "Marker")) {
                domClass.toggle(node, this.baseClass + "MarkerHover", highlight);
            } else {
                domClass.toggle(node, this.baseClass + "TickHover", highlight);
            }
        }, handleKey:function (e) {
            if (e.keyCode == keys.DOWN_ARROW) {
                this.selectNextNode();
                e.stopPropagation();
                e.preventDefault();
                return false;
            } else {
                if (e.keyCode == keys.UP_ARROW) {
                    this.selectPreviousNode();
                    e.stopPropagation();
                    e.preventDefault();
                    return false;
                } else {
                    if (e.keyCode == keys.ENTER || e.keyCode === keys.TAB) {
                        if (!this._keyboardSelected && e.keyCode === keys.TAB) {
                            return true;
                        }
                        if (this._highlighted_option) {
                            this._onOptionSelected({target:this._highlighted_option});
                        }
                        return e.keyCode === keys.TAB;
                    }
                }
            }
            return undefined;
        }, onHover:function (node) {
            this._highlightOption(node, true);
        }, onUnhover:function (node) {
            this._highlightOption(node, false);
        }, onSelect:function (node) {
            this._highlightOption(node, true);
        }, onDeselect:function (node) {
            this._highlightOption(node, false);
        }, onClick:function (node) {
            this._onOptionSelected({target:node});
        }});
        return TimePicker;
    });
}, "dojo/Evented":function () {
    define(["./aspect", "./on"], function (aspect, on) {
        "use strict";
        var after = aspect.after;
        function Evented() {
        }
        Evented.prototype = {on:function (type, listener) {
            return on.parse(this, type, listener, function (target, type) {
                return after(target, "on" + type, listener, true);
            });
        }, emit:function (type, event) {
            var args = [this];
            args.push.apply(args, arguments);
            return on.emit.apply(on, args);
        }};
        return Evented;
    });
}, "dojox/widget/Standby":function () {
    define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/event", "dojo/_base/sniff", "dojo/dom", "dojo/dom-attr", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/window", "dojo/_base/window", "dojo/_base/fx", "dojo/fx", "dijit/_Widget", "dijit/_TemplatedMixin", "dijit/registry"], function (kernel, declare, array, event, has, dom, attr, construct, geometry, domStyle, window, baseWindow, baseFx, fx, _Widget, _TemplatedMixin, registry) {
        kernel.experimental("dojox.widget.Standby");
        return declare("dojox.widget.Standby", [_Widget, _TemplatedMixin], {image:require.toUrl("dojox/widget/Standby/images/loading.gif").toString(), imageText:"Please Wait...", text:"Please wait...", centerIndicator:"image", target:"", color:"#C0C0C0", duration:500, zIndex:"auto", opacity:0.75, templateString:"<div>" + "<div style=\"display: none; opacity: 0; z-index: 9999; " + "position: absolute; cursor:wait;\" dojoAttachPoint=\"_underlayNode\"></div>" + "<img src=\"${image}\" style=\"opacity: 0; display: none; z-index: -10000; " + "position: absolute; top: 0px; left: 0px; cursor:wait;\" " + "dojoAttachPoint=\"_imageNode\">" + "<div style=\"opacity: 0; display: none; z-index: -10000; position: absolute; " + "top: 0px;\" dojoAttachPoint=\"_textNode\"></div>" + "</div>", _underlayNode:null, _imageNode:null, _textNode:null, _centerNode:null, _displayed:false, _resizeCheck:null, _started:false, _parent:null, startup:function (args) {
            if (!this._started) {
                if (typeof this.target === "string") {
                    var w = registry.byId(this.target);
                    this.target = w ? w.domNode : dom.byId(this.target);
                }
                if (this.text) {
                    this._textNode.innerHTML = this.text;
                }
                if (this.centerIndicator === "image") {
                    this._centerNode = this._imageNode;
                    attr.set(this._imageNode, "src", this.image);
                    attr.set(this._imageNode, "alt", this.imageText);
                } else {
                    this._centerNode = this._textNode;
                }
                domStyle.set(this._underlayNode, {display:"none", backgroundColor:this.color});
                domStyle.set(this._centerNode, "display", "none");
                this.connect(this._underlayNode, "onclick", "_ignore");
                if (this.domNode.parentNode && this.domNode.parentNode != baseWindow.body()) {
                    baseWindow.body().appendChild(this.domNode);
                }
                if (has("ie") == 7) {
                    this._ieFixNode = construct.create("div");
                    domStyle.set(this._ieFixNode, {opacity:"0", zIndex:"-1000", position:"absolute", top:"-1000px"});
                    baseWindow.body().appendChild(this._ieFixNode);
                }
                this.inherited(arguments);
            }
        }, show:function () {
            if (!this._displayed) {
                if (this._anim) {
                    this._anim.stop();
                    delete this._anim;
                }
                this._displayed = true;
                this._size();
                this._disableOverflow();
                this._fadeIn();
            }
        }, hide:function () {
            if (this._displayed) {
                if (this._anim) {
                    this._anim.stop();
                    delete this._anim;
                }
                this._size();
                this._fadeOut();
                this._displayed = false;
                if (this._resizeCheck !== null) {
                    clearInterval(this._resizeCheck);
                    this._resizeCheck = null;
                }
            }
        }, isVisible:function () {
            return this._displayed;
        }, onShow:function () {
        }, onHide:function () {
        }, uninitialize:function () {
            this._displayed = false;
            if (this._resizeCheck) {
                clearInterval(this._resizeCheck);
            }
            domStyle.set(this._centerNode, "display", "none");
            domStyle.set(this._underlayNode, "display", "none");
            if (has("ie") == 7 && this._ieFixNode) {
                baseWindow.body().removeChild(this._ieFixNode);
                delete this._ieFixNode;
            }
            if (this._anim) {
                this._anim.stop();
                delete this._anim;
            }
            this.target = null;
            this._imageNode = null;
            this._textNode = null;
            this._centerNode = null;
            this.inherited(arguments);
        }, _size:function () {
            if (this._displayed) {
                var dir = attr.get(baseWindow.body(), "dir");
                if (dir) {
                    dir = dir.toLowerCase();
                }
                var _ie7zoom;
                var scrollers = this._scrollerWidths();
                var target = this.target;
                var curStyle = domStyle.get(this._centerNode, "display");
                domStyle.set(this._centerNode, "display", "block");
                var box = geometry.position(target, true);
                if (target === baseWindow.body() || target === baseWindow.doc) {
                    box = window.getBox();
                    box.x = box.l;
                    box.y = box.t;
                }
                var cntrIndicator = geometry.getMarginBox(this._centerNode);
                domStyle.set(this._centerNode, "display", curStyle);
                if (this._ieFixNode) {
                    _ie7zoom = -this._ieFixNode.offsetTop / 1000;
                    box.x = Math.floor((box.x + 0.9) / _ie7zoom);
                    box.y = Math.floor((box.y + 0.9) / _ie7zoom);
                    box.w = Math.floor((box.w + 0.9) / _ie7zoom);
                    box.h = Math.floor((box.h + 0.9) / _ie7zoom);
                }
                var zi = domStyle.get(target, "zIndex");
                var ziUl = zi;
                var ziIn = zi;
                if (this.zIndex === "auto") {
                    if (zi != "auto") {
                        ziUl = parseInt(ziUl, 10) + 1;
                        ziIn = parseInt(ziIn, 10) + 2;
                    } else {
                        var cNode = target.parentNode;
                        var oldZi = -100000;
                        while (cNode && cNode !== baseWindow.body()) {
                            zi = domStyle.get(cNode, "zIndex");
                            if (!zi || zi === "auto") {
                                cNode = cNode.parentNode;
                            } else {
                                var newZi = parseInt(zi, 10);
                                if (oldZi < newZi) {
                                    oldZi = newZi;
                                    ziUl = newZi + 1;
                                    ziIn = newZi + 2;
                                }
                                cNode = cNode.parentNode;
                            }
                        }
                    }
                } else {
                    ziUl = parseInt(this.zIndex, 10) + 1;
                    ziIn = parseInt(this.zIndex, 10) + 2;
                }
                domStyle.set(this._centerNode, "zIndex", ziIn);
                domStyle.set(this._underlayNode, "zIndex", ziUl);
                var pn = target.parentNode;
                if (pn && pn !== baseWindow.body() && target !== baseWindow.body() && target !== baseWindow.doc) {
                    var obh = box.h;
                    var obw = box.w;
                    var pnBox = geometry.position(pn, true);
                    if (this._ieFixNode) {
                        _ie7zoom = -this._ieFixNode.offsetTop / 1000;
                        pnBox.x = Math.floor((pnBox.x + 0.9) / _ie7zoom);
                        pnBox.y = Math.floor((pnBox.y + 0.9) / _ie7zoom);
                        pnBox.w = Math.floor((pnBox.w + 0.9) / _ie7zoom);
                        pnBox.h = Math.floor((pnBox.h + 0.9) / _ie7zoom);
                    }
                    pnBox.w -= pn.scrollHeight > pn.clientHeight && pn.clientHeight > 0 ? scrollers.v : 0;
                    pnBox.h -= pn.scrollWidth > pn.clientWidth && pn.clientWidth > 0 ? scrollers.h : 0;
                    if (dir === "rtl") {
                        if (has("opera")) {
                            box.x += pn.scrollHeight > pn.clientHeight && pn.clientHeight > 0 ? scrollers.v : 0;
                            pnBox.x += pn.scrollHeight > pn.clientHeight && pn.clientHeight > 0 ? scrollers.v : 0;
                        } else {
                            if (has("ie")) {
                                pnBox.x += pn.scrollHeight > pn.clientHeight && pn.clientHeight > 0 ? scrollers.v : 0;
                            } else {
                                if (has("webkit")) {
                                }
                            }
                        }
                    }
                    if (pnBox.w < box.w) {
                        box.w = box.w - pnBox.w;
                    }
                    if (pnBox.h < box.h) {
                        box.h = box.h - pnBox.h;
                    }
                    var vpTop = pnBox.y;
                    var vpBottom = pnBox.y + pnBox.h;
                    var bTop = box.y;
                    var bBottom = box.y + obh;
                    var vpLeft = pnBox.x;
                    var vpRight = pnBox.x + pnBox.w;
                    var bLeft = box.x;
                    var bRight = box.x + obw;
                    var delta;
                    if (bBottom > vpTop && bTop < vpTop) {
                        box.y = pnBox.y;
                        delta = vpTop - bTop;
                        var visHeight = obh - delta;
                        if (visHeight < pnBox.h) {
                            box.h = visHeight;
                        } else {
                            box.h -= 2 * (pn.scrollWidth > pn.clientWidth && pn.clientWidth > 0 ? scrollers.h : 0);
                        }
                    } else {
                        if (bTop < vpBottom && bBottom > vpBottom) {
                            box.h = vpBottom - bTop;
                        } else {
                            if (bBottom <= vpTop || bTop >= vpBottom) {
                                box.h = 0;
                            }
                        }
                    }
                    if (bRight > vpLeft && bLeft < vpLeft) {
                        box.x = pnBox.x;
                        delta = vpLeft - bLeft;
                        var visWidth = obw - delta;
                        if (visWidth < pnBox.w) {
                            box.w = visWidth;
                        } else {
                            box.w -= 2 * (pn.scrollHeight > pn.clientHeight && pn.clientHeight > 0 ? scrollers.w : 0);
                        }
                    } else {
                        if (bLeft < vpRight && bRight > vpRight) {
                            box.w = vpRight - bLeft;
                        } else {
                            if (bRight <= vpLeft || bLeft >= vpRight) {
                                box.w = 0;
                            }
                        }
                    }
                }
                if (box.h > 0 && box.w > 0) {
                    domStyle.set(this._underlayNode, {display:"block", width:box.w + "px", height:box.h + "px", top:box.y + "px", left:box.x + "px"});
                    var styles = ["borderRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"];
                    this._cloneStyles(styles);
                    if (!has("ie")) {
                        styles = ["MozBorderRadius", "MozBorderRadiusTopleft", "MozBorderRadiusTopright", "MozBorderRadiusBottomleft", "MozBorderRadiusBottomright", "WebkitBorderRadius", "WebkitBorderTopLeftRadius", "WebkitBorderTopRightRadius", "WebkitBorderBottomLeftRadius", "WebkitBorderBottomRightRadius"];
                        this._cloneStyles(styles, this);
                    }
                    var cntrIndicatorTop = (box.h / 2) - (cntrIndicator.h / 2);
                    var cntrIndicatorLeft = (box.w / 2) - (cntrIndicator.w / 2);
                    if (box.h >= cntrIndicator.h && box.w >= cntrIndicator.w) {
                        domStyle.set(this._centerNode, {top:(cntrIndicatorTop + box.y) + "px", left:(cntrIndicatorLeft + box.x) + "px", display:"block"});
                    } else {
                        domStyle.set(this._centerNode, "display", "none");
                    }
                } else {
                    domStyle.set(this._underlayNode, "display", "none");
                    domStyle.set(this._centerNode, "display", "none");
                }
                if (this._resizeCheck === null) {
                    var self = this;
                    this._resizeCheck = setInterval(function () {
                        self._size();
                    }, 100);
                }
            }
        }, _cloneStyles:function (list) {
            array.forEach(list, function (s) {
                domStyle.set(this._underlayNode, s, domStyle.get(this.target, s));
            }, this);
        }, _fadeIn:function () {
            var self = this;
            var underlayNodeAnim = baseFx.animateProperty({duration:self.duration, node:self._underlayNode, properties:{opacity:{start:0, end:self.opacity}}});
            var imageAnim = baseFx.animateProperty({duration:self.duration, node:self._centerNode, properties:{opacity:{start:0, end:1}}, onEnd:function () {
                self.onShow();
                delete self._anim;
            }});
            this._anim = fx.combine([underlayNodeAnim, imageAnim]);
            this._anim.play();
        }, _fadeOut:function () {
            var self = this;
            var underlayNodeAnim = baseFx.animateProperty({duration:self.duration, node:self._underlayNode, properties:{opacity:{start:self.opacity, end:0}}, onEnd:function () {
                domStyle.set(this.node, {"display":"none", "zIndex":"-1000"});
            }});
            var imageAnim = baseFx.animateProperty({duration:self.duration, node:self._centerNode, properties:{opacity:{start:1, end:0}}, onEnd:function () {
                domStyle.set(this.node, {"display":"none", "zIndex":"-1000"});
                self.onHide();
                self._enableOverflow();
                delete self._anim;
            }});
            this._anim = fx.combine([underlayNodeAnim, imageAnim]);
            this._anim.play();
        }, _ignore:function (e) {
            if (e) {
                event.stop(e);
            }
        }, _scrollerWidths:function () {
            var div = construct.create("div");
            domStyle.set(div, {position:"absolute", opacity:0, overflow:"hidden", width:"50px", height:"50px", zIndex:"-100", top:"-200px", padding:"0px", margin:"0px"});
            var iDiv = construct.create("div");
            domStyle.set(iDiv, {width:"200px", height:"10px"});
            div.appendChild(iDiv);
            baseWindow.body().appendChild(div);
            var b = geometry.getContentBox(div);
            domStyle.set(div, "overflow", "scroll");
            var a = geometry.getContentBox(div);
            baseWindow.body().removeChild(div);
            return {v:b.w - a.w, h:b.h - a.h};
        }, _setTextAttr:function (text) {
            this._textNode.innerHTML = text;
            this.text = text;
        }, _setColorAttr:function (c) {
            domStyle.set(this._underlayNode, "backgroundColor", c);
            this.color = c;
        }, _setImageTextAttr:function (text) {
            attr.set(this._imageNode, "alt", text);
            this.imageText = text;
        }, _setImageAttr:function (url) {
            attr.set(this._imageNode, "src", url);
            this.image = url;
        }, _setCenterIndicatorAttr:function (indicator) {
            this.centerIndicator = indicator;
            if (indicator === "image") {
                this._centerNode = this._imageNode;
                domStyle.set(this._textNode, "display", "none");
            } else {
                this._centerNode = this._textNode;
                domStyle.set(this._imageNode, "display", "none");
            }
        }, _disableOverflow:function () {
            if (this.target === baseWindow.body() || this.target === baseWindow.doc) {
                this._overflowDisabled = true;
                var body = baseWindow.body();
                if (body.style && body.style.overflow) {
                    this._oldOverflow = domStyle.get(body, "overflow");
                } else {
                    this._oldOverflow = "";
                }
                if (has("ie") && !has("quirks")) {
                    if (body.parentNode && body.parentNode.style && body.parentNode.style.overflow) {
                        this._oldBodyParentOverflow = body.parentNode.style.overflow;
                    } else {
                        try {
                            this._oldBodyParentOverflow = domStyle.get(body.parentNode, "overflow");
                        }
                        catch (e) {
                            this._oldBodyParentOverflow = "scroll";
                        }
                    }
                    domStyle.set(body.parentNode, "overflow", "hidden");
                }
                domStyle.set(body, "overflow", "hidden");
            }
        }, _enableOverflow:function () {
            if (this._overflowDisabled) {
                delete this._overflowDisabled;
                var body = baseWindow.body();
                if (has("ie") && !has("quirks")) {
                    body.parentNode.style.overflow = this._oldBodyParentOverflow;
                    delete this._oldBodyParentOverflow;
                }
                domStyle.set(body, "overflow", this._oldOverflow);
                if (has("webkit")) {
                    var div = construct.create("div", {style:{height:"2px"}});
                    body.appendChild(div);
                    setTimeout(function () {
                        body.removeChild(div);
                    }, 0);
                }
                delete this._oldOverflow;
            }
        }});
    });
}, "dojox/uuid/Uuid":function () {
    define(["dojo/_base/lang", "./_base"], function (dojo, uuid) {
        dojox.uuid.Uuid = function (input) {
            this._uuidString = dojox.uuid.NIL_UUID;
            if (input) {
                dojox.uuid.assert(dojo.isString(input));
                this._uuidString = input.toLowerCase();
                dojox.uuid.assert(this.isValid());
            } else {
                var ourGenerator = dojox.uuid.Uuid.getGenerator();
                if (ourGenerator) {
                    this._uuidString = ourGenerator();
                    dojox.uuid.assert(this.isValid());
                }
            }
        };
        dojox.uuid.Uuid.compare = function (uuidOne, uuidTwo) {
            var uuidStringOne = uuidOne.toString();
            var uuidStringTwo = uuidTwo.toString();
            if (uuidStringOne > uuidStringTwo) {
                return 1;
            }
            if (uuidStringOne < uuidStringTwo) {
                return -1;
            }
            return 0;
        };
        dojox.uuid.Uuid.setGenerator = function (generator) {
            dojox.uuid.assert(!generator || dojo.isFunction(generator));
            dojox.uuid.Uuid._ourGenerator = generator;
        };
        dojox.uuid.Uuid.getGenerator = function () {
            return dojox.uuid.Uuid._ourGenerator;
        };
        dojox.uuid.Uuid.prototype.toString = function () {
            return this._uuidString;
        };
        dojox.uuid.Uuid.prototype.compare = function (otherUuid) {
            return dojox.uuid.Uuid.compare(this, otherUuid);
        };
        dojox.uuid.Uuid.prototype.isEqual = function (otherUuid) {
            return (this.compare(otherUuid) == 0);
        };
        dojox.uuid.Uuid.prototype.isValid = function () {
            return dojox.uuid.isValid(this);
        };
        dojox.uuid.Uuid.prototype.getVariant = function () {
            return dojox.uuid.getVariant(this);
        };
        dojox.uuid.Uuid.prototype.getVersion = function () {
            if (!this._versionNumber) {
                this._versionNumber = dojox.uuid.getVersion(this);
            }
            return this._versionNumber;
        };
        dojox.uuid.Uuid.prototype.getNode = function () {
            if (!this._nodeString) {
                this._nodeString = dojox.uuid.getNode(this);
            }
            return this._nodeString;
        };
        dojox.uuid.Uuid.prototype.getTimestamp = function (returnType) {
            if (!returnType) {
                returnType = null;
            }
            switch (returnType) {
              case "string":
              case String:
                return this.getTimestamp(Date).toUTCString();
                break;
              case "hex":
                if (!this._timestampAsHexString) {
                    this._timestampAsHexString = dojox.uuid.getTimestamp(this, "hex");
                }
                return this._timestampAsHexString;
                break;
              case null:
              case "date":
              case Date:
                if (!this._timestampAsDate) {
                    this._timestampAsDate = dojox.uuid.getTimestamp(this, Date);
                }
                return this._timestampAsDate;
                break;
              default:
                dojox.uuid.assert(false, "The getTimestamp() method dojox.uuid.Uuid was passed a bogus returnType: " + returnType);
                break;
            }
        };
        return dojox.uuid.Uuid;
    });
}, "dojo/dnd/Avatar":function () {
    define(["../_base/declare", "../_base/window", "../dom", "../dom-attr", "../dom-class", "../dom-construct", "../hccss", "../query"], function (declare, win, dom, domAttr, domClass, domConstruct, has, query) {
        return declare("dojo.dnd.Avatar", null, {constructor:function (manager) {
            this.manager = manager;
            this.construct();
        }, construct:function () {
            var a = domConstruct.create("table", {"class":"dojoDndAvatar", style:{position:"absolute", zIndex:"1999", margin:"0px"}}), source = this.manager.source, node, b = domConstruct.create("tbody", null, a), tr = domConstruct.create("tr", null, b), td = domConstruct.create("td", null, tr), k = Math.min(5, this.manager.nodes.length), i = 0;
            if (has("highcontrast")) {
                domConstruct.create("span", {id:"a11yIcon", innerHTML:this.manager.copy ? "+" : "<"}, td);
            }
            domConstruct.create("span", {innerHTML:source.generateText ? this._generateText() : ""}, td);
            domAttr.set(tr, {"class":"dojoDndAvatarHeader", style:{opacity:0.9}});
            for (; i < k; ++i) {
                if (source.creator) {
                    node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
                } else {
                    node = this.manager.nodes[i].cloneNode(true);
                    if (node.tagName.toLowerCase() == "tr") {
                        var table = domConstruct.create("table"), tbody = domConstruct.create("tbody", null, table);
                        tbody.appendChild(node);
                        node = table;
                    }
                }
                node.id = "";
                tr = domConstruct.create("tr", null, b);
                td = domConstruct.create("td", null, tr);
                td.appendChild(node);
                domAttr.set(tr, {"class":"dojoDndAvatarItem", style:{opacity:(9 - i) / 10}});
            }
            this.node = a;
        }, destroy:function () {
            domConstruct.destroy(this.node);
            this.node = false;
        }, update:function () {
            domClass.toggle(this.node, "dojoDndAvatarCanDrop", this.manager.canDropFlag);
            if (has("highcontrast")) {
                var icon = dom.byId("a11yIcon");
                var text = "+";
                if (this.manager.canDropFlag && !this.manager.copy) {
                    text = "< ";
                } else {
                    if (!this.manager.canDropFlag && !this.manager.copy) {
                        text = "o";
                    } else {
                        if (!this.manager.canDropFlag) {
                            text = "x";
                        }
                    }
                }
                icon.innerHTML = text;
            }
            query(("tr.dojoDndAvatarHeader td span" + (has("highcontrast") ? " span" : "")), this.node).forEach(function (node) {
                node.innerHTML = this.manager.source.generateText ? this._generateText() : "";
            }, this);
        }, _generateText:function () {
            return this.manager.nodes.length.toString();
        }});
    });
}, "dojo/string":function () {
    define(["./_base/kernel", "./_base/lang"], function (kernel, lang) {
        var string = {};
        lang.setObject("dojo.string", string);
        string.rep = function (str, num) {
            if (num <= 0 || !str) {
                return "";
            }
            var buf = [];
            for (; ; ) {
                if (num & 1) {
                    buf.push(str);
                }
                if (!(num >>= 1)) {
                    break;
                }
                str += str;
            }
            return buf.join("");
        };
        string.pad = function (text, size, ch, end) {
            if (!ch) {
                ch = "0";
            }
            var out = String(text), pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
            return end ? out + pad : pad + out;
        };
        string.substitute = function (template, map, transform, thisObject) {
            thisObject = thisObject || kernel.global;
            transform = transform ? lang.hitch(thisObject, transform) : function (v) {
                return v;
            };
            return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key, format) {
                var value = lang.getObject(key, false, map);
                if (format) {
                    value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
                }
                return transform(value, key).toString();
            });
        };
        string.trim = String.prototype.trim ? lang.trim : function (str) {
            str = str.replace(/^\s+/, "");
            for (var i = str.length - 1; i >= 0; i--) {
                if (/\S/.test(str.charAt(i))) {
                    str = str.substring(0, i + 1);
                    break;
                }
            }
            return str;
        };
        return string;
    });
}, "dijit/_Contained":function () {
    define(["dojo/_base/declare", "./registry"], function (declare, registry) {
        return declare("dijit._Contained", null, {_getSibling:function (which) {
            var node = this.domNode;
            do {
                node = node[which + "Sibling"];
            } while (node && node.nodeType != 1);
            return node && registry.byNode(node);
        }, getPreviousSibling:function () {
            return this._getSibling("previous");
        }, getNextSibling:function () {
            return this._getSibling("next");
        }, getIndexInParent:function () {
            var p = this.getParent();
            if (!p || !p.getIndexOfChild) {
                return -1;
            }
            return p.getIndexOfChild(this);
        }});
    });
}, "dojox/grid/enhanced/plugins/DnD":function () {
    define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/html", "dojo/_base/json", "dojo/_base/window", "dojo/query", "dojo/keys", "dojo/dnd/Source", "dojo/dnd/Avatar", "../_Plugin", "../../EnhancedGrid", "dojo/dnd/Manager", "./Selector", "./Rearrange"], function (dojo, declare, connect, array, lang, html, json, win, query, keys, Source, Avatar, _Plugin, EnhancedGrid, Manager) {
        var _devideToArrays = function (a) {
            a.sort(function (v1, v2) {
                return v1 - v2;
            });
            var arr = [[a[0]]];
            for (var i = 1, j = 0; i < a.length; ++i) {
                if (a[i] == a[i - 1] + 1) {
                    arr[j].push(a[i]);
                } else {
                    arr[++j] = [a[i]];
                }
            }
            return arr;
        }, _joinToArray = function (arrays) {
            var a = arrays[0];
            for (var i = 1; i < arrays.length; ++i) {
                a = a.concat(arrays[i]);
            }
            return a;
        };
        var GridDnDElement = declare("dojox.grid.enhanced.plugins.GridDnDElement", null, {constructor:function (dndPlugin) {
            this.plugin = dndPlugin;
            this.node = html.create("div");
            this._items = {};
        }, destroy:function () {
            this.plugin = null;
            html.destroy(this.node);
            this.node = null;
            this._items = null;
        }, createDnDNodes:function (dndRegion) {
            this.destroyDnDNodes();
            var acceptType = ["grid/" + dndRegion.type + "s"];
            var itemNodeIdBase = this.plugin.grid.id + "_dndItem";
            array.forEach(dndRegion.selected, function (range, i) {
                var id = itemNodeIdBase + i;
                this._items[id] = {"type":acceptType, "data":range, "dndPlugin":this.plugin};
                this.node.appendChild(html.create("div", {"id":id}));
            }, this);
        }, getDnDNodes:function () {
            return array.map(this.node.childNodes, function (node) {
                return node;
            });
        }, destroyDnDNodes:function () {
            html.empty(this.node);
            this._items = {};
        }, getItem:function (nodeId) {
            return this._items[nodeId];
        }});
        var GridDnDSource = declare("dojox.grid.enhanced.plugins.GridDnDSource", Source, {accept:["grid/cells", "grid/rows", "grid/cols"], constructor:function (node, param) {
            this.grid = param.grid;
            this.dndElem = param.dndElem;
            this.dndPlugin = param.dnd;
            this.sourcePlugin = null;
        }, destroy:function () {
            this.inherited(arguments);
            this.grid = null;
            this.dndElem = null;
            this.dndPlugin = null;
            this.sourcePlugin = null;
        }, getItem:function (nodeId) {
            return this.dndElem.getItem(nodeId);
        }, checkAcceptance:function (source, nodes) {
            if (this != source && nodes[0]) {
                var item = source.getItem(nodes[0].id);
                if (item.dndPlugin) {
                    var type = item.type;
                    for (var j = 0; j < type.length; ++j) {
                        if (type[j] in this.accept) {
                            if (this.dndPlugin._canAccept(item.dndPlugin)) {
                                this.sourcePlugin = item.dndPlugin;
                            } else {
                                return false;
                            }
                            break;
                        }
                    }
                } else {
                    if ("grid/rows" in this.accept) {
                        var rows = [];
                        array.forEach(nodes, function (node) {
                            var item = source.getItem(node.id);
                            if (item.data && array.indexOf(item.type, "grid/rows") >= 0) {
                                var rowData = item.data;
                                if (typeof item.data == "string") {
                                    rowData = json.fromJson(item.data);
                                }
                                if (rowData) {
                                    rows.push(rowData);
                                }
                            }
                        });
                        if (rows.length) {
                            this.sourcePlugin = {_dndRegion:{type:"row", selected:[rows]}};
                        } else {
                            return false;
                        }
                    }
                }
            }
            return this.inherited(arguments);
        }, onDraggingOver:function () {
            this.dndPlugin.onDraggingOver(this.sourcePlugin);
        }, onDraggingOut:function () {
            this.dndPlugin.onDraggingOut(this.sourcePlugin);
        }, onDndDrop:function (source, nodes, copy, target) {
            this.onDndCancel();
            if (this != source && this == target) {
                this.dndPlugin.onDragIn(this.sourcePlugin, copy);
            }
        }});
        var GridDnDAvatar = declare("dojox.grid.enhanced.plugins.GridDnDAvatar", Avatar, {construct:function () {
            this._itemType = this.manager._dndPlugin._dndRegion.type;
            this._itemCount = this._getItemCount();
            this.isA11y = html.hasClass(win.body(), "dijit_a11y");
            var a = html.create("table", {"border":"0", "cellspacing":"0", "class":"dojoxGridDndAvatar", "style":{position:"absolute", zIndex:"1999", margin:"0px"}}), source = this.manager.source, b = html.create("tbody", null, a), tr = html.create("tr", null, b), td = html.create("td", {"class":"dojoxGridDnDIcon"}, tr);
            if (this.isA11y) {
                html.create("span", {"id":"a11yIcon", "innerHTML":this.manager.copy ? "+" : "<"}, td);
            }
            td = html.create("td", {"class":"dojoxGridDnDItemIcon " + this._getGridDnDIconClass()}, tr);
            td = html.create("td", null, tr);
            html.create("span", {"class":"dojoxGridDnDItemCount", "innerHTML":source.generateText ? this._generateText() : ""}, td);
            html.style(tr, {"opacity":0.9});
            this.node = a;
        }, _getItemCount:function () {
            var selected = this.manager._dndPlugin._dndRegion.selected, count = 0;
            switch (this._itemType) {
              case "cell":
                selected = selected[0];
                var cells = this.manager._dndPlugin.grid.layout.cells, colCount = selected.max.col - selected.min.col + 1, rowCount = selected.max.row - selected.min.row + 1;
                if (colCount > 1) {
                    for (var i = selected.min.col; i <= selected.max.col; ++i) {
                        if (cells[i].hidden) {
                            --colCount;
                        }
                    }
                }
                count = colCount * rowCount;
                break;
              case "row":
              case "col":
                count = _joinToArray(selected).length;
            }
            return count;
        }, _getGridDnDIconClass:function () {
            return {"row":["dojoxGridDnDIconRowSingle", "dojoxGridDnDIconRowMulti"], "col":["dojoxGridDnDIconColSingle", "dojoxGridDnDIconColMulti"], "cell":["dojoxGridDnDIconCellSingle", "dojoxGridDnDIconCellMulti"]}[this._itemType][this._itemCount == 1 ? 0 : 1];
        }, _generateText:function () {
            return "(" + this._itemCount + ")";
        }});
        var DnD = declare("dojox.grid.enhanced.plugins.DnD", _Plugin, {name:"dnd", _targetAnchorBorderWidth:2, _copyOnly:false, _config:{"row":{"within":true, "in":true, "out":true}, "col":{"within":true, "in":true, "out":true}, "cell":{"within":true, "in":true, "out":true}}, constructor:function (grid, args) {
            this.grid = grid;
            this._config = lang.clone(this._config);
            args = lang.isObject(args) ? args : {};
            this.setupConfig(args.dndConfig);
            this._copyOnly = !!args.copyOnly;
            this._mixinGrid();
            this.selector = grid.pluginMgr.getPlugin("selector");
            this.rearranger = grid.pluginMgr.getPlugin("rearrange");
            this.rearranger.setArgs(args);
            this._clear();
            this._elem = new GridDnDElement(this);
            this._source = new GridDnDSource(this._elem.node, {"grid":grid, "dndElem":this._elem, "dnd":this});
            this._container = query(".dojoxGridMasterView", this.grid.domNode)[0];
            this._initEvents();
        }, destroy:function () {
            this.inherited(arguments);
            this._clear();
            this._source.destroy();
            this._elem.destroy();
            this._container = null;
            this.grid = null;
            this.selector = null;
            this.rearranger = null;
            this._config = null;
        }, _mixinGrid:function () {
            this.grid.setupDnDConfig = lang.hitch(this, "setupConfig");
            this.grid.dndCopyOnly = lang.hitch(this, "copyOnly");
        }, setupConfig:function (config) {
            if (config && lang.isObject(config)) {
                var firstLevel = ["row", "col", "cell"], secondLevel = ["within", "in", "out"], cfg = this._config;
                array.forEach(firstLevel, function (type) {
                    if (type in config) {
                        var t = config[type];
                        if (t && lang.isObject(t)) {
                            array.forEach(secondLevel, function (mode) {
                                if (mode in t) {
                                    cfg[type][mode] = !!t[mode];
                                }
                            });
                        } else {
                            array.forEach(secondLevel, function (mode) {
                                cfg[type][mode] = !!t;
                            });
                        }
                    }
                });
                array.forEach(secondLevel, function (mode) {
                    if (mode in config) {
                        var m = config[mode];
                        if (m && lang.isObject(m)) {
                            array.forEach(firstLevel, function (type) {
                                if (type in m) {
                                    cfg[type][mode] = !!m[type];
                                }
                            });
                        } else {
                            array.forEach(firstLevel, function (type) {
                                cfg[type][mode] = !!m;
                            });
                        }
                    }
                });
            }
        }, copyOnly:function (isCopyOnly) {
            if (typeof isCopyOnly != "undefined") {
                this._copyOnly = !!isCopyOnly;
            }
            return this._copyOnly;
        }, _isOutOfGrid:function (evt) {
            var gridPos = html.position(this.grid.domNode), x = evt.clientX, y = evt.clientY;
            return y < gridPos.y || y > gridPos.y + gridPos.h || x < gridPos.x || x > gridPos.x + gridPos.w;
        }, _onMouseMove:function (evt) {
            if (this._dndRegion && !this._dnding && !this._externalDnd) {
                this._dnding = true;
                this._startDnd(evt);
            } else {
                if (this._isMouseDown && !this._dndRegion) {
                    delete this._isMouseDown;
                    this._oldCursor = html.style(win.body(), "cursor");
                    html.style(win.body(), "cursor", "not-allowed");
                }
                var isOut = this._isOutOfGrid(evt);
                if (!this._alreadyOut && isOut) {
                    this._alreadyOut = true;
                    if (this._dnding) {
                        this._destroyDnDUI(true, false);
                    }
                    this._moveEvent = evt;
                    this._source.onOutEvent();
                } else {
                    if (this._alreadyOut && !isOut) {
                        this._alreadyOut = false;
                        if (this._dnding) {
                            this._createDnDUI(evt, true);
                        }
                        this._moveEvent = evt;
                        this._source.onOverEvent();
                    }
                }
            }
        }, _onMouseUp:function () {
            if (!this._extDnding && !this._isSource) {
                var isInner = this._dnding && !this._alreadyOut;
                if (isInner && this._config[this._dndRegion.type]["within"]) {
                    this._rearrange();
                }
                this._endDnd(isInner);
            }
            html.style(win.body(), "cursor", this._oldCursor || "");
            delete this._isMouseDown;
        }, _initEvents:function () {
            var g = this.grid, s = this.selector;
            this.connect(win.doc, "onmousemove", "_onMouseMove");
            this.connect(win.doc, "onmouseup", "_onMouseUp");
            this.connect(g, "onCellMouseOver", function (evt) {
                if (!this._dnding && !s.isSelecting() && !evt.ctrlKey) {
                    this._dndReady = s.isSelected("cell", evt.rowIndex, evt.cell.index);
                    s.selectEnabled(!this._dndReady);
                }
            });
            this.connect(g, "onHeaderCellMouseOver", function (evt) {
                if (this._dndReady) {
                    s.selectEnabled(true);
                }
            });
            this.connect(g, "onRowMouseOver", function (evt) {
                if (this._dndReady && !evt.cell) {
                    s.selectEnabled(true);
                }
            });
            this.connect(g, "onCellMouseDown", function (evt) {
                if (!evt.ctrlKey && this._dndReady) {
                    this._dndRegion = this._getDnDRegion(evt.rowIndex, evt.cell.index);
                    this._isMouseDown = true;
                }
            });
            this.connect(g, "onCellMouseUp", function (evt) {
                if (!this._dndReady && !s.isSelecting() && evt.cell) {
                    this._dndReady = s.isSelected("cell", evt.rowIndex, evt.cell.index);
                    s.selectEnabled(!this._dndReady);
                }
            });
            this.connect(g, "onCellClick", function (evt) {
                if (this._dndReady && !evt.ctrlKey && !evt.shiftKey) {
                    s.select("cell", evt.rowIndex, evt.cell.index);
                }
            });
            this.connect(g, "onEndAutoScroll", function (isVertical, isForward, view, target, evt) {
                if (this._dnding) {
                    this._markTargetAnchor(evt);
                }
            });
            this.connect(win.doc, "onkeydown", function (evt) {
                if (evt.keyCode == keys.ESCAPE) {
                    this._endDnd(false);
                } else {
                    if (evt.keyCode == keys.CTRL) {
                        s.selectEnabled(true);
                        this._isCopy = true;
                    }
                }
            });
            this.connect(win.doc, "onkeyup", function (evt) {
                if (evt.keyCode == keys.CTRL) {
                    s.selectEnabled(!this._dndReady);
                    this._isCopy = false;
                }
            });
        }, _clear:function () {
            this._dndRegion = null;
            this._target = null;
            this._moveEvent = null;
            this._targetAnchor = {};
            this._dnding = false;
            this._externalDnd = false;
            this._isSource = false;
            this._alreadyOut = false;
            this._extDnding = false;
        }, _getDnDRegion:function (rowIndex, colIndex) {
            var s = this.selector, selected = s._selected, flag = (!!selected.cell.length) | (!!selected.row.length << 1) | (!!selected.col.length << 2), type;
            switch (flag) {
              case 1:
                type = "cell";
                if (!this._config[type]["within"] && !this._config[type]["out"]) {
                    return null;
                }
                var cells = this.grid.layout.cells, getCount = function (range) {
                    var hiddenColCnt = 0;
                    for (var i = range.min.col; i <= range.max.col; ++i) {
                        if (cells[i].hidden) {
                            ++hiddenColCnt;
                        }
                    }
                    return (range.max.row - range.min.row + 1) * (range.max.col - range.min.col + 1 - hiddenColCnt);
                }, inRange = function (item, range) {
                    return item.row >= range.min.row && item.row <= range.max.row && item.col >= range.min.col && item.col <= range.max.col;
                }, range = {max:{row:-1, col:-1}, min:{row:Infinity, col:Infinity}};
                array.forEach(selected[type], function (item) {
                    if (item.row < range.min.row) {
                        range.min.row = item.row;
                    }
                    if (item.row > range.max.row) {
                        range.max.row = item.row;
                    }
                    if (item.col < range.min.col) {
                        range.min.col = item.col;
                    }
                    if (item.col > range.max.col) {
                        range.max.col = item.col;
                    }
                });
                if (array.some(selected[type], function (item) {
                    return item.row == rowIndex && item.col == colIndex;
                })) {
                    if (getCount(range) == selected[type].length && array.every(selected[type], function (item) {
                        return inRange(item, range);
                    })) {
                        return {"type":type, "selected":[range], "handle":{"row":rowIndex, "col":colIndex}};
                    }
                }
                return null;
              case 2:
              case 4:
                type = flag == 2 ? "row" : "col";
                if (!this._config[type]["within"] && !this._config[type]["out"]) {
                    return null;
                }
                var res = s.getSelected(type);
                if (res.length) {
                    return {"type":type, "selected":_devideToArrays(res), "handle":flag == 2 ? rowIndex : colIndex};
                }
                return null;
            }
            return null;
        }, _startDnd:function (evt) {
            this._createDnDUI(evt);
        }, _endDnd:function (destroySource) {
            this._destroyDnDUI(false, destroySource);
            this._clear();
        }, _createDnDUI:function (evt, isMovingIn) {
            var viewPos = html.position(this.grid.views.views[0].domNode);
            html.style(this._container, "height", viewPos.h + "px");
            try {
                if (!isMovingIn) {
                    this._createSource(evt);
                }
                this._createMoveable(evt);
                this._oldCursor = html.style(win.body(), "cursor");
                html.style(win.body(), "cursor", "default");
            }
            catch (e) {
                console.warn("DnD._createDnDUI() error:", e);
            }
        }, _destroyDnDUI:function (isMovingOut, destroySource) {
            try {
                if (destroySource) {
                    this._destroySource();
                }
                this._unmarkTargetAnchor();
                if (!isMovingOut) {
                    this._destroyMoveable();
                }
                html.style(win.body(), "cursor", this._oldCursor);
            }
            catch (e) {
                console.warn("DnD._destroyDnDUI() error:", this.grid.id, e);
            }
        }, _createSource:function (evt) {
            this._elem.createDnDNodes(this._dndRegion);
            var m = Manager.manager();
            var oldMakeAvatar = m.makeAvatar;
            m._dndPlugin = this;
            m.makeAvatar = function () {
                var avatar = new GridDnDAvatar(m);
                delete m._dndPlugin;
                return avatar;
            };
            m.startDrag(this._source, this._elem.getDnDNodes(), evt.ctrlKey);
            m.makeAvatar = oldMakeAvatar;
            m.onMouseMove(evt);
        }, _destroySource:function () {
            connect.publish("/dnd/cancel");
        }, _createMoveable:function (evt) {
            if (!this._markTagetAnchorHandler) {
                this._markTagetAnchorHandler = this.connect(win.doc, "onmousemove", "_markTargetAnchor");
            }
        }, _destroyMoveable:function () {
            this.disconnect(this._markTagetAnchorHandler);
            delete this._markTagetAnchorHandler;
        }, _calcColTargetAnchorPos:function (evt, containerPos) {
            var i, headPos, left, target, ex = evt.clientX, cells = this.grid.layout.cells, ltr = html._isBodyLtr(), headers = this._getVisibleHeaders();
            for (i = 0; i < headers.length; ++i) {
                headPos = html.position(headers[i].node);
                if (ltr ? ((i === 0 || ex >= headPos.x) && ex < headPos.x + headPos.w) : ((i === 0 || ex < headPos.x + headPos.w) && ex >= headPos.x)) {
                    left = headPos.x + (ltr ? 0 : headPos.w);
                    break;
                } else {
                    if (ltr ? (i === headers.length - 1 && ex >= headPos.x + headPos.w) : (i === headers.length - 1 && ex < headPos.x)) {
                        ++i;
                        left = headPos.x + (ltr ? headPos.w : 0);
                        break;
                    }
                }
            }
            if (i < headers.length) {
                target = headers[i].cell.index;
                if (this.selector.isSelected("col", target) && this.selector.isSelected("col", target - 1)) {
                    var ranges = this._dndRegion.selected;
                    for (i = 0; i < ranges.length; ++i) {
                        if (array.indexOf(ranges[i], target) >= 0) {
                            target = ranges[i][0];
                            headPos = html.position(cells[target].getHeaderNode());
                            left = headPos.x + (ltr ? 0 : headPos.w);
                            break;
                        }
                    }
                }
            } else {
                target = cells.length;
            }
            this._target = target;
            return left - containerPos.x;
        }, _calcRowTargetAnchorPos:function (evt, containerPos) {
            var g = this.grid, top, i = 0, cells = g.layout.cells;
            while (cells[i].hidden) {
                ++i;
            }
            var cell = g.layout.cells[i], rowIndex = g.scroller.firstVisibleRow, cellNode = cell.getNode(rowIndex);
            if (!cellNode) {
                this._target = -1;
                return 0;
            }
            var nodePos = html.position(cellNode);
            while (nodePos.y + nodePos.h < evt.clientY) {
                if (++rowIndex >= g.rowCount) {
                    break;
                }
                nodePos = html.position(cell.getNode(rowIndex));
            }
            if (rowIndex < g.rowCount) {
                if (this.selector.isSelected("row", rowIndex) && this.selector.isSelected("row", rowIndex - 1)) {
                    var ranges = this._dndRegion.selected;
                    for (i = 0; i < ranges.length; ++i) {
                        if (array.indexOf(ranges[i], rowIndex) >= 0) {
                            rowIndex = ranges[i][0];
                            nodePos = html.position(cell.getNode(rowIndex));
                            break;
                        }
                    }
                }
                top = nodePos.y;
            } else {
                top = nodePos.y + nodePos.h;
            }
            this._target = rowIndex;
            return top - containerPos.y;
        }, _calcCellTargetAnchorPos:function (evt, containerPos, targetAnchor) {
            var s = this._dndRegion.selected[0], origin = this._dndRegion.handle, g = this.grid, ltr = html._isBodyLtr(), cells = g.layout.cells, headPos, minPos, maxPos, headers, height, width, left, top, minCol, maxCol, i, preSpan = origin.col - s.min.col, postSpan = s.max.col - origin.col, leftTopDiv, rightBottomDiv;
            if (!targetAnchor.childNodes.length) {
                leftTopDiv = html.create("div", {"class":"dojoxGridCellBorderLeftTopDIV"}, targetAnchor);
                rightBottomDiv = html.create("div", {"class":"dojoxGridCellBorderRightBottomDIV"}, targetAnchor);
            } else {
                leftTopDiv = query(".dojoxGridCellBorderLeftTopDIV", targetAnchor)[0];
                rightBottomDiv = query(".dojoxGridCellBorderRightBottomDIV", targetAnchor)[0];
            }
            for (i = s.min.col + 1; i < origin.col; ++i) {
                if (cells[i].hidden) {
                    --preSpan;
                }
            }
            for (i = origin.col + 1; i < s.max.col; ++i) {
                if (cells[i].hidden) {
                    --postSpan;
                }
            }
            headers = this._getVisibleHeaders();
            for (i = preSpan; i < headers.length - postSpan; ++i) {
                headPos = html.position(headers[i].node);
                if ((evt.clientX >= headPos.x && evt.clientX < headPos.x + headPos.w) || (i == preSpan && (ltr ? evt.clientX < headPos.x : evt.clientX >= headPos.x + headPos.w)) || (i == headers.length - postSpan - 1 && (ltr ? evt.clientX >= headPos.x + headPos.w : evt < headPos.x))) {
                    minCol = headers[i - preSpan];
                    maxCol = headers[i + postSpan];
                    minPos = html.position(minCol.node);
                    maxPos = html.position(maxCol.node);
                    minCol = minCol.cell.index;
                    maxCol = maxCol.cell.index;
                    left = ltr ? minPos.x : maxPos.x;
                    width = ltr ? (maxPos.x + maxPos.w - minPos.x) : (minPos.x + minPos.w - maxPos.x);
                    break;
                }
            }
            i = 0;
            while (cells[i].hidden) {
                ++i;
            }
            var cell = cells[i], rowIndex = g.scroller.firstVisibleRow, nodePos = html.position(cell.getNode(rowIndex));
            while (nodePos.y + nodePos.h < evt.clientY) {
                if (++rowIndex < g.rowCount) {
                    nodePos = html.position(cell.getNode(rowIndex));
                } else {
                    break;
                }
            }
            var minRow = rowIndex >= origin.row - s.min.row ? rowIndex - origin.row + s.min.row : 0;
            var maxRow = minRow + s.max.row - s.min.row;
            if (maxRow >= g.rowCount) {
                maxRow = g.rowCount - 1;
                minRow = maxRow - s.max.row + s.min.row;
            }
            minPos = html.position(cell.getNode(minRow));
            maxPos = html.position(cell.getNode(maxRow));
            top = minPos.y;
            height = maxPos.y + maxPos.h - minPos.y;
            this._target = {"min":{"row":minRow, "col":minCol}, "max":{"row":maxRow, "col":maxCol}};
            var anchorBorderSize = (html.marginBox(leftTopDiv).w - html.contentBox(leftTopDiv).w) / 2;
            var leftTopCellPos = html.position(cells[minCol].getNode(minRow));
            html.style(leftTopDiv, {"width":(leftTopCellPos.w - anchorBorderSize) + "px", "height":(leftTopCellPos.h - anchorBorderSize) + "px"});
            var rightBottomCellPos = html.position(cells[maxCol].getNode(maxRow));
            html.style(rightBottomDiv, {"width":(rightBottomCellPos.w - anchorBorderSize) + "px", "height":(rightBottomCellPos.h - anchorBorderSize) + "px"});
            return {h:height, w:width, l:left - containerPos.x, t:top - containerPos.y};
        }, _markTargetAnchor:function (evt) {
            try {
                var t = this._dndRegion.type;
                if (this._alreadyOut || (this._dnding && !this._config[t]["within"]) || (this._extDnding && !this._config[t]["in"])) {
                    return;
                }
                var height, width, left, top, targetAnchor = this._targetAnchor[t], pos = html.position(this._container);
                if (!targetAnchor) {
                    targetAnchor = this._targetAnchor[t] = html.create("div", {"class":(t == "cell") ? "dojoxGridCellBorderDIV" : "dojoxGridBorderDIV"});
                    html.style(targetAnchor, "display", "none");
                    this._container.appendChild(targetAnchor);
                }
                switch (t) {
                  case "col":
                    height = pos.h;
                    width = this._targetAnchorBorderWidth;
                    left = this._calcColTargetAnchorPos(evt, pos);
                    top = 0;
                    break;
                  case "row":
                    height = this._targetAnchorBorderWidth;
                    width = pos.w;
                    left = 0;
                    top = this._calcRowTargetAnchorPos(evt, pos);
                    break;
                  case "cell":
                    var cellPos = this._calcCellTargetAnchorPos(evt, pos, targetAnchor);
                    height = cellPos.h;
                    width = cellPos.w;
                    left = cellPos.l;
                    top = cellPos.t;
                }
                if (typeof height == "number" && typeof width == "number" && typeof left == "number" && typeof top == "number") {
                    html.style(targetAnchor, {"height":height + "px", "width":width + "px", "left":left + "px", "top":top + "px"});
                    html.style(targetAnchor, "display", "");
                } else {
                    this._target = null;
                }
            }
            catch (e) {
                console.warn("DnD._markTargetAnchor() error:", e);
            }
        }, _unmarkTargetAnchor:function () {
            if (this._dndRegion) {
                var targetAnchor = this._targetAnchor[this._dndRegion.type];
                if (targetAnchor) {
                    html.style(this._targetAnchor[this._dndRegion.type], "display", "none");
                }
            }
        }, _getVisibleHeaders:function () {
            return array.map(array.filter(this.grid.layout.cells, function (cell) {
                return !cell.hidden;
            }), function (cell) {
                return {"node":cell.getHeaderNode(), "cell":cell};
            });
        }, _rearrange:function () {
            if (this._target === null) {
                return;
            }
            var t = this._dndRegion.type;
            var ranges = this._dndRegion.selected;
            if (t === "cell") {
                this.rearranger[(this._isCopy || this._copyOnly) ? "copyCells" : "moveCells"](ranges[0], this._target === -1 ? null : this._target);
            } else {
                this.rearranger[t == "col" ? "moveColumns" : "moveRows"](_joinToArray(ranges), this._target === -1 ? null : this._target);
            }
            this._target = null;
        }, onDraggingOver:function (sourcePlugin) {
            if (!this._dnding && sourcePlugin) {
                sourcePlugin._isSource = true;
                this._extDnding = true;
                if (!this._externalDnd) {
                    this._externalDnd = true;
                    this._dndRegion = this._mapRegion(sourcePlugin.grid, sourcePlugin._dndRegion);
                }
                this._createDnDUI(this._moveEvent, true);
                this.grid.pluginMgr.getPlugin("autoScroll").readyForAutoScroll = true;
            }
        }, _mapRegion:function (srcGrid, dndRegion) {
            if (dndRegion.type === "cell") {
                var srcRange = dndRegion.selected[0];
                var cells = this.grid.layout.cells;
                var srcCells = srcGrid.layout.cells;
                var c, cnt = 0;
                for (c = srcRange.min.col; c <= srcRange.max.col; ++c) {
                    if (!srcCells[c].hidden) {
                        ++cnt;
                    }
                }
                for (c = 0; cnt > 0; ++c) {
                    if (!cells[c].hidden) {
                        --cnt;
                    }
                }
                var region = lang.clone(dndRegion);
                region.selected[0].min.col = 0;
                region.selected[0].max.col = c - 1;
                for (c = srcRange.min.col; c <= dndRegion.handle.col; ++c) {
                    if (!srcCells[c].hidden) {
                        ++cnt;
                    }
                }
                for (c = 0; cnt > 0; ++c) {
                    if (!cells[c].hidden) {
                        --cnt;
                    }
                }
                region.handle.col = c;
            }
            return dndRegion;
        }, onDraggingOut:function (sourcePlugin) {
            if (this._externalDnd) {
                this._extDnding = false;
                this._destroyDnDUI(true, false);
                if (sourcePlugin) {
                    sourcePlugin._isSource = false;
                }
            }
        }, onDragIn:function (sourcePlugin, isCopy) {
            var success = false;
            if (this._target !== null) {
                var type = sourcePlugin._dndRegion.type;
                var ranges = sourcePlugin._dndRegion.selected;
                switch (type) {
                  case "cell":
                    this.rearranger.changeCells(sourcePlugin.grid, ranges[0], this._target);
                    break;
                  case "row":
                    var range = _joinToArray(ranges);
                    this.rearranger.insertRows(sourcePlugin.grid, range, this._target);
                    break;
                }
                success = true;
            }
            this._endDnd(true);
            if (sourcePlugin.onDragOut) {
                sourcePlugin.onDragOut(success && !isCopy);
            }
        }, onDragOut:function (isMove) {
            if (isMove && !this._copyOnly) {
                var type = this._dndRegion.type;
                var ranges = this._dndRegion.selected;
                switch (type) {
                  case "cell":
                    this.rearranger.clearCells(ranges[0]);
                    break;
                  case "row":
                    this.rearranger.removeRows(_joinToArray(ranges));
                    break;
                }
            }
            this._endDnd(true);
        }, _canAccept:function (sourcePlugin) {
            if (!sourcePlugin) {
                return false;
            }
            var srcRegion = sourcePlugin._dndRegion;
            var type = srcRegion.type;
            if (!this._config[type]["in"] || !sourcePlugin._config[type]["out"]) {
                return false;
            }
            var g = this.grid;
            var ranges = srcRegion.selected;
            var colCnt = array.filter(g.layout.cells, function (cell) {
                return !cell.hidden;
            }).length;
            var rowCnt = g.rowCount;
            var res = true;
            switch (type) {
              case "cell":
                ranges = ranges[0];
                res = g.store.getFeatures()["dojo.data.api.Write"] && (ranges.max.row - ranges.min.row) <= rowCnt && array.filter(sourcePlugin.grid.layout.cells, function (cell) {
                    return cell.index >= ranges.min.col && cell.index <= ranges.max.col && !cell.hidden;
                }).length <= colCnt;
              case "row":
                if (sourcePlugin._allDnDItemsLoaded()) {
                    return res;
                }
            }
            return false;
        }, _allDnDItemsLoaded:function () {
            if (this._dndRegion) {
                var type = this._dndRegion.type, ranges = this._dndRegion.selected, rows = [];
                switch (type) {
                  case "cell":
                    for (var i = ranges[0].min.row, max = ranges[0].max.row; i <= max; ++i) {
                        rows.push(i);
                    }
                    break;
                  case "row":
                    rows = _joinToArray(ranges);
                    break;
                  default:
                    return false;
                }
                var cache = this.grid._by_idx;
                return array.every(rows, function (rowIndex) {
                    return !!cache[rowIndex];
                });
            }
            return false;
        }});
        EnhancedGrid.registerPlugin(DnD, {"dependency":["selector", "rearrange"]});
        return DnD;
    });
}, "dojox/grid/_Builder":function () {
    define(["../main", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/window", "dojo/_base/event", "dojo/_base/sniff", "dojo/_base/connect", "dojo/dnd/Moveable", "dojox/html/metrics", "./util", "dojo/_base/html", "dojo/dom-geometry"], function (dojox, array, lang, win, event, has, connect, Moveable, metrics, util, html, domGeometry) {
        var dg = dojox.grid;
        var getTdIndex = function (td) {
            return td.cellIndex >= 0 ? td.cellIndex : array.indexOf(td.parentNode.cells, td);
        };
        var getTrIndex = function (tr) {
            return tr.rowIndex >= 0 ? tr.rowIndex : array.indexOf(tr.parentNode.childNodes, tr);
        };
        var getTr = function (rowOwner, index) {
            return rowOwner && ((rowOwner.rows || 0)[index] || rowOwner.childNodes[index]);
        };
        var findTable = function (node) {
            for (var n = node; n && n.tagName != "TABLE"; n = n.parentNode) {
            }
            return n;
        };
        var ascendDom = function (inNode, inWhile) {
            for (var n = inNode; n && inWhile(n); n = n.parentNode) {
            }
            return n;
        };
        var makeNotTagName = function (inTagName) {
            var name = inTagName.toUpperCase();
            return function (node) {
                return node.tagName != name;
            };
        };
        var rowIndexTag = util.rowIndexTag;
        var gridViewTag = util.gridViewTag;
        var _Builder = dg._Builder = lang.extend(function (view) {
            if (view) {
                this.view = view;
                this.grid = view.grid;
            }
        }, {view:null, _table:"<table class=\"dojoxGridRowTable\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" role=\"presentation\"", getTableArray:function () {
            var html = [this._table];
            if (this.view.viewWidth) {
                html.push([" style=\"width:", this.view.viewWidth, ";\""].join(""));
            }
            html.push(">");
            return html;
        }, generateCellMarkup:function (inCell, inMoreStyles, inMoreClasses, isHeader) {
            var result = [], html;
            if (isHeader) {
                var sortInfo = inCell.index != inCell.grid.getSortIndex() ? "" : inCell.grid.sortInfo > 0 ? "aria-sort=\"ascending\"" : "aria-sort=\"descending\"";
                if (!inCell.id) {
                    inCell.id = this.grid.id + "Hdr" + inCell.index;
                }
                html = ["<th tabIndex=\"-1\" aria-readonly=\"true\" role=\"columnheader\"", sortInfo, " id=\"", inCell.id, "\""];
            } else {
                var editInfo = this.grid.editable && !inCell.editable ? "aria-readonly=\"true\"" : "";
                html = ["<td tabIndex=\"-1\" role=\"gridcell\"", editInfo];
            }
            if (inCell.colSpan) {
                html.push(" colspan=\"", inCell.colSpan, "\"");
            }
            if (inCell.rowSpan) {
                html.push(" rowspan=\"", inCell.rowSpan, "\"");
            }
            html.push(" class=\"dojoxGridCell ");
            if (inCell.classes) {
                html.push(inCell.classes, " ");
            }
            if (inMoreClasses) {
                html.push(inMoreClasses, " ");
            }
            result.push(html.join(""));
            result.push("");
            html = ["\" idx=\"", inCell.index, "\" style=\""];
            if (inMoreStyles && inMoreStyles[inMoreStyles.length - 1] != ";") {
                inMoreStyles += ";";
            }
            html.push(inCell.styles, inMoreStyles || "", inCell.hidden ? "display:none;" : "");
            if (inCell.unitWidth) {
                html.push("width:", inCell.unitWidth, ";");
            }
            result.push(html.join(""));
            result.push("");
            html = ["\""];
            if (inCell.attrs) {
                html.push(" ", inCell.attrs);
            }
            html.push(">");
            result.push(html.join(""));
            result.push("");
            result.push(isHeader ? "</th>" : "</td>");
            return result;
        }, isCellNode:function (inNode) {
            return Boolean(inNode && inNode != win.doc && html.attr(inNode, "idx"));
        }, getCellNodeIndex:function (inCellNode) {
            return inCellNode ? Number(html.attr(inCellNode, "idx")) : -1;
        }, getCellNode:function (inRowNode, inCellIndex) {
            for (var i = 0, row; ((row = getTr(inRowNode.firstChild, i)) && row.cells); i++) {
                for (var j = 0, cell; (cell = row.cells[j]); j++) {
                    if (this.getCellNodeIndex(cell) == inCellIndex) {
                        return cell;
                    }
                }
            }
            return null;
        }, findCellTarget:function (inSourceNode, inTopNode) {
            var n = inSourceNode;
            while (n && (!this.isCellNode(n) || (n.offsetParent && gridViewTag in n.offsetParent.parentNode && n.offsetParent.parentNode[gridViewTag] != this.view.id)) && (n != inTopNode)) {
                n = n.parentNode;
            }
            return n != inTopNode ? n : null;
        }, baseDecorateEvent:function (e) {
            e.dispatch = "do" + e.type;
            e.grid = this.grid;
            e.sourceView = this.view;
            e.cellNode = this.findCellTarget(e.target, e.rowNode);
            e.cellIndex = this.getCellNodeIndex(e.cellNode);
            e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
        }, findTarget:function (inSource, inTag) {
            var n = inSource;
            while (n && (n != this.domNode) && (!(inTag in n) || (gridViewTag in n && n[gridViewTag] != this.view.id))) {
                n = n.parentNode;
            }
            return (n != this.domNode) ? n : null;
        }, findRowTarget:function (inSource) {
            return this.findTarget(inSource, rowIndexTag);
        }, isIntraNodeEvent:function (e) {
            try {
                return (e.cellNode && e.relatedTarget && html.isDescendant(e.relatedTarget, e.cellNode));
            }
            catch (x) {
                return false;
            }
        }, isIntraRowEvent:function (e) {
            try {
                var row = e.relatedTarget && this.findRowTarget(e.relatedTarget);
                return !row && (e.rowIndex == -1) || row && (e.rowIndex == row.gridRowIndex);
            }
            catch (x) {
                return false;
            }
        }, dispatchEvent:function (e) {
            if (e.dispatch in this) {
                return this[e.dispatch](e);
            }
            return false;
        }, domouseover:function (e) {
            if (e.cellNode && (e.cellNode != this.lastOverCellNode)) {
                this.lastOverCellNode = e.cellNode;
                this.grid.onMouseOver(e);
            }
            this.grid.onMouseOverRow(e);
        }, domouseout:function (e) {
            if (e.cellNode && (e.cellNode == this.lastOverCellNode) && !this.isIntraNodeEvent(e, this.lastOverCellNode)) {
                this.lastOverCellNode = null;
                this.grid.onMouseOut(e);
                if (!this.isIntraRowEvent(e)) {
                    this.grid.onMouseOutRow(e);
                }
            }
        }, domousedown:function (e) {
            if (e.cellNode) {
                this.grid.onMouseDown(e);
            }
            this.grid.onMouseDownRow(e);
        }, _getTextDirStyle:function (textDir, inCell, inRowIndex) {
            return "";
        }});
        var _ContentBuilder = dg._ContentBuilder = lang.extend(function (view) {
            _Builder.call(this, view);
        }, _Builder.prototype, {update:function () {
            this.prepareHtml();
        }, prepareHtml:function () {
            var defaultGet = this.grid.get, cells = this.view.structure.cells;
            for (var j = 0, row; (row = cells[j]); j++) {
                for (var i = 0, cell; (cell = row[i]); i++) {
                    cell.get = cell.get || (cell.value == undefined) && defaultGet;
                    cell.markup = this.generateCellMarkup(cell, cell.cellStyles, cell.cellClasses, false);
                    if (!this.grid.editable && cell.editable) {
                        this.grid.editable = true;
                    }
                }
            }
        }, generateHtml:function (inDataIndex, inRowIndex) {
            var html = this.getTableArray(), v = this.view, dir, cells = v.structure.cells, item = this.grid.getItem(inRowIndex);
            util.fire(this.view, "onBeforeRow", [inRowIndex, cells]);
            for (var j = 0, row; (row = cells[j]); j++) {
                if (row.hidden || row.header) {
                    continue;
                }
                html.push(!row.invisible ? "<tr>" : "<tr class=\"dojoxGridInvisible\">");
                for (var i = 0, cell, m, cc, cs; (cell = row[i]); i++) {
                    m = cell.markup;
                    cc = cell.customClasses = [];
                    cs = cell.customStyles = [];
                    m[5] = cell.format(inRowIndex, item);
                    m[1] = cc.join(" ");
                    m[3] = cs.join(";");
                    dir = cell.textDir || this.grid.textDir;
                    if (dir) {
                        m[3] += this._getTextDirStyle(dir, cell, inRowIndex);
                    }
                    html.push.apply(html, m);
                }
                html.push("</tr>");
            }
            html.push("</table>");
            return html.join("");
        }, decorateEvent:function (e) {
            e.rowNode = this.findRowTarget(e.target);
            if (!e.rowNode) {
                return false;
            }
            e.rowIndex = e.rowNode[rowIndexTag];
            this.baseDecorateEvent(e);
            e.cell = this.grid.getCell(e.cellIndex);
            return true;
        }});
        var _HeaderBuilder = dg._HeaderBuilder = lang.extend(function (view) {
            this.moveable = null;
            _Builder.call(this, view);
        }, _Builder.prototype, {_skipBogusClicks:false, overResizeWidth:4, minColWidth:1, update:function () {
            if (this.tableMap) {
                this.tableMap.mapRows(this.view.structure.cells);
            } else {
                this.tableMap = new dg._TableMap(this.view.structure.cells);
            }
        }, generateHtml:function (inGetValue, inValue) {
            var dir, html = this.getTableArray(), cells = this.view.structure.cells;
            util.fire(this.view, "onBeforeRow", [-1, cells]);
            for (var j = 0, row; (row = cells[j]); j++) {
                if (row.hidden) {
                    continue;
                }
                html.push(!row.invisible ? "<tr>" : "<tr class=\"dojoxGridInvisible\">");
                for (var i = 0, cell, markup; (cell = row[i]); i++) {
                    cell.customClasses = [];
                    cell.customStyles = [];
                    if (this.view.simpleStructure) {
                        if (cell.draggable) {
                            if (cell.headerClasses) {
                                if (cell.headerClasses.indexOf("dojoDndItem") == -1) {
                                    cell.headerClasses += " dojoDndItem";
                                }
                            } else {
                                cell.headerClasses = "dojoDndItem";
                            }
                        }
                        if (cell.attrs) {
                            if (cell.attrs.indexOf("dndType='gridColumn_") == -1) {
                                cell.attrs += " dndType='gridColumn_" + this.grid.id + "'";
                            }
                        } else {
                            cell.attrs = "dndType='gridColumn_" + this.grid.id + "'";
                        }
                    }
                    markup = this.generateCellMarkup(cell, cell.headerStyles, cell.headerClasses, true);
                    markup[5] = (inValue != undefined ? inValue : inGetValue(cell));
                    markup[3] = cell.customStyles.join(";");
                    dir = cell.textDir || this.grid.textDir;
                    if (dir) {
                        markup[3] += this._getTextDirStyle(dir, cell, inValue);
                    }
                    markup[1] = cell.customClasses.join(" ");
                    html.push(markup.join(""));
                }
                html.push("</tr>");
            }
            html.push("</table>");
            return html.join("");
        }, getCellX:function (e) {
            var n, x, pos;
            n = ascendDom(e.target, makeNotTagName("th"));
            if (n) {
                pos = domGeometry.position(n);
                x = e.clientX - pos.x;
            } else {
                x = e.layerX;
            }
            return x;
        }, decorateEvent:function (e) {
            this.baseDecorateEvent(e);
            e.rowIndex = -1;
            e.cellX = this.getCellX(e);
            return true;
        }, prepareResize:function (e, mod) {
            do {
                var i = e.cellIndex;
                e.cellNode = (i ? e.cellNode.parentNode.cells[i + mod] : null);
                e.cellIndex = (e.cellNode ? this.getCellNodeIndex(e.cellNode) : -1);
            } while (e.cellNode && e.cellNode.style.display == "none");
            return Boolean(e.cellNode);
        }, canResize:function (e) {
            if (!e.cellNode || e.cellNode.colSpan > 1) {
                return false;
            }
            var cell = this.grid.getCell(e.cellIndex);
            return !cell.noresize && cell.canResize();
        }, overLeftResizeArea:function (e) {
            if (html.hasClass(win.body(), "dojoDndMove")) {
                return false;
            }
            if (has("ie")) {
                var tN = e.target;
                if (html.hasClass(tN, "dojoxGridArrowButtonNode") || html.hasClass(tN, "dojoxGridArrowButtonChar") || html.hasClass(tN, "dojoxGridColCaption")) {
                    return false;
                }
            }
            if (this.grid.isLeftToRight()) {
                return (e.cellIndex > 0) && (e.cellX > 0 && e.cellX < this.overResizeWidth) && this.prepareResize(e, -1);
            }
            var t = e.cellNode && (e.cellX > 0 && e.cellX < this.overResizeWidth);
            return t;
        }, overRightResizeArea:function (e) {
            if (html.hasClass(win.body(), "dojoDndMove")) {
                return false;
            }
            if (has("ie")) {
                var tN = e.target;
                if (html.hasClass(tN, "dojoxGridArrowButtonNode") || html.hasClass(tN, "dojoxGridArrowButtonChar") || html.hasClass(tN, "dojoxGridColCaption")) {
                    return false;
                }
            }
            if (this.grid.isLeftToRight()) {
                return e.cellNode && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth);
            }
            return (e.cellIndex > 0) && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth) && this.prepareResize(e, -1);
        }, domousemove:function (e) {
            if (!this.moveable) {
                var c = (this.overRightResizeArea(e) ? "dojoxGridColResize" : (this.overLeftResizeArea(e) ? "dojoxGridColResize" : ""));
                if (c && !this.canResize(e)) {
                    c = "dojoxGridColNoResize";
                }
                html.toggleClass(e.sourceView.headerNode, "dojoxGridColNoResize", (c == "dojoxGridColNoResize"));
                html.toggleClass(e.sourceView.headerNode, "dojoxGridColResize", (c == "dojoxGridColResize"));
                if (c) {
                    event.stop(e);
                }
            }
        }, domousedown:function (e) {
            if (!this.moveable) {
                if ((this.overRightResizeArea(e) || this.overLeftResizeArea(e)) && this.canResize(e)) {
                    this.beginColumnResize(e);
                } else {
                    this.grid.onMouseDown(e);
                    this.grid.onMouseOverRow(e);
                }
            }
        }, doclick:function (e) {
            if (this._skipBogusClicks) {
                event.stop(e);
                return true;
            }
            return false;
        }, colResizeSetup:function (e, isMouse) {
            var headContentBox = html.contentBox(e.sourceView.headerNode);
            if (isMouse) {
                this.lineDiv = document.createElement("div");
                var vw = html.position(e.sourceView.headerNode, true);
                var bodyContentBox = html.contentBox(e.sourceView.domNode);
                var l = e.pageX;
                if (!this.grid.isLeftToRight() && has("ie") < 8) {
                    l -= metrics.getScrollbar().w;
                }
                html.style(this.lineDiv, {top:vw.y + "px", left:l + "px", height:(bodyContentBox.h + headContentBox.h) + "px"});
                html.addClass(this.lineDiv, "dojoxGridResizeColLine");
                this.lineDiv._origLeft = l;
                win.body().appendChild(this.lineDiv);
            }
            var spanners = [], nodes = this.tableMap.findOverlappingNodes(e.cellNode);
            for (var i = 0, cell; (cell = nodes[i]); i++) {
                spanners.push({node:cell, index:this.getCellNodeIndex(cell), width:cell.offsetWidth});
            }
            var view = e.sourceView;
            var adj = this.grid.isLeftToRight() ? 1 : -1;
            var views = e.grid.views.views;
            var followers = [];
            for (var j = view.idx + adj, cView; (cView = views[j]); j = j + adj) {
                followers.push({node:cView.headerNode, left:window.parseInt(cView.headerNode.style.left)});
            }
            var table = view.headerContentNode.firstChild;
            var drag = {scrollLeft:e.sourceView.headerNode.scrollLeft, view:view, node:e.cellNode, index:e.cellIndex, w:html.contentBox(e.cellNode).w, vw:headContentBox.w, table:table, tw:html.contentBox(table).w, spanners:spanners, followers:followers};
            return drag;
        }, beginColumnResize:function (e) {
            this.moverDiv = document.createElement("div");
            html.style(this.moverDiv, {position:"absolute", left:0});
            win.body().appendChild(this.moverDiv);
            html.addClass(this.grid.domNode, "dojoxGridColumnResizing");
            var m = (this.moveable = new Moveable(this.moverDiv));
            var drag = this.colResizeSetup(e, true);
            m.onMove = lang.hitch(this, "doResizeColumn", drag);
            connect.connect(m, "onMoveStop", lang.hitch(this, function () {
                this.endResizeColumn(drag);
                if (drag.node.releaseCapture) {
                    drag.node.releaseCapture();
                }
                this.moveable.destroy();
                delete this.moveable;
                this.moveable = null;
                html.removeClass(this.grid.domNode, "dojoxGridColumnResizing");
            }));
            if (e.cellNode.setCapture) {
                e.cellNode.setCapture();
            }
            m.onMouseDown(e);
        }, doResizeColumn:function (inDrag, mover, leftTop) {
            var changeX = leftTop.l;
            var data = {deltaX:changeX, w:inDrag.w + (this.grid.isLeftToRight() ? changeX : -changeX), vw:inDrag.vw + changeX, tw:inDrag.tw + changeX};
            this.dragRecord = {inDrag:inDrag, mover:mover, leftTop:leftTop};
            if (data.w >= this.minColWidth) {
                if (!mover) {
                    this.doResizeNow(inDrag, data);
                } else {
                    html.style(this.lineDiv, "left", (this.lineDiv._origLeft + data.deltaX) + "px");
                }
            }
        }, endResizeColumn:function (inDrag) {
            if (this.dragRecord) {
                var leftTop = this.dragRecord.leftTop;
                var changeX = this.grid.isLeftToRight() ? leftTop.l : -leftTop.l;
                changeX += Math.max(inDrag.w + changeX, this.minColWidth) - (inDrag.w + changeX);
                if (has("webkit") && inDrag.spanners.length) {
                    changeX += html._getPadBorderExtents(inDrag.spanners[0].node).w;
                }
                var data = {deltaX:changeX, w:inDrag.w + changeX, vw:inDrag.vw + changeX, tw:inDrag.tw + changeX};
                this.doResizeNow(inDrag, data);
                delete this.dragRecord;
            }
            html.destroy(this.lineDiv);
            html.destroy(this.moverDiv);
            html.destroy(this.moverDiv);
            delete this.moverDiv;
            this._skipBogusClicks = true;
            inDrag.view.update();
            this._skipBogusClicks = false;
            this.grid.onResizeColumn(inDrag.index);
        }, doResizeNow:function (inDrag, data) {
            inDrag.view.convertColPctToFixed();
            if (inDrag.view.flexCells && !inDrag.view.testFlexCells()) {
                var t = findTable(inDrag.node);
                if (t) {
                    (t.style.width = "");
                }
            }
            var i, s, sw, f, fl;
            for (i = 0; (s = inDrag.spanners[i]); i++) {
                sw = s.width + data.deltaX;
                if (sw > 0) {
                    s.node.style.width = sw + "px";
                    inDrag.view.setColWidth(s.index, sw);
                }
            }
            if (this.grid.isLeftToRight() || !has("ie")) {
                for (i = 0; (f = inDrag.followers[i]); i++) {
                    fl = f.left + data.deltaX;
                    f.node.style.left = fl + "px";
                }
            }
            inDrag.node.style.width = data.w + "px";
            inDrag.view.setColWidth(inDrag.index, data.w);
            inDrag.view.headerNode.style.width = data.vw + "px";
            inDrag.view.setColumnsWidth(data.tw);
            if (!this.grid.isLeftToRight()) {
                inDrag.view.headerNode.scrollLeft = inDrag.scrollLeft + data.deltaX;
            }
        }});
        dg._TableMap = lang.extend(function (rows) {
            this.mapRows(rows);
        }, {map:null, mapRows:function (inRows) {
            var rowCount = inRows.length;
            if (!rowCount) {
                return;
            }
            this.map = [];
            var row;
            for (var k = 0; (row = inRows[k]); k++) {
                this.map[k] = [];
            }
            for (var j = 0; (row = inRows[j]); j++) {
                for (var i = 0, x = 0, cell, colSpan, rowSpan; (cell = row[i]); i++) {
                    while (this.map[j][x]) {
                        x++;
                    }
                    this.map[j][x] = {c:i, r:j};
                    rowSpan = cell.rowSpan || 1;
                    colSpan = cell.colSpan || 1;
                    for (var y = 0; y < rowSpan; y++) {
                        for (var s = 0; s < colSpan; s++) {
                            this.map[j + y][x + s] = this.map[j][x];
                        }
                    }
                    x += colSpan;
                }
            }
        }, dumpMap:function () {
            for (var j = 0, row, h = ""; (row = this.map[j]); j++, h = "") {
                for (var i = 0, cell; (cell = row[i]); i++) {
                    h += cell.r + "," + cell.c + "   ";
                }
            }
        }, getMapCoords:function (inRow, inCol) {
            for (var j = 0, row; (row = this.map[j]); j++) {
                for (var i = 0, cell; (cell = row[i]); i++) {
                    if (cell.c == inCol && cell.r == inRow) {
                        return {j:j, i:i};
                    }
                }
            }
            return {j:-1, i:-1};
        }, getNode:function (inTable, inRow, inCol) {
            var row = inTable && inTable.rows[inRow];
            return row && row.cells[inCol];
        }, _findOverlappingNodes:function (inTable, inRow, inCol) {
            var nodes = [];
            var m = this.getMapCoords(inRow, inCol);
            for (var j = 0, row; (row = this.map[j]); j++) {
                if (j == m.j) {
                    continue;
                }
                var rw = row[m.i];
                var n = (rw ? this.getNode(inTable, rw.r, rw.c) : null);
                if (n) {
                    nodes.push(n);
                }
            }
            return nodes;
        }, findOverlappingNodes:function (inNode) {
            return this._findOverlappingNodes(findTable(inNode), getTrIndex(inNode.parentNode), getTdIndex(inNode));
        }});
        return {_Builder:_Builder, _HeaderBuilder:_HeaderBuilder, _ContentBuilder:_ContentBuilder};
    });
}, "dijit/InlineEditBox":function () {
    define(["require", "dojo/_base/array", "dojo/aspect", "dojo/_base/declare", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-style", "dojo/i18n", "dojo/_base/kernel", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/sniff", "dojo/when", "./a11yclick", "./focus", "./_Widget", "./_TemplatedMixin", "./_WidgetsInTemplateMixin", "./_Container", "./form/Button", "./form/_TextBoxMixin", "./form/TextBox", "dojo/text!./templates/InlineEditBox.html", "dojo/i18n!./nls/common"], function (require, array, aspect, declare, domAttr, domClass, domConstruct, domStyle, i18n, kernel, keys, lang, on, has, when, a11yclick, fm, _Widget, _TemplatedMixin, _WidgetsInTemplateMixin, _Container, Button, _TextBoxMixin, TextBox, template) {
        var InlineEditor = declare("dijit._InlineEditor", [_Widget, _TemplatedMixin, _WidgetsInTemplateMixin], {templateString:template, contextRequire:require, postMixInProperties:function () {
            this.inherited(arguments);
            this.messages = i18n.getLocalization("dijit", "common", this.lang);
            array.forEach(["buttonSave", "buttonCancel"], function (prop) {
                if (!this[prop]) {
                    this[prop] = this.messages[prop];
                }
            }, this);
        }, buildRendering:function () {
            this.inherited(arguments);
            var Cls = typeof this.editor == "string" ? (lang.getObject(this.editor) || require(this.editor)) : this.editor;
            var srcStyle = this.sourceStyle, editStyle = "line-height:" + srcStyle.lineHeight + ";", destStyle = domStyle.getComputedStyle(this.domNode);
            array.forEach(["Weight", "Family", "Size", "Style"], function (prop) {
                var textStyle = srcStyle["font" + prop], wrapperStyle = destStyle["font" + prop];
                if (wrapperStyle != textStyle) {
                    editStyle += "font-" + prop + ":" + srcStyle["font" + prop] + ";";
                }
            }, this);
            array.forEach(["marginTop", "marginBottom", "marginLeft", "marginRight", "position", "left", "top", "right", "bottom", "float", "clear", "display"], function (prop) {
                this.domNode.style[prop] = srcStyle[prop];
            }, this);
            var width = this.inlineEditBox.width;
            if (width == "100%") {
                editStyle += "width:100%;";
                this.domNode.style.display = "block";
            } else {
                editStyle += "width:" + (width + (Number(width) == width ? "px" : "")) + ";";
            }
            var editorParams = lang.delegate(this.inlineEditBox.editorParams, {style:editStyle, dir:this.dir, lang:this.lang, textDir:this.textDir});
            this.editWidget = new Cls(editorParams, this.editorPlaceholder);
            if (this.inlineEditBox.autoSave) {
                this.saveButton.destroy();
                this.cancelButton.destroy();
                this.saveButton = this.cancelButton = null;
                domConstruct.destroy(this.buttonContainer);
            }
        }, postCreate:function () {
            this.inherited(arguments);
            var ew = this.editWidget;
            if (this.inlineEditBox.autoSave) {
                this.own(aspect.after(ew, "onChange", lang.hitch(this, "_onChange"), true), on(ew, "keydown", lang.hitch(this, "_onKeyDown")));
            } else {
                if ("intermediateChanges" in ew) {
                    ew.set("intermediateChanges", true);
                    this.own(aspect.after(ew, "onChange", lang.hitch(this, "_onIntermediateChange"), true));
                    this.saveButton.set("disabled", true);
                }
            }
        }, startup:function () {
            this.editWidget.startup();
            this.inherited(arguments);
        }, _onIntermediateChange:function () {
            this.saveButton.set("disabled", (this.getValue() == this._resetValue) || !this.enableSave());
        }, destroy:function () {
            this.editWidget.destroy(true);
            this.inherited(arguments);
        }, getValue:function () {
            var ew = this.editWidget;
            return String(ew.get(("displayedValue" in ew || "_getDisplayedValueAttr" in ew) ? "displayedValue" : "value"));
        }, _onKeyDown:function (e) {
            if (this.inlineEditBox.autoSave && this.inlineEditBox.editing) {
                if (e.altKey || e.ctrlKey) {
                    return;
                }
                if (e.keyCode == keys.ESCAPE) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.cancel(true);
                } else {
                    if (e.keyCode == keys.ENTER && e.target.tagName == "INPUT") {
                        e.stopPropagation();
                        e.preventDefault();
                        this._onChange();
                    }
                }
            }
        }, _onBlur:function () {
            this.inherited(arguments);
            if (this.inlineEditBox.autoSave && this.inlineEditBox.editing) {
                if (this.getValue() == this._resetValue) {
                    this.cancel(false);
                } else {
                    if (this.enableSave()) {
                        this.save(false);
                    }
                }
            }
        }, _onChange:function () {
            if (this.inlineEditBox.autoSave && this.inlineEditBox.editing && this.enableSave()) {
                fm.focus(this.inlineEditBox.displayNode);
            }
        }, enableSave:function () {
            return this.editWidget.isValid ? this.editWidget.isValid() : true;
        }, focus:function () {
            this.editWidget.focus();
            if (this.editWidget.focusNode) {
                fm._onFocusNode(this.editWidget.focusNode);
                if (this.editWidget.focusNode.tagName == "INPUT") {
                    this.defer(function () {
                        _TextBoxMixin.selectInputText(this.editWidget.focusNode);
                    });
                }
            }
        }});
        var InlineEditBox = declare("dijit.InlineEditBox" + (has("dojo-bidi") ? "_NoBidi" : ""), _Widget, {editing:false, autoSave:true, buttonSave:"", buttonCancel:"", renderAsHtml:false, editor:TextBox, editorWrapper:InlineEditor, editorParams:{}, disabled:false, onChange:function () {
        }, onCancel:function () {
        }, width:"100%", value:"", noValueIndicator:has("ie") <= 6 ? "<span style='font-family: wingdings; text-decoration: underline;'>&#160;&#160;&#160;&#160;&#x270d;&#160;&#160;&#160;&#160;</span>" : "<span style='text-decoration: underline;'>&#160;&#160;&#160;&#160;&#x270d;&#160;&#160;&#160;&#160;</span>", constructor:function () {
            this.editorParams = {};
        }, postMixInProperties:function () {
            this.inherited(arguments);
            this.displayNode = this.srcNodeRef;
            this.own(on(this.displayNode, a11yclick, lang.hitch(this, "_onClick")), on(this.displayNode, "mouseover, focus", lang.hitch(this, "_onMouseOver")), on(this.displayNode, "mouseout, blur", lang.hitch(this, "_onMouseOut")));
            this.displayNode.setAttribute("role", "button");
            if (!this.displayNode.getAttribute("tabIndex")) {
                this.displayNode.setAttribute("tabIndex", 0);
            }
            if (!this.value && !("value" in this.params)) {
                this.value = lang.trim(this.renderAsHtml ? this.displayNode.innerHTML : (this.displayNode.innerText || this.displayNode.textContent || ""));
            }
            if (!this.value) {
                this.displayNode.innerHTML = this.noValueIndicator;
            }
            domClass.add(this.displayNode, "dijitInlineEditBoxDisplayMode");
        }, setDisabled:function (disabled) {
            kernel.deprecated("dijit.InlineEditBox.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
            this.set("disabled", disabled);
        }, _setDisabledAttr:function (disabled) {
            this.domNode.setAttribute("aria-disabled", disabled ? "true" : "false");
            if (disabled) {
                this.displayNode.removeAttribute("tabIndex");
            } else {
                this.displayNode.setAttribute("tabIndex", 0);
            }
            domClass.toggle(this.displayNode, "dijitInlineEditBoxDisplayModeDisabled", disabled);
            this._set("disabled", disabled);
        }, _onMouseOver:function () {
            if (!this.disabled) {
                domClass.add(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
            }
        }, _onMouseOut:function () {
            domClass.remove(this.displayNode, "dijitInlineEditBoxDisplayModeHover");
        }, _onClick:function (e) {
            if (this.disabled) {
                return;
            }
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }
            this._onMouseOut();
            this.defer("edit");
        }, edit:function () {
            if (this.disabled || this.editing) {
                return;
            }
            this._set("editing", true);
            this._savedTabIndex = domAttr.get(this.displayNode, "tabIndex") || "0";
            if (!this.wrapperWidget) {
                var placeholder = domConstruct.create("span", null, this.domNode, "before");
                var Ewc = typeof this.editorWrapper == "string" ? lang.getObject(this.editorWrapper) : this.editorWrapper;
                this.wrapperWidget = new Ewc({value:this.value, buttonSave:this.buttonSave, buttonCancel:this.buttonCancel, dir:this.dir, lang:this.lang, tabIndex:this._savedTabIndex, editor:this.editor, inlineEditBox:this, sourceStyle:domStyle.getComputedStyle(this.displayNode), save:lang.hitch(this, "save"), cancel:lang.hitch(this, "cancel"), textDir:this.textDir}, placeholder);
                if (!this.wrapperWidget._started) {
                    this.wrapperWidget.startup();
                }
                if (!this._started) {
                    this.startup();
                }
            }
            var ww = this.wrapperWidget;
            domClass.add(this.displayNode, "dijitOffScreen");
            domClass.remove(ww.domNode, "dijitOffScreen");
            domStyle.set(ww.domNode, {visibility:"visible"});
            domAttr.set(this.displayNode, "tabIndex", "-1");
            var ew = ww.editWidget;
            var self = this;
            when(ew.onLoadDeferred, lang.hitch(ww, function () {
                ew.set(("displayedValue" in ew || "_setDisplayedValueAttr" in ew) ? "displayedValue" : "value", self.value);
                this.defer(function () {
                    if (ww.saveButton) {
                        ww.saveButton.set("disabled", "intermediateChanges" in ew);
                    }
                    this.focus();
                    this._resetValue = this.getValue();
                });
            }));
        }, _onBlur:function () {
            this.inherited(arguments);
            if (!this.editing) {
            }
        }, destroy:function () {
            if (this.wrapperWidget && !this.wrapperWidget._destroyed) {
                this.wrapperWidget.destroy();
                delete this.wrapperWidget;
            }
            this.inherited(arguments);
        }, _showText:function (focus) {
            var ww = this.wrapperWidget;
            domStyle.set(ww.domNode, {visibility:"hidden"});
            domClass.add(ww.domNode, "dijitOffScreen");
            domClass.remove(this.displayNode, "dijitOffScreen");
            domAttr.set(this.displayNode, "tabIndex", this._savedTabIndex);
            if (focus) {
                fm.focus(this.displayNode);
            }
        }, save:function (focus) {
            if (this.disabled || !this.editing) {
                return;
            }
            this._set("editing", false);
            var ww = this.wrapperWidget;
            var value = ww.getValue();
            this.set("value", value);
            this._showText(focus);
        }, setValue:function (val) {
            kernel.deprecated("dijit.InlineEditBox.setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
            return this.set("value", val);
        }, _setValueAttr:function (val) {
            val = lang.trim(val);
            var renderVal = this.renderAsHtml ? val : val.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/\n/g, "<br>");
            this.displayNode.innerHTML = renderVal || this.noValueIndicator;
            this._set("value", val);
            if (this._started) {
                this.defer(function () {
                    this.onChange(val);
                });
            }
        }, getValue:function () {
            kernel.deprecated("dijit.InlineEditBox.getValue() is deprecated.  Use get('value') instead.", "", "2.0");
            return this.get("value");
        }, cancel:function (focus) {
            if (this.disabled || !this.editing) {
                return;
            }
            this._set("editing", false);
            this.defer("onCancel");
            this._showText(focus);
        }});
        if (has("dojo-bidi")) {
            InlineEditBox = declare("dijit.InlineEditBox", InlineEditBox, {_setValueAttr:function () {
                this.inherited(arguments);
                this.applyTextDir(this.displayNode);
            }});
        }
        InlineEditBox._InlineEditor = InlineEditor;
        return InlineEditBox;
    });
}, "dijit/_Container":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-construct", "dojo/_base/kernel"], function (array, declare, domConstruct, kernel) {
        return declare("dijit._Container", null, {buildRendering:function () {
            this.inherited(arguments);
            if (!this.containerNode) {
                this.containerNode = this.domNode;
            }
        }, addChild:function (widget, insertIndex) {
            var refNode = this.containerNode;
            if (insertIndex > 0) {
                refNode = refNode.firstChild;
                while (insertIndex > 0) {
                    if (refNode.nodeType == 1) {
                        insertIndex--;
                    }
                    refNode = refNode.nextSibling;
                }
                if (refNode) {
                    insertIndex = "before";
                } else {
                    refNode = this.containerNode;
                    insertIndex = "last";
                }
            }
            domConstruct.place(widget.domNode, refNode, insertIndex);
            if (this._started && !widget._started) {
                widget.startup();
            }
        }, removeChild:function (widget) {
            if (typeof widget == "number") {
                widget = this.getChildren()[widget];
            }
            if (widget) {
                var node = widget.domNode;
                if (node && node.parentNode) {
                    node.parentNode.removeChild(node);
                }
            }
        }, hasChildren:function () {
            return this.getChildren().length > 0;
        }, _getSiblingOfChild:function (child, dir) {
            kernel.deprecated(this.declaredClass + "::_getSiblingOfChild() is deprecated. Use _KeyNavMixin::_getNext() instead.", "", "2.0");
            var children = this.getChildren(), idx = array.indexOf(children, child);
            return children[idx + dir];
        }, getIndexOfChild:function (child) {
            return array.indexOf(this.getChildren(), child);
        }});
    });
}, "dijit/layout/BorderContainer":function () {
    define(["dojo/_base/array", "dojo/cookie", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/touch", "../_WidgetBase", "../_Widget", "../_TemplatedMixin", "./LayoutContainer", "./utils"], function (array, cookie, declare, domClass, domConstruct, domGeometry, domStyle, keys, lang, on, touch, _WidgetBase, _Widget, _TemplatedMixin, LayoutContainer, layoutUtils) {
        var _Splitter = declare("dijit.layout._Splitter", [_Widget, _TemplatedMixin], {live:true, templateString:"<div class=\"dijitSplitter\" data-dojo-attach-event=\"onkeydown:_onKeyDown,press:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse\" tabIndex=\"0\" role=\"separator\"><div class=\"dijitSplitterThumb\"></div></div>", constructor:function () {
            this._handlers = [];
        }, postMixInProperties:function () {
            this.inherited(arguments);
            this.horizontal = /top|bottom/.test(this.region);
            this._factor = /top|left/.test(this.region) ? 1 : -1;
            this._cookieName = this.container.id + "_" + this.region;
        }, buildRendering:function () {
            this.inherited(arguments);
            domClass.add(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));
            if (this.container.persist) {
                var persistSize = cookie(this._cookieName);
                if (persistSize) {
                    this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
                }
            }
        }, _computeMaxSize:function () {
            var dim = this.horizontal ? "h" : "w", childSize = domGeometry.getMarginBox(this.child.domNode)[dim], center = array.filter(this.container.getChildren(), function (child) {
                return child.region == "center";
            })[0];
            var spaceAvailable = domGeometry.getContentBox(center.domNode)[dim] - 10;
            return Math.min(this.child.maxSize, childSize + spaceAvailable);
        }, _startDrag:function (e) {
            if (!this.cover) {
                this.cover = domConstruct.place("<div class=dijitSplitterCover></div>", this.child.domNode, "after");
            }
            domClass.add(this.cover, "dijitSplitterCoverActive");
            if (this.fake) {
                domConstruct.destroy(this.fake);
            }
            if (!(this._resize = this.live)) {
                (this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
                domClass.add(this.domNode, "dijitSplitterShadow");
                domConstruct.place(this.fake, this.domNode, "after");
            }
            domClass.add(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
            if (this.fake) {
                domClass.remove(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
            }
            var factor = this._factor, isHorizontal = this.horizontal, axis = isHorizontal ? "pageY" : "pageX", pageStart = e[axis], splitterStyle = this.domNode.style, dim = isHorizontal ? "h" : "w", childCS = domStyle.getComputedStyle(this.child.domNode), childStart = domGeometry.getMarginBox(this.child.domNode, childCS)[dim], max = this._computeMaxSize(), min = Math.max(this.child.minSize, domGeometry.getPadBorderExtents(this.child.domNode, childCS)[dim] + 10), region = this.region, splitterAttr = region == "top" || region == "bottom" ? "top" : "left", splitterStart = parseInt(splitterStyle[splitterAttr], 10), resize = this._resize, layoutFunc = lang.hitch(this.container, "_layoutChildren", this.child.id), de = this.ownerDocument;
            this._handlers = this._handlers.concat([on(de, touch.move, this._drag = function (e, forceResize) {
                var delta = e[axis] - pageStart, childSize = factor * delta + childStart, boundChildSize = Math.max(Math.min(childSize, max), min);
                if (resize || forceResize) {
                    layoutFunc(boundChildSize);
                }
                splitterStyle[splitterAttr] = delta + splitterStart + factor * (boundChildSize - childSize) + "px";
            }), on(de, "dragstart", function (e) {
                e.stopPropagation();
                e.preventDefault();
            }), on(this.ownerDocumentBody, "selectstart", function (e) {
                e.stopPropagation();
                e.preventDefault();
            }), on(de, touch.release, lang.hitch(this, "_stopDrag"))]);
            e.stopPropagation();
            e.preventDefault();
        }, _onMouse:function (e) {
            var o = (e.type == "mouseover" || e.type == "mouseenter");
            domClass.toggle(this.domNode, "dijitSplitterHover", o);
            domClass.toggle(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
        }, _stopDrag:function (e) {
            try {
                if (this.cover) {
                    domClass.remove(this.cover, "dijitSplitterCoverActive");
                }
                if (this.fake) {
                    domConstruct.destroy(this.fake);
                }
                domClass.remove(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
                this._drag(e);
                this._drag(e, true);
            }
            finally {
                this._cleanupHandlers();
                delete this._drag;
            }
            if (this.container.persist) {
                cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
            }
        }, _cleanupHandlers:function () {
            var h;
            while (h = this._handlers.pop()) {
                h.remove();
            }
        }, _onKeyDown:function (e) {
            this._resize = true;
            var horizontal = this.horizontal;
            var tick = 1;
            switch (e.keyCode) {
              case horizontal ? keys.UP_ARROW : keys.LEFT_ARROW:
                tick *= -1;
              case horizontal ? keys.DOWN_ARROW : keys.RIGHT_ARROW:
                break;
              default:
                return;
            }
            var childSize = domGeometry.getMarginSize(this.child.domNode)[horizontal ? "h" : "w"] + this._factor * tick;
            this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
            e.stopPropagation();
            e.preventDefault();
        }, destroy:function () {
            this._cleanupHandlers();
            delete this.child;
            delete this.container;
            delete this.cover;
            delete this.fake;
            this.inherited(arguments);
        }});
        var _Gutter = declare("dijit.layout._Gutter", [_Widget, _TemplatedMixin], {templateString:"<div class=\"dijitGutter\" role=\"presentation\"></div>", postMixInProperties:function () {
            this.inherited(arguments);
            this.horizontal = /top|bottom/.test(this.region);
        }, buildRendering:function () {
            this.inherited(arguments);
            domClass.add(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
        }});
        var BorderContainer = declare("dijit.layout.BorderContainer", LayoutContainer, {gutters:true, liveSplitters:true, persist:false, baseClass:"dijitBorderContainer", _splitterClass:_Splitter, postMixInProperties:function () {
            if (!this.gutters) {
                this.baseClass += "NoGutter";
            }
            this.inherited(arguments);
        }, _setupChild:function (child) {
            this.inherited(arguments);
            var region = child.region, ltr = child.isLeftToRight();
            if (region == "leading") {
                region = ltr ? "left" : "right";
            }
            if (region == "trailing") {
                region = ltr ? "right" : "left";
            }
            if (region) {
                if (region != "center" && (child.splitter || this.gutters) && !child._splitterWidget) {
                    var _Splitter = child.splitter ? this._splitterClass : _Gutter;
                    if (lang.isString(_Splitter)) {
                        _Splitter = lang.getObject(_Splitter);
                    }
                    var splitter = new _Splitter({id:child.id + "_splitter", container:this, child:child, region:region, live:this.liveSplitters});
                    splitter.isSplitter = true;
                    child._splitterWidget = splitter;
                    var before = region == "bottom" || region == (this.isLeftToRight() ? "right" : "left");
                    domConstruct.place(splitter.domNode, child.domNode, before ? "before" : "after");
                    splitter.startup();
                }
            }
        }, layout:function () {
            this._layoutChildren();
        }, removeChild:function (child) {
            var splitter = child._splitterWidget;
            if (splitter) {
                splitter.destroy();
                delete child._splitterWidget;
            }
            this.inherited(arguments);
        }, getChildren:function () {
            return array.filter(this.inherited(arguments), function (widget) {
                return !widget.isSplitter;
            });
        }, getSplitter:function (region) {
            return array.filter(this.getChildren(), function (child) {
                return child.region == region;
            })[0]._splitterWidget;
        }, resize:function (newSize, currentSize) {
            if (!this.cs || !this.pe) {
                var node = this.domNode;
                this.cs = domStyle.getComputedStyle(node);
                this.pe = domGeometry.getPadExtents(node, this.cs);
                this.pe.r = domStyle.toPixelValue(node, this.cs.paddingRight);
                this.pe.b = domStyle.toPixelValue(node, this.cs.paddingBottom);
                domStyle.set(node, "padding", "0px");
            }
            this.inherited(arguments);
        }, _layoutChildren:function (changedChildId, changedChildSize) {
            if (!this._borderBox || !this._borderBox.h) {
                return;
            }
            var childrenAndSplitters = [];
            array.forEach(this._getOrderedChildren(), function (pane) {
                childrenAndSplitters.push(pane);
                if (pane._splitterWidget) {
                    childrenAndSplitters.push(pane._splitterWidget);
                }
            });
            var dim = {l:this.pe.l, t:this.pe.t, w:this._borderBox.w - this.pe.w, h:this._borderBox.h - this.pe.h};
            layoutUtils.layoutChildren(this.domNode, dim, childrenAndSplitters, changedChildId, changedChildSize);
        }, destroyRecursive:function () {
            array.forEach(this.getChildren(), function (child) {
                var splitter = child._splitterWidget;
                if (splitter) {
                    splitter.destroy();
                }
                delete child._splitterWidget;
            });
            this.inherited(arguments);
        }});
        BorderContainer.ChildWidgetProperties = {splitter:false, minSize:0, maxSize:Infinity};
        lang.mixin(BorderContainer.ChildWidgetProperties, LayoutContainer.ChildWidgetProperties);
        lang.extend(_WidgetBase, BorderContainer.ChildWidgetProperties);
        BorderContainer._Splitter = _Splitter;
        BorderContainer._Gutter = _Gutter;
        return BorderContainer;
    });
}, "dijit/_base/wai":function () {
    define(["dojo/dom-attr", "dojo/_base/lang", "../main", "../hccss"], function (domAttr, lang, dijit) {
        var exports = {hasWaiRole:function (elem, role) {
            var waiRole = this.getWaiRole(elem);
            return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
        }, getWaiRole:function (elem) {
            return lang.trim((domAttr.get(elem, "role") || "").replace("wairole:", ""));
        }, setWaiRole:function (elem, role) {
            domAttr.set(elem, "role", role);
        }, removeWaiRole:function (elem, role) {
            var roleValue = domAttr.get(elem, "role");
            if (!roleValue) {
                return;
            }
            if (role) {
                var t = lang.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
                domAttr.set(elem, "role", t);
            } else {
                elem.removeAttribute("role");
            }
        }, hasWaiState:function (elem, state) {
            return elem.hasAttribute ? elem.hasAttribute("aria-" + state) : !!elem.getAttribute("aria-" + state);
        }, getWaiState:function (elem, state) {
            return elem.getAttribute("aria-" + state) || "";
        }, setWaiState:function (elem, state, value) {
            elem.setAttribute("aria-" + state, value);
        }, removeWaiState:function (elem, state) {
            elem.removeAttribute("aria-" + state);
        }};
        lang.mixin(dijit, exports);
        return dijit;
    });
}, "dojo/dnd/Mover":function () {
    define(["../_base/array", "../_base/declare", "../_base/lang", "../sniff", "../_base/window", "../dom", "../dom-geometry", "../dom-style", "../Evented", "../on", "../touch", "./common", "./autoscroll"], function (array, declare, lang, has, win, dom, domGeom, domStyle, Evented, on, touch, dnd, autoscroll) {
        return declare("dojo.dnd.Mover", [Evented], {constructor:function (node, e, host) {
            this.node = dom.byId(node);
            this.marginBox = {l:e.pageX, t:e.pageY};
            this.mouseButton = e.button;
            var h = (this.host = host), d = node.ownerDocument;
            function stopEvent(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            this.events = [on(d, touch.move, lang.hitch(this, "onFirstMove")), on(d, touch.move, lang.hitch(this, "onMouseMove")), on(d, touch.release, lang.hitch(this, "onMouseUp")), on(d, "dragstart", stopEvent), on(d.body, "selectstart", stopEvent)];
            autoscroll.autoScrollStart(d);
            if (h && h.onMoveStart) {
                h.onMoveStart(this);
            }
        }, onMouseMove:function (e) {
            autoscroll.autoScroll(e);
            var m = this.marginBox;
            this.host.onMove(this, {l:m.l + e.pageX, t:m.t + e.pageY}, e);
            e.preventDefault();
            e.stopPropagation();
        }, onMouseUp:function (e) {
            if (has("webkit") && has("mac") && this.mouseButton == 2 ? e.button == 0 : this.mouseButton == e.button) {
                this.destroy();
            }
            e.preventDefault();
            e.stopPropagation();
        }, onFirstMove:function (e) {
            var s = this.node.style, l, t, h = this.host;
            switch (s.position) {
              case "relative":
              case "absolute":
                l = Math.round(parseFloat(s.left)) || 0;
                t = Math.round(parseFloat(s.top)) || 0;
                break;
              default:
                s.position = "absolute";
                var m = domGeom.getMarginBox(this.node);
                var b = win.doc.body;
                var bs = domStyle.getComputedStyle(b);
                var bm = domGeom.getMarginBox(b, bs);
                var bc = domGeom.getContentBox(b, bs);
                l = m.l - (bc.l - bm.l);
                t = m.t - (bc.t - bm.t);
                break;
            }
            this.marginBox.l = l - this.marginBox.l;
            this.marginBox.t = t - this.marginBox.t;
            if (h && h.onFirstMove) {
                h.onFirstMove(this, e);
            }
            this.events.shift().remove();
        }, destroy:function () {
            array.forEach(this.events, function (handle) {
                handle.remove();
            });
            var h = this.host;
            if (h && h.onMoveStop) {
                h.onMoveStop(this);
            }
            this.events = this.node = this.host = null;
        }});
    });
}, "dojox/grid/cells/tree":function () {
    define(["dojo/_base/kernel", "../../main", "dojo/_base/lang", "../cells"], function (dojo, dojox, lang) {
        dojox.grid.cells.TreeCell = {formatAggregate:function (inItem, level, inRowIndexes) {
            var f, g = this.grid, i = g.edit.info, d = g.aggregator ? g.aggregator.getForCell(this, level, inItem, level === this.level ? "cnt" : this.parentCell.aggregate) : (this.value || this.defaultValue);
            var ret = this._defaultFormat(d, [d, level - this.level, inRowIndexes, this]);
            var dir = this.textDir || this.grid.textDir;
            if (dir && this._enforceTextDirWithUcc) {
                ret = this._enforceTextDirWithUcc(dir, ret);
            }
            return ret;
        }, formatIndexes:function (inRowIndexes, inItem) {
            var f, g = this.grid, i = g.edit.info, d = this.get ? this.get(inRowIndexes[0], inItem, inRowIndexes) : (this.value || this.defaultValue);
            if (this.editable && (this.alwaysEditing || (i.rowIndex == inRowIndexes[0] && i.cell == this))) {
                return this.formatEditing(d, inRowIndexes[0], inRowIndexes);
            } else {
                var ret = this._defaultFormat(d, [d, inRowIndexes[0], inRowIndexes, this]);
                var dir = this.textDir || this.grid.textDir;
                if (dir && this._enforceTextDirWithUcc) {
                    ret = this._enforceTextDirWithUcc(dir, ret);
                }
                return ret;
            }
        }, getOpenState:function (itemId) {
            var grid = this.grid, store = grid.store, itm = null;
            if (store.isItem(itemId)) {
                itm = itemId;
                itemId = store.getIdentity(itemId);
            }
            if (!this.openStates) {
                this.openStates = {};
            }
            if (typeof itemId != "string" || !(itemId in this.openStates)) {
                this.openStates[itemId] = grid.getDefaultOpenState(this, itm);
            }
            return this.openStates[itemId];
        }, formatAtLevel:function (inRowIndexes, inItem, level, summaryRow, toggleClass, cellClasses) {
            if (!lang.isArray(inRowIndexes)) {
                inRowIndexes = [inRowIndexes];
            }
            var result = "";
            if (level > this.level || (level === this.level && summaryRow)) {
                cellClasses.push("dojoxGridSpacerCell");
                if (level === this.level) {
                    cellClasses.push("dojoxGridTotalCell");
                }
                result = "<span></span>";
            } else {
                if (level < this.level) {
                    cellClasses.push("dojoxGridSummaryCell");
                    result = "<span class=\"dojoxGridSummarySpan\">" + this.formatAggregate(inItem, level, inRowIndexes) + "</span>";
                } else {
                    var ret = "";
                    if (this.isCollapsable) {
                        var store = this.grid.store, id = "";
                        if (store.isItem(inItem)) {
                            id = store.getIdentity(inItem);
                        }
                        cellClasses.push("dojoxGridExpandoCell");
                        ret = "<span " + dojo._scopeName + "Type=\"dojox.grid._Expando\" level=\"" + level + "\" class=\"dojoxGridExpando\"" + "\" toggleClass=\"" + toggleClass + "\" itemId=\"" + id + "\" cellIdx=\"" + this.index + "\"></span>";
                    }
                    result = ret + this.formatIndexes(inRowIndexes, inItem);
                }
            }
            if (this.grid.focus.cell && this.index == this.grid.focus.cell.index && inRowIndexes.join("/") == this.grid.focus.rowIndex) {
                cellClasses.push(this.grid.focus.focusClass);
            }
            return result;
        }};
        return dojox.grid.cells.TreeCell;
    });
}, "dojo/request/watch":function () {
    define(["./util", "../errors/RequestTimeoutError", "../errors/CancelError", "../_base/array", "../_base/window", "../has!host-browser?dom-addeventlistener?:../on:"], function (util, RequestTimeoutError, CancelError, array, win, on) {
        var _inFlightIntvl = null, _inFlight = [];
        function watchInFlight() {
            var now = +(new Date);
            for (var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++) {
                var response = dfd.response, options = response.options;
                if ((dfd.isCanceled && dfd.isCanceled()) || (dfd.isValid && !dfd.isValid(response))) {
                    _inFlight.splice(i--, 1);
                    watch._onAction && watch._onAction();
                } else {
                    if (dfd.isReady && dfd.isReady(response)) {
                        _inFlight.splice(i--, 1);
                        dfd.handleResponse(response);
                        watch._onAction && watch._onAction();
                    } else {
                        if (dfd.startTime) {
                            if (dfd.startTime + (options.timeout || 0) < now) {
                                _inFlight.splice(i--, 1);
                                dfd.cancel(new RequestTimeoutError("Timeout exceeded", response));
                                watch._onAction && watch._onAction();
                            }
                        }
                    }
                }
            }
            watch._onInFlight && watch._onInFlight(dfd);
            if (!_inFlight.length) {
                clearInterval(_inFlightIntvl);
                _inFlightIntvl = null;
            }
        }
        function watch(dfd) {
            if (dfd.response.options.timeout) {
                dfd.startTime = +(new Date);
            }
            if (dfd.isFulfilled()) {
                return;
            }
            _inFlight.push(dfd);
            if (!_inFlightIntvl) {
                _inFlightIntvl = setInterval(watchInFlight, 50);
            }
            if (dfd.response.options.sync) {
                watchInFlight();
            }
        }
        watch.cancelAll = function cancelAll() {
            try {
                array.forEach(_inFlight, function (dfd) {
                    try {
                        dfd.cancel(new CancelError("All requests canceled."));
                    }
                    catch (e) {
                    }
                });
            }
            catch (e) {
            }
        };
        if (win && on && win.doc.attachEvent) {
            on(win.global, "unload", function () {
                watch.cancelAll();
            });
        }
        return watch;
    });
}, "dijit/form/ComboBoxMixin":function () {
    define(["dojo/_base/declare", "dojo/Deferred", "dojo/_base/kernel", "dojo/_base/lang", "dojo/store/util/QueryResults", "./_AutoCompleterMixin", "./_ComboBoxMenu", "../_HasDropDown", "dojo/text!./templates/DropDownBox.html"], function (declare, Deferred, kernel, lang, QueryResults, _AutoCompleterMixin, _ComboBoxMenu, _HasDropDown, template) {
        return declare("dijit.form.ComboBoxMixin", [_HasDropDown, _AutoCompleterMixin], {dropDownClass:_ComboBoxMenu, hasDownArrow:true, templateString:template, baseClass:"dijitTextBox dijitComboBox", cssStateNodes:{"_buttonNode":"dijitDownArrowButton"}, _setHasDownArrowAttr:function (val) {
            this._set("hasDownArrow", val);
            this._buttonNode.style.display = val ? "" : "none";
        }, _showResultList:function () {
            this.displayMessage("");
            this.inherited(arguments);
        }, _setStoreAttr:function (store) {
            if (!store.get) {
                lang.mixin(store, {_oldAPI:true, get:function (id) {
                    var deferred = new Deferred();
                    this.fetchItemByIdentity({identity:id, onItem:function (object) {
                        deferred.resolve(object);
                    }, onError:function (error) {
                        deferred.reject(error);
                    }});
                    return deferred.promise;
                }, query:function (query, options) {
                    var deferred = new Deferred(function () {
                        fetchHandle.abort && fetchHandle.abort();
                    });
                    deferred.total = new Deferred();
                    var fetchHandle = this.fetch(lang.mixin({query:query, onBegin:function (count) {
                        deferred.total.resolve(count);
                    }, onComplete:function (results) {
                        deferred.resolve(results);
                    }, onError:function (error) {
                        deferred.reject(error);
                    }}, options));
                    return QueryResults(deferred);
                }});
            }
            this._set("store", store);
        }, postMixInProperties:function () {
            var store = this.params.store || this.store;
            if (store) {
                this._setStoreAttr(store);
            }
            this.inherited(arguments);
            if (!this.params.store && !this.store._oldAPI) {
                var clazz = this.declaredClass;
                lang.mixin(this.store, {getValue:function (item, attr) {
                    kernel.deprecated(clazz + ".store.getValue(item, attr) is deprecated for builtin store.  Use item.attr directly", "", "2.0");
                    return item[attr];
                }, getLabel:function (item) {
                    kernel.deprecated(clazz + ".store.getLabel(item) is deprecated for builtin store.  Use item.label directly", "", "2.0");
                    return item.name;
                }, fetch:function (args) {
                    kernel.deprecated(clazz + ".store.fetch() is deprecated for builtin store.", "Use store.query()", "2.0");
                    var shim = ["dojo/data/ObjectStore"];
                    require(shim, lang.hitch(this, function (ObjectStore) {
                        new ObjectStore({objectStore:this}).fetch(args);
                    }));
                }});
            }
        }});
    });
}, "dijit/form/Select":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-geometry", "dojo/i18n", "dojo/_base/lang", "dojo/on", "dojo/sniff", "./_FormSelectWidget", "../_HasDropDown", "../DropDownMenu", "../MenuItem", "../MenuSeparator", "../Tooltip", "../_KeyNavMixin", "../registry", "dojo/text!./templates/Select.html", "dojo/i18n!./nls/validate"], function (array, declare, domAttr, domClass, domGeometry, i18n, lang, on, has, _FormSelectWidget, _HasDropDown, DropDownMenu, MenuItem, MenuSeparator, Tooltip, _KeyNavMixin, registry, template) {
        var _SelectMenu = declare("dijit.form._SelectMenu", DropDownMenu, {autoFocus:true, buildRendering:function () {
            this.inherited(arguments);
            this.domNode.setAttribute("role", "listbox");
        }, postCreate:function () {
            this.inherited(arguments);
            this.own(on(this.domNode, "selectstart", function (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }));
        }, focus:function () {
            var found = false, val = this.parentWidget.value;
            if (lang.isArray(val)) {
                val = val[val.length - 1];
            }
            if (val) {
                array.forEach(this.parentWidget._getChildren(), function (child) {
                    if (child.option && (val === child.option.value)) {
                        found = true;
                        this.focusChild(child, false);
                    }
                }, this);
            }
            if (!found) {
                this.inherited(arguments);
            }
        }});
        var Select = declare("dijit.form.Select" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormSelectWidget, _HasDropDown, _KeyNavMixin], {baseClass:"dijitSelect dijitValidationTextBox", templateString:template, _buttonInputDisabled:has("ie") ? "disabled" : "", required:false, state:"", message:"", tooltipPosition:[], emptyLabel:"&#160;", _isLoaded:false, _childrenLoaded:false, _fillContent:function () {
            this.inherited(arguments);
            if (this.options.length && !this.value && this.srcNodeRef) {
                var si = this.srcNodeRef.selectedIndex || 0;
                this._set("value", this.options[si >= 0 ? si : 0].value);
            }
            this.dropDown = new _SelectMenu({id:this.id + "_menu", parentWidget:this});
            domClass.add(this.dropDown.domNode, this.baseClass.replace(/\s+|$/g, "Menu "));
        }, _getMenuItemForOption:function (option) {
            if (!option.value && !option.label) {
                return new MenuSeparator({ownerDocument:this.ownerDocument});
            } else {
                var click = lang.hitch(this, "_setValueAttr", option);
                var item = new MenuItem({option:option, label:option.label || this.emptyLabel, onClick:click, ownerDocument:this.ownerDocument, dir:this.dir, textDir:this.textDir, disabled:option.disabled || false});
                item.focusNode.setAttribute("role", "option");
                return item;
            }
        }, _addOptionItem:function (option) {
            if (this.dropDown) {
                this.dropDown.addChild(this._getMenuItemForOption(option));
            }
        }, _getChildren:function () {
            if (!this.dropDown) {
                return [];
            }
            return this.dropDown.getChildren();
        }, focus:function () {
            if (!this.disabled && this.focusNode.focus) {
                try {
                    this.focusNode.focus();
                }
                catch (e) {
                }
            }
        }, focusChild:function (widget) {
            if (widget) {
                this.set("value", widget.option);
            }
        }, _getFirst:function () {
            var children = this._getChildren();
            return children.length ? children[0] : null;
        }, _getLast:function () {
            var children = this._getChildren();
            return children.length ? children[children.length - 1] : null;
        }, childSelector:function (node) {
            var node = registry.byNode(node);
            return node && node.getParent() == this.dropDown;
        }, onKeyboardSearch:function (item, evt, searchString, numMatches) {
            if (item) {
                this.focusChild(item);
            }
        }, _loadChildren:function (loadMenuItems) {
            if (loadMenuItems === true) {
                if (this.dropDown) {
                    delete this.dropDown.focusedChild;
                    this.focusedChild = null;
                }
                if (this.options.length) {
                    this.inherited(arguments);
                } else {
                    array.forEach(this._getChildren(), function (child) {
                        child.destroyRecursive();
                    });
                    var item = new MenuItem({ownerDocument:this.ownerDocument, label:this.emptyLabel});
                    this.dropDown.addChild(item);
                }
            } else {
                this._updateSelection();
            }
            this._isLoaded = false;
            this._childrenLoaded = true;
            if (!this._loadingStore) {
                this._setValueAttr(this.value, false);
            }
        }, _refreshState:function () {
            if (this._started) {
                this.validate(this.focused);
            }
        }, startup:function () {
            this.inherited(arguments);
            this._refreshState();
        }, _setValueAttr:function (value) {
            this.inherited(arguments);
            domAttr.set(this.valueNode, "value", this.get("value"));
            this._refreshState();
        }, _setNameAttr:"valueNode", _setDisabledAttr:function (value) {
            this.inherited(arguments);
            this._refreshState();
        }, _setRequiredAttr:function (value) {
            this._set("required", value);
            this.focusNode.setAttribute("aria-required", value);
            this._refreshState();
        }, _setOptionsAttr:function (options) {
            this._isLoaded = false;
            this._set("options", options);
        }, _setDisplay:function (newDisplay) {
            var lbl = newDisplay || this.emptyLabel;
            this.containerNode.innerHTML = "<span role=\"option\" class=\"dijitReset dijitInline " + this.baseClass.replace(/\s+|$/g, "Label ") + "\">" + lbl + "</span>";
        }, validate:function (isFocused) {
            var isValid = this.disabled || this.isValid(isFocused);
            this._set("state", isValid ? "" : (this._hasBeenBlurred ? "Error" : "Incomplete"));
            this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");
            var message = isValid ? "" : this._missingMsg;
            if (message && this.focused && this._hasBeenBlurred) {
                Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
            } else {
                Tooltip.hide(this.domNode);
            }
            this._set("message", message);
            return isValid;
        }, isValid:function () {
            return (!this.required || this.value === 0 || !(/^\s*$/.test(this.value || "")));
        }, reset:function () {
            this.inherited(arguments);
            Tooltip.hide(this.domNode);
            this._refreshState();
        }, postMixInProperties:function () {
            this.inherited(arguments);
            this._missingMsg = i18n.getLocalization("dijit.form", "validate", this.lang).missingMessage;
        }, postCreate:function () {
            this.inherited(arguments);
            this.own(on(this.domNode, "selectstart", function (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }));
            this.domNode.setAttribute("aria-expanded", "false");
            if (has("ie") < 9) {
                this.defer(function () {
                    try {
                        var s = domStyle.getComputedStyle(this.domNode);
                        if (s) {
                            var ff = s.fontFamily;
                            if (ff) {
                                var inputs = this.domNode.getElementsByTagName("INPUT");
                                if (inputs) {
                                    for (var i = 0; i < inputs.length; i++) {
                                        inputs[i].style.fontFamily = ff;
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                    }
                });
            }
        }, _setStyleAttr:function (value) {
            this.inherited(arguments);
            domClass.toggle(this.domNode, this.baseClass.replace(/\s+|$/g, "FixedWidth "), !!this.domNode.style.width);
        }, isLoaded:function () {
            return this._isLoaded;
        }, loadDropDown:function (loadCallback) {
            this._loadChildren(true);
            this._isLoaded = true;
            loadCallback();
        }, destroy:function (preserveDom) {
            if (this.dropDown && !this.dropDown._destroyed) {
                this.dropDown.destroyRecursive(preserveDom);
                delete this.dropDown;
            }
            this.inherited(arguments);
        }, _onFocus:function () {
            this.validate(true);
        }, _onBlur:function () {
            Tooltip.hide(this.domNode);
            this.inherited(arguments);
            this.validate(false);
        }});
        if (has("dojo-bidi")) {
            Select = declare("dijit.form.Select", Select, {_setDisplay:function (newDisplay) {
                this.inherited(arguments);
                this.applyTextDir(this.containerNode);
            }});
        }
        Select._Menu = _SelectMenu;
        function _onEventAfterLoad(method) {
            return function (evt) {
                if (!this._isLoaded) {
                    this.loadDropDown(lang.hitch(this, method, evt));
                } else {
                    this.inherited(method, arguments);
                }
            };
        }
        Select.prototype._onContainerKeydown = _onEventAfterLoad("_onContainerKeydown");
        Select.prototype._onContainerKeypress = _onEventAfterLoad("_onContainerKeypress");
        return Select;
    });
}, "dijit/Calendar":function () {
    define(["dojo/_base/array", "dojo/date", "dojo/date/locale", "dojo/_base/declare", "dojo/dom-attr", "dojo/dom-class", "dojo/_base/kernel", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/sniff", "./CalendarLite", "./_Widget", "./_CssStateMixin", "./_TemplatedMixin", "./form/DropDownButton"], function (array, date, local, declare, domAttr, domClass, kernel, keys, lang, on, has, CalendarLite, _Widget, _CssStateMixin, _TemplatedMixin, DropDownButton) {
        var Calendar = declare("dijit.Calendar", [CalendarLite, _Widget, _CssStateMixin], {cssStateNodes:{"decrementMonth":"dijitCalendarArrow", "incrementMonth":"dijitCalendarArrow", "previousYearLabelNode":"dijitCalendarPreviousYear", "nextYearLabelNode":"dijitCalendarNextYear"}, setValue:function (value) {
            kernel.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
            this.set("value", value);
        }, _createMonthWidget:function () {
            return new Calendar._MonthDropDownButton({id:this.id + "_mddb", tabIndex:-1, onMonthSelect:lang.hitch(this, "_onMonthSelect"), lang:this.lang, dateLocaleModule:this.dateLocaleModule}, this.monthNode);
        }, postCreate:function () {
            this.inherited(arguments);
            this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")), on(this.dateRowsNode, "mouseover", lang.hitch(this, "_onDayMouseOver")), on(this.dateRowsNode, "mouseout", lang.hitch(this, "_onDayMouseOut")), on(this.dateRowsNode, "mousedown", lang.hitch(this, "_onDayMouseDown")), on(this.dateRowsNode, "mouseup", lang.hitch(this, "_onDayMouseUp")));
        }, _onMonthSelect:function (newMonth) {
            var date = new this.dateClassObj(this.currentFocus);
            date.setDate(1);
            date.setMonth(newMonth);
            var daysInMonth = this.dateModule.getDaysInMonth(date);
            var currentDate = this.currentFocus.getDate();
            date.setDate(Math.min(currentDate, daysInMonth));
            this._setCurrentFocusAttr(date);
        }, _onDayMouseOver:function (evt) {
            var node = domClass.contains(evt.target, "dijitCalendarDateLabel") ? evt.target.parentNode : evt.target;
            if (node && ((node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate")) || node == this.previousYearLabelNode || node == this.nextYearLabelNode)) {
                domClass.add(node, "dijitCalendarHoveredDate");
                this._currentNode = node;
            }
        }, _onDayMouseOut:function (evt) {
            if (!this._currentNode) {
                return;
            }
            if (evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode) {
                return;
            }
            var cls = "dijitCalendarHoveredDate";
            if (domClass.contains(this._currentNode, "dijitCalendarActiveDate")) {
                cls += " dijitCalendarActiveDate";
            }
            domClass.remove(this._currentNode, cls);
            this._currentNode = null;
        }, _onDayMouseDown:function (evt) {
            var node = evt.target.parentNode;
            if (node && node.dijitDateValue && !domClass.contains(node, "dijitCalendarDisabledDate")) {
                domClass.add(node, "dijitCalendarActiveDate");
                this._currentNode = node;
            }
        }, _onDayMouseUp:function (evt) {
            var node = evt.target.parentNode;
            if (node && node.dijitDateValue) {
                domClass.remove(node, "dijitCalendarActiveDate");
            }
        }, handleKey:function (evt) {
            var increment = -1, interval, newValue = this.currentFocus;
            switch (evt.keyCode) {
              case keys.RIGHT_ARROW:
                increment = 1;
              case keys.LEFT_ARROW:
                interval = "day";
                if (!this.isLeftToRight()) {
                    increment *= -1;
                }
                break;
              case keys.DOWN_ARROW:
                increment = 1;
              case keys.UP_ARROW:
                interval = "week";
                break;
              case keys.PAGE_DOWN:
                increment = 1;
              case keys.PAGE_UP:
                interval = evt.ctrlKey || evt.altKey ? "year" : "month";
                break;
              case keys.END:
                newValue = this.dateModule.add(newValue, "month", 1);
                interval = "day";
              case keys.HOME:
                newValue = new this.dateClassObj(newValue);
                newValue.setDate(1);
                break;
              default:
                return true;
            }
            if (interval) {
                newValue = this.dateModule.add(newValue, interval, increment);
            }
            this._setCurrentFocusAttr(newValue);
            return false;
        }, _onKeyDown:function (evt) {
            if (!this.handleKey(evt)) {
                evt.stopPropagation();
                evt.preventDefault();
            }
        }, onValueSelected:function () {
        }, onChange:function (value) {
            this.onValueSelected(value);
        }, getClassForDate:function () {
        }});
        Calendar._MonthDropDownButton = declare("dijit.Calendar._MonthDropDownButton", DropDownButton, {onMonthSelect:function () {
        }, postCreate:function () {
            this.inherited(arguments);
            this.dropDown = new Calendar._MonthDropDown({id:this.id + "_mdd", onChange:this.onMonthSelect});
        }, _setMonthAttr:function (month) {
            var monthNames = this.dateLocaleModule.getNames("months", "wide", "standAlone", this.lang, month);
            this.dropDown.set("months", monthNames);
            this.containerNode.innerHTML = (has("ie") == 6 ? "" : "<div class='dijitSpacer'>" + this.dropDown.domNode.innerHTML + "</div>") + "<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" + monthNames[month.getMonth()] + "</div>";
        }});
        Calendar._MonthDropDown = declare("dijit.Calendar._MonthDropDown", [_Widget, _TemplatedMixin], {months:[], templateString:"<div class='dijitCalendarMonthMenu dijitMenu' " + "data-dojo-attach-event='onclick:_onClick,onmouseover:_onMenuHover,onmouseout:_onMenuHover'></div>", _setMonthsAttr:function (months) {
            this.domNode.innerHTML = array.map(months, function (month, idx) {
                return month ? "<div class='dijitCalendarMonthLabel' month='" + idx + "'>" + month + "</div>" : "";
            }).join("");
        }, _onClick:function (evt) {
            this.onChange(domAttr.get(evt.target, "month"));
        }, onChange:function () {
        }, _onMenuHover:function (evt) {
            domClass.toggle(evt.target, "dijitCalendarMonthLabelHover", evt.type == "mouseover");
        }});
        return Calendar;
    });
}, "dojox/grid/enhanced/_Events":function () {
    define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/keys", "dojo/_base/html", "dojo/_base/event", "dojox/grid/_Events"], function (dojo, declare, keys, html, event, _Events) {
        return declare("dojox.grid.enhanced._Events", null, {_events:null, headerCellActiveClass:"dojoxGridHeaderActive", cellActiveClass:"dojoxGridCellActive", rowActiveClass:"dojoxGridRowActive", constructor:function (inGrid) {
            this._events = new _Events();
            inGrid.mixin(inGrid, this);
        }, dokeyup:function (e) {
            this.focus.currentArea().keyup(e);
        }, onKeyDown:function (e) {
            if (e.altKey || e.metaKey) {
                return;
            }
            var focus = this.focus;
            var editing = this.edit.isEditing();
            switch (e.keyCode) {
              case keys.TAB:
                if (e.ctrlKey) {
                    return;
                }
                focus.tab(e.shiftKey ? -1 : 1, e);
                break;
              case keys.UP_ARROW:
              case keys.DOWN_ARROW:
                if (editing) {
                    return;
                }
                focus.currentArea().move(e.keyCode == keys.UP_ARROW ? -1 : 1, 0, e);
                break;
              case keys.LEFT_ARROW:
              case keys.RIGHT_ARROW:
                if (editing) {
                    return;
                }
                var offset = (e.keyCode == keys.LEFT_ARROW) ? 1 : -1;
                if (html._isBodyLtr()) {
                    offset *= -1;
                }
                focus.currentArea().move(0, offset, e);
                break;
              case keys.F10:
                if (this.menus && e.shiftKey) {
                    this.onRowContextMenu(e);
                }
                break;
              default:
                focus.currentArea().keydown(e);
                break;
            }
        }, domouseup:function (e) {
            if (e.cellNode) {
                this.onMouseUp(e);
            } else {
                this.onRowSelectorMouseUp(e);
            }
        }, domousedown:function (e) {
            if (!e.cellNode) {
                this.onRowSelectorMouseDown(e);
            }
        }, onMouseUp:function (e) {
            this[e.rowIndex == -1 ? "onHeaderCellMouseUp" : "onCellMouseUp"](e);
        }, onCellMouseDown:function (e) {
            html.addClass(e.cellNode, this.cellActiveClass);
            html.addClass(e.rowNode, this.rowActiveClass);
        }, onCellMouseUp:function (e) {
            html.removeClass(e.cellNode, this.cellActiveClass);
            html.removeClass(e.rowNode, this.rowActiveClass);
        }, onCellClick:function (e) {
            this._events.onCellClick.call(this, e);
            this.focus.contentMouseEvent(e);
        }, onCellDblClick:function (e) {
            if (this.pluginMgr.isFixedCell(e.cell)) {
                return;
            }
            if (this._click.length > 1 && (!this._click[0] || !this._click[1])) {
                this._click[0] = this._click[1] = e;
            }
            this._events.onCellDblClick.call(this, e);
        }, onRowClick:function (e) {
            this.edit.rowClick(e);
            if (!e.cell || !this.plugin("indirectSelection")) {
                this.selection.clickSelectEvent(e);
            }
        }, onRowContextMenu:function (e) {
            if (!this.edit.isEditing() && this.menus) {
                this.showMenu(e);
            }
        }, onSelectedRegionContextMenu:function (e) {
            if (this.selectedRegionMenu) {
                this.selectedRegionMenu._openMyself({target:e.target, coords:e.keyCode !== keys.F10 && "pageX" in e ? {x:e.pageX, y:e.pageY} : null});
                event.stop(e);
            }
        }, onHeaderCellMouseOut:function (e) {
            if (e.cellNode) {
                html.removeClass(e.cellNode, this.cellOverClass);
                html.removeClass(e.cellNode, this.headerCellActiveClass);
            }
        }, onHeaderCellMouseDown:function (e) {
            if (e.cellNode) {
                html.addClass(e.cellNode, this.headerCellActiveClass);
            }
        }, onHeaderCellMouseUp:function (e) {
            if (e.cellNode) {
                html.removeClass(e.cellNode, this.headerCellActiveClass);
            }
        }, onHeaderCellClick:function (e) {
            this.focus.currentArea("header");
            if (!e.cell.isRowSelector) {
                this._events.onHeaderCellClick.call(this, e);
            }
            this.focus.headerMouseEvent(e);
        }, onRowSelectorMouseDown:function (e) {
            this.focus.focusArea("rowHeader", e);
        }, onRowSelectorMouseUp:function (e) {
        }, onMouseUpRow:function (e) {
            if (e.rowIndex != -1) {
                this.onRowMouseUp(e);
            }
        }, onRowMouseUp:function (e) {
        }});
    });
}, "dojo/topic":function () {
    define(["./Evented"], function (Evented) {
        var hub = new Evented;
        return {publish:function (topic, event) {
            return hub.emit.apply(hub, arguments);
        }, subscribe:function (topic, listener) {
            return hub.on.apply(hub, arguments);
        }};
    });
}, "dojox/validate/regexp":function () {
    define(["dojo/_base/lang", "dojo/regexp", "dojox/main"], function (lang, regexp, dojox) {
        var dxregexp = lang.getObject("validate.regexp", true, dojox);
        dxregexp = dojox.validate.regexp = {ipAddress:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (typeof flags.allowDottedDecimal != "boolean") {
                flags.allowDottedDecimal = true;
            }
            if (typeof flags.allowDottedHex != "boolean") {
                flags.allowDottedHex = true;
            }
            if (typeof flags.allowDottedOctal != "boolean") {
                flags.allowDottedOctal = true;
            }
            if (typeof flags.allowDecimal != "boolean") {
                flags.allowDecimal = true;
            }
            if (typeof flags.allowHex != "boolean") {
                flags.allowHex = true;
            }
            if (typeof flags.allowIPv6 != "boolean") {
                flags.allowIPv6 = true;
            }
            if (typeof flags.allowHybrid != "boolean") {
                flags.allowHybrid = true;
            }
            var dottedDecimalRE = "((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
            var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";
            var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";
            var decimalRE = "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" + "4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";
            var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";
            var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";
            var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" + "((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
            var a = [];
            if (flags.allowDottedDecimal) {
                a.push(dottedDecimalRE);
            }
            if (flags.allowDottedHex) {
                a.push(dottedHexRE);
            }
            if (flags.allowDottedOctal) {
                a.push(dottedOctalRE);
            }
            if (flags.allowDecimal) {
                a.push(decimalRE);
            }
            if (flags.allowHex) {
                a.push(hexRE);
            }
            if (flags.allowIPv6) {
                a.push(ipv6RE);
            }
            if (flags.allowHybrid) {
                a.push(hybridRE);
            }
            var ipAddressRE = "";
            if (a.length > 0) {
                ipAddressRE = "(" + a.join("|") + ")";
            }
            return ipAddressRE;
        }, host:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (typeof flags.allowIP != "boolean") {
                flags.allowIP = true;
            }
            if (typeof flags.allowLocal != "boolean") {
                flags.allowLocal = false;
            }
            if (typeof flags.allowPort != "boolean") {
                flags.allowPort = true;
            }
            if (typeof flags.allowNamed != "boolean") {
                flags.allowNamed = false;
            }
            var domainLabelRE = "(?:[\\da-zA-Z](?:[-\\da-zA-Z]{0,61}[\\da-zA-Z])?)";
            var domainNameRE = "(?:[a-zA-Z](?:[-\\da-zA-Z]{0,6}[\\da-zA-Z])?)";
            var portRE = flags.allowPort ? "(\\:\\d+)?" : "";
            var hostNameRE = "((?:" + domainLabelRE + "\\.)+" + domainNameRE + "\\.?)";
            if (flags.allowIP) {
                hostNameRE += "|" + dxregexp.ipAddress(flags);
            }
            if (flags.allowLocal) {
                hostNameRE += "|localhost";
            }
            if (flags.allowNamed) {
                hostNameRE += "|^[^-][a-zA-Z0-9_-]*";
            }
            return "(" + hostNameRE + ")" + portRE;
        }, url:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (!("scheme" in flags)) {
                flags.scheme = [true, false];
            }
            var protocolRE = regexp.buildGroupRE(flags.scheme, function (q) {
                if (q) {
                    return "(https?|ftps?)\\://";
                }
                return "";
            });
            var pathRE = "(/(?:[^?#\\s/]+/)*(?:[^?#\\s/]+(?:\\?[^?#\\s/]*)?(?:#[A-Za-z][\\w.:-]*)?)?)?";
            return protocolRE + dxregexp.host(flags) + pathRE;
        }, emailAddress:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (typeof flags.allowCruft != "boolean") {
                flags.allowCruft = false;
            }
            flags.allowPort = false;
            var usernameRE = "([!#-'*+\\-\\/-9=?A-Z^-~]+[.])*[!#-'*+\\-\\/-9=?A-Z^-~]+";
            var emailAddressRE = usernameRE + "@" + dxregexp.host(flags);
            if (flags.allowCruft) {
                emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
            }
            return emailAddressRE;
        }, emailAddressList:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (typeof flags.listSeparator != "string") {
                flags.listSeparator = "\\s;,";
            }
            var emailAddressRE = dxregexp.emailAddress(flags);
            var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" + emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";
            return emailAddressListRE;
        }, numberFormat:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (typeof flags.format == "undefined") {
                flags.format = "###-###-####";
            }
            var digitRE = function (format) {
                return regexp.escapeString(format, "?").replace(/\?/g, "\\d?").replace(/#/g, "\\d");
            };
            return regexp.buildGroupRE(flags.format, digitRE);
        }, ca:{postalCode:function () {
            return "([A-Z][0-9][A-Z] [0-9][A-Z][0-9])";
        }, province:function () {
            return "(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)";
        }}, us:{state:function (flags) {
            flags = (typeof flags == "object") ? flags : {};
            if (typeof flags.allowTerritories != "boolean") {
                flags.allowTerritories = true;
            }
            if (typeof flags.allowMilitary != "boolean") {
                flags.allowMilitary = true;
            }
            var statesRE = "AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" + "NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";
            var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";
            var militaryRE = "AA|AE|AP";
            if (flags.allowTerritories) {
                statesRE += "|" + territoriesRE;
            }
            if (flags.allowMilitary) {
                statesRE += "|" + militaryRE;
            }
            return "(" + statesRE + ")";
        }}};
        return dxregexp;
    });
}, "dijit/_base/manager":function () {
    define(["dojo/_base/array", "dojo/_base/config", "dojo/_base/lang", "../registry", "../main"], function (array, config, lang, registry, dijit) {
        var exports = {};
        array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function (name) {
            exports[name] = registry[name];
        });
        lang.mixin(exports, {defaultDuration:config["defaultDuration"] || 200});
        lang.mixin(dijit, exports);
        return dijit;
    });
}, "dojo/data/ItemFileReadStore":function () {
    define(["../_base/kernel", "../_base/lang", "../_base/declare", "../_base/array", "../_base/xhr", "../Evented", "./util/filter", "./util/simpleFetch", "../date/stamp"], function (kernel, lang, declare, array, xhr, Evented, filterUtil, simpleFetch, dateStamp) {
        var ItemFileReadStore = declare("dojo.data.ItemFileReadStore", [Evented], {constructor:function (keywordParameters) {
            this._arrayOfAllItems = [];
            this._arrayOfTopLevelItems = [];
            this._loadFinished = false;
            this._jsonFileUrl = keywordParameters.url;
            this._ccUrl = keywordParameters.url;
            this.url = keywordParameters.url;
            this._jsonData = keywordParameters.data;
            this.data = null;
            this._datatypeMap = keywordParameters.typeMap || {};
            if (!this._datatypeMap["Date"]) {
                this._datatypeMap["Date"] = {type:Date, deserialize:function (value) {
                    return dateStamp.fromISOString(value);
                }};
            }
            this._features = {"dojo.data.api.Read":true, "dojo.data.api.Identity":true};
            this._itemsByIdentity = null;
            this._storeRefPropName = "_S";
            this._itemNumPropName = "_0";
            this._rootItemPropName = "_RI";
            this._reverseRefMap = "_RRM";
            this._loadInProgress = false;
            this._queuedFetches = [];
            if (keywordParameters.urlPreventCache !== undefined) {
                this.urlPreventCache = keywordParameters.urlPreventCache ? true : false;
            }
            if (keywordParameters.hierarchical !== undefined) {
                this.hierarchical = keywordParameters.hierarchical ? true : false;
            }
            if (keywordParameters.clearOnClose) {
                this.clearOnClose = true;
            }
            if ("failOk" in keywordParameters) {
                this.failOk = keywordParameters.failOk ? true : false;
            }
        }, url:"", _ccUrl:"", data:null, typeMap:null, clearOnClose:false, urlPreventCache:false, failOk:false, hierarchical:true, _assertIsItem:function (item) {
            if (!this.isItem(item)) {
                throw new Error(this.declaredClass + ": Invalid item argument.");
            }
        }, _assertIsAttribute:function (attribute) {
            if (typeof attribute !== "string") {
                throw new Error(this.declaredClass + ": Invalid attribute argument.");
            }
        }, getValue:function (item, attribute, defaultValue) {
            var values = this.getValues(item, attribute);
            return (values.length > 0) ? values[0] : defaultValue;
        }, getValues:function (item, attribute) {
            this._assertIsItem(item);
            this._assertIsAttribute(attribute);
            return (item[attribute] || []).slice(0);
        }, getAttributes:function (item) {
            this._assertIsItem(item);
            var attributes = [];
            for (var key in item) {
                if ((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)) {
                    attributes.push(key);
                }
            }
            return attributes;
        }, hasAttribute:function (item, attribute) {
            this._assertIsItem(item);
            this._assertIsAttribute(attribute);
            return (attribute in item);
        }, containsValue:function (item, attribute, value) {
            var regexp = undefined;
            if (typeof value === "string") {
                regexp = filterUtil.patternToRegExp(value, false);
            }
            return this._containsValue(item, attribute, value, regexp);
        }, _containsValue:function (item, attribute, value, regexp) {
            return array.some(this.getValues(item, attribute), function (possibleValue) {
                if (possibleValue !== null && !lang.isObject(possibleValue) && regexp) {
                    if (possibleValue.toString().match(regexp)) {
                        return true;
                    }
                } else {
                    if (value === possibleValue) {
                        return true;
                    }
                }
            });
        }, isItem:function (something) {
            if (something && something[this._storeRefPropName] === this) {
                if (this._arrayOfAllItems[something[this._itemNumPropName]] === something) {
                    return true;
                }
            }
            return false;
        }, isItemLoaded:function (something) {
            return this.isItem(something);
        }, loadItem:function (keywordArgs) {
            this._assertIsItem(keywordArgs.item);
        }, getFeatures:function () {
            return this._features;
        }, getLabel:function (item) {
            if (this._labelAttr && this.isItem(item)) {
                return this.getValue(item, this._labelAttr);
            }
            return undefined;
        }, getLabelAttributes:function (item) {
            if (this._labelAttr) {
                return [this._labelAttr];
            }
            return null;
        }, filter:function (requestArgs, arrayOfItems, findCallback) {
            var items = [], i, key;
            if (requestArgs.query) {
                var value, ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;
                var regexpList = {};
                for (key in requestArgs.query) {
                    value = requestArgs.query[key];
                    if (typeof value === "string") {
                        regexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);
                    } else {
                        if (value instanceof RegExp) {
                            regexpList[key] = value;
                        }
                    }
                }
                for (i = 0; i < arrayOfItems.length; ++i) {
                    var match = true;
                    var candidateItem = arrayOfItems[i];
                    if (candidateItem === null) {
                        match = false;
                    } else {
                        for (key in requestArgs.query) {
                            value = requestArgs.query[key];
                            if (!this._containsValue(candidateItem, key, value, regexpList[key])) {
                                match = false;
                            }
                        }
                    }
                    if (match) {
                        items.push(candidateItem);
                    }
                }
                findCallback(items, requestArgs);
            } else {
                for (i = 0; i < arrayOfItems.length; ++i) {
                    var item = arrayOfItems[i];
                    if (item !== null) {
                        items.push(item);
                    }
                }
                findCallback(items, requestArgs);
            }
        }, _fetchItems:function (keywordArgs, findCallback, errorCallback) {
            var self = this;
            if (this._loadFinished) {
                this.filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions), findCallback);
            } else {
                if (this._jsonFileUrl !== this._ccUrl) {
                    kernel.deprecated(this.declaredClass + ": ", "To change the url, set the url property of the store," + " not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
                    this._ccUrl = this._jsonFileUrl;
                    this.url = this._jsonFileUrl;
                } else {
                    if (this.url !== this._ccUrl) {
                        this._jsonFileUrl = this.url;
                        this._ccUrl = this.url;
                    }
                }
                if (this.data != null) {
                    this._jsonData = this.data;
                    this.data = null;
                }
                if (this._jsonFileUrl) {
                    if (this._loadInProgress) {
                        this._queuedFetches.push({args:keywordArgs, filter:lang.hitch(self, "filter"), findCallback:lang.hitch(self, findCallback)});
                    } else {
                        this._loadInProgress = true;
                        var getArgs = {url:self._jsonFileUrl, handleAs:"json-comment-optional", preventCache:this.urlPreventCache, failOk:this.failOk};
                        var getHandler = xhr.get(getArgs);
                        getHandler.addCallback(function (data) {
                            try {
                                self._getItemsFromLoadedData(data);
                                self._loadFinished = true;
                                self._loadInProgress = false;
                                self.filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions), findCallback);
                                self._handleQueuedFetches();
                            }
                            catch (e) {
                                self._loadFinished = true;
                                self._loadInProgress = false;
                                errorCallback(e, keywordArgs);
                            }
                        });
                        getHandler.addErrback(function (error) {
                            self._loadInProgress = false;
                            errorCallback(error, keywordArgs);
                        });
                        var oldAbort = null;
                        if (keywordArgs.abort) {
                            oldAbort = keywordArgs.abort;
                        }
                        keywordArgs.abort = function () {
                            var df = getHandler;
                            if (df && df.fired === -1) {
                                df.cancel();
                                df = null;
                            }
                            if (oldAbort) {
                                oldAbort.call(keywordArgs);
                            }
                        };
                    }
                } else {
                    if (this._jsonData) {
                        try {
                            this._loadFinished = true;
                            this._getItemsFromLoadedData(this._jsonData);
                            this._jsonData = null;
                            self.filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions), findCallback);
                        }
                        catch (e) {
                            errorCallback(e, keywordArgs);
                        }
                    } else {
                        errorCallback(new Error(this.declaredClass + ": No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
                    }
                }
            }
        }, _handleQueuedFetches:function () {
            if (this._queuedFetches.length > 0) {
                for (var i = 0; i < this._queuedFetches.length; i++) {
                    var fData = this._queuedFetches[i], delayedQuery = fData.args, delayedFilter = fData.filter, delayedFindCallback = fData.findCallback;
                    if (delayedFilter) {
                        delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions), delayedFindCallback);
                    } else {
                        this.fetchItemByIdentity(delayedQuery);
                    }
                }
                this._queuedFetches = [];
            }
        }, _getItemsArray:function (queryOptions) {
            if (queryOptions && queryOptions.deep) {
                return this._arrayOfAllItems;
            }
            return this._arrayOfTopLevelItems;
        }, close:function (request) {
            if (this.clearOnClose && this._loadFinished && !this._loadInProgress) {
                if (((this._jsonFileUrl == "" || this._jsonFileUrl == null) && (this.url == "" || this.url == null)) && this.data == null) {
                    console.debug(this.declaredClass + ": WARNING!  Data reload " + " information has not been provided." + "  Please set 'url' or 'data' to the appropriate value before" + " the next fetch");
                }
                this._arrayOfAllItems = [];
                this._arrayOfTopLevelItems = [];
                this._loadFinished = false;
                this._itemsByIdentity = null;
                this._loadInProgress = false;
                this._queuedFetches = [];
            }
        }, _getItemsFromLoadedData:function (dataObject) {
            var addingArrays = false, self = this;
            function valueIsAnItem(aValue) {
                return (aValue !== null) && (typeof aValue === "object") && (!lang.isArray(aValue) || addingArrays) && (!lang.isFunction(aValue)) && (aValue.constructor == Object || lang.isArray(aValue)) && (typeof aValue._reference === "undefined") && (typeof aValue._type === "undefined") && (typeof aValue._value === "undefined") && self.hierarchical;
            }
            function addItemAndSubItemsToArrayOfAllItems(anItem) {
                self._arrayOfAllItems.push(anItem);
                for (var attribute in anItem) {
                    var valueForAttribute = anItem[attribute];
                    if (valueForAttribute) {
                        if (lang.isArray(valueForAttribute)) {
                            var valueArray = valueForAttribute;
                            for (var k = 0; k < valueArray.length; ++k) {
                                var singleValue = valueArray[k];
                                if (valueIsAnItem(singleValue)) {
                                    addItemAndSubItemsToArrayOfAllItems(singleValue);
                                }
                            }
                        } else {
                            if (valueIsAnItem(valueForAttribute)) {
                                addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
                            }
                        }
                    }
                }
            }
            this._labelAttr = dataObject.label;
            var i, item;
            this._arrayOfAllItems = [];
            this._arrayOfTopLevelItems = dataObject.items;
            for (i = 0; i < this._arrayOfTopLevelItems.length; ++i) {
                item = this._arrayOfTopLevelItems[i];
                if (lang.isArray(item)) {
                    addingArrays = true;
                }
                addItemAndSubItemsToArrayOfAllItems(item);
                item[this._rootItemPropName] = true;
            }
            var allAttributeNames = {}, key;
            for (i = 0; i < this._arrayOfAllItems.length; ++i) {
                item = this._arrayOfAllItems[i];
                for (key in item) {
                    if (key !== this._rootItemPropName) {
                        var value = item[key];
                        if (value !== null) {
                            if (!lang.isArray(value)) {
                                item[key] = [value];
                            }
                        } else {
                            item[key] = [null];
                        }
                    }
                    allAttributeNames[key] = key;
                }
            }
            while (allAttributeNames[this._storeRefPropName]) {
                this._storeRefPropName += "_";
            }
            while (allAttributeNames[this._itemNumPropName]) {
                this._itemNumPropName += "_";
            }
            while (allAttributeNames[this._reverseRefMap]) {
                this._reverseRefMap += "_";
            }
            var arrayOfValues;
            var identifier = dataObject.identifier;
            if (identifier) {
                this._itemsByIdentity = {};
                this._features["dojo.data.api.Identity"] = identifier;
                for (i = 0; i < this._arrayOfAllItems.length; ++i) {
                    item = this._arrayOfAllItems[i];
                    arrayOfValues = item[identifier];
                    var identity = arrayOfValues[0];
                    if (!Object.hasOwnProperty.call(this._itemsByIdentity, identity)) {
                        this._itemsByIdentity[identity] = item;
                    } else {
                        if (this._jsonFileUrl) {
                            throw new Error(this.declaredClass + ":  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
                        } else {
                            if (this._jsonData) {
                                throw new Error(this.declaredClass + ":  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
                            }
                        }
                    }
                }
            } else {
                this._features["dojo.data.api.Identity"] = Number;
            }
            for (i = 0; i < this._arrayOfAllItems.length; ++i) {
                item = this._arrayOfAllItems[i];
                item[this._storeRefPropName] = this;
                item[this._itemNumPropName] = i;
            }
            for (i = 0; i < this._arrayOfAllItems.length; ++i) {
                item = this._arrayOfAllItems[i];
                for (key in item) {
                    arrayOfValues = item[key];
                    for (var j = 0; j < arrayOfValues.length; ++j) {
                        value = arrayOfValues[j];
                        if (value !== null && typeof value == "object") {
                            if (("_type" in value) && ("_value" in value)) {
                                var type = value._type;
                                var mappingObj = this._datatypeMap[type];
                                if (!mappingObj) {
                                    throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
                                } else {
                                    if (lang.isFunction(mappingObj)) {
                                        arrayOfValues[j] = new mappingObj(value._value);
                                    } else {
                                        if (lang.isFunction(mappingObj.deserialize)) {
                                            arrayOfValues[j] = mappingObj.deserialize(value._value);
                                        } else {
                                            throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
                                        }
                                    }
                                }
                            }
                            if (value._reference) {
                                var referenceDescription = value._reference;
                                if (!lang.isObject(referenceDescription)) {
                                    arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
                                } else {
                                    for (var k = 0; k < this._arrayOfAllItems.length; ++k) {
                                        var candidateItem = this._arrayOfAllItems[k], found = true;
                                        for (var refKey in referenceDescription) {
                                            if (candidateItem[refKey] != referenceDescription[refKey]) {
                                                found = false;
                                            }
                                        }
                                        if (found) {
                                            arrayOfValues[j] = candidateItem;
                                        }
                                    }
                                }
                                if (this.referenceIntegrity) {
                                    var refItem = arrayOfValues[j];
                                    if (this.isItem(refItem)) {
                                        this._addReferenceToMap(refItem, item, key);
                                    }
                                }
                            } else {
                                if (this.isItem(value)) {
                                    if (this.referenceIntegrity) {
                                        this._addReferenceToMap(value, item, key);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }, _addReferenceToMap:function (refItem, parentItem, attribute) {
        }, getIdentity:function (item) {
            var identifier = this._features["dojo.data.api.Identity"];
            if (identifier === Number) {
                return item[this._itemNumPropName];
            } else {
                var arrayOfValues = item[identifier];
                if (arrayOfValues) {
                    return arrayOfValues[0];
                }
            }
            return null;
        }, fetchItemByIdentity:function (keywordArgs) {
            var item, scope;
            if (!this._loadFinished) {
                var self = this;
                if (this._jsonFileUrl !== this._ccUrl) {
                    kernel.deprecated(this.declaredClass + ": ", "To change the url, set the url property of the store," + " not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
                    this._ccUrl = this._jsonFileUrl;
                    this.url = this._jsonFileUrl;
                } else {
                    if (this.url !== this._ccUrl) {
                        this._jsonFileUrl = this.url;
                        this._ccUrl = this.url;
                    }
                }
                if (this.data != null && this._jsonData == null) {
                    this._jsonData = this.data;
                    this.data = null;
                }
                if (this._jsonFileUrl) {
                    if (this._loadInProgress) {
                        this._queuedFetches.push({args:keywordArgs});
                    } else {
                        this._loadInProgress = true;
                        var getArgs = {url:self._jsonFileUrl, handleAs:"json-comment-optional", preventCache:this.urlPreventCache, failOk:this.failOk};
                        var getHandler = xhr.get(getArgs);
                        getHandler.addCallback(function (data) {
                            var scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;
                            try {
                                self._getItemsFromLoadedData(data);
                                self._loadFinished = true;
                                self._loadInProgress = false;
                                item = self._getItemByIdentity(keywordArgs.identity);
                                if (keywordArgs.onItem) {
                                    keywordArgs.onItem.call(scope, item);
                                }
                                self._handleQueuedFetches();
                            }
                            catch (error) {
                                self._loadInProgress = false;
                                if (keywordArgs.onError) {
                                    keywordArgs.onError.call(scope, error);
                                }
                            }
                        });
                        getHandler.addErrback(function (error) {
                            self._loadInProgress = false;
                            if (keywordArgs.onError) {
                                var scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;
                                keywordArgs.onError.call(scope, error);
                            }
                        });
                    }
                } else {
                    if (this._jsonData) {
                        self._getItemsFromLoadedData(self._jsonData);
                        self._jsonData = null;
                        self._loadFinished = true;
                        item = self._getItemByIdentity(keywordArgs.identity);
                        if (keywordArgs.onItem) {
                            scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;
                            keywordArgs.onItem.call(scope, item);
                        }
                    }
                }
            } else {
                item = this._getItemByIdentity(keywordArgs.identity);
                if (keywordArgs.onItem) {
                    scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;
                    keywordArgs.onItem.call(scope, item);
                }
            }
        }, _getItemByIdentity:function (identity) {
            var item = null;
            if (this._itemsByIdentity) {
                if (Object.hasOwnProperty.call(this._itemsByIdentity, identity)) {
                    item = this._itemsByIdentity[identity];
                }
            } else {
                if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)) {
                    item = this._arrayOfAllItems[identity];
                }
            }
            if (item === undefined) {
                item = null;
            }
            return item;
        }, getIdentityAttributes:function (item) {
            var identifier = this._features["dojo.data.api.Identity"];
            if (identifier === Number) {
                return null;
            } else {
                return [identifier];
            }
        }, _forceLoad:function () {
            var self = this;
            if (this._jsonFileUrl !== this._ccUrl) {
                kernel.deprecated(this.declaredClass + ": ", "To change the url, set the url property of the store," + " not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
                this._ccUrl = this._jsonFileUrl;
                this.url = this._jsonFileUrl;
            } else {
                if (this.url !== this._ccUrl) {
                    this._jsonFileUrl = this.url;
                    this._ccUrl = this.url;
                }
            }
            if (this.data != null) {
                this._jsonData = this.data;
                this.data = null;
            }
            if (this._jsonFileUrl) {
                var getArgs = {url:this._jsonFileUrl, handleAs:"json-comment-optional", preventCache:this.urlPreventCache, failOk:this.failOk, sync:true};
                var getHandler = xhr.get(getArgs);
                getHandler.addCallback(function (data) {
                    try {
                        if (self._loadInProgress !== true && !self._loadFinished) {
                            self._getItemsFromLoadedData(data);
                            self._loadFinished = true;
                        } else {
                            if (self._loadInProgress) {
                                throw new Error(this.declaredClass + ":  Unable to perform a synchronous load, an async load is in progress.");
                            }
                        }
                    }
                    catch (e) {
                        console.log(e);
                        throw e;
                    }
                });
                getHandler.addErrback(function (error) {
                    throw error;
                });
            } else {
                if (this._jsonData) {
                    self._getItemsFromLoadedData(self._jsonData);
                    self._jsonData = null;
                    self._loadFinished = true;
                }
            }
        }});
        lang.extend(ItemFileReadStore, simpleFetch);
        return ItemFileReadStore;
    });
}, "dijit/form/ComboButton":function () {
    define(["dojo/_base/declare", "dojo/keys", "../focus", "./DropDownButton", "dojo/text!./templates/ComboButton.html"], function (declare, keys, focus, DropDownButton, template) {
        return declare("dijit.form.ComboButton", DropDownButton, {templateString:template, _setIdAttr:"", _setTabIndexAttr:["focusNode", "titleNode"], _setTitleAttr:"titleNode", optionsTitle:"", baseClass:"dijitComboButton", cssStateNodes:{"buttonNode":"dijitButtonNode", "titleNode":"dijitButtonContents", "_popupStateNode":"dijitDownArrowButton"}, _focusedNode:null, _onButtonKeyDown:function (evt) {
            if (evt.keyCode == keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]) {
                focus.focus(this._popupStateNode);
                evt.stopPropagation();
                evt.preventDefault();
            }
        }, _onArrowKeyDown:function (evt) {
            if (evt.keyCode == keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]) {
                focus.focus(this.titleNode);
                evt.stopPropagation();
                evt.preventDefault();
            }
        }, focus:function (position) {
            if (!this.disabled) {
                focus.focus(position == "start" ? this.titleNode : this._popupStateNode);
            }
        }});
    });
}, "dijit/WidgetSet":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/_base/kernel", "./registry"], function (array, declare, kernel, registry) {
        var WidgetSet = declare("dijit.WidgetSet", null, {constructor:function () {
            this._hash = {};
            this.length = 0;
        }, add:function (widget) {
            if (this._hash[widget.id]) {
                throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
            }
            this._hash[widget.id] = widget;
            this.length++;
        }, remove:function (id) {
            if (this._hash[id]) {
                delete this._hash[id];
                this.length--;
            }
        }, forEach:function (func, thisObj) {
            thisObj = thisObj || kernel.global;
            var i = 0, id;
            for (id in this._hash) {
                func.call(thisObj, this._hash[id], i++, this._hash);
            }
            return this;
        }, filter:function (filter, thisObj) {
            thisObj = thisObj || kernel.global;
            var res = new WidgetSet(), i = 0, id;
            for (id in this._hash) {
                var w = this._hash[id];
                if (filter.call(thisObj, w, i++, this._hash)) {
                    res.add(w);
                }
            }
            return res;
        }, byId:function (id) {
            return this._hash[id];
        }, byClass:function (cls) {
            var res = new WidgetSet(), id, widget;
            for (id in this._hash) {
                widget = this._hash[id];
                if (widget.declaredClass == cls) {
                    res.add(widget);
                }
            }
            return res;
        }, toArray:function () {
            var ar = [];
            for (var id in this._hash) {
                ar.push(this._hash[id]);
            }
            return ar;
        }, map:function (func, thisObj) {
            return array.map(this.toArray(), func, thisObj);
        }, every:function (func, thisObj) {
            thisObj = thisObj || kernel.global;
            var x = 0, i;
            for (i in this._hash) {
                if (!func.call(thisObj, this._hash[i], x++, this._hash)) {
                    return false;
                }
            }
            return true;
        }, some:function (func, thisObj) {
            thisObj = thisObj || kernel.global;
            var x = 0, i;
            for (i in this._hash) {
                if (func.call(thisObj, this._hash[i], x++, this._hash)) {
                    return true;
                }
            }
            return false;
        }});
        array.forEach(["forEach", "filter", "byClass", "map", "every", "some"], function (func) {
            registry[func] = WidgetSet.prototype[func];
        });
        return WidgetSet;
    });
}, "dijit/form/RangeBoundTextBox":function () {
    define(["dojo/_base/declare", "dojo/i18n", "./MappedTextBox"], function (declare, i18n, MappedTextBox) {
        var RangeBoundTextBox = declare("dijit.form.RangeBoundTextBox", MappedTextBox, {rangeMessage:"", rangeCheck:function (primitive, constraints) {
            return ("min" in constraints ? (this.compare(primitive, constraints.min) >= 0) : true) && ("max" in constraints ? (this.compare(primitive, constraints.max) <= 0) : true);
        }, isInRange:function () {
            return this.rangeCheck(this.get("value"), this.constraints);
        }, _isDefinitelyOutOfRange:function () {
            var val = this.get("value");
            if (val == null) {
                return false;
            }
            var outOfRange = false;
            if ("min" in this.constraints) {
                var min = this.constraints.min;
                outOfRange = this.compare(val, ((typeof min == "number") && min >= 0 && val != 0) ? 0 : min) < 0;
            }
            if (!outOfRange && ("max" in this.constraints)) {
                var max = this.constraints.max;
                outOfRange = this.compare(val, ((typeof max != "number") || max > 0) ? max : 0) > 0;
            }
            return outOfRange;
        }, _isValidSubset:function () {
            return this.inherited(arguments) && !this._isDefinitelyOutOfRange();
        }, isValid:function (isFocused) {
            return this.inherited(arguments) && ((this._isEmpty(this.textbox.value) && !this.required) || this.isInRange(isFocused));
        }, getErrorMessage:function (isFocused) {
            var v = this.get("value");
            if (v != null && v !== "" && (typeof v != "number" || !isNaN(v)) && !this.isInRange(isFocused)) {
                return this.rangeMessage;
            }
            return this.inherited(arguments);
        }, postMixInProperties:function () {
            this.inherited(arguments);
            if (!this.rangeMessage) {
                this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
                this.rangeMessage = this.messages.rangeMessage;
            }
        }});
        return RangeBoundTextBox;
    });
}, "dojo/dom-class":function () {
    define(["./_base/lang", "./_base/array", "./dom"], function (lang, array, dom) {
        var className = "className";
        var cls, spaces = /\s+/, a1 = [""];
        function str2array(s) {
            if (typeof s == "string" || s instanceof String) {
                if (s && !spaces.test(s)) {
                    a1[0] = s;
                    return a1;
                }
                var a = s.split(spaces);
                if (a.length && !a[0]) {
                    a.shift();
                }
                if (a.length && !a[a.length - 1]) {
                    a.pop();
                }
                return a;
            }
            if (!s) {
                return [];
            }
            return array.filter(s, function (x) {
                return x;
            });
        }
        var fakeNode = {};
        cls = {contains:function containsClass(node, classStr) {
            return ((" " + dom.byId(node)[className] + " ").indexOf(" " + classStr + " ") >= 0);
        }, add:function addClass(node, classStr) {
            node = dom.byId(node);
            classStr = str2array(classStr);
            var cls = node[className], oldLen;
            cls = cls ? " " + cls + " " : " ";
            oldLen = cls.length;
            for (var i = 0, len = classStr.length, c; i < len; ++i) {
                c = classStr[i];
                if (c && cls.indexOf(" " + c + " ") < 0) {
                    cls += c + " ";
                }
            }
            if (oldLen < cls.length) {
                node[className] = cls.substr(1, cls.length - 2);
            }
        }, remove:function removeClass(node, classStr) {
            node = dom.byId(node);
            var cls;
            if (classStr !== undefined) {
                classStr = str2array(classStr);
                cls = " " + node[className] + " ";
                for (var i = 0, len = classStr.length; i < len; ++i) {
                    cls = cls.replace(" " + classStr[i] + " ", " ");
                }
                cls = lang.trim(cls);
            } else {
                cls = "";
            }
            if (node[className] != cls) {
                node[className] = cls;
            }
        }, replace:function replaceClass(node, addClassStr, removeClassStr) {
            node = dom.byId(node);
            fakeNode[className] = node[className];
            cls.remove(fakeNode, removeClassStr);
            cls.add(fakeNode, addClassStr);
            if (node[className] !== fakeNode[className]) {
                node[className] = fakeNode[className];
            }
        }, toggle:function toggleClass(node, classStr, condition) {
            node = dom.byId(node);
            if (condition === undefined) {
                classStr = str2array(classStr);
                for (var i = 0, len = classStr.length, c; i < len; ++i) {
                    c = classStr[i];
                    cls[cls.contains(node, c) ? "remove" : "add"](node, c);
                }
            } else {
                cls[condition ? "add" : "remove"](node, classStr);
            }
            return condition;
        }};
        return cls;
    });
}, "dojox/html/entities":function () {
    define(["dojo/_base/lang"], function (lang) {
        var dhe = lang.getObject("dojox.html.entities", true);
        var _applyEncodingMap = function (str, map) {
            var mapper, regexp;
            if (map._encCache && map._encCache.regexp && map._encCache.mapper && map.length == map._encCache.length) {
                mapper = map._encCache.mapper;
                regexp = map._encCache.regexp;
            } else {
                mapper = {};
                regexp = ["["];
                var i;
                for (i = 0; i < map.length; i++) {
                    mapper[map[i][0]] = "&" + map[i][1] + ";";
                    regexp.push(map[i][0]);
                }
                regexp.push("]");
                regexp = new RegExp(regexp.join(""), "g");
                map._encCache = {mapper:mapper, regexp:regexp, length:map.length};
            }
            str = str.replace(regexp, function (c) {
                return mapper[c];
            });
            return str;
        };
        var _applyDecodingMap = function (str, map) {
            var mapper, regexp;
            if (map._decCache && map._decCache.regexp && map._decCache.mapper && map.length == map._decCache.length) {
                mapper = map._decCache.mapper;
                regexp = map._decCache.regexp;
            } else {
                mapper = {};
                regexp = ["("];
                var i;
                for (i = 0; i < map.length; i++) {
                    var e = "&" + map[i][1] + ";";
                    if (i) {
                        regexp.push("|");
                    }
                    mapper[e] = map[i][0];
                    regexp.push(e);
                }
                regexp.push(")");
                regexp = new RegExp(regexp.join(""), "g");
                map._decCache = {mapper:mapper, regexp:regexp, length:map.length};
            }
            str = str.replace(regexp, function (c) {
                return mapper[c];
            });
            return str;
        };
        dhe.html = [["&", "amp"], ["\"", "quot"], ["<", "lt"], [">", "gt"], ["\xa0", "nbsp"]];
        dhe.latin = [["\xa1", "iexcl"], ["\xa2", "cent"], ["\xa3", "pound"], ["\u20ac", "euro"], ["\xa4", "curren"], ["\xa5", "yen"], ["\xa6", "brvbar"], ["\xa7", "sect"], ["\xa8", "uml"], ["\xa9", "copy"], ["\xaa", "ordf"], ["\xab", "laquo"], ["\xac", "not"], ["\xad", "shy"], ["\xae", "reg"], ["\xaf", "macr"], ["\xb0", "deg"], ["\xb1", "plusmn"], ["\xb2", "sup2"], ["\xb3", "sup3"], ["\xb4", "acute"], ["\xb5", "micro"], ["\xb6", "para"], ["\xb7", "middot"], ["\xb8", "cedil"], ["\xb9", "sup1"], ["\xba", "ordm"], ["\xbb", "raquo"], ["\xbc", "frac14"], ["\xbd", "frac12"], ["\xbe", "frac34"], ["\xbf", "iquest"], ["\xc0", "Agrave"], ["\xc1", "Aacute"], ["\xc2", "Acirc"], ["\xc3", "Atilde"], ["\xc4", "Auml"], ["\xc5", "Aring"], ["\xc6", "AElig"], ["\xc7", "Ccedil"], ["\xc8", "Egrave"], ["\xc9", "Eacute"], ["\xca", "Ecirc"], ["\xcb", "Euml"], ["\xcc", "Igrave"], ["\xcd", "Iacute"], ["\xce", "Icirc"], ["\xcf", "Iuml"], ["\xd0", "ETH"], ["\xd1", "Ntilde"], ["\xd2", "Ograve"], ["\xd3", "Oacute"], ["\xd4", "Ocirc"], ["\xd5", "Otilde"], ["\xd6", "Ouml"], ["\xd7", "times"], ["\xd8", "Oslash"], ["\xd9", "Ugrave"], ["\xda", "Uacute"], ["\xdb", "Ucirc"], ["\xdc", "Uuml"], ["\xdd", "Yacute"], ["\xde", "THORN"], ["\xdf", "szlig"], ["\xe0", "agrave"], ["\xe1", "aacute"], ["\xe2", "acirc"], ["\xe3", "atilde"], ["\xe4", "auml"], ["\xe5", "aring"], ["\xe6", "aelig"], ["\xe7", "ccedil"], ["\xe8", "egrave"], ["\xe9", "eacute"], ["\xea", "ecirc"], ["\xeb", "euml"], ["\xec", "igrave"], ["\xed", "iacute"], ["\xee", "icirc"], ["\xef", "iuml"], ["\xf0", "eth"], ["\xf1", "ntilde"], ["\xf2", "ograve"], ["\xf3", "oacute"], ["\xf4", "ocirc"], ["\xf5", "otilde"], ["\xf6", "ouml"], ["\xf7", "divide"], ["\xf8", "oslash"], ["\xf9", "ugrave"], ["\xfa", "uacute"], ["\xfb", "ucirc"], ["\xfc", "uuml"], ["\xfd", "yacute"], ["\xfe", "thorn"], ["\xff", "yuml"], ["\u0192", "fnof"], ["\u0391", "Alpha"], ["\u0392", "Beta"], ["\u0393", "Gamma"], ["\u0394", "Delta"], ["\u0395", "Epsilon"], ["\u0396", "Zeta"], ["\u0397", "Eta"], ["\u0398", "Theta"], ["\u0399", "Iota"], ["\u039a", "Kappa"], ["\u039b", "Lambda"], ["\u039c", "Mu"], ["\u039d", "Nu"], ["\u039e", "Xi"], ["\u039f", "Omicron"], ["\u03a0", "Pi"], ["\u03a1", "Rho"], ["\u03a3", "Sigma"], ["\u03a4", "Tau"], ["\u03a5", "Upsilon"], ["\u03a6", "Phi"], ["\u03a7", "Chi"], ["\u03a8", "Psi"], ["\u03a9", "Omega"], ["\u03b1", "alpha"], ["\u03b2", "beta"], ["\u03b3", "gamma"], ["\u03b4", "delta"], ["\u03b5", "epsilon"], ["\u03b6", "zeta"], ["\u03b7", "eta"], ["\u03b8", "theta"], ["\u03b9", "iota"], ["\u03ba", "kappa"], ["\u03bb", "lambda"], ["\u03bc", "mu"], ["\u03bd", "nu"], ["\u03be", "xi"], ["\u03bf", "omicron"], ["\u03c0", "pi"], ["\u03c1", "rho"], ["\u03c2", "sigmaf"], ["\u03c3", "sigma"], ["\u03c4", "tau"], ["\u03c5", "upsilon"], ["\u03c6", "phi"], ["\u03c7", "chi"], ["\u03c8", "psi"], ["\u03c9", "omega"], ["\u03d1", "thetasym"], ["\u03d2", "upsih"], ["\u03d6", "piv"], ["\u2022", "bull"], ["\u2026", "hellip"], ["\u2032", "prime"], ["\u2033", "Prime"], ["\u203e", "oline"], ["\u2044", "frasl"], ["\u2118", "weierp"], ["\u2111", "image"], ["\u211c", "real"], ["\u2122", "trade"], ["\u2135", "alefsym"], ["\u2190", "larr"], ["\u2191", "uarr"], ["\u2192", "rarr"], ["\u2193", "darr"], ["\u2194", "harr"], ["\u21b5", "crarr"], ["\u21d0", "lArr"], ["\u21d1", "uArr"], ["\u21d2", "rArr"], ["\u21d3", "dArr"], ["\u21d4", "hArr"], ["\u2200", "forall"], ["\u2202", "part"], ["\u2203", "exist"], ["\u2205", "empty"], ["\u2207", "nabla"], ["\u2208", "isin"], ["\u2209", "notin"], ["\u220b", "ni"], ["\u220f", "prod"], ["\u2211", "sum"], ["\u2212", "minus"], ["\u2217", "lowast"], ["\u221a", "radic"], ["\u221d", "prop"], ["\u221e", "infin"], ["\u2220", "ang"], ["\u2227", "and"], ["\u2228", "or"], ["\u2229", "cap"], ["\u222a", "cup"], ["\u222b", "int"], ["\u2234", "there4"], ["\u223c", "sim"], ["\u2245", "cong"], ["\u2248", "asymp"], ["\u2260", "ne"], ["\u2261", "equiv"], ["\u2264", "le"], ["\u2265", "ge"], ["\u2282", "sub"], ["\u2283", "sup"], ["\u2284", "nsub"], ["\u2286", "sube"], ["\u2287", "supe"], ["\u2295", "oplus"], ["\u2297", "otimes"], ["\u22a5", "perp"], ["\u22c5", "sdot"], ["\u2308", "lceil"], ["\u2309", "rceil"], ["\u230a", "lfloor"], ["\u230b", "rfloor"], ["\u2329", "lang"], ["\u232a", "rang"], ["\u25ca", "loz"], ["\u2660", "spades"], ["\u2663", "clubs"], ["\u2665", "hearts"], ["\u2666", "diams"], ["\u0152", "OElig"], ["\u0153", "oelig"], ["\u0160", "Scaron"], ["\u0161", "scaron"], ["\u0178", "Yuml"], ["\u02c6", "circ"], ["\u02dc", "tilde"], ["\u2002", "ensp"], ["\u2003", "emsp"], ["\u2009", "thinsp"], ["\u200c", "zwnj"], ["\u200d", "zwj"], ["\u200e", "lrm"], ["\u200f", "rlm"], ["\u2013", "ndash"], ["\u2014", "mdash"], ["\u2018", "lsquo"], ["\u2019", "rsquo"], ["\u201a", "sbquo"], ["\u201c", "ldquo"], ["\u201d", "rdquo"], ["\u201e", "bdquo"], ["\u2020", "dagger"], ["\u2021", "Dagger"], ["\u2030", "permil"], ["\u2039", "lsaquo"], ["\u203a", "rsaquo"]];
        dhe.encode = function (str, m) {
            if (str) {
                if (!m) {
                    str = _applyEncodingMap(str, dhe.html);
                    str = _applyEncodingMap(str, dhe.latin);
                } else {
                    str = _applyEncodingMap(str, m);
                }
            }
            return str;
        };
        dhe.decode = function (str, m) {
            if (str) {
                if (!m) {
                    str = _applyDecodingMap(str, dhe.html);
                    str = _applyDecodingMap(str, dhe.latin);
                } else {
                    str = _applyDecodingMap(str, m);
                }
            }
            return str;
        };
        return dhe;
    });
}, "dojo/touch":function () {
    define(["./_base/kernel", "./aspect", "./dom", "./dom-class", "./_base/lang", "./on", "./has", "./mouse", "./domReady", "./_base/window"], function (dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win) {
        var hasTouch = has("touch");
        var ios4 = has("ios") < 5;
        var msPointer = navigator.pointerEnabled || navigator.msPointerEnabled, pointer = (function () {
            var pointer = {};
            for (var type in {down:1, move:1, up:1, cancel:1, over:1, out:1}) {
                pointer[type] = !navigator.pointerEnabled ? "MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) : "pointer" + type;
            }
            return pointer;
        })();
        var clicksInited, clickTracker, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;
        var lastTouch;
        function dualEvent(mouseType, touchType, msPointerType) {
            if (msPointer && msPointerType) {
                return function (node, listener) {
                    return on(node, msPointerType, listener);
                };
            } else {
                if (hasTouch) {
                    return function (node, listener) {
                        var handle1 = on(node, touchType, function (evt) {
                            listener.call(this, evt);
                            lastTouch = (new Date()).getTime();
                        }), handle2 = on(node, mouseType, function (evt) {
                            if (!lastTouch || (new Date()).getTime() > lastTouch + 1000) {
                                listener.call(this, evt);
                            }
                        });
                        return {remove:function () {
                            handle1.remove();
                            handle2.remove();
                        }};
                    };
                } else {
                    return function (node, listener) {
                        return on(node, mouseType, listener);
                    };
                }
            }
        }
        function marked(node) {
            do {
                if (node.dojoClick !== undefined) {
                    return node.dojoClick;
                }
            } while (node = node.parentNode);
        }
        function doClicks(e, moveType, endType) {
            clickTracker = !e.target.disabled && marked(e.target);
            if (clickTracker) {
                clickTarget = e.target;
                clickX = e.changedTouches ? e.changedTouches[0].pageX : e.clientX;
                clickY = e.changedTouches ? e.changedTouches[0].pageY : e.clientY;
                clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
                clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
                if (!clicksInited) {
                    clicksInited = true;
                    win.doc.addEventListener(moveType, function (e) {
                        clickTracker = clickTracker && (e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget && Math.abs((e.changedTouches ? e.changedTouches[0].pageX : e.clientX) - clickX) <= clickDx && Math.abs((e.changedTouches ? e.changedTouches[0].pageY : e.clientY) - clickY) <= clickDy;
                    }, true);
                    win.doc.addEventListener(endType, function (e) {
                        if (clickTracker) {
                            clickTime = (new Date()).getTime();
                            var target = e.target;
                            if (target.tagName === "LABEL") {
                                target = dom.byId(target.getAttribute("for")) || target;
                            }
                            var src = (e.changedTouches) ? e.changedTouches[0] : e;
                            var clickEvt = document.createEvent("MouseEvents");
                            clickEvt._dojo_click = true;
                            clickEvt.initMouseEvent("click", true, true, e.view, e.detail, src.screenX, src.screenY, src.clientX, src.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
                            setTimeout(function () {
                                on.emit(target, "click", clickEvt);
                            }, 0);
                        }
                    }, true);
                    function stopNativeEvents(type) {
                        win.doc.addEventListener(type, function (e) {
                            if (!e._dojo_click && (new Date()).getTime() <= clickTime + 1000 && !(e.target.tagName == "INPUT" && domClass.contains(e.target, "dijitOffScreen"))) {
                                e.stopPropagation();
                                e.stopImmediatePropagation && e.stopImmediatePropagation();
                                if (type == "click" && (e.target.tagName != "INPUT" || e.target.type == "radio" || e.target.type == "checkbox") && e.target.tagName != "TEXTAREA" && e.target.tagName != "AUDIO" && e.target.tagName != "VIDEO") {
                                    e.preventDefault();
                                }
                            }
                        }, true);
                    }
                    stopNativeEvents("click");
                    stopNativeEvents("mousedown");
                    stopNativeEvents("mouseup");
                }
            }
        }
        var hoveredNode;
        if (hasTouch) {
            if (msPointer) {
                domReady(function () {
                    win.doc.addEventListener(pointer.down, function (evt) {
                        doClicks(evt, pointer.move, pointer.up);
                    }, true);
                });
            } else {
                domReady(function () {
                    hoveredNode = win.body();
                    win.doc.addEventListener("touchstart", function (evt) {
                        lastTouch = (new Date()).getTime();
                        var oldNode = hoveredNode;
                        hoveredNode = evt.target;
                        on.emit(oldNode, "dojotouchout", {relatedTarget:hoveredNode, bubbles:true});
                        on.emit(hoveredNode, "dojotouchover", {relatedTarget:oldNode, bubbles:true});
                        doClicks(evt, "touchmove", "touchend");
                    }, true);
                    function copyEventProps(evt) {
                        var props = lang.delegate(evt, {bubbles:true});
                        if (has("ios") >= 6) {
                            props.touches = evt.touches;
                            props.altKey = evt.altKey;
                            props.changedTouches = evt.changedTouches;
                            props.ctrlKey = evt.ctrlKey;
                            props.metaKey = evt.metaKey;
                            props.shiftKey = evt.shiftKey;
                            props.targetTouches = evt.targetTouches;
                        }
                        return props;
                    }
                    on(win.doc, "touchmove", function (evt) {
                        lastTouch = (new Date()).getTime();
                        var newNode = win.doc.elementFromPoint(evt.pageX - (ios4 ? 0 : win.global.pageXOffset), evt.pageY - (ios4 ? 0 : win.global.pageYOffset));
                        if (newNode) {
                            if (hoveredNode !== newNode) {
                                on.emit(hoveredNode, "dojotouchout", {relatedTarget:newNode, bubbles:true});
                                on.emit(newNode, "dojotouchover", {relatedTarget:hoveredNode, bubbles:true});
                                hoveredNode = newNode;
                            }
                            if (!on.emit(newNode, "dojotouchmove", copyEventProps(evt))) {
                                evt.preventDefault();
                            }
                        }
                    });
                    on(win.doc, "touchend", function (evt) {
                        lastTouch = (new Date()).getTime();
                        var node = win.doc.elementFromPoint(evt.pageX - (ios4 ? 0 : win.global.pageXOffset), evt.pageY - (ios4 ? 0 : win.global.pageYOffset)) || win.body();
                        on.emit(node, "dojotouchend", copyEventProps(evt));
                    });
                });
            }
        }
        var touch = {press:dualEvent("mousedown", "touchstart", pointer.down), move:dualEvent("mousemove", "dojotouchmove", pointer.move), release:dualEvent("mouseup", "dojotouchend", pointer.up), cancel:dualEvent(mouse.leave, "touchcancel", hasTouch ? pointer.cancel : null), over:dualEvent("mouseover", "dojotouchover", pointer.over), out:dualEvent("mouseout", "dojotouchout", pointer.out), enter:mouse._eventHandler(dualEvent("mouseover", "dojotouchover", pointer.over)), leave:mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))};
        1 && (dojo.touch = touch);
        return touch;
    });
}, "dojo/cache":function () {
    define(["./_base/kernel", "./text"], function (dojo) {
        return dojo.cache;
    });
}, "dojo/_base/xhr":function () {
    define(["./kernel", "./sniff", "require", "../io-query", "../dom", "../dom-form", "./Deferred", "./config", "./json", "./lang", "./array", "../on", "../aspect", "../request/watch", "../request/xhr", "../request/util"], function (dojo, has, require, ioq, dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util) {
        dojo._xhrObj = _xhr._create;
        var cfg = dojo.config;
        dojo.objectToQuery = ioq.objectToQuery;
        dojo.queryToObject = ioq.queryToObject;
        dojo.fieldToObject = domForm.fieldToObject;
        dojo.formToObject = domForm.toObject;
        dojo.formToQuery = domForm.toQuery;
        dojo.formToJson = domForm.toJson;
        dojo._blockAsync = false;
        var handlers = dojo._contentHandlers = dojo.contentHandlers = {"text":function (xhr) {
            return xhr.responseText;
        }, "json":function (xhr) {
            return json.fromJson(xhr.responseText || null);
        }, "json-comment-filtered":function (xhr) {
            if (!config.useCommentedJson) {
                console.warn("Consider using the standard mimetype:application/json." + " json-commenting can introduce security issues. To" + " decrease the chances of hijacking, use the standard the 'json' handler and" + " prefix your json with: {}&&\n" + "Use djConfig.useCommentedJson=true to turn off this message.");
            }
            var value = xhr.responseText;
            var cStartIdx = value.indexOf("/*");
            var cEndIdx = value.lastIndexOf("*/");
            if (cStartIdx == -1 || cEndIdx == -1) {
                throw new Error("JSON was not comment filtered");
            }
            return json.fromJson(value.substring(cStartIdx + 2, cEndIdx));
        }, "javascript":function (xhr) {
            return dojo.eval(xhr.responseText);
        }, "xml":function (xhr) {
            var result = xhr.responseXML;
            if (result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")) {
                result = new DOMParser().parseFromString(xhr.responseText, "application/xml");
            }
            if (has("ie")) {
                if ((!result || !result.documentElement)) {
                    var ms = function (n) {
                        return "MSXML" + n + ".DOMDocument";
                    };
                    var dp = ["Microsoft.XMLDOM", ms(6), ms(4), ms(3), ms(2)];
                    array.some(dp, function (p) {
                        try {
                            var dom = new ActiveXObject(p);
                            dom.async = false;
                            dom.loadXML(xhr.responseText);
                            result = dom;
                        }
                        catch (e) {
                            return false;
                        }
                        return true;
                    });
                }
            }
            return result;
        }, "json-comment-optional":function (xhr) {
            if (xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)) {
                return handlers["json-comment-filtered"](xhr);
            } else {
                return handlers["json"](xhr);
            }
        }};
        dojo._ioSetArgs = function (args, canceller, okHandler, errHandler) {
            var ioArgs = {args:args, url:args.url};
            var formObject = null;
            if (args.form) {
                var form = dom.byId(args.form);
                var actnNode = form.getAttributeNode("action");
                ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
                formObject = domForm.toObject(form);
            }
            var miArgs = [{}];
            if (formObject) {
                miArgs.push(formObject);
            }
            if (args.content) {
                miArgs.push(args.content);
            }
            if (args.preventCache) {
                miArgs.push({"dojo.preventCache":new Date().valueOf()});
            }
            ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));
            ioArgs.handleAs = args.handleAs || "text";
            var d = new Deferred(function (dfd) {
                dfd.canceled = true;
                canceller && canceller(dfd);
                var err = dfd.ioArgs.error;
                if (!err) {
                    err = new Error("request cancelled");
                    err.dojoType = "cancel";
                    dfd.ioArgs.error = err;
                }
                return err;
            });
            d.addCallback(okHandler);
            var ld = args.load;
            if (ld && lang.isFunction(ld)) {
                d.addCallback(function (value) {
                    return ld.call(args, value, ioArgs);
                });
            }
            var err = args.error;
            if (err && lang.isFunction(err)) {
                d.addErrback(function (value) {
                    return err.call(args, value, ioArgs);
                });
            }
            var handle = args.handle;
            if (handle && lang.isFunction(handle)) {
                d.addBoth(function (value) {
                    return handle.call(args, value, ioArgs);
                });
            }
            d.addErrback(function (error) {
                return errHandler(error, d);
            });
            if (cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false) {
                d.addCallbacks(function (res) {
                    dojo.publish("/dojo/io/load", [d, res]);
                    return res;
                }, function (res) {
                    dojo.publish("/dojo/io/error", [d, res]);
                    return res;
                });
                d.addBoth(function (res) {
                    dojo.publish("/dojo/io/done", [d, res]);
                    return res;
                });
            }
            d.ioArgs = ioArgs;
            return d;
        };
        var _deferredOk = function (dfd) {
            var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
            return ret === undefined ? null : ret;
        };
        var _deferError = function (error, dfd) {
            if (!dfd.ioArgs.args.failOk) {
                console.error(error);
            }
            return error;
        };
        var _checkPubCount = function (dfd) {
            if (_pubCount <= 0) {
                _pubCount = 0;
                if (cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)) {
                    dojo.publish("/dojo/io/stop");
                }
            }
        };
        var _pubCount = 0;
        aspect.after(watch, "_onAction", function () {
            _pubCount -= 1;
        });
        aspect.after(watch, "_onInFlight", _checkPubCount);
        dojo._ioCancelAll = watch.cancelAll;
        dojo._ioNotifyStart = function (dfd) {
            if (cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false) {
                if (!_pubCount) {
                    dojo.publish("/dojo/io/start");
                }
                _pubCount += 1;
                dojo.publish("/dojo/io/send", [dfd]);
            }
        };
        dojo._ioWatch = function (dfd, validCheck, ioCheck, resHandle) {
            var args = dfd.ioArgs.options = dfd.ioArgs.args;
            lang.mixin(dfd, {response:dfd.ioArgs, isValid:function (response) {
                return validCheck(dfd);
            }, isReady:function (response) {
                return ioCheck(dfd);
            }, handleResponse:function (response) {
                return resHandle(dfd);
            }});
            watch(dfd);
            _checkPubCount(dfd);
        };
        var _defaultContentType = "application/x-www-form-urlencoded";
        dojo._ioAddQueryToUrl = function (ioArgs) {
            if (ioArgs.query.length) {
                ioArgs.url += (ioArgs.url.indexOf("?") == -1 ? "?" : "&") + ioArgs.query;
                ioArgs.query = null;
            }
        };
        dojo.xhr = function (method, args, hasBody) {
            var rDfd;
            var dfd = dojo._ioSetArgs(args, function (dfd) {
                rDfd && rDfd.cancel();
            }, _deferredOk, _deferError);
            var ioArgs = dfd.ioArgs;
            if ("postData" in args) {
                ioArgs.query = args.postData;
            } else {
                if ("putData" in args) {
                    ioArgs.query = args.putData;
                } else {
                    if ("rawBody" in args) {
                        ioArgs.query = args.rawBody;
                    } else {
                        if ((arguments.length > 2 && !hasBody) || "POST|PUT".indexOf(method.toUpperCase()) === -1) {
                            dojo._ioAddQueryToUrl(ioArgs);
                        }
                    }
                }
            }
            var options = {method:method, handleAs:"text", timeout:args.timeout, withCredentials:args.withCredentials, ioArgs:ioArgs};
            if (typeof args.headers !== "undefined") {
                options.headers = args.headers;
            }
            if (typeof args.contentType !== "undefined") {
                if (!options.headers) {
                    options.headers = {};
                }
                options.headers["Content-Type"] = args.contentType;
            }
            if (typeof ioArgs.query !== "undefined") {
                options.data = ioArgs.query;
            }
            if (typeof args.sync !== "undefined") {
                options.sync = args.sync;
            }
            dojo._ioNotifyStart(dfd);
            try {
                rDfd = _xhr(ioArgs.url, options, true);
            }
            catch (e) {
                dfd.cancel();
                return dfd;
            }
            dfd.ioArgs.xhr = rDfd.response.xhr;
            rDfd.then(function () {
                dfd.resolve(dfd);
            }).otherwise(function (error) {
                ioArgs.error = error;
                if (error.response) {
                    error.status = error.response.status;
                    error.responseText = error.response.text;
                    error.xhr = error.response.xhr;
                }
                dfd.reject(error);
            });
            return dfd;
        };
        dojo.xhrGet = function (args) {
            return dojo.xhr("GET", args);
        };
        dojo.rawXhrPost = dojo.xhrPost = function (args) {
            return dojo.xhr("POST", args, true);
        };
        dojo.rawXhrPut = dojo.xhrPut = function (args) {
            return dojo.xhr("PUT", args, true);
        };
        dojo.xhrDelete = function (args) {
            return dojo.xhr("DELETE", args);
        };
        dojo._isDocumentOk = function (x) {
            return util.checkStatus(x.status);
        };
        dojo._getText = function (url) {
            var result;
            dojo.xhrGet({url:url, sync:true, load:function (text) {
                result = text;
            }});
            return result;
        };
        lang.mixin(dojo.xhr, {_xhrObj:dojo._xhrObj, fieldToObject:domForm.fieldToObject, formToObject:domForm.toObject, objectToQuery:ioq.objectToQuery, formToQuery:domForm.toQuery, formToJson:domForm.toJson, queryToObject:ioq.queryToObject, contentHandlers:handlers, _ioSetArgs:dojo._ioSetArgs, _ioCancelAll:dojo._ioCancelAll, _ioNotifyStart:dojo._ioNotifyStart, _ioWatch:dojo._ioWatch, _ioAddQueryToUrl:dojo._ioAddQueryToUrl, _isDocumentOk:dojo._isDocumentOk, _getText:dojo._getText, get:dojo.xhrGet, post:dojo.xhrPost, put:dojo.xhrPut, del:dojo.xhrDelete});
        return dojo.xhr;
    });
}, "dijit/DialogUnderlay":function () {
    define(["dojo/_base/declare", "dojo/_base/lang", "dojo/aspect", "dojo/dom-attr", "dojo/dom-style", "dojo/on", "dojo/window", "./_Widget", "./_TemplatedMixin", "./BackgroundIframe", "./Viewport", "./main"], function (declare, lang, aspect, domAttr, domStyle, on, winUtils, _Widget, _TemplatedMixin, BackgroundIframe, Viewport, dijit) {
        var DialogUnderlay = declare("dijit.DialogUnderlay", [_Widget, _TemplatedMixin], {templateString:"<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' tabIndex='-1' data-dojo-attach-point='node'></div></div>", dialogId:"", "class":"", _modalConnects:[], _setDialogIdAttr:function (id) {
            domAttr.set(this.node, "id", id + "_underlay");
            this._set("dialogId", id);
        }, _setClassAttr:function (clazz) {
            this.node.className = "dijitDialogUnderlay " + clazz;
            this._set("class", clazz);
        }, postCreate:function () {
            this.ownerDocumentBody.appendChild(this.domNode);
            this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")));
            this.inherited(arguments);
        }, layout:function () {
            var is = this.node.style, os = this.domNode.style;
            os.display = "none";
            var viewport = winUtils.getBox(this.ownerDocument);
            os.top = viewport.t + "px";
            os.left = viewport.l + "px";
            is.width = viewport.w + "px";
            is.height = viewport.h + "px";
            os.display = "block";
        }, show:function () {
            this.domNode.style.display = "block";
            this.open = true;
            this.layout();
            this.bgIframe = new BackgroundIframe(this.domNode);
            var win = winUtils.get(this.ownerDocument);
            this._modalConnects = [Viewport.on("resize", lang.hitch(this, "layout")), on(win, "scroll", lang.hitch(this, "layout"))];
        }, hide:function () {
            this.bgIframe.destroy();
            delete this.bgIframe;
            this.domNode.style.display = "none";
            while (this._modalConnects.length) {
                (this._modalConnects.pop()).remove();
            }
            this.open = false;
        }, destroy:function () {
            while (this._modalConnects.length) {
                (this._modalConnects.pop()).remove();
            }
            this.inherited(arguments);
        }, _onKeyDown:function () {
        }});
        DialogUnderlay.show = function (attrs, zIndex) {
            var underlay = DialogUnderlay._singleton;
            if (!underlay || underlay._destroyed) {
                underlay = dijit._underlay = DialogUnderlay._singleton = new DialogUnderlay(attrs);
            } else {
                if (attrs) {
                    underlay.set(attrs);
                }
            }
            domStyle.set(underlay.domNode, "zIndex", zIndex);
            if (!underlay.open) {
                underlay.show();
            }
        };
        DialogUnderlay.hide = function () {
            var underlay = DialogUnderlay._singleton;
            if (underlay && !underlay._destroyed) {
                underlay.hide();
            }
        };
        return DialogUnderlay;
    });
}, "dijit/form/_ToggleButtonMixin":function () {
    define(["dojo/_base/declare", "dojo/dom-attr"], function (declare, domAttr) {
        return declare("dijit.form._ToggleButtonMixin", null, {checked:false, _aria_attr:"aria-pressed", _onClick:function (evt) {
            var original = this.checked;
            this._set("checked", !original);
            var ret = this.inherited(arguments);
            this.set("checked", ret ? this.checked : original);
            return ret;
        }, _setCheckedAttr:function (value, priorityChange) {
            this._set("checked", value);
            var node = this.focusNode || this.domNode;
            if (this._created) {
                if (domAttr.get(node, "checked") != !!value) {
                    domAttr.set(node, "checked", !!value);
                }
            }
            node.setAttribute(this._aria_attr, String(value));
            this._handleOnChange(value, priorityChange);
        }, postCreate:function () {
            this.inherited(arguments);
            var node = this.focusNode || this.domNode;
            if (this.checked) {
                node.setAttribute("checked", "checked");
            }
        }, reset:function () {
            this._hasBeenBlurred = false;
            this.set("checked", this.params.checked || false);
        }});
    });
}, "dojo/store/util/SimpleQueryEngine":function () {
    define(["../../_base/array"], function (arrayUtil) {
        return function (query, options) {
            switch (typeof query) {
              default:
                throw new Error("Can not query with a " + typeof query);
              case "object":
              case "undefined":
                var queryObject = query;
                query = function (object) {
                    for (var key in queryObject) {
                        var required = queryObject[key];
                        if (required && required.test) {
                            if (!required.test(object[key], object)) {
                                return false;
                            }
                        } else {
                            if (required != object[key]) {
                                return false;
                            }
                        }
                    }
                    return true;
                };
                break;
              case "string":
                if (!this[query]) {
                    throw new Error("No filter function " + query + " was found in store");
                }
                query = this[query];
              case "function":
            }
            function execute(array) {
                var results = arrayUtil.filter(array, query);
                var sortSet = options && options.sort;
                if (sortSet) {
                    results.sort(typeof sortSet == "function" ? sortSet : function (a, b) {
                        for (var sort, i = 0; sort = sortSet[i]; i++) {
                            var aValue = a[sort.attribute];
                            var bValue = b[sort.attribute];
                            aValue = aValue != null ? aValue.valueOf() : aValue;
                            bValue = bValue != null ? bValue.valueOf() : bValue;
                            if (aValue != bValue) {
                                return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
                            }
                        }
                        return 0;
                    });
                }
                if (options && (options.start || options.count)) {
                    var total = results.length;
                    results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
                    results.total = total;
                }
                return results;
            }
            execute.matches = query;
            return execute;
        };
    });
}, "dijit/_TemplatedMixin":function () {
    define(["dojo/cache", "dojo/_base/declare", "dojo/dom-construct", "dojo/_base/lang", "dojo/on", "dojo/sniff", "dojo/string", "./_AttachMixin"], function (cache, declare, domConstruct, lang, on, has, string, _AttachMixin) {
        var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {templateString:null, templatePath:null, _skipNodeCache:false, searchContainerNode:true, _stringRepl:function (tmpl) {
            var className = this.declaredClass, _this = this;
            return string.substitute(tmpl, this, function (value, key) {
                if (key.charAt(0) == "!") {
                    value = lang.getObject(key.substr(1), false, _this);
                }
                if (typeof value == "undefined") {
                    throw new Error(className + " template:" + key);
                }
                if (value == null) {
                    return "";
                }
                return key.charAt(0) == "!" ? value : value.toString().replace(/"/g, "&quot;");
            }, this);
        }, buildRendering:function () {
            if (!this._rendered) {
                if (!this.templateString) {
                    this.templateString = cache(this.templatePath, {sanitize:true});
                }
                var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);
                var node;
                if (lang.isString(cached)) {
                    node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
                    if (node.nodeType != 1) {
                        throw new Error("Invalid template: " + cached);
                    }
                } else {
                    node = cached.cloneNode(true);
                }
                this.domNode = node;
            }
            this.inherited(arguments);
            if (!this._rendered) {
                this._fillContent(this.srcNodeRef);
            }
            this._rendered = true;
        }, _fillContent:function (source) {
            var dest = this.containerNode;
            if (source && dest) {
                while (source.hasChildNodes()) {
                    dest.appendChild(source.firstChild);
                }
            }
        }});
        _TemplatedMixin._templateCache = {};
        _TemplatedMixin.getCachedTemplate = function (templateString, alwaysUseString, doc) {
            var tmplts = _TemplatedMixin._templateCache;
            var key = templateString;
            var cached = tmplts[key];
            if (cached) {
                try {
                    if (!cached.ownerDocument || cached.ownerDocument == (doc || document)) {
                        return cached;
                    }
                }
                catch (e) {
                }
                domConstruct.destroy(cached);
            }
            templateString = string.trim(templateString);
            if (alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)) {
                return (tmplts[key] = templateString);
            } else {
                var node = domConstruct.toDom(templateString, doc);
                if (node.nodeType != 1) {
                    throw new Error("Invalid template: " + templateString);
                }
                return (tmplts[key] = node);
            }
        };
        if (has("ie")) {
            on(window, "unload", function () {
                var cache = _TemplatedMixin._templateCache;
                for (var key in cache) {
                    var value = cache[key];
                    if (typeof value == "object") {
                        domConstruct.destroy(value);
                    }
                    delete cache[key];
                }
            });
        }
        return _TemplatedMixin;
    });
}, "dojo/dnd/AutoSource":function () {
    define(["../_base/declare", "./Source"], function (declare, Source) {
        return declare("dojo.dnd.AutoSource", Source, {constructor:function () {
            this.autoSync = true;
        }});
    });
}, "dijit/form/HorizontalSlider":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dnd/move", "dojo/_base/fx", "dojo/dom-geometry", "dojo/dom-style", "dojo/keys", "dojo/_base/lang", "dojo/sniff", "dojo/dnd/Moveable", "dojo/dnd/Mover", "dojo/query", "dojo/mouse", "dojo/on", "../_base/manager", "../focus", "../typematic", "./Button", "./_FormValueWidget", "../_Container", "dojo/text!./templates/HorizontalSlider.html"], function (array, declare, move, fx, domGeometry, domStyle, keys, lang, has, Moveable, Mover, query, mouse, on, manager, focus, typematic, Button, _FormValueWidget, _Container, template) {
        var _SliderMover = declare("dijit.form._SliderMover", Mover, {onMouseMove:function (e) {
            var widget = this.widget;
            var abspos = widget._abspos;
            if (!abspos) {
                abspos = widget._abspos = domGeometry.position(widget.sliderBarContainer, true);
                widget._setPixelValue_ = lang.hitch(widget, "_setPixelValue");
                widget._isReversed_ = widget._isReversed();
            }
            var pixelValue = e[widget._mousePixelCoord] - abspos[widget._startingPixelCoord];
            widget._setPixelValue_(widget._isReversed_ ? (abspos[widget._pixelCount] - pixelValue) : pixelValue, abspos[widget._pixelCount], false);
        }, destroy:function (e) {
            Mover.prototype.destroy.apply(this, arguments);
            var widget = this.widget;
            widget._abspos = null;
            widget._setValueAttr(widget.value, true);
        }});
        var HorizontalSlider = declare("dijit.form.HorizontalSlider", [_FormValueWidget, _Container], {templateString:template, value:0, showButtons:true, minimum:0, maximum:100, discreteValues:Infinity, pageIncrement:2, clickSelect:true, slideDuration:manager.defaultDuration, _setIdAttr:"", _setNameAttr:"valueNode", baseClass:"dijitSlider", cssStateNodes:{incrementButton:"dijitSliderIncrementButton", decrementButton:"dijitSliderDecrementButton", focusNode:"dijitSliderThumb"}, _mousePixelCoord:"pageX", _pixelCount:"w", _startingPixelCoord:"x", _handleOffsetCoord:"left", _progressPixelSize:"width", _onKeyUp:function (e) {
            if (this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }
            this._setValueAttr(this.value, true);
        }, _onKeyDown:function (e) {
            if (this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }
            switch (e.keyCode) {
              case keys.HOME:
                this._setValueAttr(this.minimum, false);
                break;
              case keys.END:
                this._setValueAttr(this.maximum, false);
                break;
              case ((this._descending || this.isLeftToRight()) ? keys.RIGHT_ARROW : keys.LEFT_ARROW):
              case (this._descending === false ? keys.DOWN_ARROW : keys.UP_ARROW):
              case (this._descending === false ? keys.PAGE_DOWN : keys.PAGE_UP):
                this.increment(e);
                break;
              case ((this._descending || this.isLeftToRight()) ? keys.LEFT_ARROW : keys.RIGHT_ARROW):
              case (this._descending === false ? keys.UP_ARROW : keys.DOWN_ARROW):
              case (this._descending === false ? keys.PAGE_UP : keys.PAGE_DOWN):
                this.decrement(e);
                break;
              default:
                return;
            }
            e.stopPropagation();
            e.preventDefault();
        }, _onHandleClick:function (e) {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (!has("ie")) {
                focus.focus(this.sliderHandle);
            }
            e.stopPropagation();
            e.preventDefault();
        }, _isReversed:function () {
            return !this.isLeftToRight();
        }, _onBarClick:function (e) {
            if (this.disabled || this.readOnly || !this.clickSelect) {
                return;
            }
            focus.focus(this.sliderHandle);
            e.stopPropagation();
            e.preventDefault();
            var abspos = domGeometry.position(this.sliderBarContainer, true);
            var pixelValue = e[this._mousePixelCoord] - abspos[this._startingPixelCoord];
            this._setPixelValue(this._isReversed() ? (abspos[this._pixelCount] - pixelValue) : pixelValue, abspos[this._pixelCount], true);
            this._movable.onMouseDown(e);
        }, _setPixelValue:function (pixelValue, maxPixels, priorityChange) {
            if (this.disabled || this.readOnly) {
                return;
            }
            var count = this.discreteValues;
            if (count <= 1 || count == Infinity) {
                count = maxPixels;
            }
            count--;
            var pixelsPerValue = maxPixels / count;
            var wholeIncrements = Math.round(pixelValue / pixelsPerValue);
            this._setValueAttr(Math.max(Math.min((this.maximum - this.minimum) * wholeIncrements / count + this.minimum, this.maximum), this.minimum), priorityChange);
        }, _setValueAttr:function (value, priorityChange) {
            this._set("value", value);
            this.valueNode.value = value;
            this.focusNode.setAttribute("aria-valuenow", value);
            this.inherited(arguments);
            var percent = (value - this.minimum) / (this.maximum - this.minimum);
            var progressBar = (this._descending === false) ? this.remainingBar : this.progressBar;
            var remainingBar = (this._descending === false) ? this.progressBar : this.remainingBar;
            if (this._inProgressAnim && this._inProgressAnim.status != "stopped") {
                this._inProgressAnim.stop(true);
            }
            if (priorityChange && this.slideDuration > 0 && progressBar.style[this._progressPixelSize]) {
                var _this = this;
                var props = {};
                var start = parseFloat(progressBar.style[this._progressPixelSize]);
                var duration = this.slideDuration * (percent - start / 100);
                if (duration == 0) {
                    return;
                }
                if (duration < 0) {
                    duration = 0 - duration;
                }
                props[this._progressPixelSize] = {start:start, end:percent * 100, units:"%"};
                this._inProgressAnim = fx.animateProperty({node:progressBar, duration:duration, onAnimate:function (v) {
                    remainingBar.style[_this._progressPixelSize] = (100 - parseFloat(v[_this._progressPixelSize])) + "%";
                }, onEnd:function () {
                    delete _this._inProgressAnim;
                }, properties:props});
                this._inProgressAnim.play();
            } else {
                progressBar.style[this._progressPixelSize] = (percent * 100) + "%";
                remainingBar.style[this._progressPixelSize] = ((1 - percent) * 100) + "%";
            }
        }, _bumpValue:function (signedChange, priorityChange) {
            if (this.disabled || this.readOnly) {
                return;
            }
            var s = domStyle.getComputedStyle(this.sliderBarContainer);
            var c = domGeometry.getContentBox(this.sliderBarContainer, s);
            var count = this.discreteValues;
            if (count <= 1 || count == Infinity) {
                count = c[this._pixelCount];
            }
            count--;
            var value = (this.value - this.minimum) * count / (this.maximum - this.minimum) + signedChange;
            if (value < 0) {
                value = 0;
            }
            if (value > count) {
                value = count;
            }
            value = value * (this.maximum - this.minimum) / count + this.minimum;
            this._setValueAttr(value, priorityChange);
        }, _onClkBumper:function (val) {
            if (this.disabled || this.readOnly || !this.clickSelect) {
                return;
            }
            this._setValueAttr(val, true);
        }, _onClkIncBumper:function () {
            this._onClkBumper(this._descending === false ? this.minimum : this.maximum);
        }, _onClkDecBumper:function () {
            this._onClkBumper(this._descending === false ? this.maximum : this.minimum);
        }, decrement:function (e) {
            this._bumpValue(e.keyCode == keys.PAGE_DOWN ? -this.pageIncrement : -1);
        }, increment:function (e) {
            this._bumpValue(e.keyCode == keys.PAGE_UP ? this.pageIncrement : 1);
        }, _mouseWheeled:function (evt) {
            evt.stopPropagation();
            evt.preventDefault();
            this._bumpValue(evt.wheelDelta < 0 ? -1 : 1, true);
        }, startup:function () {
            if (this._started) {
                return;
            }
            array.forEach(this.getChildren(), function (child) {
                if (this[child.container] != this.containerNode) {
                    this[child.container].appendChild(child.domNode);
                }
            }, this);
            this.inherited(arguments);
        }, _typematicCallback:function (count, button, e) {
            if (count == -1) {
                this._setValueAttr(this.value, true);
            } else {
                this[(button == (this._descending ? this.incrementButton : this.decrementButton)) ? "decrement" : "increment"](e);
            }
        }, buildRendering:function () {
            this.inherited(arguments);
            if (this.showButtons) {
                this.incrementButton.style.display = "";
                this.decrementButton.style.display = "";
            }
            var label = query("label[for=\"" + this.id + "\"]");
            if (label.length) {
                if (!label[0].id) {
                    label[0].id = this.id + "_label";
                }
                this.focusNode.setAttribute("aria-labelledby", label[0].id);
            }
            this.focusNode.setAttribute("aria-valuemin", this.minimum);
            this.focusNode.setAttribute("aria-valuemax", this.maximum);
        }, postCreate:function () {
            this.inherited(arguments);
            if (this.showButtons) {
                this.own(typematic.addMouseListener(this.decrementButton, this, "_typematicCallback", 25, 500), typematic.addMouseListener(this.incrementButton, this, "_typematicCallback", 25, 500));
            }
            this.own(on(this.domNode, mouse.wheel, lang.hitch(this, "_mouseWheeled")));
            var mover = declare(_SliderMover, {widget:this});
            this._movable = new Moveable(this.sliderHandle, {mover:mover});
            this._layoutHackIE7();
        }, destroy:function () {
            this._movable.destroy();
            if (this._inProgressAnim && this._inProgressAnim.status != "stopped") {
                this._inProgressAnim.stop(true);
            }
            this.inherited(arguments);
        }});
        HorizontalSlider._Mover = _SliderMover;
        return HorizontalSlider;
    });
}, "dojo/dnd/Manager":function () {
    define(["../_base/array", "../_base/declare", "../_base/lang", "../_base/window", "../dom-class", "../Evented", "../has", "../keys", "../on", "../topic", "../touch", "./common", "./autoscroll", "./Avatar"], function (array, declare, lang, win, domClass, Evented, has, keys, on, topic, touch, dnd, autoscroll, Avatar) {
        var Manager = declare("dojo.dnd.Manager", [Evented], {constructor:function () {
            this.avatar = null;
            this.source = null;
            this.nodes = [];
            this.copy = true;
            this.target = null;
            this.canDropFlag = false;
            this.events = [];
        }, OFFSET_X:has("touch") ? 0 : 16, OFFSET_Y:has("touch") ? -64 : 16, overSource:function (source) {
            if (this.avatar) {
                this.target = (source && source.targetState != "Disabled") ? source : null;
                this.canDropFlag = Boolean(this.target);
                this.avatar.update();
            }
            topic.publish("/dnd/source/over", source);
        }, outSource:function (source) {
            if (this.avatar) {
                if (this.target == source) {
                    this.target = null;
                    this.canDropFlag = false;
                    this.avatar.update();
                    topic.publish("/dnd/source/over", null);
                }
            } else {
                topic.publish("/dnd/source/over", null);
            }
        }, startDrag:function (source, nodes, copy) {
            autoscroll.autoScrollStart(win.doc);
            this.source = source;
            this.nodes = nodes;
            this.copy = Boolean(copy);
            this.avatar = this.makeAvatar();
            win.body().appendChild(this.avatar.node);
            topic.publish("/dnd/start", source, nodes, this.copy);
            function stopEvent(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            this.events = [on(win.doc, touch.move, lang.hitch(this, "onMouseMove")), on(win.doc, touch.release, lang.hitch(this, "onMouseUp")), on(win.doc, "keydown", lang.hitch(this, "onKeyDown")), on(win.doc, "keyup", lang.hitch(this, "onKeyUp")), on(win.doc, "dragstart", stopEvent), on(win.body(), "selectstart", stopEvent)];
            var c = "dojoDnd" + (copy ? "Copy" : "Move");
            domClass.add(win.body(), c);
        }, canDrop:function (flag) {
            var canDropFlag = Boolean(this.target && flag);
            if (this.canDropFlag != canDropFlag) {
                this.canDropFlag = canDropFlag;
                this.avatar.update();
            }
        }, stopDrag:function () {
            domClass.remove(win.body(), ["dojoDndCopy", "dojoDndMove"]);
            array.forEach(this.events, function (handle) {
                handle.remove();
            });
            this.events = [];
            this.avatar.destroy();
            this.avatar = null;
            this.source = this.target = null;
            this.nodes = [];
        }, makeAvatar:function () {
            return new Avatar(this);
        }, updateAvatar:function () {
            this.avatar.update();
        }, onMouseMove:function (e) {
            var a = this.avatar;
            if (a) {
                autoscroll.autoScrollNodes(e);
                var s = a.node.style;
                s.left = (e.pageX + this.OFFSET_X) + "px";
                s.top = (e.pageY + this.OFFSET_Y) + "px";
                var copy = Boolean(this.source.copyState(dnd.getCopyKeyState(e)));
                if (this.copy != copy) {
                    this._setCopyStatus(copy);
                }
            }
            if (has("touch")) {
                e.preventDefault();
            }
        }, onMouseUp:function (e) {
            if (this.avatar) {
                if (this.target && this.canDropFlag) {
                    var copy = Boolean(this.source.copyState(dnd.getCopyKeyState(e)));
                    topic.publish("/dnd/drop/before", this.source, this.nodes, copy, this.target, e);
                    topic.publish("/dnd/drop", this.source, this.nodes, copy, this.target, e);
                } else {
                    topic.publish("/dnd/cancel");
                }
                this.stopDrag();
            }
        }, onKeyDown:function (e) {
            if (this.avatar) {
                switch (e.keyCode) {
                  case keys.CTRL:
                    var copy = Boolean(this.source.copyState(true));
                    if (this.copy != copy) {
                        this._setCopyStatus(copy);
                    }
                    break;
                  case keys.ESCAPE:
                    topic.publish("/dnd/cancel");
                    this.stopDrag();
                    break;
                }
            }
        }, onKeyUp:function (e) {
            if (this.avatar && e.keyCode == keys.CTRL) {
                var copy = Boolean(this.source.copyState(false));
                if (this.copy != copy) {
                    this._setCopyStatus(copy);
                }
            }
        }, _setCopyStatus:function (copy) {
            this.copy = copy;
            this.source._markDndStatus(this.copy);
            this.updateAvatar();
            domClass.replace(win.body(), "dojoDnd" + (this.copy ? "Copy" : "Move"), "dojoDnd" + (this.copy ? "Move" : "Copy"));
        }});
        dnd._manager = null;
        Manager.manager = dnd.manager = function () {
            if (!dnd._manager) {
                dnd._manager = new Manager();
            }
            return dnd._manager;
        };
        return Manager;
    });
}, "dojo/promise/Promise":function () {
    define(["../_base/lang"], function (lang) {
        "use strict";
        function throwAbstract() {
            throw new TypeError("abstract");
        }
        return lang.extend(function Promise() {
        }, {then:function (callback, errback, progback) {
            throwAbstract();
        }, cancel:function (reason, strict) {
            throwAbstract();
        }, isResolved:function () {
            throwAbstract();
        }, isRejected:function () {
            throwAbstract();
        }, isFulfilled:function () {
            throwAbstract();
        }, isCanceled:function () {
            throwAbstract();
        }, always:function (callbackOrErrback) {
            return this.then(callbackOrErrback, callbackOrErrback);
        }, otherwise:function (errback) {
            return this.then(null, errback);
        }, trace:function () {
            return this;
        }, traceRejected:function () {
            return this;
        }, toString:function () {
            return "[object Promise]";
        }});
    });
}, "dijit/_KeyNavMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-attr", "dojo/keys", "dojo/_base/lang", "dojo/on", "dijit/registry", "dijit/_FocusMixin"], function (array, declare, domAttr, keys, lang, on, registry, _FocusMixin) {
        return declare("dijit._KeyNavMixin", _FocusMixin, {tabIndex:"0", childSelector:null, postCreate:function () {
            this.inherited(arguments);
            domAttr.set(this.domNode, "tabIndex", this.tabIndex);
            if (!this._keyNavCodes) {
                var keyCodes = this._keyNavCodes = {};
                keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
                keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
                keyCodes[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW] = lang.hitch(this, "_onLeftArrow");
                keyCodes[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW] = lang.hitch(this, "_onRightArrow");
                keyCodes[keys.UP_ARROW] = lang.hitch(this, "_onUpArrow");
                keyCodes[keys.DOWN_ARROW] = lang.hitch(this, "_onDownArrow");
            }
            var self = this, childSelector = typeof this.childSelector == "string" ? this.childSelector : lang.hitch(this, "childSelector");
            this.own(on(this.domNode, "keypress", lang.hitch(this, "_onContainerKeypress")), on(this.domNode, "keydown", lang.hitch(this, "_onContainerKeydown")), on(this.domNode, "focus", lang.hitch(this, "_onContainerFocus")), on(this.containerNode, on.selector(childSelector, "focusin"), function (evt) {
                self._onChildFocus(registry.getEnclosingWidget(this), evt);
            }));
        }, _onLeftArrow:function () {
        }, _onRightArrow:function () {
        }, _onUpArrow:function () {
        }, _onDownArrow:function () {
        }, focus:function () {
            this.focusFirstChild();
        }, _getFirstFocusableChild:function () {
            return this._getNextFocusableChild(null, 1);
        }, _getLastFocusableChild:function () {
            return this._getNextFocusableChild(null, -1);
        }, focusFirstChild:function () {
            this.focusChild(this._getFirstFocusableChild());
        }, focusLastChild:function () {
            this.focusChild(this._getLastFocusableChild());
        }, focusChild:function (widget, last) {
            if (!widget) {
                return;
            }
            if (this.focusedChild && widget !== this.focusedChild) {
                this._onChildBlur(this.focusedChild);
            }
            widget.set("tabIndex", this.tabIndex);
            widget.focus(last ? "end" : "start");
        }, _onContainerFocus:function (evt) {
            if (evt.target !== this.domNode || this.focusedChild) {
                return;
            }
            this.focus();
        }, _onFocus:function () {
            domAttr.set(this.domNode, "tabIndex", "-1");
            this.inherited(arguments);
        }, _onBlur:function (evt) {
            domAttr.set(this.domNode, "tabIndex", this.tabIndex);
            if (this.focusedChild) {
                this.focusedChild.set("tabIndex", "-1");
                this.lastFocusedChild = this.focusedChild;
                this._set("focusedChild", null);
            }
            this.inherited(arguments);
        }, _onChildFocus:function (child) {
            if (child && child != this.focusedChild) {
                if (this.focusedChild && !this.focusedChild._destroyed) {
                    this.focusedChild.set("tabIndex", "-1");
                }
                child.set("tabIndex", this.tabIndex);
                this.lastFocused = child;
                this._set("focusedChild", child);
            }
        }, _searchString:"", multiCharSearchDuration:1000, onKeyboardSearch:function (item, evt, searchString, numMatches) {
            if (item) {
                this.focusChild(item);
            }
        }, _keyboardSearchCompare:function (item, searchString) {
            var element = item.domNode, text = item.label || (element.focusNode ? element.focusNode.label : "") || element.innerText || element.textContent || "", currentString = text.replace(/^\s+/, "").substr(0, searchString.length).toLowerCase();
            return (!!searchString.length && currentString == searchString) ? -1 : 0;
        }, _onContainerKeydown:function (evt) {
            var func = this._keyNavCodes[evt.keyCode];
            if (func) {
                func(evt, this.focusedChild);
                evt.stopPropagation();
                evt.preventDefault();
                this._searchString = "";
            } else {
                if (evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)) {
                    evt.stopImmediatePropagation();
                    evt.preventDefault();
                    this._keyboardSearch(evt, " ");
                }
            }
        }, _onContainerKeypress:function (evt) {
            if (evt.charCode <= keys.SPACE || evt.ctrlKey || evt.altKey || evt.metaKey) {
                return;
            }
            evt.preventDefault();
            evt.stopPropagation();
            this._keyboardSearch(evt, String.fromCharCode(evt.charCode).toLowerCase());
        }, _keyboardSearch:function (evt, keyChar) {
            var matchedItem = null, searchString, numMatches = 0, search = lang.hitch(this, function () {
                if (this._searchTimer) {
                    this._searchTimer.remove();
                }
                this._searchString += keyChar;
                var allSameLetter = /^(.)\1*$/.test(this._searchString);
                var searchLen = allSameLetter ? 1 : this._searchString.length;
                searchString = this._searchString.substr(0, searchLen);
                this._searchTimer = this.defer(function () {
                    this._searchTimer = null;
                    this._searchString = "";
                }, this.multiCharSearchDuration);
                var currentItem = this.focusedChild || null;
                if (searchLen == 1 || !currentItem) {
                    currentItem = this._getNextFocusableChild(currentItem, 1);
                    if (!currentItem) {
                        return;
                    }
                }
                var stop = currentItem;
                do {
                    var rc = this._keyboardSearchCompare(currentItem, searchString);
                    if (!!rc && numMatches++ == 0) {
                        matchedItem = currentItem;
                    }
                    if (rc == -1) {
                        numMatches = -1;
                        break;
                    }
                    currentItem = this._getNextFocusableChild(currentItem, 1);
                } while (currentItem != stop);
            });
            search();
            this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
        }, _onChildBlur:function () {
        }, _getNextFocusableChild:function (child, dir) {
            var wrappedValue = child;
            do {
                if (!child) {
                    child = this[dir > 0 ? "_getFirst" : "_getLast"]();
                    if (!child) {
                        break;
                    }
                } else {
                    child = this._getNext(child, dir);
                }
                if (child != null && child != wrappedValue && child.isFocusable()) {
                    return child;
                }
            } while (child != wrappedValue);
            return null;
        }, _getFirst:function () {
            return null;
        }, _getLast:function () {
            return null;
        }, _getNext:function (child, dir) {
            if (child) {
                child = child.domNode;
                while (child) {
                    child = child[dir < 0 ? "previousSibling" : "nextSibling"];
                    if (child && "getAttribute" in child) {
                        var w = registry.byNode(child);
                        if (w) {
                            return w;
                        }
                    }
                }
            }
            return null;
        }});
    });
}, "dojox/grid/DataSelection":function () {
    define(["dojo/_base/declare", "./_SelectionPreserver", "./Selection"], function (declare, _SelectionPreserver, Selection) {
        return declare("dojox.grid.DataSelection", Selection, {constructor:function (grid) {
            if (grid.keepSelection) {
                this.preserver = new _SelectionPreserver(this);
            }
        }, destroy:function () {
            if (this.preserver) {
                this.preserver.destroy();
            }
        }, getFirstSelected:function () {
            var idx = Selection.prototype.getFirstSelected.call(this);
            if (idx == -1) {
                return null;
            }
            return this.grid.getItem(idx);
        }, getNextSelected:function (inPrev) {
            var old_idx = this.grid.getItemIndex(inPrev);
            var idx = Selection.prototype.getNextSelected.call(this, old_idx);
            if (idx == -1) {
                return null;
            }
            return this.grid.getItem(idx);
        }, getSelected:function () {
            var result = [];
            for (var i = 0, l = this.selected.length; i < l; i++) {
                if (this.selected[i]) {
                    result.push(this.grid.getItem(i));
                }
            }
            return result;
        }, addToSelection:function (inItemOrIndex) {
            if (this.mode == "none") {
                return;
            }
            var idx = null;
            if (typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string") {
                idx = inItemOrIndex;
            } else {
                idx = this.grid.getItemIndex(inItemOrIndex);
            }
            Selection.prototype.addToSelection.call(this, idx);
        }, deselect:function (inItemOrIndex) {
            if (this.mode == "none") {
                return;
            }
            var idx = null;
            if (typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string") {
                idx = inItemOrIndex;
            } else {
                idx = this.grid.getItemIndex(inItemOrIndex);
            }
            Selection.prototype.deselect.call(this, idx);
        }, deselectAll:function (inItemOrIndex) {
            var idx = null;
            if (inItemOrIndex || typeof inItemOrIndex == "number") {
                if (typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string") {
                    idx = inItemOrIndex;
                } else {
                    idx = this.grid.getItemIndex(inItemOrIndex);
                }
                Selection.prototype.deselectAll.call(this, idx);
            } else {
                this.inherited(arguments);
            }
        }});
    });
}, "dijit/form/_TextBoxMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom", "dojo/has", "dojo/keys", "dojo/_base/lang", "dojo/on", "../main"], function (array, declare, dom, has, keys, lang, on, dijit) {
        var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {trim:false, uppercase:false, lowercase:false, propercase:false, maxLength:"", selectOnClick:false, placeHolder:"", _getValueAttr:function () {
            return this.parse(this.get("displayedValue"), this.constraints);
        }, _setValueAttr:function (value, priorityChange, formattedValue) {
            var filteredValue;
            if (value !== undefined) {
                filteredValue = this.filter(value);
                if (typeof formattedValue != "string") {
                    if (filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))) {
                        formattedValue = this.filter(this.format(filteredValue, this.constraints));
                    } else {
                        formattedValue = "";
                    }
                }
            }
            if (formattedValue != null && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue) {
                this.textbox.value = formattedValue;
                this._set("displayedValue", this.get("displayedValue"));
            }
            this.inherited(arguments, [filteredValue, priorityChange]);
        }, displayedValue:"", _getDisplayedValueAttr:function () {
            return this.filter(this.textbox.value);
        }, _setDisplayedValueAttr:function (value) {
            if (value == null) {
                value = "";
            } else {
                if (typeof value != "string") {
                    value = String(value);
                }
            }
            this.textbox.value = value;
            this._setValueAttr(this.get("value"), undefined);
            this._set("displayedValue", this.get("displayedValue"));
        }, format:function (value) {
            return value == null ? "" : (value.toString ? value.toString() : value);
        }, parse:function (value) {
            return value;
        }, _refreshState:function () {
        }, onInput:function () {
        }, __skipInputEvent:false, _onInput:function (evt) {
            this._processInput(evt);
            if (this.intermediateChanges) {
                this.defer(function () {
                    this._handleOnChange(this.get("value"), false);
                });
            }
        }, _processInput:function (evt) {
            this._refreshState();
            this._set("displayedValue", this.get("displayedValue"));
        }, postCreate:function () {
            this.textbox.setAttribute("value", this.textbox.value);
            this.inherited(arguments);
            function handleEvent(e) {
                var charOrCode;
                if (e.type == "keydown") {
                    charOrCode = e.keyCode;
                    switch (charOrCode) {
                      case keys.SHIFT:
                      case keys.ALT:
                      case keys.CTRL:
                      case keys.META:
                      case keys.CAPS_LOCK:
                      case keys.NUM_LOCK:
                      case keys.SCROLL_LOCK:
                        return;
                    }
                    if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                        switch (charOrCode) {
                          case keys.NUMPAD_0:
                          case keys.NUMPAD_1:
                          case keys.NUMPAD_2:
                          case keys.NUMPAD_3:
                          case keys.NUMPAD_4:
                          case keys.NUMPAD_5:
                          case keys.NUMPAD_6:
                          case keys.NUMPAD_7:
                          case keys.NUMPAD_8:
                          case keys.NUMPAD_9:
                          case keys.NUMPAD_MULTIPLY:
                          case keys.NUMPAD_PLUS:
                          case keys.NUMPAD_ENTER:
                          case keys.NUMPAD_MINUS:
                          case keys.NUMPAD_PERIOD:
                          case keys.NUMPAD_DIVIDE:
                            return;
                        }
                        if ((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE) {
                            return;
                        }
                        var named = false;
                        for (var i in keys) {
                            if (keys[i] === e.keyCode) {
                                named = true;
                                break;
                            }
                        }
                        if (!named) {
                            return;
                        }
                    }
                }
                charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
                if (!charOrCode) {
                    charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
                }
                if (!charOrCode) {
                    charOrCode = 229;
                }
                if (e.type == "keypress") {
                    if (typeof charOrCode != "string") {
                        return;
                    }
                    if ((charOrCode >= "a" && charOrCode <= "z") || (charOrCode >= "A" && charOrCode <= "Z") || (charOrCode >= "0" && charOrCode <= "9") || (charOrCode === " ")) {
                        if (e.ctrlKey || e.metaKey || e.altKey) {
                            return;
                        }
                    }
                }
                if (e.type == "input") {
                    if (this.__skipInputEvent) {
                        this.__skipInputEvent = false;
                        return;
                    }
                } else {
                    this.__skipInputEvent = true;
                }
                var faux = {faux:true}, attr;
                for (attr in e) {
                    if (!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)) {
                        var v = e[attr];
                        if (typeof v != "function" && typeof v != "undefined") {
                            faux[attr] = v;
                        }
                    }
                }
                lang.mixin(faux, {charOrCode:charOrCode, _wasConsumed:false, preventDefault:function () {
                    faux._wasConsumed = true;
                    e.preventDefault();
                }, stopPropagation:function () {
                    e.stopPropagation();
                }});
                if (this.onInput(faux) === false) {
                    faux.preventDefault();
                    faux.stopPropagation();
                }
                if (faux._wasConsumed) {
                    return;
                }
                this.defer(function () {
                    this._onInput(faux);
                });
            }
            this.own(on(this.textbox, "keydown, keypress, paste, cut, input, compositionend", lang.hitch(this, handleEvent)), on(this.domNode, "keypress", function (e) {
                e.stopPropagation();
            }));
        }, _blankValue:"", filter:function (val) {
            if (val === null) {
                return this._blankValue;
            }
            if (typeof val != "string") {
                return val;
            }
            if (this.trim) {
                val = lang.trim(val);
            }
            if (this.uppercase) {
                val = val.toUpperCase();
            }
            if (this.lowercase) {
                val = val.toLowerCase();
            }
            if (this.propercase) {
                val = val.replace(/[^\s]+/g, function (word) {
                    return word.substring(0, 1).toUpperCase() + word.substring(1);
                });
            }
            return val;
        }, _setBlurValue:function () {
            this._setValueAttr(this.get("value"), true);
        }, _onBlur:function (e) {
            if (this.disabled) {
                return;
            }
            this._setBlurValue();
            this.inherited(arguments);
        }, _isTextSelected:function () {
            return this.textbox.selectionStart != this.textbox.selectionEnd;
        }, _onFocus:function (by) {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (this.selectOnClick && by == "mouse") {
                this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function (evt) {
                    if (!this._isTextSelected()) {
                        _TextBoxMixin.selectInputText(this.textbox);
                    }
                }));
                this.own(this._selectOnClickHandle);
                this.defer(function () {
                    if (this._selectOnClickHandle) {
                        this._selectOnClickHandle.remove();
                        this._selectOnClickHandle = null;
                    }
                }, 500);
            }
            this.inherited(arguments);
            this._refreshState();
        }, reset:function () {
            this.textbox.value = "";
            this.inherited(arguments);
        }});
        if (has("dojo-bidi")) {
            _TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {_setValueAttr:function () {
                this.inherited(arguments);
                this.applyTextDir(this.focusNode);
            }, _setDisplayedValueAttr:function () {
                this.inherited(arguments);
                this.applyTextDir(this.focusNode);
            }, _onInput:function () {
                this.applyTextDir(this.focusNode);
                this.inherited(arguments);
            }});
        }
        _TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function (element, start, stop) {
            if (element.setSelectionRange) {
                element.setSelectionRange(start, stop);
            }
        };
        _TextBoxMixin.selectInputText = dijit.selectInputText = function (element, start, stop) {
            element = dom.byId(element);
            if (isNaN(start)) {
                start = 0;
            }
            if (isNaN(stop)) {
                stop = element.value ? element.value.length : 0;
            }
            try {
                element.focus();
                _TextBoxMixin._setSelectionRange(element, start, stop);
            }
            catch (e) {
            }
        };
        return _TextBoxMixin;
    });
}, "dojox/grid/enhanced/plugins/_SelectionPreserver":function () {
    define(["dojo/_base/declare", "dojo/_base/lang", "dojo/_base/connect", "../../_SelectionPreserver"], function (declare, lang, connect, _SelectionPreserver) {
        return declare("dojox.grid.enhanced.plugins._SelectionPreserver", _SelectionPreserver, {constructor:function (selection) {
            var grid = this.grid;
            grid.onSelectedById = this.onSelectedById;
            this._oldClearData = grid._clearData;
            var self = this;
            grid._clearData = function () {
                self._updateMapping(!grid._noInternalMapping);
                self._trustSelection = [];
                self._oldClearData.apply(grid, arguments);
            };
            this._connects.push(connect.connect(selection, "selectRange", lang.hitch(this, "_updateMapping", true, true, false)), connect.connect(selection, "deselectRange", lang.hitch(this, "_updateMapping", true, false, false)), connect.connect(selection, "deselectAll", lang.hitch(this, "_updateMapping", true, false, true)));
        }, destroy:function () {
            this.inherited(arguments);
            this.grid._clearData = this._oldClearData;
        }, reset:function () {
            this.inherited(arguments);
            this._idMap = [];
            this._trustSelection = [];
            this._defaultSelected = false;
        }, _reSelectById:function (item, index) {
            var s = this.selection, g = this.grid;
            if (item && g._hasIdentity) {
                var id = g.store.getIdentity(item);
                if (this._selectedById[id] === undefined) {
                    if (!this._trustSelection[index]) {
                        s.selected[index] = this._defaultSelected;
                    }
                } else {
                    s.selected[index] = this._selectedById[id];
                }
                this._idMap.push(id);
                g.onSelectedById(id, index, s.selected[index]);
            }
        }, _selectById:function (toSelect, inItemOrIndex) {
            if (!this.inherited(arguments)) {
                this._trustSelection[inItemOrIndex] = true;
            }
        }, onSelectedById:function (id, rowIndex, value) {
        }, _updateMapping:function (trustSelection, isSelect, isForAll, from, to) {
            var s = this.selection, g = this.grid, flag = 0, unloaded = 0, i, id;
            for (i = g.rowCount - 1; i >= 0; --i) {
                if (!g._by_idx[i]) {
                    ++unloaded;
                    flag += s.selected[i] ? 1 : -1;
                } else {
                    id = g._by_idx[i].idty;
                    if (id && (trustSelection || this._selectedById[id] === undefined)) {
                        this._selectedById[id] = !!s.selected[i];
                    }
                }
            }
            if (unloaded) {
                this._defaultSelected = flag > 0;
            }
            if (!isForAll && from !== undefined && to !== undefined) {
                isForAll = !g.usingPagination && Math.abs(to - from + 1) === g.rowCount;
            }
            if (isForAll && (!g.usingPagination || g.selectionMode === "single")) {
                for (i = this._idMap.length - 1; i >= 0; --i) {
                    this._selectedById[this._idMap[i]] = isSelect;
                }
            }
        }});
    });
}, "dijit/a11y":function () {
    define(["dojo/_base/array", "dojo/dom", "dojo/dom-attr", "dojo/dom-style", "dojo/_base/lang", "dojo/sniff", "./main"], function (array, dom, domAttr, domStyle, lang, has, dijit) {
        var undefined;
        var a11y = {_isElementShown:function (elem) {
            var s = domStyle.get(elem);
            return (s.visibility != "hidden") && (s.visibility != "collapsed") && (s.display != "none") && (domAttr.get(elem, "type") != "hidden");
        }, hasDefaultTabStop:function (elem) {
            switch (elem.nodeName.toLowerCase()) {
              case "a":
                return domAttr.has(elem, "href");
              case "area":
              case "button":
              case "input":
              case "object":
              case "select":
              case "textarea":
                return true;
              case "iframe":
                var body;
                try {
                    var contentDocument = elem.contentDocument;
                    if ("designMode" in contentDocument && contentDocument.designMode == "on") {
                        return true;
                    }
                    body = contentDocument.body;
                }
                catch (e1) {
                    try {
                        body = elem.contentWindow.document.body;
                    }
                    catch (e2) {
                        return false;
                    }
                }
                return body && (body.contentEditable == "true" || (body.firstChild && body.firstChild.contentEditable == "true"));
              default:
                return elem.contentEditable == "true";
            }
        }, effectiveTabIndex:function (elem) {
            if (domAttr.get(elem, "disabled")) {
                return undefined;
            } else {
                if (domAttr.has(elem, "tabIndex")) {
                    return +domAttr.get(elem, "tabIndex");
                } else {
                    return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
                }
            }
        }, isTabNavigable:function (elem) {
            return a11y.effectiveTabIndex(elem) >= 0;
        }, isFocusable:function (elem) {
            return a11y.effectiveTabIndex(elem) >= -1;
        }, _getTabNavigable:function (root) {
            var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};
            function radioName(node) {
                return node && node.tagName.toLowerCase() == "input" && node.type && node.type.toLowerCase() == "radio" && node.name && node.name.toLowerCase();
            }
            var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
            var walkTree = function (parent) {
                for (var child = parent.firstChild; child; child = child.nextSibling) {
                    if (child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)) {
                        continue;
                    }
                    var tabindex = effectiveTabIndex(child);
                    if (tabindex >= 0) {
                        if (tabindex == 0) {
                            if (!first) {
                                first = child;
                            }
                            last = child;
                        } else {
                            if (tabindex > 0) {
                                if (!lowest || tabindex < lowestTabindex) {
                                    lowestTabindex = tabindex;
                                    lowest = child;
                                }
                                if (!highest || tabindex >= highestTabindex) {
                                    highestTabindex = tabindex;
                                    highest = child;
                                }
                            }
                        }
                        var rn = radioName(child);
                        if (domAttr.get(child, "checked") && rn) {
                            radioSelected[rn] = child;
                        }
                    }
                    if (child.nodeName.toUpperCase() != "SELECT") {
                        walkTree(child);
                    }
                }
            };
            if (shown(root)) {
                walkTree(root);
            }
            function rs(node) {
                return radioSelected[radioName(node)] || node;
            }
            return {first:rs(first), last:rs(last), lowest:rs(lowest), highest:rs(highest)};
        }, getFirstInTabbingOrder:function (root, doc) {
            var elems = a11y._getTabNavigable(dom.byId(root, doc));
            return elems.lowest ? elems.lowest : elems.first;
        }, getLastInTabbingOrder:function (root, doc) {
            var elems = a11y._getTabNavigable(dom.byId(root, doc));
            return elems.last ? elems.last : elems.highest;
        }};
        1 && lang.mixin(dijit, a11y);
        return a11y;
    });
}, "dijit/form/TextBox":function () {
    define(["dojo/_base/declare", "dojo/dom-construct", "dojo/dom-style", "dojo/_base/kernel", "dojo/_base/lang", "dojo/on", "dojo/sniff", "./_FormValueWidget", "./_TextBoxMixin", "dojo/text!./templates/TextBox.html", "../main"], function (declare, domConstruct, domStyle, kernel, lang, on, has, _FormValueWidget, _TextBoxMixin, template, dijit) {
        var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {templateString:template, _singleNodeTemplate:"<input class=\"dijit dijitReset dijitLeft dijitInputField\" data-dojo-attach-point=\"textbox,focusNode\" autocomplete=\"off\" type=\"${type}\" ${!nameAttrSetting} />", _buttonInputDisabled:has("ie") ? "disabled" : "", baseClass:"dijitTextBox", postMixInProperties:function () {
            var type = this.type.toLowerCase();
            if (this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)) {
                this.templateString = this._singleNodeTemplate;
            }
            this.inherited(arguments);
        }, postCreate:function () {
            this.inherited(arguments);
            if (has("ie") < 9) {
                this.defer(function () {
                    try {
                        var s = domStyle.getComputedStyle(this.domNode);
                        if (s) {
                            var ff = s.fontFamily;
                            if (ff) {
                                var inputs = this.domNode.getElementsByTagName("INPUT");
                                if (inputs) {
                                    for (var i = 0; i < inputs.length; i++) {
                                        inputs[i].style.fontFamily = ff;
                                    }
                                }
                            }
                        }
                    }
                    catch (e) {
                    }
                });
            }
        }, _setPlaceHolderAttr:function (v) {
            this._set("placeHolder", v);
            if (!this._phspan) {
                this._attachPoints.push("_phspan");
                this._phspan = domConstruct.create("span", {className:"dijitPlaceHolder dijitInputField"}, this.textbox, "after");
                this.own(on(this._phspan, "mousedown", function (evt) {
                    evt.preventDefault();
                }), on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function () {
                    this.focus();
                })));
            }
            this._phspan.innerHTML = "";
            this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
            this._updatePlaceHolder();
        }, _onInput:function (evt) {
            this.inherited(arguments);
            this._updatePlaceHolder();
        }, _updatePlaceHolder:function () {
            if (this._phspan) {
                this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
            }
        }, _setValueAttr:function (value, priorityChange, formattedValue) {
            this.inherited(arguments);
            this._updatePlaceHolder();
        }, getDisplayedValue:function () {
            kernel.deprecated(this.declaredClass + "::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
            return this.get("displayedValue");
        }, setDisplayedValue:function (value) {
            kernel.deprecated(this.declaredClass + "::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
            this.set("displayedValue", value);
        }, _onBlur:function (e) {
            if (this.disabled) {
                return;
            }
            this.inherited(arguments);
            this._updatePlaceHolder();
            if (has("mozilla")) {
                if (this.selectOnClick) {
                    this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
                }
            }
        }, _onFocus:function (by) {
            if (this.disabled || this.readOnly) {
                return;
            }
            this.inherited(arguments);
            this._updatePlaceHolder();
        }});
        if (has("ie") < 9) {
            TextBox.prototype._isTextSelected = function () {
                var range = this.ownerDocument.selection.createRange();
                var parent = range.parentElement();
                return parent == this.textbox && range.text.length > 0;
            };
            dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function (element, start, stop) {
                if (element.createTextRange) {
                    var r = element.createTextRange();
                    r.collapse(true);
                    r.moveStart("character", -99999);
                    r.moveStart("character", start);
                    r.moveEnd("character", stop - start);
                    r.select();
                }
            };
        }
        if (has("dojo-bidi")) {
            TextBox = declare("dijit.form.TextBox", TextBox, {_setPlaceHolderAttr:function (v) {
                this.inherited(arguments);
                this.applyTextDir(this._phspan);
            }});
        }
        return TextBox;
    });
}, "dijit/form/_DateTimeTextBox":function () {
    define(["dojo/date", "dojo/date/locale", "dojo/date/stamp", "dojo/_base/declare", "dojo/_base/lang", "./RangeBoundTextBox", "../_HasDropDown", "dojo/text!./templates/DropDownBox.html"], function (date, locale, stamp, declare, lang, RangeBoundTextBox, _HasDropDown, template) {
        new Date("X");
        var _DateTimeTextBox = declare("dijit.form._DateTimeTextBox", [RangeBoundTextBox, _HasDropDown], {templateString:template, hasDownArrow:true, cssStateNodes:{"_buttonNode":"dijitDownArrowButton"}, pattern:locale.regexp, datePackage:"", postMixInProperties:function () {
            this.inherited(arguments);
            this._set("type", "text");
        }, compare:function (val1, val2) {
            var isInvalid1 = this._isInvalidDate(val1);
            var isInvalid2 = this._isInvalidDate(val2);
            return isInvalid1 ? (isInvalid2 ? 0 : -1) : (isInvalid2 ? 1 : date.compare(val1, val2, this._selector));
        }, autoWidth:true, format:function (value, constraints) {
            if (!value) {
                return "";
            }
            return this.dateLocaleModule.format(value, constraints);
        }, "parse":function (value, constraints) {
            return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);
        }, serialize:function (val, options) {
            if (val.toGregorian) {
                val = val.toGregorian();
            }
            return stamp.toISOString(val, options);
        }, dropDownDefaultValue:new Date(), value:new Date(""), _blankValue:null, popupClass:"", _selector:"", constructor:function (params) {
            this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
            this.dateClassObj = this.dateModule.Date || Date;
            this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage + ".locale", false) : locale;
            this._set("pattern", this.dateLocaleModule.regexp);
            this._invalidDate = this.constructor.prototype.value.toString();
        }, buildRendering:function () {
            this.inherited(arguments);
            if (!this.hasDownArrow) {
                this._buttonNode.style.display = "none";
            }
            if (!this.hasDownArrow) {
                this._buttonNode = this.domNode;
                this.baseClass += " dijitComboBoxOpenOnClick";
            }
        }, _setConstraintsAttr:function (constraints) {
            constraints.selector = this._selector;
            constraints.fullYear = true;
            var fromISO = stamp.fromISOString;
            if (typeof constraints.min == "string") {
                constraints.min = fromISO(constraints.min);
            }
            if (typeof constraints.max == "string") {
                constraints.max = fromISO(constraints.max);
            }
            this.inherited(arguments);
        }, _isInvalidDate:function (value) {
            return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
        }, _setValueAttr:function (value, priorityChange, formattedValue) {
            if (value !== undefined) {
                if (typeof value == "string") {
                    value = stamp.fromISOString(value);
                }
                if (this._isInvalidDate(value)) {
                    value = null;
                }
                if (value instanceof Date && !(this.dateClassObj instanceof Date)) {
                    value = new this.dateClassObj(value);
                }
            }
            this.inherited(arguments);
            if (this.value instanceof Date) {
                this.filterString = "";
            }
            if (this.dropDown) {
                this.dropDown.set("value", value, false);
            }
        }, _set:function (attr, value) {
            var oldValue = this._get("value");
            if (attr == "value" && oldValue instanceof Date && this.compare(value, oldValue) == 0) {
                return;
            }
            this.inherited(arguments);
        }, _setDropDownDefaultValueAttr:function (val) {
            if (this._isInvalidDate(val)) {
                val = new this.dateClassObj();
            }
            this._set("dropDownDefaultValue", val);
        }, openDropDown:function (callback) {
            if (this.dropDown) {
                this.dropDown.destroy();
            }
            var PopupProto = lang.isString(this.popupClass) ? lang.getObject(this.popupClass, false) : this.popupClass, textBox = this, value = this.get("value");
            this.dropDown = new PopupProto({onChange:function (value) {
                textBox.set("value", value, true);
            }, id:this.id + "_popup", dir:textBox.dir, lang:textBox.lang, value:value, textDir:textBox.textDir, currentFocus:!this._isInvalidDate(value) ? value : this.dropDownDefaultValue, constraints:textBox.constraints, filterString:textBox.filterString, datePackage:textBox.params.datePackage, isDisabledDate:function (date) {
                return !textBox.rangeCheck(date, textBox.constraints);
            }});
            this.inherited(arguments);
        }, _getDisplayedValueAttr:function () {
            return this.textbox.value;
        }, _setDisplayedValueAttr:function (value, priorityChange) {
            this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
        }});
        return _DateTimeTextBox;
    });
}, "dijit/layout/StackContainer":function () {
    define(["dojo/_base/array", "dojo/cookie", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-construct", "dojo/has", "dojo/_base/lang", "dojo/on", "dojo/ready", "dojo/topic", "dojo/when", "../registry", "../_WidgetBase", "./_LayoutWidget", "dojo/i18n!../nls/common"], function (array, cookie, declare, domClass, domConstruct, has, lang, on, ready, topic, when, registry, _WidgetBase, _LayoutWidget) {
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/layout/StackController"];
                require(requires);
            });
        }
        var StackContainer = declare("dijit.layout.StackContainer", _LayoutWidget, {doLayout:true, persist:false, baseClass:"dijitStackContainer", buildRendering:function () {
            this.inherited(arguments);
            domClass.add(this.domNode, "dijitLayoutContainer");
        }, postCreate:function () {
            this.inherited(arguments);
            this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")));
        }, startup:function () {
            if (this._started) {
                return;
            }
            var children = this.getChildren();
            array.forEach(children, this._setupChild, this);
            if (this.persist) {
                this.selectedChildWidget = registry.byId(cookie(this.id + "_selectedChild"));
            } else {
                array.some(children, function (child) {
                    if (child.selected) {
                        this.selectedChildWidget = child;
                    }
                    return child.selected;
                }, this);
            }
            var selected = this.selectedChildWidget;
            if (!selected && children[0]) {
                selected = this.selectedChildWidget = children[0];
                selected.selected = true;
            }
            topic.publish(this.id + "-startup", {children:children, selected:selected, textDir:this.textDir});
            this.inherited(arguments);
        }, resize:function () {
            if (!this._hasBeenShown) {
                this._hasBeenShown = true;
                var selected = this.selectedChildWidget;
                if (selected) {
                    this._showChild(selected);
                }
            }
            this.inherited(arguments);
        }, _setupChild:function (child) {
            var childNode = child.domNode, wrapper = domConstruct.place("<div role='tabpanel' class='" + this.baseClass + "ChildWrapper dijitHidden'>", child.domNode, "replace"), label = child["aria-label"] || child.title || child.label;
            if (label) {
                wrapper.setAttribute("aria-label", label);
            }
            domConstruct.place(childNode, wrapper);
            child._wrapper = wrapper;
            this.inherited(arguments);
            if (childNode.style.display == "none") {
                childNode.style.display = "block";
            }
            child.domNode.title = "";
        }, addChild:function (child, insertIndex) {
            this.inherited(arguments);
            if (this._started) {
                topic.publish(this.id + "-addChild", child, insertIndex);
                this.layout();
                if (!this.selectedChildWidget) {
                    this.selectChild(child);
                }
            }
        }, removeChild:function (page) {
            var idx = array.indexOf(this.getChildren(), page);
            this.inherited(arguments);
            domConstruct.destroy(page._wrapper);
            delete page._wrapper;
            if (this._started) {
                topic.publish(this.id + "-removeChild", page);
            }
            if (this._descendantsBeingDestroyed) {
                return;
            }
            if (this.selectedChildWidget === page) {
                this.selectedChildWidget = undefined;
                if (this._started) {
                    var children = this.getChildren();
                    if (children.length) {
                        this.selectChild(children[Math.max(idx - 1, 0)]);
                    }
                }
            }
            if (this._started) {
                this.layout();
            }
        }, selectChild:function (page, animate) {
            var d;
            page = registry.byId(page);
            if (this.selectedChildWidget != page) {
                d = this._transition(page, this.selectedChildWidget, animate);
                this._set("selectedChildWidget", page);
                topic.publish(this.id + "-selectChild", page);
                if (this.persist) {
                    cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
                }
            }
            return when(d || true);
        }, _transition:function (newWidget, oldWidget) {
            if (oldWidget) {
                this._hideChild(oldWidget);
            }
            var d = this._showChild(newWidget);
            if (newWidget.resize) {
                if (this.doLayout) {
                    newWidget.resize(this._containerContentBox || this._contentBox);
                } else {
                    newWidget.resize();
                }
            }
            return d;
        }, _adjacent:function (forward) {
            var children = this.getChildren();
            var index = array.indexOf(children, this.selectedChildWidget);
            index += forward ? 1 : children.length - 1;
            return children[index % children.length];
        }, forward:function () {
            return this.selectChild(this._adjacent(true), true);
        }, back:function () {
            return this.selectChild(this._adjacent(false), true);
        }, _onKeyDown:function (e) {
            topic.publish(this.id + "-containerKeyDown", {e:e, page:this});
        }, layout:function () {
            var child = this.selectedChildWidget;
            if (child && child.resize) {
                if (this.doLayout) {
                    child.resize(this._containerContentBox || this._contentBox);
                } else {
                    child.resize();
                }
            }
        }, _showChild:function (page) {
            var children = this.getChildren();
            page.isFirstChild = (page == children[0]);
            page.isLastChild = (page == children[children.length - 1]);
            page._set("selected", true);
            if (page._wrapper) {
                domClass.replace(page._wrapper, "dijitVisible", "dijitHidden");
            }
            return (page._onShow && page._onShow()) || true;
        }, _hideChild:function (page) {
            page._set("selected", false);
            if (page._wrapper) {
                domClass.replace(page._wrapper, "dijitHidden", "dijitVisible");
            }
            page.onHide && page.onHide();
        }, closeChild:function (page) {
            var remove = page.onClose && page.onClose(this, page);
            if (remove) {
                this.removeChild(page);
                page.destroyRecursive();
            }
        }, destroyDescendants:function (preserveDom) {
            this._descendantsBeingDestroyed = true;
            this.selectedChildWidget = undefined;
            array.forEach(this.getChildren(), function (child) {
                if (!preserveDom) {
                    this.removeChild(child);
                }
                child.destroyRecursive(preserveDom);
            }, this);
            this._descendantsBeingDestroyed = false;
        }});
        StackContainer.ChildWidgetProperties = {selected:false, disabled:false, closable:false, iconClass:"dijitNoIcon", showTitle:true};
        lang.extend(_WidgetBase, StackContainer.ChildWidgetProperties);
        return StackContainer;
    });
}, "dijit/form/_RadioButtonMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-attr", "dojo/_base/lang", "dojo/query", "../registry"], function (array, declare, domAttr, lang, query, registry) {
        return declare("dijit.form._RadioButtonMixin", null, {type:"radio", _getRelatedWidgets:function () {
            var ary = [];
            query("input[type=radio]", this.focusNode.form || this.ownerDocument).forEach(lang.hitch(this, function (inputNode) {
                if (inputNode.name == this.name && inputNode.form == this.focusNode.form) {
                    var widget = registry.getEnclosingWidget(inputNode);
                    if (widget) {
                        ary.push(widget);
                    }
                }
            }));
            return ary;
        }, _setCheckedAttr:function (value) {
            this.inherited(arguments);
            if (!this._created) {
                return;
            }
            if (value) {
                array.forEach(this._getRelatedWidgets(), lang.hitch(this, function (widget) {
                    if (widget != this && widget.checked) {
                        widget.set("checked", false);
                    }
                }));
            }
        }, _getSubmitValue:function (value) {
            return value == null ? "on" : value;
        }, _onClick:function (e) {
            if (this.checked || this.disabled) {
                e.stopPropagation();
                e.preventDefault();
                return false;
            }
            if (this.readOnly) {
                e.stopPropagation();
                e.preventDefault();
                array.forEach(this._getRelatedWidgets(), lang.hitch(this, function (widget) {
                    domAttr.set(this.focusNode || this.domNode, "checked", widget.checked);
                }));
                return false;
            }
            return this.inherited(arguments);
        }});
    });
}, "dojox/grid/TreeSelection":function () {
    define(["../main", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/dom-attr", "dojo/query", "./DataSelection"], function (dojox, declare, array, lang, domAttr, query, DataSelection) {
        return declare("dojox.grid.TreeSelection", DataSelection, {setMode:function (mode) {
            this.selected = {};
            this.sorted_sel = [];
            this.sorted_ltos = {};
            this.sorted_stol = {};
            DataSelection.prototype.setMode.call(this, mode);
        }, addToSelection:function (inItemOrIndex) {
            if (this.mode == "none") {
                return;
            }
            var idx = null;
            if (typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string") {
                idx = inItemOrIndex;
            } else {
                idx = this.grid.getItemIndex(inItemOrIndex);
            }
            if (this.selected[idx]) {
                this.selectedIndex = idx;
            } else {
                if (this.onCanSelect(idx) !== false) {
                    this.selectedIndex = idx;
                    var rowNodes = query("tr[dojoxTreeGridPath='" + idx + "']", this.grid.domNode);
                    if (rowNodes.length) {
                        domAttr.set(rowNodes[0], "aria-selected", "true");
                    }
                    this._beginUpdate();
                    this.selected[idx] = true;
                    this._insertSortedSelection(idx);
                    this.onSelected(idx);
                    this._endUpdate();
                }
            }
        }, deselect:function (inItemOrIndex) {
            if (this.mode == "none") {
                return;
            }
            var idx = null;
            if (typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string") {
                idx = inItemOrIndex;
            } else {
                idx = this.grid.getItemIndex(inItemOrIndex);
            }
            if (this.selectedIndex == idx) {
                this.selectedIndex = -1;
            }
            if (this.selected[idx]) {
                if (this.onCanDeselect(idx) === false) {
                    return;
                }
                var rowNodes = query("tr[dojoxTreeGridPath='" + idx + "']", this.grid.domNode);
                if (rowNodes.length) {
                    domAttr.set(rowNodes[0], "aria-selected", "false");
                }
                this._beginUpdate();
                delete this.selected[idx];
                this._removeSortedSelection(idx);
                this.onDeselected(idx);
                this._endUpdate();
            }
        }, getSelected:function () {
            var result = [];
            for (var i in this.selected) {
                if (this.selected[i]) {
                    result.push(this.grid.getItem(i));
                }
            }
            return result;
        }, getSelectedCount:function () {
            var c = 0;
            for (var i in this.selected) {
                if (this.selected[i]) {
                    c++;
                }
            }
            return c;
        }, _bsearch:function (v) {
            var o = this.sorted_sel;
            var h = o.length - 1, l = 0, m;
            while (l <= h) {
                var cmp = this._comparePaths(o[m = (l + h) >> 1], v);
                if (cmp < 0) {
                    l = m + 1;
                    continue;
                }
                if (cmp > 0) {
                    h = m - 1;
                    continue;
                }
                return m;
            }
            return cmp < 0 ? m - cmp : m;
        }, _comparePaths:function (a, b) {
            for (var i = 0, l = (a.length < b.length ? a.length : b.length); i < l; i++) {
                if (a[i] < b[i]) {
                    return -1;
                }
                if (a[i] > b[i]) {
                    return 1;
                }
            }
            if (a.length < b.length) {
                return -1;
            }
            if (a.length > b.length) {
                return 1;
            }
            return 0;
        }, _insertSortedSelection:function (index) {
            index = String(index);
            var s = this.sorted_sel;
            var sl = this.sorted_ltos;
            var ss = this.sorted_stol;
            var lpath = index.split("/");
            lpath = array.map(lpath, function (item) {
                return parseInt(item, 10);
            });
            sl[lpath] = index;
            ss[index] = lpath;
            if (s.length === 0) {
                s.push(lpath);
                return;
            }
            if (s.length == 1) {
                var cmp = this._comparePaths(s[0], lpath);
                if (cmp == 1) {
                    s.unshift(lpath);
                } else {
                    s.push(lpath);
                }
                return;
            }
            var idx = this._bsearch(lpath);
            this.sorted_sel.splice(idx, 0, lpath);
        }, _removeSortedSelection:function (index) {
            index = String(index);
            var s = this.sorted_sel;
            var sl = this.sorted_ltos;
            var ss = this.sorted_stol;
            if (s.length === 0) {
                return;
            }
            var lpath = ss[index];
            if (!lpath) {
                return;
            }
            var idx = this._bsearch(lpath);
            if (idx > -1) {
                delete sl[lpath];
                delete ss[index];
                s.splice(idx, 1);
            }
        }, getFirstSelected:function () {
            if (!this.sorted_sel.length || this.mode == "none") {
                return -1;
            }
            var fpath = this.sorted_sel[0];
            if (!fpath) {
                return -1;
            }
            fpath = this.sorted_ltos[fpath];
            if (!fpath) {
                return -1;
            }
            return fpath;
        }, getNextSelected:function (inPrev) {
            if (!this.sorted_sel.length || this.mode == "none") {
                return -1;
            }
            inPrev = String(inPrev);
            var prevPath = this.sorted_stol[inPrev];
            if (!prevPath) {
                return -1;
            }
            var idx = this._bsearch(prevPath);
            var lpath = this.sorted_sel[idx + 1];
            if (!lpath) {
                return -1;
            }
            return this.sorted_ltos[lpath];
        }, _range:function (inFrom, inTo, func) {
            if (!lang.isString(inFrom) && inFrom < 0) {
                inFrom = inTo;
            }
            var cells = this.grid.layout.cells, store = this.grid.store, grid = this.grid;
            inFrom = new dojox.grid.TreePath(String(inFrom), grid);
            inTo = new dojox.grid.TreePath(String(inTo), grid);
            if (inFrom.compare(inTo) > 0) {
                var tmp = inFrom;
                inFrom = inTo;
                inTo = tmp;
            }
            var inFromStr = inFrom._str, inToStr = inTo._str;
            func(inFromStr);
            var p = inFrom;
            while ((p = p.next())) {
                if (p._str == inToStr) {
                    break;
                }
                func(p._str);
            }
            func(inToStr);
        }});
    });
}, "dojo/_base/window":function () {
    define(["./kernel", "./lang", "../sniff"], function (dojo, lang, has) {
        var ret = {global:dojo.global, doc:this["document"] || null, body:function (doc) {
            doc = doc || dojo.doc;
            return doc.body || doc.getElementsByTagName("body")[0];
        }, setContext:function (globalObject, globalDocument) {
            dojo.global = ret.global = globalObject;
            dojo.doc = ret.doc = globalDocument;
        }, withGlobal:function (globalObject, callback, thisObject, cbArguments) {
            var oldGlob = dojo.global;
            try {
                dojo.global = ret.global = globalObject;
                return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
            }
            finally {
                dojo.global = ret.global = oldGlob;
            }
        }, withDoc:function (documentObject, callback, thisObject, cbArguments) {
            var oldDoc = ret.doc, oldQ = has("quirks"), oldIE = has("ie"), isIE, mode, pwin;
            try {
                dojo.doc = ret.doc = documentObject;
                dojo.isQuirks = has.add("quirks", dojo.doc.compatMode == "BackCompat", true, true);
                if (has("ie")) {
                    if ((pwin = documentObject.parentWindow) && pwin.navigator) {
                        isIE = parseFloat(pwin.navigator.appVersion.split("MSIE ")[1]) || undefined;
                        mode = documentObject.documentMode;
                        if (mode && mode != 5 && Math.floor(isIE) != mode) {
                            isIE = mode;
                        }
                        dojo.isIE = has.add("ie", isIE, true, true);
                    }
                }
                if (thisObject && typeof callback == "string") {
                    callback = thisObject[callback];
                }
                return callback.apply(thisObject, cbArguments || []);
            }
            finally {
                dojo.doc = ret.doc = oldDoc;
                dojo.isQuirks = has.add("quirks", oldQ, true, true);
                dojo.isIE = has.add("ie", oldIE, true, true);
            }
        }};
        1 && lang.mixin(dojo, ret);
        return ret;
    });
}, "dojo/_base/json":function () {
    define(["./kernel", "../json"], function (dojo, json) {
        dojo.fromJson = function (js) {
            return eval("(" + js + ")");
        };
        dojo._escapeString = json.stringify;
        dojo.toJsonIndentStr = "\t";
        dojo.toJson = function (it, prettyPrint) {
            return json.stringify(it, function (key, value) {
                if (value) {
                    var tf = value.__json__ || value.json;
                    if (typeof tf == "function") {
                        return tf.call(value);
                    }
                }
                return value;
            }, prettyPrint && dojo.toJsonIndentStr);
        };
        return dojo;
    });
}, "dijit/form/Form":function () {
    define(["dojo/_base/declare", "dojo/dom-attr", "dojo/_base/kernel", "dojo/sniff", "../_Widget", "../_TemplatedMixin", "./_FormMixin", "../layout/_ContentPaneResizeMixin"], function (declare, domAttr, kernel, has, _Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin) {
        return declare("dijit.form.Form", [_Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin], {name:"", action:"", method:"", encType:"", "accept-charset":"", accept:"", target:"", templateString:"<form data-dojo-attach-point='containerNode' data-dojo-attach-event='onreset:_onReset,onsubmit:_onSubmit' ${!nameAttrSetting}></form>", postMixInProperties:function () {
            this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
            this.inherited(arguments);
        }, execute:function () {
        }, onExecute:function () {
        }, _setEncTypeAttr:function (value) {
            domAttr.set(this.domNode, "encType", value);
            if (has("ie")) {
                this.domNode.encoding = value;
            }
            this._set("encType", value);
        }, reset:function (e) {
            var faux = {returnValue:true, preventDefault:function () {
                this.returnValue = false;
            }, stopPropagation:function () {
            }, currentTarget:e ? e.target : this.domNode, target:e ? e.target : this.domNode};
            if (!(this.onReset(faux) === false) && faux.returnValue) {
                this.inherited(arguments, []);
            }
        }, onReset:function () {
            return true;
        }, _onReset:function (e) {
            this.reset(e);
            e.stopPropagation();
            e.preventDefault();
            return false;
        }, _onSubmit:function (e) {
            var fp = this.constructor.prototype;
            if (this.execute != fp.execute || this.onExecute != fp.onExecute) {
                kernel.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
                this.onExecute();
                this.execute(this.getValues());
            }
            if (this.onSubmit(e) === false) {
                e.stopPropagation();
                e.preventDefault();
            }
        }, onSubmit:function () {
            return this.isValid();
        }, submit:function () {
            if (!(this.onSubmit() === false)) {
                this.containerNode.submit();
            }
        }});
    });
}, "dijit/form/_FormWidgetMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-attr", "dojo/dom-style", "dojo/_base/lang", "dojo/mouse", "dojo/on", "dojo/sniff", "dojo/window", "../a11y"], function (array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y) {
        return declare("dijit.form._FormWidgetMixin", null, {name:"", alt:"", value:"", type:"text", "aria-label":"focusNode", tabIndex:"0", _setTabIndexAttr:"focusNode", disabled:false, intermediateChanges:false, scrollOnFocus:true, _setIdAttr:"focusNode", _setDisabledAttr:function (value) {
            this._set("disabled", value);
            domAttr.set(this.focusNode, "disabled", value);
            if (this.valueNode) {
                domAttr.set(this.valueNode, "disabled", value);
            }
            this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
            if (value) {
                this._set("hovering", false);
                this._set("active", false);
                var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex : ("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
                array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function (attachPointName) {
                    var node = this[attachPointName];
                    if (has("webkit") || a11y.hasDefaultTabStop(node)) {
                        node.setAttribute("tabIndex", "-1");
                    } else {
                        node.removeAttribute("tabIndex");
                    }
                }, this);
            } else {
                if (this.tabIndex != "") {
                    this.set("tabIndex", this.tabIndex);
                }
            }
        }, _onFocus:function (by) {
            if (by == "mouse" && this.isFocusable()) {
                var focusHandle = this.own(on(this.focusNode, "focus", function () {
                    mouseUpHandle.remove();
                    focusHandle.remove();
                }))[0];
                var mouseUpHandle = this.own(on(this.ownerDocumentBody, "mouseup, touchend", lang.hitch(this, function (evt) {
                    mouseUpHandle.remove();
                    focusHandle.remove();
                    if (this.focused) {
                        if (evt.type == "touchend") {
                            this.defer("focus");
                        } else {
                            this.focus();
                        }
                    }
                })))[0];
            }
            if (this.scrollOnFocus) {
                this.defer(function () {
                    winUtils.scrollIntoView(this.domNode);
                });
            }
            this.inherited(arguments);
        }, isFocusable:function () {
            return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
        }, focus:function () {
            if (!this.disabled && this.focusNode.focus) {
                try {
                    this.focusNode.focus();
                }
                catch (e) {
                }
            }
        }, compare:function (val1, val2) {
            if (typeof val1 == "number" && typeof val2 == "number") {
                return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
            } else {
                if (val1 > val2) {
                    return 1;
                } else {
                    if (val1 < val2) {
                        return -1;
                    } else {
                        return 0;
                    }
                }
            }
        }, onChange:function () {
        }, _onChangeActive:false, _handleOnChange:function (newValue, priorityChange) {
            if (this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)) {
                this._resetValue = this._lastValueReported = newValue;
            }
            this._pendingOnChange = this._pendingOnChange || (typeof newValue != typeof this._lastValueReported) || (this.compare(newValue, this._lastValueReported) != 0);
            if ((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange) {
                this._lastValueReported = newValue;
                this._pendingOnChange = false;
                if (this._onChangeActive) {
                    if (this._onChangeHandle) {
                        this._onChangeHandle.remove();
                    }
                    this._onChangeHandle = this.defer(function () {
                        this._onChangeHandle = null;
                        this.onChange(newValue);
                    });
                }
            }
        }, create:function () {
            this.inherited(arguments);
            this._onChangeActive = true;
        }, destroy:function () {
            if (this._onChangeHandle) {
                this._onChangeHandle.remove();
                this.onChange(this._lastValueReported);
            }
            this.inherited(arguments);
        }});
    });
}, "dojo/json":function () {
    define(["./has"], function (has) {
        "use strict";
        var hasJSON = typeof JSON != "undefined";
        has.add("json-parse", hasJSON);
        has.add("json-stringify", hasJSON && JSON.stringify({a:0}, function (k, v) {
            return v || 1;
        }) == "{\"a\":1}");
        if (has("json-stringify")) {
            return JSON;
        } else {
            var escapeString = function (str) {
                return ("\"" + str.replace(/(["\\])/g, "\\$1") + "\"").replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r");
            };
            return {parse:has("json-parse") ? JSON.parse : function (str, strict) {
                if (strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)) {
                    throw new SyntaxError("Invalid characters in JSON");
                }
                return eval("(" + str + ")");
            }, stringify:function (value, replacer, spacer) {
                var undef;
                if (typeof replacer == "string") {
                    spacer = replacer;
                    replacer = null;
                }
                function stringify(it, indent, key) {
                    if (replacer) {
                        it = replacer(key, it);
                    }
                    var val, objtype = typeof it;
                    if (objtype == "number") {
                        return isFinite(it) ? it + "" : "null";
                    }
                    if (objtype == "boolean") {
                        return it + "";
                    }
                    if (it === null) {
                        return "null";
                    }
                    if (typeof it == "string") {
                        return escapeString(it);
                    }
                    if (objtype == "function" || objtype == "undefined") {
                        return undef;
                    }
                    if (typeof it.toJSON == "function") {
                        return stringify(it.toJSON(key), indent, key);
                    }
                    if (it instanceof Date) {
                        return "\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"".replace(/\{(\w+)(\+)?\}/g, function (t, prop, plus) {
                            var num = it["getUTC" + prop]() + (plus ? 1 : 0);
                            return num < 10 ? "0" + num : num;
                        });
                    }
                    if (it.valueOf() !== it) {
                        return stringify(it.valueOf(), indent, key);
                    }
                    var nextIndent = spacer ? (indent + spacer) : "";
                    var sep = spacer ? " " : "";
                    var newLine = spacer ? "\n" : "";
                    if (it instanceof Array) {
                        var itl = it.length, res = [];
                        for (key = 0; key < itl; key++) {
                            var obj = it[key];
                            val = stringify(obj, nextIndent, key);
                            if (typeof val != "string") {
                                val = "null";
                            }
                            res.push(newLine + nextIndent + val);
                        }
                        return "[" + res.join(",") + newLine + indent + "]";
                    }
                    var output = [];
                    for (key in it) {
                        var keyStr;
                        if (it.hasOwnProperty(key)) {
                            if (typeof key == "number") {
                                keyStr = "\"" + key + "\"";
                            } else {
                                if (typeof key == "string") {
                                    keyStr = escapeString(key);
                                } else {
                                    continue;
                                }
                            }
                            val = stringify(it[key], nextIndent, key);
                            if (typeof val != "string") {
                                continue;
                            }
                            output.push(newLine + nextIndent + keyStr + ":" + sep + val);
                        }
                    }
                    return "{" + output.join(",") + newLine + indent + "}";
                }
                return stringify(value, "", "");
            }};
        }
    });
}, "dojox/uuid/generateRandomUuid":function () {
    define(["./_base"], function () {
        dojox.uuid.generateRandomUuid = function () {
            var HEX_RADIX = 16;
            function _generateRandomEightCharacterHexString() {
                var random32bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 32));
                var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
                while (eightCharacterHexString.length < 8) {
                    eightCharacterHexString = "0" + eightCharacterHexString;
                }
                return eightCharacterHexString;
            }
            var hyphen = "-";
            var versionCodeForRandomlyGeneratedUuids = "4";
            var variantCodeForDCEUuids = "8";
            var a = _generateRandomEightCharacterHexString();
            var b = _generateRandomEightCharacterHexString();
            b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
            var c = _generateRandomEightCharacterHexString();
            c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
            var d = _generateRandomEightCharacterHexString();
            var returnValue = a + hyphen + b + hyphen + c + d;
            returnValue = returnValue.toLowerCase();
            return returnValue;
        };
        return dojox.uuid.generateRandomUuid;
    });
}, "dijit/_base/place":function () {
    define(["dojo/_base/array", "dojo/_base/lang", "dojo/window", "../place", "../main"], function (array, lang, windowUtils, place, dijit) {
        var exports = {};
        exports.getViewport = function () {
            return windowUtils.getBox();
        };
        exports.placeOnScreen = place.at;
        exports.placeOnScreenAroundElement = function (node, aroundNode, aroundCorners, layoutNode) {
            var positions;
            if (lang.isArray(aroundCorners)) {
                positions = aroundCorners;
            } else {
                positions = [];
                for (var key in aroundCorners) {
                    positions.push({aroundCorner:key, corner:aroundCorners[key]});
                }
            }
            return place.around(node, aroundNode, positions, true, layoutNode);
        };
        exports.placeOnScreenAroundNode = exports.placeOnScreenAroundElement;
        exports.placeOnScreenAroundRectangle = exports.placeOnScreenAroundElement;
        exports.getPopupAroundAlignment = function (position, leftToRight) {
            var align = {};
            array.forEach(position, function (pos) {
                var ltr = leftToRight;
                switch (pos) {
                  case "after":
                    align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
                    break;
                  case "before":
                    align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
                    break;
                  case "below-alt":
                    ltr = !ltr;
                  case "below":
                    align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
                    align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
                    break;
                  case "above-alt":
                    ltr = !ltr;
                  case "above":
                  default:
                    align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
                    align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
                    break;
                }
            });
            return align;
        };
        lang.mixin(dijit, exports);
        return dijit;
    });
}, "dojox/main":function () {
    define(["dojo/_base/kernel"], function (dojo) {
        return dojo.dojox;
    });
}, "dojo/dnd/Selector":function () {
    define(["../_base/array", "../_base/declare", "../_base/kernel", "../_base/lang", "../dom", "../dom-construct", "../mouse", "../_base/NodeList", "../on", "../touch", "./common", "./Container"], function (array, declare, kernel, lang, dom, domConstruct, mouse, NodeList, on, touch, dnd, Container) {
        var Selector = declare("dojo.dnd.Selector", Container, {constructor:function (node, params) {
            if (!params) {
                params = {};
            }
            this.singular = params.singular;
            this.autoSync = params.autoSync;
            this.selection = {};
            this.anchor = null;
            this.simpleSelection = false;
            this.events.push(on(this.node, touch.press, lang.hitch(this, "onMouseDown")), on(this.node, touch.release, lang.hitch(this, "onMouseUp")));
        }, singular:false, getSelectedNodes:function () {
            var t = new NodeList();
            var e = dnd._empty;
            for (var i in this.selection) {
                if (i in e) {
                    continue;
                }
                t.push(dom.byId(i));
            }
            return t;
        }, selectNone:function () {
            return this._removeSelection()._removeAnchor();
        }, selectAll:function () {
            this.forInItems(function (data, id) {
                this._addItemClass(dom.byId(id), "Selected");
                this.selection[id] = 1;
            }, this);
            return this._removeAnchor();
        }, deleteSelectedNodes:function () {
            var e = dnd._empty;
            for (var i in this.selection) {
                if (i in e) {
                    continue;
                }
                var n = dom.byId(i);
                this.delItem(i);
                domConstruct.destroy(n);
            }
            this.anchor = null;
            this.selection = {};
            return this;
        }, forInSelectedItems:function (f, o) {
            o = o || kernel.global;
            var s = this.selection, e = dnd._empty;
            for (var i in s) {
                if (i in e) {
                    continue;
                }
                f.call(o, this.getItem(i), i, this);
            }
        }, sync:function () {
            Selector.superclass.sync.call(this);
            if (this.anchor) {
                if (!this.getItem(this.anchor.id)) {
                    this.anchor = null;
                }
            }
            var t = [], e = dnd._empty;
            for (var i in this.selection) {
                if (i in e) {
                    continue;
                }
                if (!this.getItem(i)) {
                    t.push(i);
                }
            }
            array.forEach(t, function (i) {
                delete this.selection[i];
            }, this);
            return this;
        }, insertNodes:function (addSelected, data, before, anchor) {
            var oldCreator = this._normalizedCreator;
            this._normalizedCreator = function (item, hint) {
                var t = oldCreator.call(this, item, hint);
                if (addSelected) {
                    if (!this.anchor) {
                        this.anchor = t.node;
                        this._removeItemClass(t.node, "Selected");
                        this._addItemClass(this.anchor, "Anchor");
                    } else {
                        if (this.anchor != t.node) {
                            this._removeItemClass(t.node, "Anchor");
                            this._addItemClass(t.node, "Selected");
                        }
                    }
                    this.selection[t.node.id] = 1;
                } else {
                    this._removeItemClass(t.node, "Selected");
                    this._removeItemClass(t.node, "Anchor");
                }
                return t;
            };
            Selector.superclass.insertNodes.call(this, data, before, anchor);
            this._normalizedCreator = oldCreator;
            return this;
        }, destroy:function () {
            Selector.superclass.destroy.call(this);
            this.selection = this.anchor = null;
        }, onMouseDown:function (e) {
            if (this.autoSync) {
                this.sync();
            }
            if (!this.current) {
                return;
            }
            if (!this.singular && !dnd.getCopyKeyState(e) && !e.shiftKey && (this.current.id in this.selection)) {
                this.simpleSelection = true;
                if (mouse.isLeft(e)) {
                    e.stopPropagation();
                    e.preventDefault();
                }
                return;
            }
            if (!this.singular && e.shiftKey) {
                if (!dnd.getCopyKeyState(e)) {
                    this._removeSelection();
                }
                var c = this.getAllNodes();
                if (c.length) {
                    if (!this.anchor) {
                        this.anchor = c[0];
                        this._addItemClass(this.anchor, "Anchor");
                    }
                    this.selection[this.anchor.id] = 1;
                    if (this.anchor != this.current) {
                        var i = 0, node;
                        for (; i < c.length; ++i) {
                            node = c[i];
                            if (node == this.anchor || node == this.current) {
                                break;
                            }
                        }
                        for (++i; i < c.length; ++i) {
                            node = c[i];
                            if (node == this.anchor || node == this.current) {
                                break;
                            }
                            this._addItemClass(node, "Selected");
                            this.selection[node.id] = 1;
                        }
                        this._addItemClass(this.current, "Selected");
                        this.selection[this.current.id] = 1;
                    }
                }
            } else {
                if (this.singular) {
                    if (this.anchor == this.current) {
                        if (dnd.getCopyKeyState(e)) {
                            this.selectNone();
                        }
                    } else {
                        this.selectNone();
                        this.anchor = this.current;
                        this._addItemClass(this.anchor, "Anchor");
                        this.selection[this.current.id] = 1;
                    }
                } else {
                    if (dnd.getCopyKeyState(e)) {
                        if (this.anchor == this.current) {
                            delete this.selection[this.anchor.id];
                            this._removeAnchor();
                        } else {
                            if (this.current.id in this.selection) {
                                this._removeItemClass(this.current, "Selected");
                                delete this.selection[this.current.id];
                            } else {
                                if (this.anchor) {
                                    this._removeItemClass(this.anchor, "Anchor");
                                    this._addItemClass(this.anchor, "Selected");
                                }
                                this.anchor = this.current;
                                this._addItemClass(this.current, "Anchor");
                                this.selection[this.current.id] = 1;
                            }
                        }
                    } else {
                        if (!(this.current.id in this.selection)) {
                            this.selectNone();
                            this.anchor = this.current;
                            this._addItemClass(this.current, "Anchor");
                            this.selection[this.current.id] = 1;
                        }
                    }
                }
            }
            e.stopPropagation();
            e.preventDefault();
        }, onMouseUp:function () {
            if (!this.simpleSelection) {
                return;
            }
            this.simpleSelection = false;
            this.selectNone();
            if (this.current) {
                this.anchor = this.current;
                this._addItemClass(this.anchor, "Anchor");
                this.selection[this.current.id] = 1;
            }
        }, onMouseMove:function () {
            this.simpleSelection = false;
        }, onOverEvent:function () {
            this.onmousemoveEvent = on(this.node, touch.move, lang.hitch(this, "onMouseMove"));
        }, onOutEvent:function () {
            if (this.onmousemoveEvent) {
                this.onmousemoveEvent.remove();
                delete this.onmousemoveEvent;
            }
        }, _removeSelection:function () {
            var e = dnd._empty;
            for (var i in this.selection) {
                if (i in e) {
                    continue;
                }
                var node = dom.byId(i);
                if (node) {
                    this._removeItemClass(node, "Selected");
                }
            }
            this.selection = {};
            return this;
        }, _removeAnchor:function () {
            if (this.anchor) {
                this._removeItemClass(this.anchor, "Anchor");
                this.anchor = null;
            }
            return this;
        }});
        return Selector;
    });
}, "dojox/grid/_Scroller":function () {
    define(["dijit/registry", "dojo/_base/declare", "dojo/_base/lang", "./util", "dojo/_base/html"], function (dijitRegistry, declare, lang, util, html) {
        var indexInParent = function (inNode) {
            var i = 0, n, p = inNode.parentNode;
            while ((n = p.childNodes[i++])) {
                if (n == inNode) {
                    return i - 1;
                }
            }
            return -1;
        };
        var cleanNode = function (inNode) {
            if (!inNode) {
                return;
            }
            dojo.forEach(dijitRegistry.toArray(), function (w) {
                if (w.domNode && html.isDescendant(w.domNode, inNode, true)) {
                    w.destroy();
                }
            });
        };
        var getTagName = function (inNodeOrId) {
            var node = html.byId(inNodeOrId);
            return (node && node.tagName ? node.tagName.toLowerCase() : "");
        };
        var nodeKids = function (inNode, inTag) {
            var result = [];
            var i = 0, n;
            while ((n = inNode.childNodes[i])) {
                i++;
                if (getTagName(n) == inTag) {
                    result.push(n);
                }
            }
            return result;
        };
        var divkids = function (inNode) {
            return nodeKids(inNode, "div");
        };
        return declare("dojox.grid._Scroller", null, {constructor:function (inContentNodes) {
            this.setContentNodes(inContentNodes);
            this.pageHeights = [];
            this.pageNodes = [];
            this.stack = [];
        }, rowCount:0, defaultRowHeight:32, keepRows:100, contentNode:null, scrollboxNode:null, defaultPageHeight:0, keepPages:10, pageCount:0, windowHeight:0, firstVisibleRow:0, lastVisibleRow:0, averageRowHeight:0, page:0, pageTop:0, init:function (inRowCount, inKeepRows, inRowsPerPage) {
            switch (arguments.length) {
              case 3:
                this.rowsPerPage = inRowsPerPage;
              case 2:
                this.keepRows = inKeepRows;
              case 1:
                this.rowCount = inRowCount;
              default:
                break;
            }
            this.defaultPageHeight = (this.grid.rowHeight > 0 ? this.grid.rowHeight : this.defaultRowHeight) * this.rowsPerPage;
            this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
            this.setKeepInfo(this.keepRows);
            this.invalidate();
            if (this.scrollboxNode) {
                this.scrollboxNode.scrollTop = 0;
                this.scroll(0);
                this.scrollboxNode.onscroll = lang.hitch(this, "onscroll");
            }
        }, _getPageCount:function (rowCount, rowsPerPage) {
            return rowCount ? (Math.ceil(rowCount / rowsPerPage) || 1) : 0;
        }, destroy:function () {
            this.invalidateNodes();
            delete this.contentNodes;
            delete this.contentNode;
            delete this.scrollboxNode;
        }, setKeepInfo:function (inKeepRows) {
            this.keepRows = inKeepRows;
            this.keepPages = !this.keepRows ? this.keepPages : Math.max(Math.ceil(this.keepRows / this.rowsPerPage), 2);
        }, setContentNodes:function (inNodes) {
            this.contentNodes = inNodes;
            this.colCount = (this.contentNodes ? this.contentNodes.length : 0);
            this.pageNodes = [];
            for (var i = 0; i < this.colCount; i++) {
                this.pageNodes[i] = [];
            }
        }, getDefaultNodes:function () {
            return this.pageNodes[0] || [];
        }, invalidate:function () {
            this._invalidating = true;
            this.invalidateNodes();
            this.pageHeights = [];
            this.height = (this.pageCount ? (this.pageCount - 1) * this.defaultPageHeight + this.calcLastPageHeight() : 0);
            this.resize();
            this._invalidating = false;
        }, updateRowCount:function (inRowCount) {
            this.invalidateNodes();
            this.rowCount = inRowCount;
            var oldPageCount = this.pageCount;
            if (oldPageCount === 0) {
                this.height = 1;
            }
            this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
            if (this.pageCount < oldPageCount) {
                for (var i = oldPageCount - 1; i >= this.pageCount; i--) {
                    this.height -= this.getPageHeight(i);
                    delete this.pageHeights[i];
                }
            } else {
                if (this.pageCount > oldPageCount) {
                    this.height += this.defaultPageHeight * (this.pageCount - oldPageCount - 1) + this.calcLastPageHeight();
                }
            }
            this.resize();
        }, pageExists:function (inPageIndex) {
            return Boolean(this.getDefaultPageNode(inPageIndex));
        }, measurePage:function (inPageIndex) {
            if (this.grid.rowHeight) {
                return ((inPageIndex + 1) * this.rowsPerPage > this.rowCount ? this.rowCount - inPageIndex * this.rowsPerPage : this.rowsPerPage) * this.grid.rowHeight;
            }
            var n = this.getDefaultPageNode(inPageIndex);
            return (n && n.innerHTML) ? n.offsetHeight : undefined;
        }, positionPage:function (inPageIndex, inPos) {
            for (var i = 0; i < this.colCount; i++) {
                this.pageNodes[i][inPageIndex].style.top = inPos + "px";
            }
        }, repositionPages:function (inPageIndex) {
            var nodes = this.getDefaultNodes();
            var last = 0;
            for (var i = 0; i < this.stack.length; i++) {
                last = Math.max(this.stack[i], last);
            }
            var n = nodes[inPageIndex];
            var y = (n ? this.getPageNodePosition(n) + this.getPageHeight(inPageIndex) : 0);
            for (var p = inPageIndex + 1; p <= last; p++) {
                n = nodes[p];
                if (n) {
                    if (this.getPageNodePosition(n) == y) {
                        return;
                    }
                    this.positionPage(p, y);
                }
                y += this.getPageHeight(p);
            }
        }, installPage:function (inPageIndex) {
            for (var i = 0; i < this.colCount; i++) {
                this.contentNodes[i].appendChild(this.pageNodes[i][inPageIndex]);
            }
        }, preparePage:function (inPageIndex, inReuseNode) {
            var p = (inReuseNode ? this.popPage() : null);
            for (var i = 0; i < this.colCount; i++) {
                var nodes = this.pageNodes[i];
                var new_p = (p === null ? this.createPageNode() : this.invalidatePageNode(p, nodes));
                new_p.pageIndex = inPageIndex;
                nodes[inPageIndex] = new_p;
            }
        }, renderPage:function (inPageIndex) {
            var nodes = [];
            var i, j;
            for (i = 0; i < this.colCount; i++) {
                nodes[i] = this.pageNodes[i][inPageIndex];
            }
            for (i = 0, j = inPageIndex * this.rowsPerPage; (i < this.rowsPerPage) && (j < this.rowCount); i++, j++) {
                this.renderRow(j, nodes);
            }
        }, removePage:function (inPageIndex) {
            for (var i = 0, j = inPageIndex * this.rowsPerPage; i < this.rowsPerPage; i++, j++) {
                this.removeRow(j);
            }
        }, destroyPage:function (inPageIndex) {
            for (var i = 0; i < this.colCount; i++) {
                var n = this.invalidatePageNode(inPageIndex, this.pageNodes[i]);
                if (n) {
                    html.destroy(n);
                }
            }
        }, pacify:function (inShouldPacify) {
        }, pacifying:false, pacifyTicks:200, setPacifying:function (inPacifying) {
            if (this.pacifying != inPacifying) {
                this.pacifying = inPacifying;
                this.pacify(this.pacifying);
            }
        }, startPacify:function () {
            this.startPacifyTicks = new Date().getTime();
        }, doPacify:function () {
            var result = (new Date().getTime() - this.startPacifyTicks) > this.pacifyTicks;
            this.setPacifying(true);
            this.startPacify();
            return result;
        }, endPacify:function () {
            this.setPacifying(false);
        }, resize:function () {
            if (this.scrollboxNode) {
                this.windowHeight = this.scrollboxNode.clientHeight;
            }
            for (var i = 0; i < this.colCount; i++) {
                util.setStyleHeightPx(this.contentNodes[i], Math.max(1, this.height));
            }
            var needPage = (!this._invalidating);
            if (!needPage) {
                var ah = this.grid.get("autoHeight");
                if (typeof ah == "number" && ah <= Math.min(this.rowsPerPage, this.rowCount)) {
                    needPage = true;
                }
            }
            if (needPage) {
                this.needPage(this.page, this.pageTop);
            }
            var rowsOnPage = (this.page < this.pageCount - 1) ? this.rowsPerPage : ((this.rowCount % this.rowsPerPage) || this.rowsPerPage);
            var pageHeight = this.getPageHeight(this.page);
            this.averageRowHeight = (pageHeight > 0 && rowsOnPage > 0) ? (pageHeight / rowsOnPage) : 0;
        }, calcLastPageHeight:function () {
            if (!this.pageCount) {
                return 0;
            }
            var lastPage = this.pageCount - 1;
            var lastPageHeight = ((this.rowCount % this.rowsPerPage) || (this.rowsPerPage)) * this.defaultRowHeight;
            this.pageHeights[lastPage] = lastPageHeight;
            return lastPageHeight;
        }, updateContentHeight:function (inDh) {
            this.height += inDh;
            this.resize();
        }, updatePageHeight:function (inPageIndex, fromBuild, fromAsynRendering) {
            if (this.pageExists(inPageIndex)) {
                var oh = this.getPageHeight(inPageIndex);
                var h = (this.measurePage(inPageIndex));
                if (h === undefined) {
                    h = oh;
                }
                this.pageHeights[inPageIndex] = h;
                if (oh != h) {
                    this.updateContentHeight(h - oh);
                    var ah = this.grid.get("autoHeight");
                    if ((typeof ah == "number" && ah > this.rowCount) || (ah === true && !fromBuild)) {
                        if (!fromAsynRendering) {
                            this.grid.sizeChange();
                        } else {
                            var ns = this.grid.viewsNode.style;
                            ns.height = parseInt(ns.height) + h - oh + "px";
                            this.repositionPages(inPageIndex);
                        }
                    } else {
                        this.repositionPages(inPageIndex);
                    }
                }
                return h;
            }
            return 0;
        }, rowHeightChanged:function (inRowIndex, fromAsynRendering) {
            this.updatePageHeight(Math.floor(inRowIndex / this.rowsPerPage), false, fromAsynRendering);
        }, invalidateNodes:function () {
            while (this.stack.length) {
                this.destroyPage(this.popPage());
            }
        }, createPageNode:function () {
            var p = document.createElement("div");
            html.attr(p, "role", "presentation");
            p.style.position = "absolute";
            p.style[this.grid.isLeftToRight() ? "left" : "right"] = "0";
            return p;
        }, getPageHeight:function (inPageIndex) {
            var ph = this.pageHeights[inPageIndex];
            return (ph !== undefined ? ph : this.defaultPageHeight);
        }, pushPage:function (inPageIndex) {
            return this.stack.push(inPageIndex);
        }, popPage:function () {
            return this.stack.shift();
        }, findPage:function (inTop) {
            var i = 0, h = 0;
            for (var ph = 0; i < this.pageCount; i++, h += ph) {
                ph = this.getPageHeight(i);
                if (h + ph >= inTop) {
                    break;
                }
            }
            this.page = i;
            this.pageTop = h;
        }, buildPage:function (inPageIndex, inReuseNode, inPos) {
            this.preparePage(inPageIndex, inReuseNode);
            this.positionPage(inPageIndex, inPos);
            this.installPage(inPageIndex);
            this.renderPage(inPageIndex);
            this.pushPage(inPageIndex);
        }, needPage:function (inPageIndex, inPos) {
            var h = this.getPageHeight(inPageIndex), oh = h;
            if (!this.pageExists(inPageIndex)) {
                this.buildPage(inPageIndex, (!this.grid._autoHeight && this.keepPages && (this.stack.length >= this.keepPages)), inPos);
                h = this.updatePageHeight(inPageIndex, true);
            } else {
                this.positionPage(inPageIndex, inPos);
            }
            return h;
        }, onscroll:function () {
            this.scroll(this.scrollboxNode.scrollTop);
        }, scroll:function (inTop) {
            this.grid.scrollTop = inTop;
            if (this.colCount) {
                this.startPacify();
                this.findPage(inTop);
                var h = this.height;
                var b = this.getScrollBottom(inTop);
                for (var p = this.page, y = this.pageTop; (p < this.pageCount) && ((b < 0) || (y < b)); p++) {
                    y += this.needPage(p, y);
                }
                this.firstVisibleRow = this.getFirstVisibleRow(this.page, this.pageTop, inTop);
                this.lastVisibleRow = this.getLastVisibleRow(p - 1, y, b);
                if (h != this.height) {
                    this.repositionPages(p - 1);
                }
                this.endPacify();
            }
        }, getScrollBottom:function (inTop) {
            return (this.windowHeight >= 0 ? inTop + this.windowHeight : -1);
        }, processNodeEvent:function (e, inNode) {
            var t = e.target;
            while (t && (t != inNode) && t.parentNode && (t.parentNode.parentNode != inNode)) {
                t = t.parentNode;
            }
            if (!t || !t.parentNode || (t.parentNode.parentNode != inNode)) {
                return false;
            }
            var page = t.parentNode;
            e.topRowIndex = page.pageIndex * this.rowsPerPage;
            e.rowIndex = e.topRowIndex + indexInParent(t);
            e.rowTarget = t;
            return true;
        }, processEvent:function (e) {
            return this.processNodeEvent(e, this.contentNode);
        }, renderRow:function (inRowIndex, inPageNode) {
        }, removeRow:function (inRowIndex) {
        }, getDefaultPageNode:function (inPageIndex) {
            return this.getDefaultNodes()[inPageIndex];
        }, positionPageNode:function (inNode, inPos) {
        }, getPageNodePosition:function (inNode) {
            return inNode.offsetTop;
        }, invalidatePageNode:function (inPageIndex, inNodes) {
            var p = inNodes[inPageIndex];
            if (p) {
                delete inNodes[inPageIndex];
                this.removePage(inPageIndex, p);
                cleanNode(p);
                p.innerHTML = "";
            }
            return p;
        }, getPageRow:function (inPage) {
            return inPage * this.rowsPerPage;
        }, getLastPageRow:function (inPage) {
            return Math.min(this.rowCount, this.getPageRow(inPage + 1)) - 1;
        }, getFirstVisibleRow:function (inPage, inPageTop, inScrollTop) {
            if (!this.pageExists(inPage)) {
                return 0;
            }
            var row = this.getPageRow(inPage);
            var nodes = this.getDefaultNodes();
            var rows = divkids(nodes[inPage]);
            for (var i = 0, l = rows.length; i < l && inPageTop < inScrollTop; i++, row++) {
                inPageTop += rows[i].offsetHeight;
            }
            return (row ? row - 1 : row);
        }, getLastVisibleRow:function (inPage, inBottom, inScrollBottom) {
            if (!this.pageExists(inPage)) {
                return 0;
            }
            var nodes = this.getDefaultNodes();
            var row = this.getLastPageRow(inPage);
            var rows = divkids(nodes[inPage]);
            for (var i = rows.length - 1; i >= 0 && inBottom > inScrollBottom; i--, row--) {
                inBottom -= rows[i].offsetHeight;
            }
            return row + 1;
        }, findTopRow:function (inScrollTop) {
            var nodes = this.getDefaultNodes();
            var rows = divkids(nodes[this.page]);
            for (var i = 0, l = rows.length, t = this.pageTop, h; i < l; i++) {
                h = rows[i].offsetHeight;
                t += h;
                if (t >= inScrollTop) {
                    this.offset = h - (t - inScrollTop);
                    return i + this.page * this.rowsPerPage;
                }
            }
            return -1;
        }, findScrollTop:function (inRow) {
            var rowPage = Math.floor(inRow / this.rowsPerPage);
            var t = 0;
            var i, l;
            for (i = 0; i < rowPage; i++) {
                t += this.getPageHeight(i);
            }
            this.pageTop = t;
            this.page = rowPage;
            this.needPage(rowPage, this.pageTop);
            var nodes = this.getDefaultNodes();
            var rows = divkids(nodes[rowPage]);
            var r = inRow - this.rowsPerPage * rowPage;
            for (i = 0, l = rows.length; i < l && i < r; i++) {
                t += rows[i].offsetHeight;
            }
            return t;
        }, dummy:0});
    });
}, "dijit/_BidiMixin":function () {
    define([], function () {
        var bidi_const = {LRM:"\u200e", LRE:"\u202a", PDF:"\u202c", RLM:"\u200f", RLE:"\u202b"};
        return {textDir:"", getTextDir:function (text) {
            return this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
        }, _checkContextual:function (text) {
            var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
            return fdc ? (fdc[0] <= "z" ? "ltr" : "rtl") : this.dir ? this.dir : this.isLeftToRight() ? "ltr" : "rtl";
        }, applyTextDir:function (element, text) {
            if (this.textDir) {
                var textDir = this.textDir;
                if (textDir == "auto") {
                    if (typeof text === "undefined") {
                        var tagName = element.tagName.toLowerCase();
                        text = (tagName == "input" || tagName == "textarea") ? element.value : element.innerText || element.textContent || "";
                    }
                    textDir = this._checkContextual(text);
                }
                if (element.dir != textDir) {
                    element.dir = textDir;
                }
            }
        }, enforceTextDirWithUcc:function (option, text) {
            if (this.textDir) {
                if (option) {
                    option.originalText = text;
                }
                var dir = this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
                return (dir == "ltr" ? bidi_const.LRE : bidi_const.RLE) + text + bidi_const.PDF;
            }
            return text;
        }, restoreOriginalText:function (origObj) {
            if (origObj.originalText) {
                origObj.text = origObj.originalText;
                delete origObj.originalText;
            }
            return origObj;
        }, _setTextDirAttr:function (textDir) {
            if (!this._created || this.textDir != textDir) {
                this._set("textDir", textDir);
                var node = null;
                if (this.displayNode) {
                    node = this.displayNode;
                    this.displayNode.align = this.dir == "rtl" ? "right" : "left";
                } else {
                    node = this.textDirNode || this.focusNode || this.textbox;
                }
                if (node) {
                    this.applyTextDir(node);
                }
            }
        }};
    });
}, "dojox/collections/Dictionary":function () {
    define(["dojo/_base/kernel", "dojo/_base/array", "./_base"], function (dojo, darray, dxc) {
        dxc.Dictionary = function (dictionary) {
            var items = {};
            this.count = 0;
            var testObject = {};
            this.add = function (k, v) {
                var b = (k in items);
                items[k] = new dxc.DictionaryEntry(k, v);
                if (!b) {
                    this.count++;
                }
            };
            this.clear = function () {
                items = {};
                this.count = 0;
            };
            this.clone = function () {
                return new dxc.Dictionary(this);
            };
            this.contains = this.containsKey = function (k) {
                if (testObject[k]) {
                    return false;
                }
                return (items[k] != null);
            };
            this.containsValue = function (v) {
                var e = this.getIterator();
                while (e.get()) {
                    if (e.element.value == v) {
                        return true;
                    }
                }
                return false;
            };
            this.entry = function (k) {
                return items[k];
            };
            this.forEach = function (fn, scope) {
                var a = [];
                for (var p in items) {
                    if (!testObject[p]) {
                        a.push(items[p]);
                    }
                }
                dojo.forEach(a, fn, scope);
            };
            this.getKeyList = function () {
                return (this.getIterator()).map(function (entry) {
                    return entry.key;
                });
            };
            this.getValueList = function () {
                return (this.getIterator()).map(function (entry) {
                    return entry.value;
                });
            };
            this.item = function (k) {
                if (k in items) {
                    return items[k].valueOf();
                }
                return undefined;
            };
            this.getIterator = function () {
                return new dxc.DictionaryIterator(items);
            };
            this.remove = function (k) {
                if (k in items && !testObject[k]) {
                    delete items[k];
                    this.count--;
                    return true;
                }
                return false;
            };
            if (dictionary) {
                var e = dictionary.getIterator();
                while (e.get()) {
                    this.add(e.element.key, e.element.value);
                }
            }
        };
        return dxc.Dictionary;
    });
}, "dojo/_base/Color":function () {
    define(["./kernel", "./lang", "./array", "./config"], function (dojo, lang, ArrayUtil, config) {
        var Color = dojo.Color = function (color) {
            if (color) {
                this.setColor(color);
            }
        };
        Color.named = {"black":[0, 0, 0], "silver":[192, 192, 192], "gray":[128, 128, 128], "white":[255, 255, 255], "maroon":[128, 0, 0], "red":[255, 0, 0], "purple":[128, 0, 128], "fuchsia":[255, 0, 255], "green":[0, 128, 0], "lime":[0, 255, 0], "olive":[128, 128, 0], "yellow":[255, 255, 0], "navy":[0, 0, 128], "blue":[0, 0, 255], "teal":[0, 128, 128], "aqua":[0, 255, 255], "transparent":config.transparentColor || [0, 0, 0, 0]};
        lang.extend(Color, {r:255, g:255, b:255, a:1, _set:function (r, g, b, a) {
            var t = this;
            t.r = r;
            t.g = g;
            t.b = b;
            t.a = a;
        }, setColor:function (color) {
            if (lang.isString(color)) {
                Color.fromString(color, this);
            } else {
                if (lang.isArray(color)) {
                    Color.fromArray(color, this);
                } else {
                    this._set(color.r, color.g, color.b, color.a);
                    if (!(color instanceof Color)) {
                        this.sanitize();
                    }
                }
            }
            return this;
        }, sanitize:function () {
            return this;
        }, toRgb:function () {
            var t = this;
            return [t.r, t.g, t.b];
        }, toRgba:function () {
            var t = this;
            return [t.r, t.g, t.b, t.a];
        }, toHex:function () {
            var arr = ArrayUtil.map(["r", "g", "b"], function (x) {
                var s = this[x].toString(16);
                return s.length < 2 ? "0" + s : s;
            }, this);
            return "#" + arr.join("");
        }, toCss:function (includeAlpha) {
            var t = this, rgb = t.r + ", " + t.g + ", " + t.b;
            return (includeAlpha ? "rgba(" + rgb + ", " + t.a : "rgb(" + rgb) + ")";
        }, toString:function () {
            return this.toCss(true);
        }});
        Color.blendColors = dojo.blendColors = function (start, end, weight, obj) {
            var t = obj || new Color();
            ArrayUtil.forEach(["r", "g", "b", "a"], function (x) {
                t[x] = start[x] + (end[x] - start[x]) * weight;
                if (x != "a") {
                    t[x] = Math.round(t[x]);
                }
            });
            return t.sanitize();
        };
        Color.fromRgb = dojo.colorFromRgb = function (color, obj) {
            var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
            return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);
        };
        Color.fromHex = dojo.colorFromHex = function (color, obj) {
            var t = obj || new Color(), bits = (color.length == 4) ? 4 : 8, mask = (1 << bits) - 1;
            color = Number("0x" + color.substr(1));
            if (isNaN(color)) {
                return null;
            }
            ArrayUtil.forEach(["b", "g", "r"], function (x) {
                var c = color & mask;
                color >>= bits;
                t[x] = bits == 4 ? 17 * c : c;
            });
            t.a = 1;
            return t;
        };
        Color.fromArray = dojo.colorFromArray = function (a, obj) {
            var t = obj || new Color();
            t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
            if (isNaN(t.a)) {
                t.a = 1;
            }
            return t.sanitize();
        };
        Color.fromString = dojo.colorFromString = function (str, obj) {
            var a = Color.named[str];
            return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);
        };
        return Color;
    });
}, "dojo/fx":function () {
    define(["./_base/lang", "./Evented", "./_base/kernel", "./_base/array", "./aspect", "./_base/fx", "./dom", "./dom-style", "./dom-geometry", "./ready", "require"], function (lang, Evented, dojo, arrayUtil, aspect, baseFx, dom, domStyle, geom, ready, require) {
        if (!dojo.isAsync) {
            ready(0, function () {
                var requires = ["./fx/Toggler"];
                require(requires);
            });
        }
        var coreFx = dojo.fx = {};
        var _baseObj = {_fire:function (evt, args) {
            if (this[evt]) {
                this[evt].apply(this, args || []);
            }
            return this;
        }};
        var _chain = function (animations) {
            this._index = -1;
            this._animations = animations || [];
            this._current = this._onAnimateCtx = this._onEndCtx = null;
            this.duration = 0;
            arrayUtil.forEach(this._animations, function (a) {
                this.duration += a.duration;
                if (a.delay) {
                    this.duration += a.delay;
                }
            }, this);
        };
        _chain.prototype = new Evented();
        lang.extend(_chain, {_onAnimate:function () {
            this._fire("onAnimate", arguments);
        }, _onEnd:function () {
            this._onAnimateCtx.remove();
            this._onEndCtx.remove();
            this._onAnimateCtx = this._onEndCtx = null;
            if (this._index + 1 == this._animations.length) {
                this._fire("onEnd");
            } else {
                this._current = this._animations[++this._index];
                this._onAnimateCtx = aspect.after(this._current, "onAnimate", lang.hitch(this, "_onAnimate"), true);
                this._onEndCtx = aspect.after(this._current, "onEnd", lang.hitch(this, "_onEnd"), true);
                this._current.play(0, true);
            }
        }, play:function (delay, gotoStart) {
            if (!this._current) {
                this._current = this._animations[this._index = 0];
            }
            if (!gotoStart && this._current.status() == "playing") {
                return this;
            }
            var beforeBegin = aspect.after(this._current, "beforeBegin", lang.hitch(this, function () {
                this._fire("beforeBegin");
            }), true), onBegin = aspect.after(this._current, "onBegin", lang.hitch(this, function (arg) {
                this._fire("onBegin", arguments);
            }), true), onPlay = aspect.after(this._current, "onPlay", lang.hitch(this, function (arg) {
                this._fire("onPlay", arguments);
                beforeBegin.remove();
                onBegin.remove();
                onPlay.remove();
            }));
            if (this._onAnimateCtx) {
                this._onAnimateCtx.remove();
            }
            this._onAnimateCtx = aspect.after(this._current, "onAnimate", lang.hitch(this, "_onAnimate"), true);
            if (this._onEndCtx) {
                this._onEndCtx.remove();
            }
            this._onEndCtx = aspect.after(this._current, "onEnd", lang.hitch(this, "_onEnd"), true);
            this._current.play.apply(this._current, arguments);
            return this;
        }, pause:function () {
            if (this._current) {
                var e = aspect.after(this._current, "onPause", lang.hitch(this, function (arg) {
                    this._fire("onPause", arguments);
                    e.remove();
                }), true);
                this._current.pause();
            }
            return this;
        }, gotoPercent:function (percent, andPlay) {
            this.pause();
            var offset = this.duration * percent;
            this._current = null;
            arrayUtil.some(this._animations, function (a) {
                if (a.duration <= offset) {
                    this._current = a;
                    return true;
                }
                offset -= a.duration;
                return false;
            });
            if (this._current) {
                this._current.gotoPercent(offset / this._current.duration, andPlay);
            }
            return this;
        }, stop:function (gotoEnd) {
            if (this._current) {
                if (gotoEnd) {
                    for (; this._index + 1 < this._animations.length; ++this._index) {
                        this._animations[this._index].stop(true);
                    }
                    this._current = this._animations[this._index];
                }
                var e = aspect.after(this._current, "onStop", lang.hitch(this, function (arg) {
                    this._fire("onStop", arguments);
                    e.remove();
                }), true);
                this._current.stop();
            }
            return this;
        }, status:function () {
            return this._current ? this._current.status() : "stopped";
        }, destroy:function () {
            if (this._onAnimateCtx) {
                this._onAnimateCtx.remove();
            }
            if (this._onEndCtx) {
                this._onEndCtx.remove();
            }
        }});
        lang.extend(_chain, _baseObj);
        coreFx.chain = function (animations) {
            return new _chain(animations);
        };
        var _combine = function (animations) {
            this._animations = animations || [];
            this._connects = [];
            this._finished = 0;
            this.duration = 0;
            arrayUtil.forEach(animations, function (a) {
                var duration = a.duration;
                if (a.delay) {
                    duration += a.delay;
                }
                if (this.duration < duration) {
                    this.duration = duration;
                }
                this._connects.push(aspect.after(a, "onEnd", lang.hitch(this, "_onEnd"), true));
            }, this);
            this._pseudoAnimation = new baseFx.Animation({curve:[0, 1], duration:this.duration});
            var self = this;
            arrayUtil.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"], function (evt) {
                self._connects.push(aspect.after(self._pseudoAnimation, evt, function () {
                    self._fire(evt, arguments);
                }, true));
            });
        };
        lang.extend(_combine, {_doAction:function (action, args) {
            arrayUtil.forEach(this._animations, function (a) {
                a[action].apply(a, args);
            });
            return this;
        }, _onEnd:function () {
            if (++this._finished > this._animations.length) {
                this._fire("onEnd");
            }
        }, _call:function (action, args) {
            var t = this._pseudoAnimation;
            t[action].apply(t, args);
        }, play:function (delay, gotoStart) {
            this._finished = 0;
            this._doAction("play", arguments);
            this._call("play", arguments);
            return this;
        }, pause:function () {
            this._doAction("pause", arguments);
            this._call("pause", arguments);
            return this;
        }, gotoPercent:function (percent, andPlay) {
            var ms = this.duration * percent;
            arrayUtil.forEach(this._animations, function (a) {
                a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
            });
            this._call("gotoPercent", arguments);
            return this;
        }, stop:function (gotoEnd) {
            this._doAction("stop", arguments);
            this._call("stop", arguments);
            return this;
        }, status:function () {
            return this._pseudoAnimation.status();
        }, destroy:function () {
            arrayUtil.forEach(this._connects, function (handle) {
                handle.remove();
            });
        }});
        lang.extend(_combine, _baseObj);
        coreFx.combine = function (animations) {
            return new _combine(animations);
        };
        coreFx.wipeIn = function (args) {
            var node = args.node = dom.byId(args.node), s = node.style, o;
            var anim = baseFx.animateProperty(lang.mixin({properties:{height:{start:function () {
                o = s.overflow;
                s.overflow = "hidden";
                if (s.visibility == "hidden" || s.display == "none") {
                    s.height = "1px";
                    s.display = "";
                    s.visibility = "";
                    return 1;
                } else {
                    var height = domStyle.get(node, "height");
                    return Math.max(height, 1);
                }
            }, end:function () {
                return node.scrollHeight;
            }}}}, args));
            var fini = function () {
                s.height = "auto";
                s.overflow = o;
            };
            aspect.after(anim, "onStop", fini, true);
            aspect.after(anim, "onEnd", fini, true);
            return anim;
        };
        coreFx.wipeOut = function (args) {
            var node = args.node = dom.byId(args.node), s = node.style, o;
            var anim = baseFx.animateProperty(lang.mixin({properties:{height:{end:1}}}, args));
            aspect.after(anim, "beforeBegin", function () {
                o = s.overflow;
                s.overflow = "hidden";
                s.display = "";
            }, true);
            var fini = function () {
                s.overflow = o;
                s.height = "auto";
                s.display = "none";
            };
            aspect.after(anim, "onStop", fini, true);
            aspect.after(anim, "onEnd", fini, true);
            return anim;
        };
        coreFx.slideTo = function (args) {
            var node = args.node = dom.byId(args.node), top = null, left = null;
            var init = (function (n) {
                return function () {
                    var cs = domStyle.getComputedStyle(n);
                    var pos = cs.position;
                    top = (pos == "absolute" ? n.offsetTop : parseInt(cs.top) || 0);
                    left = (pos == "absolute" ? n.offsetLeft : parseInt(cs.left) || 0);
                    if (pos != "absolute" && pos != "relative") {
                        var ret = geom.position(n, true);
                        top = ret.y;
                        left = ret.x;
                        n.style.position = "absolute";
                        n.style.top = top + "px";
                        n.style.left = left + "px";
                    }
                };
            })(node);
            init();
            var anim = baseFx.animateProperty(lang.mixin({properties:{top:args.top || 0, left:args.left || 0}}, args));
            aspect.after(anim, "beforeBegin", init, true);
            return anim;
        };
        return coreFx;
    });
}, "dijit/_base/sniff":function () {
    define(["dojo/uacss"], function () {
    });
}, "dojo/Deferred":function () {
    define(["./has", "./_base/lang", "./errors/CancelError", "./promise/Promise", "./promise/instrumentation"], function (has, lang, CancelError, Promise, instrumentation) {
        "use strict";
        var PROGRESS = 0, RESOLVED = 1, REJECTED = 2;
        var FULFILLED_ERROR_MESSAGE = "This deferred has already been fulfilled.";
        var freezeObject = Object.freeze || function () {
        };
        var signalWaiting = function (waiting, type, result, rejection, deferred) {
            if (1) {
                if (type === REJECTED && Deferred.instrumentRejected && waiting.length === 0) {
                    Deferred.instrumentRejected(result, false, rejection, deferred);
                }
            }
            for (var i = 0; i < waiting.length; i++) {
                signalListener(waiting[i], type, result, rejection);
            }
        };
        var signalListener = function (listener, type, result, rejection) {
            var func = listener[type];
            var deferred = listener.deferred;
            if (func) {
                try {
                    var newResult = func(result);
                    if (type === PROGRESS) {
                        if (typeof newResult !== "undefined") {
                            signalDeferred(deferred, type, newResult);
                        }
                    } else {
                        if (newResult && typeof newResult.then === "function") {
                            listener.cancel = newResult.cancel;
                            newResult.then(makeDeferredSignaler(deferred, RESOLVED), makeDeferredSignaler(deferred, REJECTED), makeDeferredSignaler(deferred, PROGRESS));
                            return;
                        }
                        signalDeferred(deferred, RESOLVED, newResult);
                    }
                }
                catch (error) {
                    signalDeferred(deferred, REJECTED, error);
                }
            } else {
                signalDeferred(deferred, type, result);
            }
            if (1) {
                if (type === REJECTED && Deferred.instrumentRejected) {
                    Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
                }
            }
        };
        var makeDeferredSignaler = function (deferred, type) {
            return function (value) {
                signalDeferred(deferred, type, value);
            };
        };
        var signalDeferred = function (deferred, type, result) {
            if (!deferred.isCanceled()) {
                switch (type) {
                  case PROGRESS:
                    deferred.progress(result);
                    break;
                  case RESOLVED:
                    deferred.resolve(result);
                    break;
                  case REJECTED:
                    deferred.reject(result);
                    break;
                }
            }
        };
        var Deferred = function (canceler) {
            var promise = this.promise = new Promise();
            var deferred = this;
            var fulfilled, result, rejection;
            var canceled = false;
            var waiting = [];
            if (1 && Error.captureStackTrace) {
                Error.captureStackTrace(deferred, Deferred);
                Error.captureStackTrace(promise, Deferred);
            }
            this.isResolved = promise.isResolved = function () {
                return fulfilled === RESOLVED;
            };
            this.isRejected = promise.isRejected = function () {
                return fulfilled === REJECTED;
            };
            this.isFulfilled = promise.isFulfilled = function () {
                return !!fulfilled;
            };
            this.isCanceled = promise.isCanceled = function () {
                return canceled;
            };
            this.progress = function (update, strict) {
                if (!fulfilled) {
                    signalWaiting(waiting, PROGRESS, update, null, deferred);
                    return promise;
                } else {
                    if (strict === true) {
                        throw new Error(FULFILLED_ERROR_MESSAGE);
                    } else {
                        return promise;
                    }
                }
            };
            this.resolve = function (value, strict) {
                if (!fulfilled) {
                    signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
                    waiting = null;
                    return promise;
                } else {
                    if (strict === true) {
                        throw new Error(FULFILLED_ERROR_MESSAGE);
                    } else {
                        return promise;
                    }
                }
            };
            var reject = this.reject = function (error, strict) {
                if (!fulfilled) {
                    if (1 && Error.captureStackTrace) {
                        Error.captureStackTrace(rejection = {}, reject);
                    }
                    signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
                    waiting = null;
                    return promise;
                } else {
                    if (strict === true) {
                        throw new Error(FULFILLED_ERROR_MESSAGE);
                    } else {
                        return promise;
                    }
                }
            };
            this.then = promise.then = function (callback, errback, progback) {
                var listener = [progback, callback, errback];
                listener.cancel = promise.cancel;
                listener.deferred = new Deferred(function (reason) {
                    return listener.cancel && listener.cancel(reason);
                });
                if (fulfilled && !waiting) {
                    signalListener(listener, fulfilled, result, rejection);
                } else {
                    waiting.push(listener);
                }
                return listener.deferred.promise;
            };
            this.cancel = promise.cancel = function (reason, strict) {
                if (!fulfilled) {
                    if (canceler) {
                        var returnedReason = canceler(reason);
                        reason = typeof returnedReason === "undefined" ? reason : returnedReason;
                    }
                    canceled = true;
                    if (!fulfilled) {
                        if (typeof reason === "undefined") {
                            reason = new CancelError();
                        }
                        reject(reason);
                        return reason;
                    } else {
                        if (fulfilled === REJECTED && result === reason) {
                            return reason;
                        }
                    }
                } else {
                    if (strict === true) {
                        throw new Error(FULFILLED_ERROR_MESSAGE);
                    }
                }
            };
            freezeObject(promise);
        };
        Deferred.prototype.toString = function () {
            return "[object Deferred]";
        };
        if (instrumentation) {
            instrumentation(Deferred);
        }
        return Deferred;
    });
}, "dojo/data/util/sorter":function () {
    define(["../../_base/lang"], function (lang) {
        var sorter = {};
        lang.setObject("dojo.data.util.sorter", sorter);
        sorter.basicComparator = function (a, b) {
            var r = -1;
            if (a === null) {
                a = undefined;
            }
            if (b === null) {
                b = undefined;
            }
            if (a == b) {
                r = 0;
            } else {
                if (a > b || a == null) {
                    r = 1;
                }
            }
            return r;
        };
        sorter.createSortFunction = function (sortSpec, store) {
            var sortFunctions = [];
            function createSortFunction(attr, dir, comp, s) {
                return function (itemA, itemB) {
                    var a = s.getValue(itemA, attr);
                    var b = s.getValue(itemB, attr);
                    return dir * comp(a, b);
                };
            }
            var sortAttribute;
            var map = store.comparatorMap;
            var bc = sorter.basicComparator;
            for (var i = 0; i < sortSpec.length; i++) {
                sortAttribute = sortSpec[i];
                var attr = sortAttribute.attribute;
                if (attr) {
                    var dir = (sortAttribute.descending) ? -1 : 1;
                    var comp = bc;
                    if (map) {
                        if (typeof attr !== "string" && ("toString" in attr)) {
                            attr = attr.toString();
                        }
                        comp = map[attr] || bc;
                    }
                    sortFunctions.push(createSortFunction(attr, dir, comp, store));
                }
            }
            return function (rowA, rowB) {
                var i = 0;
                while (i < sortFunctions.length) {
                    var ret = sortFunctions[i++](rowA, rowB);
                    if (ret !== 0) {
                        return ret;
                    }
                }
                return 0;
            };
        };
        return sorter;
    });
}, "dojo/dom":function () {
    define(["./sniff", "./_base/window"], function (has, win) {
        if (has("ie") <= 7) {
            try {
                document.execCommand("BackgroundImageCache", false, true);
            }
            catch (e) {
            }
        }
        var dom = {};
        if (has("ie")) {
            dom.byId = function (id, doc) {
                if (typeof id != "string") {
                    return id;
                }
                var _d = doc || win.doc, te = id && _d.getElementById(id);
                if (te && (te.attributes.id.value == id || te.id == id)) {
                    return te;
                } else {
                    var eles = _d.all[id];
                    if (!eles || eles.nodeName) {
                        eles = [eles];
                    }
                    var i = 0;
                    while ((te = eles[i++])) {
                        if ((te.attributes && te.attributes.id && te.attributes.id.value == id) || te.id == id) {
                            return te;
                        }
                    }
                }
            };
        } else {
            dom.byId = function (id, doc) {
                return ((typeof id == "string") ? (doc || win.doc).getElementById(id) : id) || null;
            };
        }
        dom.isDescendant = function (node, ancestor) {
            try {
                node = dom.byId(node);
                ancestor = dom.byId(ancestor);
                while (node) {
                    if (node == ancestor) {
                        return true;
                    }
                    node = node.parentNode;
                }
            }
            catch (e) {
            }
            return false;
        };
        has.add("css-user-select", function (global, doc, element) {
            if (!element) {
                return false;
            }
            var style = element.style;
            var prefixes = ["Khtml", "O", "ms", "Moz", "Webkit"], i = prefixes.length, name = "userSelect", prefix;
            do {
                if (typeof style[name] !== "undefined") {
                    return name;
                }
            } while (i-- && (name = prefixes[i] + "UserSelect"));
            return false;
        });
        var cssUserSelect = has("css-user-select");
        dom.setSelectable = cssUserSelect ? function (node, selectable) {
            dom.byId(node).style[cssUserSelect] = selectable ? "" : "none";
        } : function (node, selectable) {
            node = dom.byId(node);
            var nodes = node.getElementsByTagName("*"), i = nodes.length;
            if (selectable) {
                node.removeAttribute("unselectable");
                while (i--) {
                    nodes[i].removeAttribute("unselectable");
                }
            } else {
                node.setAttribute("unselectable", "on");
                while (i--) {
                    nodes[i].setAttribute("unselectable", "on");
                }
            }
        };
        return dom;
    });
}, "dojo/window":function () {
    define(["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"], function (lang, has, baseWindow, dom, geom, style, domConstruct) {
        has.add("rtl-adjust-position-for-verticalScrollBar", function (win, doc) {
            var body = baseWindow.body(doc), scrollable = domConstruct.create("div", {style:{overflow:"scroll", overflowX:"visible", direction:"rtl", visibility:"hidden", position:"absolute", left:"0", top:"0", width:"64px", height:"64px"}}, body, "last"), div = domConstruct.create("div", {style:{overflow:"hidden", direction:"ltr"}}, scrollable, "last"), ret = geom.position(div).x != 0;
            scrollable.removeChild(div);
            body.removeChild(scrollable);
            return ret;
        });
        has.add("position-fixed-support", function (win, doc) {
            var body = baseWindow.body(doc), outer = domConstruct.create("span", {style:{visibility:"hidden", position:"fixed", left:"1px", top:"1px"}}, body, "last"), inner = domConstruct.create("span", {style:{position:"fixed", left:"0", top:"0"}}, outer, "last"), ret = geom.position(inner).x != geom.position(outer).x;
            outer.removeChild(inner);
            body.removeChild(outer);
            return ret;
        });
        var window = {getBox:function (doc) {
            doc = doc || baseWindow.doc;
            var scrollRoot = (doc.compatMode == "BackCompat") ? baseWindow.body(doc) : doc.documentElement, scroll = geom.docScroll(doc), w, h;
            if (has("touch")) {
                var uiWindow = window.get(doc);
                w = uiWindow.innerWidth || scrollRoot.clientWidth;
                h = uiWindow.innerHeight || scrollRoot.clientHeight;
            } else {
                w = scrollRoot.clientWidth;
                h = scrollRoot.clientHeight;
            }
            return {l:scroll.x, t:scroll.y, w:w, h:h};
        }, get:function (doc) {
            if (has("ie") && window !== document.parentWindow) {
                doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
                var win = doc._parentWindow;
                doc._parentWindow = null;
                return win;
            }
            return doc.parentWindow || doc.defaultView;
        }, scrollIntoView:function (node, pos) {
            try {
                node = dom.byId(node);
                var doc = node.ownerDocument || baseWindow.doc, body = baseWindow.body(doc), html = doc.documentElement || body.parentNode, isIE = has("ie"), isWK = has("webkit");
                if (node == body || node == html) {
                    return;
                }
                if (!(has("mozilla") || isIE || isWK || has("opera") || has("trident")) && ("scrollIntoView" in node)) {
                    node.scrollIntoView(false);
                    return;
                }
                var backCompat = doc.compatMode == "BackCompat", rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth), rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight), scrollRoot = (isWK || backCompat) ? body : html, nodePos = pos || geom.position(node), el = node.parentNode, isFixed = function (el) {
                    return (isIE <= 6 || (isIE == 7 && backCompat)) ? false : (has("position-fixed-support") && (style.get(el, "position").toLowerCase() == "fixed"));
                }, self = this, scrollElementBy = function (el, x, y) {
                    if (el.tagName == "BODY" || el.tagName == "HTML") {
                        self.get(el.ownerDocument).scrollBy(x, y);
                    } else {
                        x && (el.scrollLeft += x);
                        y && (el.scrollTop += y);
                    }
                };
                if (isFixed(node)) {
                    return;
                }
                while (el) {
                    if (el == body) {
                        el = scrollRoot;
                    }
                    var elPos = geom.position(el), fixedPos = isFixed(el), rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";
                    if (el == scrollRoot) {
                        elPos.w = rootWidth;
                        elPos.h = rootHeight;
                        if (scrollRoot == html && isIE && rtl) {
                            elPos.x += scrollRoot.offsetWidth - elPos.w;
                        }
                        if (elPos.x < 0 || !isIE || isIE >= 9) {
                            elPos.x = 0;
                        }
                        if (elPos.y < 0 || !isIE || isIE >= 9) {
                            elPos.y = 0;
                        }
                    } else {
                        var pb = geom.getPadBorderExtents(el);
                        elPos.w -= pb.w;
                        elPos.h -= pb.h;
                        elPos.x += pb.l;
                        elPos.y += pb.t;
                        var clientSize = el.clientWidth, scrollBarSize = elPos.w - clientSize;
                        if (clientSize > 0 && scrollBarSize > 0) {
                            if (rtl && has("rtl-adjust-position-for-verticalScrollBar")) {
                                elPos.x += scrollBarSize;
                            }
                            elPos.w = clientSize;
                        }
                        clientSize = el.clientHeight;
                        scrollBarSize = elPos.h - clientSize;
                        if (clientSize > 0 && scrollBarSize > 0) {
                            elPos.h = clientSize;
                        }
                    }
                    if (fixedPos) {
                        if (elPos.y < 0) {
                            elPos.h += elPos.y;
                            elPos.y = 0;
                        }
                        if (elPos.x < 0) {
                            elPos.w += elPos.x;
                            elPos.x = 0;
                        }
                        if (elPos.y + elPos.h > rootHeight) {
                            elPos.h = rootHeight - elPos.y;
                        }
                        if (elPos.x + elPos.w > rootWidth) {
                            elPos.w = rootWidth - elPos.x;
                        }
                    }
                    var l = nodePos.x - elPos.x, t = nodePos.y - elPos.y, r = l + nodePos.w - elPos.w, bot = t + nodePos.h - elPos.h;
                    var s, old;
                    if (r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)) {
                        s = Math[l < 0 ? "max" : "min"](l, r);
                        if (rtl && ((isIE == 8 && !backCompat) || isIE >= 9)) {
                            s = -s;
                        }
                        old = el.scrollLeft;
                        scrollElementBy(el, s, 0);
                        s = el.scrollLeft - old;
                        nodePos.x -= s;
                    }
                    if (bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)) {
                        s = Math.ceil(Math[t < 0 ? "max" : "min"](t, bot));
                        old = el.scrollTop;
                        scrollElementBy(el, 0, s);
                        s = el.scrollTop - old;
                        nodePos.y -= s;
                    }
                    el = (el != scrollRoot) && !fixedPos && el.parentNode;
                }
            }
            catch (error) {
                console.error("scrollIntoView: " + error);
                node.scrollIntoView(false);
            }
        }};
        1 && lang.setObject("dojo.window", window);
        return window;
    });
}, "dijit/_base/popup":function () {
    define(["dojo/dom-class", "dojo/_base/window", "../popup", "../BackgroundIframe"], function (domClass, win, popup) {
        var origCreateWrapper = popup._createWrapper;
        popup._createWrapper = function (widget) {
            if (!widget.declaredClass) {
                widget = {_popupWrapper:(widget.parentNode && domClass.contains(widget.parentNode, "dijitPopup")) ? widget.parentNode : null, domNode:widget, destroy:function () {
                }, ownerDocument:widget.ownerDocument, ownerDocumentBody:win.body(widget.ownerDocument)};
            }
            return origCreateWrapper.call(this, widget);
        };
        var origOpen = popup.open;
        popup.open = function (args) {
            if (args.orient && typeof args.orient != "string" && !("length" in args.orient)) {
                var ary = [];
                for (var key in args.orient) {
                    ary.push({aroundCorner:key, corner:args.orient[key]});
                }
                args.orient = ary;
            }
            return origOpen.call(this, args);
        };
        return popup;
    });
}, "dojo/store/DataStore":function () {
    define(["../_base/lang", "../_base/declare", "../Deferred", "../_base/array", "./util/QueryResults", "./util/SimpleQueryEngine"], function (lang, declare, Deferred, array, QueryResults, SimpleQueryEngine) {
        var base = null;
        return declare("dojo.store.DataStore", base, {target:"", constructor:function (options) {
            lang.mixin(this, options);
            if (!"idProperty" in options) {
                var idAttribute;
                try {
                    idAttribute = this.store.getIdentityAttributes();
                }
                catch (e) {
                }
                this.idProperty = (!idAttribute || !idAttributes[0]) || this.idProperty;
            }
            var features = this.store.getFeatures();
            if (!features["dojo.data.api.Read"]) {
                this.get = null;
            }
            if (!features["dojo.data.api.Identity"]) {
                this.getIdentity = null;
            }
            if (!features["dojo.data.api.Write"]) {
                this.put = this.add = null;
            }
        }, idProperty:"id", store:null, queryEngine:SimpleQueryEngine, _objectConverter:function (callback) {
            var store = this.store;
            var idProperty = this.idProperty;
            function convert(item) {
                var object = {};
                var attributes = store.getAttributes(item);
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    var values = store.getValues(item, attribute);
                    if (values.length > 1) {
                        for (var j = 0; j < values.length; j++) {
                            var value = values[j];
                            if (typeof value == "object" && store.isItem(value)) {
                                values[j] = convert(value);
                            }
                        }
                        value = values;
                    } else {
                        var value = store.getValue(item, attribute);
                        if (typeof value == "object" && store.isItem(value)) {
                            value = convert(value);
                        }
                    }
                    object[attributes[i]] = value;
                }
                if (!(idProperty in object) && store.getIdentity) {
                    object[idProperty] = store.getIdentity(item);
                }
                return object;
            }
            return function (item) {
                return callback(convert(item));
            };
        }, get:function (id, options) {
            var returnedObject, returnedError;
            var deferred = new Deferred();
            this.store.fetchItemByIdentity({identity:id, onItem:this._objectConverter(function (object) {
                deferred.resolve(returnedObject = object);
            }), onError:function (error) {
                deferred.reject(returnedError = error);
            }});
            if (returnedObject) {
                return returnedObject;
            }
            if (returnedError) {
                throw returnedError;
            }
            return deferred.promise;
        }, put:function (object, options) {
            var id = options && typeof options.id != "undefined" || this.getIdentity(object);
            var store = this.store;
            var idProperty = this.idProperty;
            if (typeof id == "undefined") {
                store.newItem(object);
                store.save();
            } else {
                store.fetchItemByIdentity({identity:id, onItem:function (item) {
                    if (item) {
                        for (var i in object) {
                            if (i != idProperty && store.getValue(item, i) != object[i]) {
                                store.setValue(item, i, object[i]);
                            }
                        }
                    } else {
                        store.newItem(object);
                    }
                    store.save();
                }});
            }
        }, remove:function (id) {
            var store = this.store;
            this.store.fetchItemByIdentity({identity:id, onItem:function (item) {
                store.deleteItem(item);
                store.save();
            }});
        }, query:function (query, options) {
            var fetchHandle;
            var deferred = new Deferred(function () {
                fetchHandle.abort && fetchHandle.abort();
            });
            deferred.total = new Deferred();
            var converter = this._objectConverter(function (object) {
                return object;
            });
            fetchHandle = this.store.fetch(lang.mixin({query:query, onBegin:function (count) {
                deferred.total.resolve(count);
            }, onComplete:function (results) {
                deferred.resolve(array.map(results, converter));
            }, onError:function (error) {
                deferred.reject(error);
            }}, options));
            return QueryResults(deferred);
        }, getIdentity:function (object) {
            return object[this.idProperty];
        }});
    });
}, "dojo/_base/lang":function () {
    define(["./kernel", "../has", "../sniff"], function (dojo, has) {
        has.add("bug-for-in-skips-shadowed", function () {
            for (var i in {toString:1}) {
                return 0;
            }
            return 1;
        });
        var _extraNames = has("bug-for-in-skips-shadowed") ? "hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor".split(".") : [], _extraLen = _extraNames.length, getProp = function (parts, create, context) {
            var p, i = 0, dojoGlobal = dojo.global;
            if (!context) {
                if (!parts.length) {
                    return dojoGlobal;
                } else {
                    p = parts[i++];
                    try {
                        context = dojo.scopeMap[p] && dojo.scopeMap[p][1];
                    }
                    catch (e) {
                    }
                    context = context || (p in dojoGlobal ? dojoGlobal[p] : (create ? dojoGlobal[p] = {} : undefined));
                }
            }
            while (context && (p = parts[i++])) {
                context = (p in context ? context[p] : (create ? context[p] = {} : undefined));
            }
            return context;
        }, opts = Object.prototype.toString, efficient = function (obj, offset, startWith) {
            return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
        }, _pattern = /\{([^\}]+)\}/g;
        var lang = {_extraNames:_extraNames, _mixin:function (dest, source, copyFunc) {
            var name, s, i, empty = {};
            for (name in source) {
                s = source[name];
                if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                    dest[name] = copyFunc ? copyFunc(s) : s;
                }
            }
            if (has("bug-for-in-skips-shadowed")) {
                if (source) {
                    for (i = 0; i < _extraLen; ++i) {
                        name = _extraNames[i];
                        s = source[name];
                        if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                            dest[name] = copyFunc ? copyFunc(s) : s;
                        }
                    }
                }
            }
            return dest;
        }, mixin:function (dest, sources) {
            if (!dest) {
                dest = {};
            }
            for (var i = 1, l = arguments.length; i < l; i++) {
                lang._mixin(dest, arguments[i]);
            }
            return dest;
        }, setObject:function (name, value, context) {
            var parts = name.split("."), p = parts.pop(), obj = getProp(parts, true, context);
            return obj && p ? (obj[p] = value) : undefined;
        }, getObject:function (name, create, context) {
            return getProp(name.split("."), create, context);
        }, exists:function (name, obj) {
            return lang.getObject(name, false, obj) !== undefined;
        }, isString:function (it) {
            return (typeof it == "string" || it instanceof String);
        }, isArray:function (it) {
            return it && (it instanceof Array || typeof it == "array");
        }, isFunction:function (it) {
            return opts.call(it) === "[object Function]";
        }, isObject:function (it) {
            return it !== undefined && (it === null || typeof it == "object" || lang.isArray(it) || lang.isFunction(it));
        }, isArrayLike:function (it) {
            return it && it !== undefined && !lang.isString(it) && !lang.isFunction(it) && !(it.tagName && it.tagName.toLowerCase() == "form") && (lang.isArray(it) || isFinite(it.length));
        }, isAlien:function (it) {
            return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it));
        }, extend:function (ctor, props) {
            for (var i = 1, l = arguments.length; i < l; i++) {
                lang._mixin(ctor.prototype, arguments[i]);
            }
            return ctor;
        }, _hitchArgs:function (scope, method) {
            var pre = lang._toArray(arguments, 2);
            var named = lang.isString(method);
            return function () {
                var args = lang._toArray(arguments);
                var f = named ? (scope || dojo.global)[method] : method;
                return f && f.apply(scope || this, pre.concat(args));
            };
        }, hitch:function (scope, method) {
            if (arguments.length > 2) {
                return lang._hitchArgs.apply(dojo, arguments);
            }
            if (!method) {
                method = scope;
                scope = null;
            }
            if (lang.isString(method)) {
                scope = scope || dojo.global;
                if (!scope[method]) {
                    throw (["lang.hitch: scope[\"", method, "\"] is null (scope=\"", scope, "\")"].join(""));
                }
                return function () {
                    return scope[method].apply(scope, arguments || []);
                };
            }
            return !scope ? method : function () {
                return method.apply(scope, arguments || []);
            };
        }, delegate:(function () {
            function TMP() {
            }
            return function (obj, props) {
                TMP.prototype = obj;
                var tmp = new TMP();
                TMP.prototype = null;
                if (props) {
                    lang._mixin(tmp, props);
                }
                return tmp;
            };
        })(), _toArray:has("ie") ? (function () {
            function slow(obj, offset, startWith) {
                var arr = startWith || [];
                for (var x = offset || 0; x < obj.length; x++) {
                    arr.push(obj[x]);
                }
                return arr;
            }
            return function (obj) {
                return ((obj.item) ? slow : efficient).apply(this, arguments);
            };
        })() : efficient, partial:function (method) {
            var arr = [null];
            return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments)));
        }, clone:function (src) {
            if (!src || typeof src != "object" || lang.isFunction(src)) {
                return src;
            }
            if (src.nodeType && "cloneNode" in src) {
                return src.cloneNode(true);
            }
            if (src instanceof Date) {
                return new Date(src.getTime());
            }
            if (src instanceof RegExp) {
                return new RegExp(src);
            }
            var r, i, l;
            if (lang.isArray(src)) {
                r = [];
                for (i = 0, l = src.length; i < l; ++i) {
                    if (i in src) {
                        r.push(lang.clone(src[i]));
                    }
                }
            } else {
                r = src.constructor ? new src.constructor() : {};
            }
            return lang._mixin(r, src, lang.clone);
        }, trim:String.prototype.trim ? function (str) {
            return str.trim();
        } : function (str) {
            return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        }, replace:function (tmpl, map, pattern) {
            return tmpl.replace(pattern || _pattern, lang.isFunction(map) ? map : function (_, k) {
                return lang.getObject(k, false, map);
            });
        }};
        1 && lang.mixin(dojo, lang);
        return lang;
    });
}, "dojox/grid/enhanced/_FocusManager":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/event", "dojo/_base/sniff", "dojo/_base/html", "dojo/keys", "dijit/a11y", "dijit/focus", "../_FocusManager"], function (dojo, lang, declare, array, connect, event, has, html, keys, dijitA11y, dijitFocus, _FocusManager) {
        var _FocusArea = declare("dojox.grid.enhanced._FocusArea", null, {constructor:function (area, focusManager) {
            this._fm = focusManager;
            this._evtStack = [area.name];
            var dummy = function () {
                return true;
            };
            area.onFocus = area.onFocus || dummy;
            area.onBlur = area.onBlur || dummy;
            area.onMove = area.onMove || dummy;
            area.onKeyUp = area.onKeyUp || dummy;
            area.onKeyDown = area.onKeyDown || dummy;
            lang.mixin(this, area);
        }, move:function (rowStep, colStep, evt) {
            if (this.name) {
                var i, len = this._evtStack.length;
                for (i = len - 1; i >= 0; --i) {
                    if (this._fm._areas[this._evtStack[i]].onMove(rowStep, colStep, evt) === false) {
                        return false;
                    }
                }
            }
            return true;
        }, _onKeyEvent:function (evt, funcName) {
            if (this.name) {
                var i, len = this._evtStack.length;
                for (i = len - 1; i >= 0; --i) {
                    if (this._fm._areas[this._evtStack[i]][funcName](evt, false) === false) {
                        return false;
                    }
                }
                for (i = 0; i < len; ++i) {
                    if (this._fm._areas[this._evtStack[i]][funcName](evt, true) === false) {
                        return false;
                    }
                }
            }
            return true;
        }, keydown:function (evt) {
            return this._onKeyEvent(evt, "onKeyDown");
        }, keyup:function (evt) {
            return this._onKeyEvent(evt, "onKeyUp");
        }, contentMouseEventPlanner:function () {
            return 0;
        }, headerMouseEventPlanner:function () {
            return 0;
        }});
        return declare("dojox.grid.enhanced._FocusManager", _FocusManager, {_stopEvent:function (evt) {
            try {
                if (evt && evt.preventDefault) {
                    event.stop(evt);
                }
            }
            catch (e) {
            }
        }, constructor:function (grid) {
            this.grid = grid;
            this._areas = {};
            this._areaQueue = [];
            this._contentMouseEventHandlers = [];
            this._headerMouseEventHandlers = [];
            this._currentAreaIdx = -1;
            this._gridBlured = true;
            this._connects.push(connect.connect(grid, "onBlur", this, "_doBlur"));
            this._connects.push(connect.connect(grid.scroller, "renderPage", this, "_delayedCellFocus"));
            this.addArea({name:"header", onFocus:lang.hitch(this, this.focusHeader), onBlur:lang.hitch(this, this._blurHeader), onMove:lang.hitch(this, this._navHeader), getRegions:lang.hitch(this, this._findHeaderCells), onRegionFocus:lang.hitch(this, this.doColHeaderFocus), onRegionBlur:lang.hitch(this, this.doColHeaderBlur), onKeyDown:lang.hitch(this, this._onHeaderKeyDown)});
            this.addArea({name:"content", onFocus:lang.hitch(this, this._focusContent), onBlur:lang.hitch(this, this._blurContent), onMove:lang.hitch(this, this._navContent), onKeyDown:lang.hitch(this, this._onContentKeyDown)});
            this.addArea({name:"editableCell", onFocus:lang.hitch(this, this._focusEditableCell), onBlur:lang.hitch(this, this._blurEditableCell), onKeyDown:lang.hitch(this, this._onEditableCellKeyDown), onContentMouseEvent:lang.hitch(this, this._onEditableCellMouseEvent), contentMouseEventPlanner:function (evt, areas) {
                return -1;
            }});
            this.placeArea("header");
            this.placeArea("content");
            this.placeArea("editableCell");
            this.placeArea("editableCell", "above", "content");
        }, destroy:function () {
            for (var name in this._areas) {
                var area = this._areas[name];
                array.forEach(area._connects, connect.disconnect);
                area._connects = null;
                if (area.uninitialize) {
                    area.uninitialize();
                }
            }
            this.inherited(arguments);
        }, addArea:function (area) {
            if (area.name && lang.isString(area.name)) {
                if (this._areas[area.name]) {
                    array.forEach(area._connects, connect.disconnect);
                }
                this._areas[area.name] = new _FocusArea(area, this);
                if (area.onHeaderMouseEvent) {
                    this._headerMouseEventHandlers.push(area.name);
                }
                if (area.onContentMouseEvent) {
                    this._contentMouseEventHandlers.push(area.name);
                }
            }
        }, getArea:function (areaName) {
            return this._areas[areaName];
        }, _bindAreaEvents:function () {
            var area, hdl, areas = this._areas;
            array.forEach(this._areaQueue, function (name) {
                area = areas[name];
                if (!area._initialized && lang.isFunction(area.initialize)) {
                    area.initialize();
                    area._initialized = true;
                }
                if (area.getRegions) {
                    area._regions = area.getRegions() || [];
                    array.forEach(area._connects || [], connect.disconnect);
                    area._connects = [];
                    array.forEach(area._regions, function (r) {
                        if (area.onRegionFocus) {
                            hdl = connect.connect(r, "onfocus", area.onRegionFocus);
                            area._connects.push(hdl);
                        }
                        if (area.onRegionBlur) {
                            hdl = connect.connect(r, "onblur", area.onRegionBlur);
                            area._connects.push(hdl);
                        }
                    });
                }
            });
        }, removeArea:function (areaName) {
            var area = this._areas[areaName];
            if (area) {
                this.ignoreArea(areaName);
                var i = array.indexOf(this._contentMouseEventHandlers, areaName);
                if (i >= 0) {
                    this._contentMouseEventHandlers.splice(i, 1);
                }
                i = array.indexOf(this._headerMouseEventHandlers, areaName);
                if (i >= 0) {
                    this._headerMouseEventHandlers.splice(i, 1);
                }
                array.forEach(area._connects, connect.disconnect);
                if (area.uninitialize) {
                    area.uninitialize();
                }
                delete this._areas[areaName];
            }
        }, currentArea:function (areaName, toBlurOld) {
            var idx, cai = this._currentAreaIdx;
            if (lang.isString(areaName) && (idx = array.indexOf(this._areaQueue, areaName)) >= 0) {
                if (cai != idx) {
                    this.tabbingOut = false;
                    if (toBlurOld && cai >= 0 && cai < this._areaQueue.length) {
                        this._areas[this._areaQueue[cai]].onBlur();
                    }
                    this._currentAreaIdx = idx;
                }
            } else {
                return (cai < 0 || cai >= this._areaQueue.length) ? new _FocusArea({}, this) : this._areas[this._areaQueue[this._currentAreaIdx]];
            }
            return null;
        }, placeArea:function (name, pos, otherAreaName) {
            if (!this._areas[name]) {
                return;
            }
            var idx = array.indexOf(this._areaQueue, otherAreaName);
            switch (pos) {
              case "after":
                if (idx >= 0) {
                    ++idx;
                }
              case "before":
                if (idx >= 0) {
                    this._areaQueue.splice(idx, 0, name);
                    break;
                }
              default:
                this._areaQueue.push(name);
                break;
              case "above":
                var isAbove = true;
              case "below":
                var otherArea = this._areas[otherAreaName];
                if (otherArea) {
                    if (isAbove) {
                        otherArea._evtStack.push(name);
                    } else {
                        otherArea._evtStack.splice(0, 0, name);
                    }
                }
            }
        }, ignoreArea:function (name) {
            this._areaQueue = array.filter(this._areaQueue, function (areaName) {
                return areaName != name;
            });
        }, focusArea:function (areaId, evt) {
            var idx;
            if (typeof areaId == "number") {
                idx = areaId < 0 ? this._areaQueue.length + areaId : areaId;
            } else {
                idx = array.indexOf(this._areaQueue, lang.isString(areaId) ? areaId : (areaId && areaId.name));
            }
            if (idx < 0) {
                idx = 0;
            }
            var step = idx - this._currentAreaIdx;
            this._gridBlured = false;
            if (step) {
                this.tab(step, evt);
            } else {
                this.currentArea().onFocus(evt, step);
            }
        }, tab:function (step, evt) {
            this._gridBlured = false;
            this.tabbingOut = false;
            if (step === 0) {
                return;
            }
            var cai = this._currentAreaIdx;
            var dir = step > 0 ? 1 : -1;
            if (cai < 0 || cai >= this._areaQueue.length) {
                cai = (this._currentAreaIdx += step);
            } else {
                var nextArea = this._areas[this._areaQueue[cai]].onBlur(evt, step);
                if (nextArea === true) {
                    cai = (this._currentAreaIdx += step);
                } else {
                    if (lang.isString(nextArea) && this._areas[nextArea]) {
                        cai = this._currentAreaIdx = array.indexOf(this._areaQueue, nextArea);
                    }
                }
            }
            for (; cai >= 0 && cai < this._areaQueue.length; cai += dir) {
                this._currentAreaIdx = cai;
                if (this._areaQueue[cai] && this._areas[this._areaQueue[cai]].onFocus(evt, step)) {
                    return;
                }
            }
            this.tabbingOut = true;
            if (step < 0) {
                this._currentAreaIdx = -1;
                dijitFocus.focus(this.grid.domNode);
            } else {
                this._currentAreaIdx = this._areaQueue.length;
                dijitFocus.focus(this.grid.lastFocusNode);
            }
        }, _onMouseEvent:function (type, evt) {
            var lowercase = type.toLowerCase(), handlers = this["_" + lowercase + "MouseEventHandlers"], res = array.map(handlers, function (areaName) {
                return {"area":areaName, "idx":this._areas[areaName][lowercase + "MouseEventPlanner"](evt, handlers)};
            }, this).sort(function (a, b) {
                return b.idx - a.idx;
            }), resHandlers = array.map(res, function (handler) {
                return res.area;
            }), i = res.length;
            while (--i >= 0) {
                if (this._areas[res[i].area]["on" + type + "MouseEvent"](evt, resHandlers) === false) {
                    return;
                }
            }
        }, contentMouseEvent:function (evt) {
            this._onMouseEvent("Content", evt);
        }, headerMouseEvent:function (evt) {
            this._onMouseEvent("Header", evt);
        }, initFocusView:function () {
            this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
            this._bindAreaEvents();
        }, isNavHeader:function () {
            return this._areaQueue[this._currentAreaIdx] == "header";
        }, previousKey:function (e) {
            this.tab(-1, e);
        }, nextKey:function (e) {
            this.tab(1, e);
        }, setFocusCell:function (inCell, inRowIndex) {
            if (inCell) {
                this.currentArea(this.grid.edit.isEditing() ? "editableCell" : "content", true);
                this._focusifyCellNode(false);
                this.cell = inCell;
                this.rowIndex = inRowIndex;
                this._focusifyCellNode(true);
            }
            this.grid.onCellFocus(this.cell, this.rowIndex);
        }, doFocus:function (e) {
            if (e && e.target == e.currentTarget && !this.tabbingOut) {
                if (this._gridBlured) {
                    this._gridBlured = false;
                    if (this._currentAreaIdx < 0 || this._currentAreaIdx >= this._areaQueue.length) {
                        this.focusArea(0, e);
                    } else {
                        this.focusArea(this._currentAreaIdx, e);
                    }
                }
            } else {
                this.tabbingOut = false;
            }
            event.stop(e);
        }, _doBlur:function () {
            this._gridBlured = true;
        }, doLastNodeFocus:function (e) {
            if (this.tabbingOut) {
                this.tabbingOut = false;
            } else {
                this.focusArea(-1, e);
            }
        }, _delayedHeaderFocus:function () {
            if (this.isNavHeader() && !has("ie")) {
                this.focusHeader();
            }
        }, _delayedCellFocus:function () {
        }, _changeMenuBindNode:function (oldBindNode, newBindNode) {
            var hm = this.grid.headerMenu;
            if (hm && this._contextMenuBindNode == oldBindNode) {
                hm.unBindDomNode(oldBindNode);
                hm.bindDomNode(newBindNode);
                this._contextMenuBindNode = newBindNode;
            }
        }, focusHeader:function (evt, step) {
            var didFocus = false;
            this.inherited(arguments);
            if (this._colHeadNode && html.style(this._colHeadNode, "display") != "none") {
                dijitFocus.focus(this._colHeadNode);
                this._stopEvent(evt);
                didFocus = true;
            }
            return didFocus;
        }, _blurHeader:function (evt, step) {
            if (this._colHeadNode) {
                html.removeClass(this._colHeadNode, this.focusClass);
            }
            html.removeAttr(this.grid.domNode, "aria-activedescendant");
            this._changeMenuBindNode(this.grid.domNode, this.grid.viewsHeaderNode);
            this._colHeadNode = this._colHeadFocusIdx = null;
            return true;
        }, _navHeader:function (rowStep, colStep, evt) {
            var colDir = colStep < 0 ? -1 : 1, savedIdx = array.indexOf(this._findHeaderCells(), this._colHeadNode);
            if (savedIdx >= 0 && (evt.shiftKey && evt.ctrlKey)) {
                this.colSizeAdjust(evt, savedIdx, colDir * 5);
                return;
            }
            this.move(rowStep, colStep);
        }, _onHeaderKeyDown:function (e, isBubble) {
            if (isBubble) {
                var dk = keys;
                switch (e.keyCode) {
                  case dk.ENTER:
                  case dk.SPACE:
                    var colIdx = this.getHeaderIndex();
                    if (colIdx >= 0 && !this.grid.pluginMgr.isFixedCell(e.cell)) {
                        this.grid.setSortIndex(colIdx, null, e);
                        event.stop(e);
                    }
                    break;
                }
            }
            return true;
        }, _setActiveColHeader:function () {
            this.inherited(arguments);
            dijitFocus.focus(this._colHeadNode);
        }, findAndFocusGridCell:function () {
            this._focusContent();
        }, _focusContent:function (evt, step) {
            var didFocus = true;
            var isEmpty = (this.grid.rowCount === 0);
            if (this.isNoFocusCell() && !isEmpty) {
                for (var i = 0, cell = this.grid.getCell(0); cell && cell.hidden; cell = this.grid.getCell(++i)) {
                }
                this.setFocusIndex(0, cell ? i : 0);
            } else {
                if (this.cell && !isEmpty) {
                    if (this.focusView && !this.focusView.rowNodes[this.rowIndex]) {
                        this.grid.scrollToRow(this.rowIndex);
                        this.focusGrid();
                    } else {
                        this.setFocusIndex(this.rowIndex, this.cell.index);
                    }
                } else {
                    didFocus = false;
                }
            }
            if (didFocus) {
                this._stopEvent(evt);
            }
            return didFocus;
        }, _blurContent:function (evt, step) {
            this._focusifyCellNode(false);
            return true;
        }, _navContent:function (rowStep, colStep, evt) {
            if ((this.rowIndex === 0 && rowStep < 0) || (this.rowIndex === this.grid.rowCount - 1 && rowStep > 0)) {
                return;
            }
            this._colHeadNode = null;
            this.move(rowStep, colStep, evt);
            if (evt) {
                event.stop(evt);
            }
        }, _onContentKeyDown:function (e, isBubble) {
            if (isBubble) {
                var dk = keys, s = this.grid.scroller;
                switch (e.keyCode) {
                  case dk.ENTER:
                  case dk.SPACE:
                    var g = this.grid;
                    if (g.indirectSelection) {
                        break;
                    }
                    g.selection.clickSelect(this.rowIndex, connect.isCopyKey(e), e.shiftKey);
                    g.onRowClick(e);
                    event.stop(e);
                    break;
                  case dk.PAGE_UP:
                    if (this.rowIndex !== 0) {
                        if (this.rowIndex != s.firstVisibleRow + 1) {
                            this._navContent(s.firstVisibleRow - this.rowIndex, 0);
                        } else {
                            this.grid.setScrollTop(s.findScrollTop(this.rowIndex - 1));
                            this._navContent(s.firstVisibleRow - s.lastVisibleRow + 1, 0);
                        }
                        event.stop(e);
                    }
                    break;
                  case dk.PAGE_DOWN:
                    if (this.rowIndex + 1 != this.grid.rowCount) {
                        event.stop(e);
                        if (this.rowIndex != s.lastVisibleRow - 1) {
                            this._navContent(s.lastVisibleRow - this.rowIndex - 1, 0);
                        } else {
                            this.grid.setScrollTop(s.findScrollTop(this.rowIndex + 1));
                            this._navContent(s.lastVisibleRow - s.firstVisibleRow - 1, 0);
                        }
                        event.stop(e);
                    }
                    break;
                }
            }
            return true;
        }, _blurFromEditableCell:false, _isNavigating:false, _navElems:null, _focusEditableCell:function (evt, step) {
            var didFocus = false;
            if (this._isNavigating) {
                didFocus = true;
            } else {
                if (this.grid.edit.isEditing() && this.cell) {
                    if (this._blurFromEditableCell || !this._blurEditableCell(evt, step)) {
                        this.setFocusIndex(this.rowIndex, this.cell.index);
                        didFocus = true;
                    }
                    this._stopEvent(evt);
                }
            }
            return didFocus;
        }, _applyEditableCell:function () {
            try {
                this.grid.edit.apply();
            }
            catch (e) {
                console.warn("_FocusManager._applyEditableCell() error:", e);
            }
        }, _blurEditableCell:function (evt, step) {
            this._blurFromEditableCell = false;
            if (this._isNavigating) {
                var toBlur = true;
                if (evt) {
                    var elems = this._navElems;
                    var firstElem = elems.lowest || elems.first;
                    var lastElem = elems.last || elems.highest || firstElem;
                    var target = has("ie") ? evt.srcElement : evt.target;
                    toBlur = target == (step > 0 ? lastElem : firstElem);
                }
                if (toBlur) {
                    this._isNavigating = false;
                    html.setSelectable(this.cell.getNode(this.rowIndex), false);
                    return "content";
                }
                return false;
            } else {
                if (this.grid.edit.isEditing() && this.cell) {
                    if (!step || typeof step != "number") {
                        return false;
                    }
                    var dir = step > 0 ? 1 : -1;
                    var cc = this.grid.layout.cellCount;
                    for (var cell, col = this.cell.index + dir; col >= 0 && col < cc; col += dir) {
                        cell = this.grid.getCell(col);
                        if (cell.editable) {
                            this.cell = cell;
                            this._blurFromEditableCell = true;
                            return false;
                        }
                    }
                    if ((this.rowIndex > 0 || dir == 1) && (this.rowIndex < this.grid.rowCount || dir == -1)) {
                        this.rowIndex += dir;
                        for (col = dir > 0 ? 0 : cc - 1; col >= 0 && col < cc; col += dir) {
                            cell = this.grid.getCell(col);
                            if (cell.editable) {
                                this.cell = cell;
                                break;
                            }
                        }
                        this._applyEditableCell();
                        return "content";
                    }
                }
            }
            return true;
        }, _initNavigatableElems:function () {
            this._navElems = dijitA11y._getTabNavigable(this.cell.getNode(this.rowIndex));
        }, _onEditableCellKeyDown:function (e, isBubble) {
            var dk = keys, g = this.grid, edit = g.edit, editApplied = false, toPropagate = true;
            switch (e.keyCode) {
              case dk.ENTER:
                if (isBubble && edit.isEditing()) {
                    this._applyEditableCell();
                    editApplied = true;
                    event.stop(e);
                }
              case dk.SPACE:
                if (!isBubble && this._isNavigating) {
                    toPropagate = false;
                    break;
                }
                if (isBubble) {
                    if (!this.cell.editable && this.cell.navigatable) {
                        this._initNavigatableElems();
                        var toFocus = this._navElems.lowest || this._navElems.first;
                        if (toFocus) {
                            this._isNavigating = true;
                            html.setSelectable(this.cell.getNode(this.rowIndex), true);
                            dijitFocus.focus(toFocus);
                            event.stop(e);
                            this.currentArea("editableCell", true);
                            break;
                        }
                    }
                    if (!editApplied && !edit.isEditing() && !g.pluginMgr.isFixedCell(this.cell)) {
                        edit.setEditCell(this.cell, this.rowIndex);
                    }
                    if (editApplied) {
                        this.currentArea("content", true);
                    } else {
                        if (this.cell.editable && g.canEdit()) {
                            this.currentArea("editableCell", true);
                        }
                    }
                }
                break;
              case dk.PAGE_UP:
              case dk.PAGE_DOWN:
                if (!isBubble && edit.isEditing()) {
                    toPropagate = false;
                }
                break;
              case dk.ESCAPE:
                if (!isBubble) {
                    edit.cancel();
                    this.currentArea("content", true);
                }
            }
            return toPropagate;
        }, _onEditableCellMouseEvent:function (evt) {
            if (evt.type == "click") {
                var cell = this.cell || evt.cell;
                if (cell && !cell.editable && cell.navigatable) {
                    this._initNavigatableElems();
                    if (this._navElems.lowest || this._navElems.first) {
                        var target = has("ie") ? evt.srcElement : evt.target;
                        if (target != cell.getNode(evt.rowIndex)) {
                            this._isNavigating = true;
                            this.focusArea("editableCell", evt);
                            html.setSelectable(cell.getNode(evt.rowIndex), true);
                            dijitFocus.focus(target);
                            return false;
                        }
                    }
                } else {
                    if (this.grid.singleClickEdit) {
                        this.currentArea("editableCell");
                        return false;
                    }
                }
            }
            return true;
        }});
    });
}, "dojo/sniff":function () {
    define(["./has"], function (has) {
        if (1) {
            var n = navigator, dua = n.userAgent, dav = n.appVersion, tv = parseFloat(dav);
            has.add("air", dua.indexOf("AdobeAIR") >= 0);
            has.add("msapp", parseFloat(dua.split("MSAppHost/")[1]) || undefined);
            has.add("khtml", dav.indexOf("Konqueror") >= 0 ? tv : undefined);
            has.add("webkit", parseFloat(dua.split("WebKit/")[1]) || undefined);
            has.add("chrome", parseFloat(dua.split("Chrome/")[1]) || undefined);
            has.add("safari", dav.indexOf("Safari") >= 0 && !has("chrome") ? parseFloat(dav.split("Version/")[1]) : undefined);
            has.add("mac", dav.indexOf("Macintosh") >= 0);
            has.add("quirks", document.compatMode == "BackCompat");
            if (dua.match(/(iPhone|iPod|iPad)/)) {
                var p = RegExp.$1.replace(/P/, "p");
                var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : "1";
                var os = parseFloat(v.replace(/_/, ".").replace(/_/g, ""));
                has.add(p, os);
                has.add("ios", os);
            }
            has.add("android", parseFloat(dua.split("Android ")[1]) || undefined);
            has.add("bb", (dua.indexOf("BlackBerry") >= 0 || dua.indexOf("BB10") >= 0) && parseFloat(dua.split("Version/")[1]) || undefined);
            has.add("trident", parseFloat(dav.split("Trident/")[1]) || undefined);
            has.add("svg", typeof SVGAngle !== "undefined");
            if (!has("webkit")) {
                if (dua.indexOf("Opera") >= 0) {
                    has.add("opera", tv >= 9.8 ? parseFloat(dua.split("Version/")[1]) || tv : tv);
                }
                if (dua.indexOf("Gecko") >= 0 && !has("khtml") && !has("webkit") && !has("trident")) {
                    has.add("mozilla", tv);
                }
                if (has("mozilla")) {
                    has.add("ff", parseFloat(dua.split("Firefox/")[1] || dua.split("Minefield/")[1]) || undefined);
                }
                if (document.all && !has("opera")) {
                    var isIE = parseFloat(dav.split("MSIE ")[1]) || undefined;
                    var mode = document.documentMode;
                    if (mode && mode != 5 && Math.floor(isIE) != mode) {
                        isIE = mode;
                    }
                    has.add("ie", isIE);
                }
                has.add("wii", typeof opera != "undefined" && opera.wiiremote);
            }
        }
        return has;
    });
}, "dojox/grid/enhanced/_PluginManager":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/connect", "./_Events", "./_FocusManager", "../util"], function (dojo, lang, declare, array, connect, _Events, _FocusManager, util) {
        var _PluginManager = declare("dojox.grid.enhanced._PluginManager", null, {_options:null, _plugins:null, _connects:null, constructor:function (inGrid) {
            this.grid = inGrid;
            this._store = inGrid.store;
            this._options = {};
            this._plugins = [];
            this._connects = [];
            this._parseProps(this.grid.plugins);
            inGrid.connect(inGrid, "_setStore", lang.hitch(this, function (store) {
                if (this._store !== store) {
                    this.forEach("onSetStore", [store, this._store]);
                    this._store = store;
                }
            }));
        }, startup:function () {
            this.forEach("onStartUp");
        }, preInit:function () {
            this.grid.focus.destroy();
            this.grid.focus = new _FocusManager(this.grid);
            new _Events(this.grid);
            this._init(true);
            this.forEach("onPreInit");
        }, postInit:function () {
            this._init(false);
            array.forEach(this.grid.views.views, this._initView, this);
            this._connects.push(connect.connect(this.grid.views, "addView", lang.hitch(this, this._initView)));
            if (this._plugins.length > 0) {
                var edit = this.grid.edit;
                if (edit) {
                    edit.styleRow = function (inRow) {
                    };
                }
            }
            this.forEach("onPostInit");
        }, forEach:function (func, args) {
            array.forEach(this._plugins, function (p) {
                if (!p || !p[func]) {
                    return;
                }
                p[func].apply(p, args ? args : []);
            });
        }, _parseProps:function (plugins) {
            if (!plugins) {
                return;
            }
            var p, loading = {}, options = this._options, grid = this.grid;
            var registry = _PluginManager.registry;
            for (p in plugins) {
                if (plugins[p]) {
                    this._normalize(p, plugins, registry, loading);
                }
            }
            if (options.dnd) {
                options.columnReordering = false;
            }
            lang.mixin(grid, options);
        }, _normalize:function (p, plugins, registry, loading) {
            if (!registry[p]) {
                throw new Error("Plugin " + p + " is required.");
            }
            if (loading[p]) {
                throw new Error("Recursive cycle dependency is not supported.");
            }
            var options = this._options;
            if (options[p]) {
                return options[p];
            }
            loading[p] = true;
            options[p] = lang.mixin({}, registry[p], lang.isObject(plugins[p]) ? plugins[p] : {});
            var dependencies = options[p]["dependency"];
            if (dependencies) {
                if (!lang.isArray(dependencies)) {
                    dependencies = options[p]["dependency"] = [dependencies];
                }
                array.forEach(dependencies, function (dependency) {
                    if (!this._normalize(dependency, plugins, registry, loading)) {
                        throw new Error("Plugin " + dependency + " is required.");
                    }
                }, this);
            }
            delete loading[p];
            return options[p];
        }, _init:function (pre) {
            var p, preInit, options = this._options;
            for (p in options) {
                preInit = options[p]["preInit"];
                if ((pre ? preInit : !preInit) && options[p]["class"] && !this.pluginExisted(p)) {
                    this.loadPlugin(p);
                }
            }
        }, loadPlugin:function (name) {
            var option = this._options[name];
            if (!option) {
                return null;
            }
            var plugin = this.getPlugin(name);
            if (plugin) {
                return plugin;
            }
            var dependencies = option["dependency"];
            array.forEach(dependencies, function (dependency) {
                if (!this.loadPlugin(dependency)) {
                    throw new Error("Plugin " + dependency + " is required.");
                }
            }, this);
            var cls = option["class"];
            delete option["class"];
            plugin = new this.getPluginClazz(cls)(this.grid, option);
            this._plugins.push(plugin);
            return plugin;
        }, _initView:function (view) {
            if (!view) {
                return;
            }
            util.funnelEvents(view.contentNode, view, "doContentEvent", ["mouseup", "mousemove"]);
            util.funnelEvents(view.headerNode, view, "doHeaderEvent", ["mouseup"]);
        }, pluginExisted:function (name) {
            return !!this.getPlugin(name);
        }, getPlugin:function (name) {
            var plugins = this._plugins;
            name = name.toLowerCase();
            for (var i = 0, len = plugins.length; i < len; i++) {
                if (name == plugins[i]["name"].toLowerCase()) {
                    return plugins[i];
                }
            }
            return null;
        }, getPluginClazz:function (clazz) {
            if (lang.isFunction(clazz)) {
                return clazz;
            }
            var errorMsg = "Please make sure Plugin \"" + clazz + "\" is existed.";
            try {
                var cls = lang.getObject(clazz);
                if (!cls) {
                    throw new Error(errorMsg);
                }
                return cls;
            }
            catch (e) {
                throw new Error(errorMsg);
            }
        }, isFixedCell:function (cell) {
            return cell && (cell.isRowSelector || cell.fixedPos);
        }, destroy:function () {
            array.forEach(this._connects, connect.disconnect);
            this.forEach("destroy");
            if (this.grid.unwrap) {
                this.grid.unwrap();
            }
            delete this._connects;
            delete this._plugins;
            delete this._options;
        }});
        _PluginManager.registerPlugin = function (clazz, props) {
            if (!clazz) {
                console.warn("Failed to register plugin, class missed!");
                return;
            }
            var cls = _PluginManager;
            cls.registry = cls.registry || {};
            cls.registry[clazz.prototype.name] = lang.mixin({"class":clazz}, (props ? props : {}));
        };
        return _PluginManager;
    });
}, "dijit/registry":function () {
    define(["dojo/_base/array", "dojo/sniff", "dojo/_base/window", "./main"], function (array, has, win, dijit) {
        var _widgetTypeCtr = {}, hash = {};
        var registry = {length:0, add:function (widget) {
            if (hash[widget.id]) {
                throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
            }
            hash[widget.id] = widget;
            this.length++;
        }, remove:function (id) {
            if (hash[id]) {
                delete hash[id];
                this.length--;
            }
        }, byId:function (id) {
            return typeof id == "string" ? hash[id] : id;
        }, byNode:function (node) {
            return hash[node.getAttribute("widgetId")];
        }, toArray:function () {
            var ar = [];
            for (var id in hash) {
                ar.push(hash[id]);
            }
            return ar;
        }, getUniqueId:function (widgetType) {
            var id;
            do {
                id = widgetType + "_" + (widgetType in _widgetTypeCtr ? ++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
            } while (hash[id]);
            return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id;
        }, findWidgets:function (root, skipNode) {
            var outAry = [];
            function getChildrenHelper(root) {
                for (var node = root.firstChild; node; node = node.nextSibling) {
                    if (node.nodeType == 1) {
                        var widgetId = node.getAttribute("widgetId");
                        if (widgetId) {
                            var widget = hash[widgetId];
                            if (widget) {
                                outAry.push(widget);
                            }
                        } else {
                            if (node !== skipNode) {
                                getChildrenHelper(node);
                            }
                        }
                    }
                }
            }
            getChildrenHelper(root);
            return outAry;
        }, _destroyAll:function () {
            dijit._curFocus = null;
            dijit._prevFocus = null;
            dijit._activeStack = [];
            array.forEach(registry.findWidgets(win.body()), function (widget) {
                if (!widget._destroyed) {
                    if (widget.destroyRecursive) {
                        widget.destroyRecursive();
                    } else {
                        if (widget.destroy) {
                            widget.destroy();
                        }
                    }
                }
            });
        }, getEnclosingWidget:function (node) {
            while (node) {
                var id = node.nodeType == 1 && node.getAttribute("widgetId");
                if (id) {
                    return hash[id];
                }
                node = node.parentNode;
            }
            return null;
        }, _hash:hash};
        dijit.registry = registry;
        return registry;
    });
}, "dijit/_base/focus":function () {
    define(["dojo/_base/array", "dojo/dom", "dojo/_base/lang", "dojo/topic", "dojo/_base/window", "../focus", "../selection", "../main"], function (array, dom, lang, topic, win, focus, selection, dijit) {
        var exports = {_curFocus:null, _prevFocus:null, isCollapsed:function () {
            return dijit.getBookmark().isCollapsed;
        }, getBookmark:function () {
            var sel = win.global == window ? selection : new selection.SelectionManager(win.global);
            return sel.getBookmark();
        }, moveToBookmark:function (bookmark) {
            var sel = win.global == window ? selection : new selection.SelectionManager(win.global);
            return sel.moveToBookmark(bookmark);
        }, getFocus:function (menu, openedForWindow) {
            var node = !focus.curNode || (menu && dom.isDescendant(focus.curNode, menu.domNode)) ? dijit._prevFocus : focus.curNode;
            return {node:node, bookmark:node && (node == focus.curNode) && win.withGlobal(openedForWindow || win.global, dijit.getBookmark), openedForWindow:openedForWindow};
        }, _activeStack:[], registerIframe:function (iframe) {
            return focus.registerIframe(iframe);
        }, unregisterIframe:function (handle) {
            handle && handle.remove();
        }, registerWin:function (targetWindow, effectiveNode) {
            return focus.registerWin(targetWindow, effectiveNode);
        }, unregisterWin:function (handle) {
            handle && handle.remove();
        }};
        focus.focus = function (handle) {
            if (!handle) {
                return;
            }
            var node = "node" in handle ? handle.node : handle, bookmark = handle.bookmark, openedForWindow = handle.openedForWindow, collapsed = bookmark ? bookmark.isCollapsed : false;
            if (node) {
                var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
                if (focusNode && focusNode.focus) {
                    try {
                        focusNode.focus();
                    }
                    catch (e) {
                    }
                }
                focus._onFocusNode(node);
            }
            if (bookmark && win.withGlobal(openedForWindow || win.global, dijit.isCollapsed) && !collapsed) {
                if (openedForWindow) {
                    openedForWindow.focus();
                }
                try {
                    win.withGlobal(openedForWindow || win.global, dijit.moveToBookmark, null, [bookmark]);
                }
                catch (e2) {
                }
            }
        };
        focus.watch("curNode", function (name, oldVal, newVal) {
            dijit._curFocus = newVal;
            dijit._prevFocus = oldVal;
            if (newVal) {
                topic.publish("focusNode", newVal);
            }
        });
        focus.watch("activeStack", function (name, oldVal, newVal) {
            dijit._activeStack = newVal;
        });
        focus.on("widget-blur", function (widget, by) {
            topic.publish("widgetBlur", widget, by);
        });
        focus.on("widget-focus", function (widget, by) {
            topic.publish("widgetFocus", widget, by);
        });
        lang.mixin(dijit, exports);
        return dijit;
    });
}, "dijit/form/_FormMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/_base/kernel", "dojo/_base/lang", "dojo/on", "dojo/window"], function (array, declare, kernel, lang, on, winUtils) {
        return declare("dijit.form._FormMixin", null, {state:"", _getDescendantFormWidgets:function (children) {
            var res = [];
            array.forEach(children || this.getChildren(), function (child) {
                if ("value" in child) {
                    res.push(child);
                } else {
                    res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
                }
            }, this);
            return res;
        }, reset:function () {
            array.forEach(this._getDescendantFormWidgets(), function (widget) {
                if (widget.reset) {
                    widget.reset();
                }
            });
        }, validate:function () {
            var didFocus = false;
            return array.every(array.map(this._getDescendantFormWidgets(), function (widget) {
                widget._hasBeenBlurred = true;
                var valid = widget.disabled || !widget.validate || widget.validate();
                if (!valid && !didFocus) {
                    winUtils.scrollIntoView(widget.containerNode || widget.domNode);
                    widget.focus();
                    didFocus = true;
                }
                return valid;
            }), function (item) {
                return item;
            });
        }, setValues:function (val) {
            kernel.deprecated(this.declaredClass + "::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
            return this.set("value", val);
        }, _setValueAttr:function (obj) {
            var map = {};
            array.forEach(this._getDescendantFormWidgets(), function (widget) {
                if (!widget.name) {
                    return;
                }
                var entry = map[widget.name] || (map[widget.name] = []);
                entry.push(widget);
            });
            for (var name in map) {
                if (!map.hasOwnProperty(name)) {
                    continue;
                }
                var widgets = map[name], values = lang.getObject(name, false, obj);
                if (values === undefined) {
                    continue;
                }
                values = [].concat(values);
                if (typeof widgets[0].checked == "boolean") {
                    array.forEach(widgets, function (w) {
                        w.set("value", array.indexOf(values, w._get("value")) != -1);
                    });
                } else {
                    if (widgets[0].multiple) {
                        widgets[0].set("value", values);
                    } else {
                        array.forEach(widgets, function (w, i) {
                            w.set("value", values[i]);
                        });
                    }
                }
            }
        }, getValues:function () {
            kernel.deprecated(this.declaredClass + "::getValues() is deprecated. Use get('value') instead.", "", "2.0");
            return this.get("value");
        }, _getValueAttr:function () {
            var obj = {};
            array.forEach(this._getDescendantFormWidgets(), function (widget) {
                var name = widget.name;
                if (!name || widget.disabled) {
                    return;
                }
                var value = widget.get("value");
                if (typeof widget.checked == "boolean") {
                    if (/Radio/.test(widget.declaredClass)) {
                        if (value !== false) {
                            lang.setObject(name, value, obj);
                        } else {
                            value = lang.getObject(name, false, obj);
                            if (value === undefined) {
                                lang.setObject(name, null, obj);
                            }
                        }
                    } else {
                        var ary = lang.getObject(name, false, obj);
                        if (!ary) {
                            ary = [];
                            lang.setObject(name, ary, obj);
                        }
                        if (value !== false) {
                            ary.push(value);
                        }
                    }
                } else {
                    var prev = lang.getObject(name, false, obj);
                    if (typeof prev != "undefined") {
                        if (lang.isArray(prev)) {
                            prev.push(value);
                        } else {
                            lang.setObject(name, [prev, value], obj);
                        }
                    } else {
                        lang.setObject(name, value, obj);
                    }
                }
            });
            return obj;
        }, isValid:function () {
            return this.state == "";
        }, onValidStateChange:function () {
        }, _getState:function () {
            var states = array.map(this._descendants, function (w) {
                return w.get("state") || "";
            });
            return array.indexOf(states, "Error") >= 0 ? "Error" : array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
        }, disconnectChildren:function () {
        }, connectChildren:function (inStartup) {
            this._descendants = this._getDescendantFormWidgets();
            array.forEach(this._descendants, function (child) {
                if (!child._started) {
                    child.startup();
                }
            });
            if (!inStartup) {
                this._onChildChange();
            }
        }, _onChildChange:function (attr) {
            if (!attr || attr == "state" || attr == "disabled") {
                this._set("state", this._getState());
            }
            if (!attr || attr == "value" || attr == "disabled" || attr == "checked") {
                if (this._onChangeDelayTimer) {
                    this._onChangeDelayTimer.remove();
                }
                this._onChangeDelayTimer = this.defer(function () {
                    delete this._onChangeDelayTimer;
                    this._set("value", this.get("value"));
                }, 10);
            }
        }, startup:function () {
            this.inherited(arguments);
            this._descendants = this._getDescendantFormWidgets();
            this.value = this.get("value");
            this.state = this._getState();
            var self = this;
            this.own(on(this.containerNode, "attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked", function (evt) {
                if (evt.target == self.domNode) {
                    return;
                }
                self._onChildChange(evt.type.replace("attrmodified-", ""));
            }));
            this.watch("state", function (attr, oldVal, newVal) {
                this.onValidStateChange(newVal == "");
            });
        }, destroy:function () {
            this.inherited(arguments);
        }});
    });
}, "dijit/BackgroundIframe":function () {
    define(["require", "./main", "dojo/_base/config", "dojo/dom-construct", "dojo/dom-style", "dojo/_base/lang", "dojo/on", "dojo/sniff"], function (require, dijit, config, domConstruct, domStyle, lang, on, has) {
        has.add("config-bgIframe", !has("touch"));
        var _frames = new function () {
            var queue = [];
            this.pop = function () {
                var iframe;
                if (queue.length) {
                    iframe = queue.pop();
                    iframe.style.display = "";
                } else {
                    if (has("ie") < 9) {
                        var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
                        var html = "<iframe src='" + burl + "' role='presentation'" + " style='position: absolute; left: 0px; top: 0px;" + "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
                        iframe = document.createElement(html);
                    } else {
                        iframe = domConstruct.create("iframe");
                        iframe.src = "javascript:\"\"";
                        iframe.className = "dijitBackgroundIframe";
                        iframe.setAttribute("role", "presentation");
                        domStyle.set(iframe, "opacity", 0.1);
                    }
                    iframe.tabIndex = -1;
                }
                return iframe;
            };
            this.push = function (iframe) {
                iframe.style.display = "none";
                queue.push(iframe);
            };
        }();
        dijit.BackgroundIframe = function (node) {
            if (!node.id) {
                throw new Error("no id");
            }
            if (has("config-bgIframe")) {
                var iframe = (this.iframe = _frames.pop());
                node.appendChild(iframe);
                if (has("ie") < 7 || has("quirks")) {
                    this.resize(node);
                    this._conn = on(node, "resize", lang.hitch(this, "resize", node));
                } else {
                    domStyle.set(iframe, {width:"100%", height:"100%"});
                }
            }
        };
        lang.extend(dijit.BackgroundIframe, {resize:function (node) {
            if (this.iframe) {
                domStyle.set(this.iframe, {width:node.offsetWidth + "px", height:node.offsetHeight + "px"});
            }
        }, destroy:function () {
            if (this._conn) {
                this._conn.remove();
                this._conn = null;
            }
            if (this.iframe) {
                _frames.push(this.iframe);
                delete this.iframe;
            }
        }});
        return dijit.BackgroundIframe;
    });
}, "dijit/layout/TabController":function () {
    define(["dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/has", "dojo/i18n", "dojo/_base/lang", "./StackController", "../registry", "../Menu", "../MenuItem", "dojo/text!./templates/_TabButton.html", "dojo/i18n!../nls/common"], function (declare, dom, domAttr, domClass, has, i18n, lang, StackController, registry, Menu, MenuItem, template) {
        var TabButton = declare("dijit.layout._TabButton" + (has("dojo-bidi") ? "_NoBidi" : ""), StackController.StackButton, {baseClass:"dijitTab", cssStateNodes:{closeNode:"dijitTabCloseButton"}, templateString:template, _setNameAttr:"focusNode", scrollOnFocus:false, buildRendering:function () {
            this.inherited(arguments);
            dom.setSelectable(this.containerNode, false);
        }, startup:function () {
            this.inherited(arguments);
            var n = this.domNode;
            this.defer(function () {
                n.className = n.className;
            }, 1);
        }, _setCloseButtonAttr:function (disp) {
            this._set("closeButton", disp);
            domClass.toggle(this.domNode, "dijitClosable", disp);
            this.closeNode.style.display = disp ? "" : "none";
            if (disp) {
                var _nlsResources = i18n.getLocalization("dijit", "common");
                if (this.closeNode) {
                    domAttr.set(this.closeNode, "title", _nlsResources.itemClose);
                }
            }
        }, _setDisabledAttr:function (disabled) {
            this.inherited(arguments);
            if (this.closeNode) {
                if (disabled) {
                    domAttr.remove(this.closeNode, "title");
                } else {
                    var _nlsResources = i18n.getLocalization("dijit", "common");
                    domAttr.set(this.closeNode, "title", _nlsResources.itemClose);
                }
            }
        }, _setLabelAttr:function (content) {
            this.inherited(arguments);
            if (!this.showLabel && !this.params.title) {
                this.iconNode.alt = lang.trim(this.containerNode.innerText || this.containerNode.textContent || "");
            }
        }});
        if (has("dojo-bidi")) {
            TabButton = declare("dijit.layout._TabButton", TabButton, {_setLabelAttr:function (content) {
                this.inherited(arguments);
                this.applyTextDir(this.iconNode, this.iconNode.alt);
            }});
        }
        var TabController = declare("dijit.layout.TabController", StackController, {baseClass:"dijitTabController", templateString:"<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'></div>", tabPosition:"top", buttonWidget:TabButton, buttonWidgetCloseClass:"dijitTabCloseButton", postCreate:function () {
            this.inherited(arguments);
            var closeMenu = new Menu({id:this.id + "_Menu", ownerDocument:this.ownerDocument, dir:this.dir, lang:this.lang, textDir:this.textDir, targetNodeIds:[this.domNode], selector:function (node) {
                return domClass.contains(node, "dijitClosable") && !domClass.contains(node, "dijitTabDisabled");
            }});
            this.own(closeMenu);
            var _nlsResources = i18n.getLocalization("dijit", "common"), controller = this;
            closeMenu.addChild(new MenuItem({label:_nlsResources.itemClose, ownerDocument:this.ownerDocument, dir:this.dir, lang:this.lang, textDir:this.textDir, onClick:function (evt) {
                var button = registry.byNode(this.getParent().currentTarget);
                controller.onCloseButtonClick(button.page);
            }}));
        }});
        TabController.TabButton = TabButton;
        return TabController;
    });
}, "dijit/_MenuBase":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/_base/lang", "dojo/mouse", "dojo/on", "dojo/window", "./a11yclick", "./registry", "./_Widget", "./_CssStateMixin", "./_KeyNavContainer", "./_TemplatedMixin"], function (array, declare, dom, domAttr, domClass, lang, mouse, on, winUtils, a11yclick, registry, _Widget, _CssStateMixin, _KeyNavContainer, _TemplatedMixin) {
        return declare("dijit._MenuBase", [_Widget, _TemplatedMixin, _KeyNavContainer, _CssStateMixin], {selected:null, _setSelectedAttr:function (item) {
            if (this.selected != item) {
                if (this.selected) {
                    this.selected._setSelected(false);
                    this._onChildDeselect(this.selected);
                }
                if (item) {
                    item._setSelected(true);
                }
                this._set("selected", item);
            }
        }, activated:false, _setActivatedAttr:function (val) {
            domClass.toggle(this.domNode, "dijitMenuActive", val);
            domClass.toggle(this.domNode, "dijitMenuPassive", !val);
            this._set("activated", val);
        }, parentMenu:null, popupDelay:500, passivePopupDelay:Infinity, autoFocus:false, childSelector:function (node) {
            var widget = registry.byNode(node);
            return node.parentNode == this.containerNode && widget && widget.focus;
        }, postCreate:function () {
            var self = this, matches = typeof this.childSelector == "string" ? this.childSelector : lang.hitch(this, "childSelector");
            this.own(on(this.containerNode, on.selector(matches, mouse.enter), function () {
                self.onItemHover(registry.byNode(this));
            }), on(this.containerNode, on.selector(matches, mouse.leave), function () {
                self.onItemUnhover(registry.byNode(this));
            }), on(this.containerNode, on.selector(matches, a11yclick), function (evt) {
                self.onItemClick(registry.byNode(this), evt);
                evt.stopPropagation();
                evt.preventDefault();
            }));
            this.inherited(arguments);
        }, onKeyboardSearch:function (item, evt, searchString, numMatches) {
            this.inherited(arguments);
            if (!!item && (numMatches == -1 || (!!item.popup && numMatches == 1))) {
                this.onItemClick(item, evt);
            }
        }, _keyboardSearchCompare:function (item, searchString) {
            if (!!item.shortcutKey) {
                return searchString == item.shortcutKey.toLowerCase() ? -1 : 0;
            }
            return this.inherited(arguments) ? 1 : 0;
        }, onExecute:function () {
        }, onCancel:function () {
        }, _moveToPopup:function (evt) {
            if (this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled) {
                this.onItemClick(this.focusedChild, evt);
            } else {
                var topMenu = this._getTopMenu();
                if (topMenu && topMenu._isMenuBar) {
                    topMenu.focusNext();
                }
            }
        }, _onPopupHover:function () {
            this.set("selected", this.currentPopupItem);
            this._stopPendingCloseTimer();
        }, onItemHover:function (item) {
            if (this.activated) {
                this.set("selected", item);
                if (item.popup && !item.disabled && !this.hover_timer) {
                    this.hover_timer = this.defer(function () {
                        this._openItemPopup(item);
                    }, this.popupDelay);
                }
            } else {
                if (this.passivePopupDelay < Infinity) {
                    if (this.passive_hover_timer) {
                        this.passive_hover_timer.remove();
                    }
                    this.passive_hover_timer = this.defer(function () {
                        this.onItemClick(item, {type:"click"});
                    }, this.passivePopupDelay);
                }
            }
            this._hoveredChild = item;
            item._set("hovering", true);
        }, _onChildDeselect:function (item) {
            this._stopPopupTimer();
            if (this.currentPopupItem == item) {
                this._stopPendingCloseTimer();
                this._pendingClose_timer = this.defer(function () {
                    this._pendingClose_timer = null;
                    this.currentPopupItem = null;
                    item._closePopup();
                }, this.popupDelay);
            }
        }, onItemUnhover:function (item) {
            if (this._hoveredChild == item) {
                this._hoveredChild = null;
            }
            if (this.passive_hover_timer) {
                this.passive_hover_timer.remove();
                this.passive_hover_timer = null;
            }
            item._set("hovering", false);
        }, _stopPopupTimer:function () {
            if (this.hover_timer) {
                this.hover_timer = this.hover_timer.remove();
            }
        }, _stopPendingCloseTimer:function () {
            if (this._pendingClose_timer) {
                this._pendingClose_timer = this._pendingClose_timer.remove();
            }
        }, _getTopMenu:function () {
            for (var top = this; top.parentMenu; top = top.parentMenu) {
            }
            return top;
        }, onItemClick:function (item, evt) {
            if (this.passive_hover_timer) {
                this.passive_hover_timer.remove();
            }
            this.focusChild(item);
            if (item.disabled) {
                return false;
            }
            if (item.popup) {
                this.set("selected", item);
                this.set("activated", true);
                var byKeyboard = /^key/.test(evt._origType || evt.type) || (evt.clientX == 0 && evt.clientY == 0);
                this._openItemPopup(item, byKeyboard);
            } else {
                this.onExecute();
                item._onClick ? item._onClick(evt) : item.onClick(evt);
            }
        }, _openItemPopup:function (from_item, focus) {
            if (from_item == this.currentPopupItem) {
                return;
            }
            if (this.currentPopupItem) {
                this._stopPendingCloseTimer();
                this.currentPopupItem._closePopup();
            }
            this._stopPopupTimer();
            var popup = from_item.popup;
            popup.parentMenu = this;
            this.own(this._mouseoverHandle = on.once(popup.domNode, "mouseover", lang.hitch(this, "_onPopupHover")));
            var self = this;
            from_item._openPopup({parent:this, orient:this._orient || ["after", "before"], onCancel:function () {
                if (focus) {
                    self.focusChild(from_item);
                }
                self._cleanUp();
            }, onExecute:lang.hitch(this, "_cleanUp", true), onClose:function () {
                if (self._mouseoverHandle) {
                    self._mouseoverHandle.remove();
                    delete self._mouseoverHandle;
                }
            }}, focus);
            this.currentPopupItem = from_item;
        }, onOpen:function () {
            this.isShowingNow = true;
            this.set("activated", true);
        }, onClose:function () {
            this.set("activated", false);
            this.set("selected", null);
            this.isShowingNow = false;
            this.parentMenu = null;
        }, _closeChild:function () {
            this._stopPopupTimer();
            if (this.currentPopupItem) {
                if (this.focused) {
                    domAttr.set(this.selected.focusNode, "tabIndex", this.tabIndex);
                    this.selected.focusNode.focus();
                }
                this.currentPopupItem._closePopup();
                this.currentPopupItem = null;
            }
        }, _onItemFocus:function (item) {
            if (this._hoveredChild && this._hoveredChild != item) {
                this.onItemUnhover(this._hoveredChild);
            }
            this.set("selected", item);
        }, _onBlur:function () {
            this._cleanUp(true);
            this.inherited(arguments);
        }, _cleanUp:function (clearSelectedItem) {
            this._closeChild();
            if (typeof this.isShowingNow == "undefined") {
                this.set("activated", false);
            }
            if (clearSelectedItem) {
                this.set("selected", null);
            }
        }});
    });
}, "dijit/_editor/_Plugin":function () {
    define(["dojo/_base/connect", "dojo/_base/declare", "dojo/_base/lang", "../Destroyable", "../form/Button"], function (connect, declare, lang, Destroyable, Button) {
        var _Plugin = declare("dijit._editor._Plugin", Destroyable, {constructor:function (args) {
            this.params = args || {};
            lang.mixin(this, this.params);
            this._attrPairNames = {};
        }, editor:null, iconClassPrefix:"dijitEditorIcon", button:null, command:"", useDefaultCommand:true, buttonClass:Button, disabled:false, getLabel:function (key) {
            return this.editor.commands[key];
        }, _initButton:function () {
            if (this.command.length) {
                var label = this.getLabel(this.command), editor = this.editor, className = this.iconClassPrefix + " " + this.iconClassPrefix + this.command.charAt(0).toUpperCase() + this.command.substr(1);
                if (!this.button) {
                    var props = lang.mixin({label:label, ownerDocument:editor.ownerDocument, dir:editor.dir, lang:editor.lang, showLabel:false, iconClass:className, dropDown:this.dropDown, tabIndex:"-1"}, this.params || {});
                    this.button = new this.buttonClass(props);
                }
            }
            if (this.get("disabled") && this.button) {
                this.button.set("disabled", this.get("disabled"));
            }
        }, destroy:function () {
            if (this.dropDown) {
                this.dropDown.destroyRecursive();
            }
            this.inherited(arguments);
        }, connect:function (o, f, tf) {
            this.own(connect.connect(o, f, this, tf));
        }, updateState:function () {
            var e = this.editor, c = this.command, checked, enabled;
            if (!e || !e.isLoaded || !c.length) {
                return;
            }
            var disabled = this.get("disabled");
            if (this.button) {
                try {
                    enabled = !disabled && e.queryCommandEnabled(c);
                    if (this.enabled !== enabled) {
                        this.enabled = enabled;
                        this.button.set("disabled", !enabled);
                    }
                    if (enabled) {
                        if (typeof this.button.checked == "boolean") {
                            checked = e.queryCommandState(c);
                            if (this.checked !== checked) {
                                this.checked = checked;
                                this.button.set("checked", e.queryCommandState(c));
                            }
                        }
                    }
                }
                catch (e) {
                    console.log(e);
                }
            }
        }, setEditor:function (editor) {
            this.editor = editor;
            this._initButton();
            if (this.button && this.useDefaultCommand) {
                if (this.editor.queryCommandAvailable(this.command)) {
                    this.own(this.button.on("click", lang.hitch(this.editor, "execCommand", this.command, this.commandArg)));
                } else {
                    this.button.domNode.style.display = "none";
                }
            }
            this.own(this.editor.on("NormalizedDisplayChanged", lang.hitch(this, "updateState")));
        }, setToolbar:function (toolbar) {
            if (this.button) {
                toolbar.addChild(this.button);
            }
        }, set:function (name, value) {
            if (typeof name === "object") {
                for (var x in name) {
                    this.set(x, name[x]);
                }
                return this;
            }
            var names = this._getAttrNames(name);
            if (this[names.s]) {
                var result = this[names.s].apply(this, Array.prototype.slice.call(arguments, 1));
            } else {
                this._set(name, value);
            }
            return result || this;
        }, get:function (name) {
            var names = this._getAttrNames(name);
            return this[names.g] ? this[names.g]() : this[name];
        }, _setDisabledAttr:function (disabled) {
            this._set("disabled", disabled);
            this.updateState();
        }, _getAttrNames:function (name) {
            var apn = this._attrPairNames;
            if (apn[name]) {
                return apn[name];
            }
            var uc = name.charAt(0).toUpperCase() + name.substr(1);
            return (apn[name] = {s:"_set" + uc + "Attr", g:"_get" + uc + "Attr"});
        }, _set:function (name, value) {
            this[name] = value;
        }});
        _Plugin.registry = {};
        return _Plugin;
    });
}, "dijit/layout/ScrollingTabController":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/fx", "dojo/_base/lang", "dojo/on", "dojo/query", "dojo/sniff", "../registry", "dojo/text!./templates/ScrollingTabController.html", "dojo/text!./templates/_ScrollingTabControllerButton.html", "./TabController", "./utils", "../_WidgetsInTemplateMixin", "../Menu", "../MenuItem", "../form/Button", "../_HasDropDown", "dojo/NodeList-dom", "../a11yclick"], function (array, declare, domClass, domGeometry, domStyle, fx, lang, on, query, has, registry, tabControllerTemplate, buttonTemplate, TabController, layoutUtils, _WidgetsInTemplateMixin, Menu, MenuItem, Button, _HasDropDown) {
        var ScrollingTabController = declare("dijit.layout.ScrollingTabController", [TabController, _WidgetsInTemplateMixin], {baseClass:"dijitTabController dijitScrollingTabController", templateString:tabControllerTemplate, useMenu:true, useSlider:true, tabStripClass:"", _minScroll:5, _setClassAttr:{node:"containerNode", type:"class"}, buildRendering:function () {
            this.inherited(arguments);
            var n = this.domNode;
            this.scrollNode = this.tablistWrapper;
            this._initButtons();
            if (!this.tabStripClass) {
                this.tabStripClass = "dijitTabContainer" + this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "") + "None";
                domClass.add(n, "tabStrip-disabled");
            }
            domClass.add(this.tablistWrapper, this.tabStripClass);
        }, onStartup:function () {
            this.inherited(arguments);
            domStyle.set(this.domNode, "visibility", "");
            this._postStartup = true;
            this.own(on(this.containerNode, "attrmodified-label, attrmodified-iconclass", lang.hitch(this, function (evt) {
                if (this._dim) {
                    this.resize(this._dim);
                }
            })));
        }, onAddChild:function (page, insertIndex) {
            this.inherited(arguments);
            domStyle.set(this.containerNode, "width", (domStyle.get(this.containerNode, "width") + 200) + "px");
        }, onRemoveChild:function (page, insertIndex) {
            var button = this.pane2button(page.id);
            if (this._selectedTab === button.domNode) {
                this._selectedTab = null;
            }
            this.inherited(arguments);
        }, _initButtons:function () {
            this._btnWidth = 0;
            this._buttons = query("> .tabStripButton", this.domNode).filter(function (btn) {
                if ((this.useMenu && btn == this._menuBtn.domNode) || (this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))) {
                    this._btnWidth += domGeometry.getMarginSize(btn).w;
                    return true;
                } else {
                    domStyle.set(btn, "display", "none");
                    return false;
                }
            }, this);
        }, _getTabsWidth:function () {
            var children = this.getChildren();
            if (children.length) {
                var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode, rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
                return rightTab.offsetLeft + rightTab.offsetWidth - leftTab.offsetLeft;
            } else {
                return 0;
            }
        }, _enableBtn:function (width) {
            var tabsWidth = this._getTabsWidth();
            width = width || domStyle.get(this.scrollNode, "width");
            return tabsWidth > 0 && width < tabsWidth;
        }, resize:function (dim) {
            this._dim = dim;
            this.scrollNode.style.height = "auto";
            var cb = this._contentBox = layoutUtils.marginBox2contentBox(this.domNode, {h:0, w:dim.w});
            cb.h = this.scrollNode.offsetHeight;
            domGeometry.setContentSize(this.domNode, cb);
            var enable = this._enableBtn(this._contentBox.w);
            this._buttons.style("display", enable ? "" : "none");
            this._leftBtn.region = "left";
            this._rightBtn.region = "right";
            this._menuBtn.region = this.isLeftToRight() ? "right" : "left";
            layoutUtils.layoutChildren(this.domNode, this._contentBox, [this._menuBtn, this._leftBtn, this._rightBtn, {domNode:this.scrollNode, region:"center"}]);
            if (this._selectedTab) {
                if (this._anim && this._anim.status() == "playing") {
                    this._anim.stop();
                }
                this.scrollNode.scrollLeft = this._convertToScrollLeft(this._getScrollForSelectedTab());
            }
            this._setButtonClass(this._getScroll());
            this._postResize = true;
            return {h:this._contentBox.h, w:dim.w};
        }, _getScroll:function () {
            return (this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")) ? this.scrollNode.scrollLeft : domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width") + (has("ie") >= 8 ? -1 : 1) * this.scrollNode.scrollLeft;
        }, _convertToScrollLeft:function (val) {
            if (this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")) {
                return val;
            } else {
                var maxScroll = domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width");
                return (has("ie") >= 8 ? -1 : 1) * (val - maxScroll);
            }
        }, onSelectChild:function (page) {
            var tab = this.pane2button(page.id);
            if (!tab) {
                return;
            }
            var node = tab.domNode;
            if (node != this._selectedTab) {
                this._selectedTab = node;
                if (this._postResize) {
                    var sl = this._getScroll();
                    if (sl > node.offsetLeft || sl + domStyle.get(this.scrollNode, "width") < node.offsetLeft + domStyle.get(node, "width")) {
                        this.createSmoothScroll().play();
                    }
                }
            }
            this.inherited(arguments);
        }, _getScrollBounds:function () {
            var children = this.getChildren(), scrollNodeWidth = domStyle.get(this.scrollNode, "width"), containerWidth = domStyle.get(this.containerNode, "width"), maxPossibleScroll = containerWidth - scrollNodeWidth, tabsWidth = this._getTabsWidth();
            if (children.length && tabsWidth > scrollNodeWidth) {
                return {min:this.isLeftToRight() ? 0 : children[children.length - 1].domNode.offsetLeft, max:this.isLeftToRight() ? (children[children.length - 1].domNode.offsetLeft + children[children.length - 1].domNode.offsetWidth) - scrollNodeWidth : maxPossibleScroll};
            } else {
                var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
                return {min:onlyScrollPosition, max:onlyScrollPosition};
            }
        }, _getScrollForSelectedTab:function () {
            var w = this.scrollNode, n = this._selectedTab, scrollNodeWidth = domStyle.get(this.scrollNode, "width"), scrollBounds = this._getScrollBounds();
            var pos = (n.offsetLeft + domStyle.get(n, "width") / 2) - scrollNodeWidth / 2;
            pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);
            return pos;
        }, createSmoothScroll:function (x) {
            if (arguments.length > 0) {
                var scrollBounds = this._getScrollBounds();
                x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
            } else {
                x = this._getScrollForSelectedTab();
            }
            if (this._anim && this._anim.status() == "playing") {
                this._anim.stop();
            }
            var self = this, w = this.scrollNode, anim = new fx.Animation({beforeBegin:function () {
                if (this.curve) {
                    delete this.curve;
                }
                var oldS = w.scrollLeft, newS = self._convertToScrollLeft(x);
                anim.curve = new fx._Line(oldS, newS);
            }, onAnimate:function (val) {
                w.scrollLeft = val;
            }});
            this._anim = anim;
            this._setButtonClass(x);
            return anim;
        }, _getBtnNode:function (e) {
            var n = e.target;
            while (n && !domClass.contains(n, "tabStripButton")) {
                n = n.parentNode;
            }
            return n;
        }, doSlideRight:function (e) {
            this.doSlide(1, this._getBtnNode(e));
        }, doSlideLeft:function (e) {
            this.doSlide(-1, this._getBtnNode(e));
        }, doSlide:function (direction, node) {
            if (node && domClass.contains(node, "dijitTabDisabled")) {
                return;
            }
            var sWidth = domStyle.get(this.scrollNode, "width");
            var d = (sWidth * 0.75) * direction;
            var to = this._getScroll() + d;
            this._setButtonClass(to);
            this.createSmoothScroll(to).play();
        }, _setButtonClass:function (scroll) {
            var scrollBounds = this._getScrollBounds();
            this._leftBtn.set("disabled", scroll <= scrollBounds.min);
            this._rightBtn.set("disabled", scroll >= scrollBounds.max);
        }});
        var ScrollingTabControllerButtonMixin = declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {baseClass:"dijitTab tabStripButton", templateString:buttonTemplate, tabIndex:"", isFocusable:function () {
            return false;
        }});
        declare("dijit.layout._ScrollingTabControllerButton", [Button, ScrollingTabControllerButtonMixin]);
        declare("dijit.layout._ScrollingTabControllerMenuButton", [Button, _HasDropDown, ScrollingTabControllerButtonMixin], {containerId:"", tabIndex:"-1", isLoaded:function () {
            return false;
        }, loadDropDown:function (callback) {
            this.dropDown = new Menu({id:this.containerId + "_menu", ownerDocument:this.ownerDocument, dir:this.dir, lang:this.lang, textDir:this.textDir});
            var container = registry.byId(this.containerId);
            array.forEach(container.getChildren(), function (page) {
                var menuItem = new MenuItem({id:page.id + "_stcMi", label:page.title, iconClass:page.iconClass, disabled:page.disabled, ownerDocument:this.ownerDocument, dir:page.dir, lang:page.lang, textDir:page.textDir || container.textDir, onClick:function () {
                    container.selectChild(page);
                }});
                this.dropDown.addChild(menuItem);
            }, this);
            callback();
        }, closeDropDown:function (focus) {
            this.inherited(arguments);
            if (this.dropDown) {
                this._popupStateNode.removeAttribute("aria-owns");
                this.dropDown.destroyRecursive();
                delete this.dropDown;
            }
        }});
        return ScrollingTabController;
    });
}, "dojox/color":function () {
    define(["./color/_base"], function (dxcolor) {
        return dxcolor;
    });
}, "dijit/form/_ListMouseMixin":function () {
    define(["dojo/_base/declare", "dojo/on", "dojo/touch", "./_ListBase"], function (declare, on, touch, _ListBase) {
        return declare("dijit.form._ListMouseMixin", _ListBase, {postCreate:function () {
            this.inherited(arguments);
            this.domNode.dojoClick = true;
            this._listConnect("click", "_onClick");
            this._listConnect("mousedown", "_onMouseDown");
            this._listConnect("mouseup", "_onMouseUp");
            this._listConnect("mouseover", "_onMouseOver");
            this._listConnect("mouseout", "_onMouseOut");
        }, _onClick:function (evt, target) {
            this._setSelectedAttr(target, false);
            if (this._deferredClick) {
                this._deferredClick.remove();
            }
            this._deferredClick = this.defer(function () {
                this._deferredClick = null;
                this.onClick(target);
            });
        }, _onMouseDown:function (evt, target) {
            if (this._hoveredNode) {
                this.onUnhover(this._hoveredNode);
                this._hoveredNode = null;
            }
            this._isDragging = true;
            this._setSelectedAttr(target, false);
        }, _onMouseUp:function (evt, target) {
            this._isDragging = false;
            var selectedNode = this.selected;
            var hoveredNode = this._hoveredNode;
            if (selectedNode && target == selectedNode) {
                this.defer(function () {
                    this._onClick(evt, selectedNode);
                });
            } else {
                if (hoveredNode) {
                    this.defer(function () {
                        this._onClick(evt, hoveredNode);
                    });
                }
            }
        }, _onMouseOut:function (evt, target) {
            if (this._hoveredNode) {
                this.onUnhover(this._hoveredNode);
                this._hoveredNode = null;
            }
            if (this._isDragging) {
                this._cancelDrag = (new Date()).getTime() + 1000;
            }
        }, _onMouseOver:function (evt, target) {
            if (this._cancelDrag) {
                var time = (new Date()).getTime();
                if (time > this._cancelDrag) {
                    this._isDragging = false;
                }
                this._cancelDrag = null;
            }
            this._hoveredNode = target;
            this.onHover(target);
            if (this._isDragging) {
                this._setSelectedAttr(target, false);
            }
        }});
    });
}, "dojo/io-query":function () {
    define(["./_base/lang"], function (lang) {
        var backstop = {};
        return {objectToQuery:function objectToQuery(map) {
            var enc = encodeURIComponent, pairs = [];
            for (var name in map) {
                var value = map[name];
                if (value != backstop[name]) {
                    var assign = enc(name) + "=";
                    if (lang.isArray(value)) {
                        for (var i = 0, l = value.length; i < l; ++i) {
                            pairs.push(assign + enc(value[i]));
                        }
                    } else {
                        pairs.push(assign + enc(value));
                    }
                }
            }
            return pairs.join("&");
        }, queryToObject:function queryToObject(str) {
            var dec = decodeURIComponent, qp = str.split("&"), ret = {}, name, val;
            for (var i = 0, l = qp.length, item; i < l; ++i) {
                item = qp[i];
                if (item.length) {
                    var s = item.indexOf("=");
                    if (s < 0) {
                        name = dec(item);
                        val = "";
                    } else {
                        name = dec(item.slice(0, s));
                        val = dec(item.slice(s + 1));
                    }
                    if (typeof ret[name] == "string") {
                        ret[name] = [ret[name]];
                    }
                    if (lang.isArray(ret[name])) {
                        ret[name].push(val);
                    } else {
                        ret[name] = val;
                    }
                }
            }
            return ret;
        }};
    });
}, "dijit/tree/_dndSelector":function () {
    define(["dojo/_base/array", "dojo/_base/connect", "dojo/_base/declare", "dojo/_base/kernel", "dojo/_base/lang", "dojo/dom", "dojo/mouse", "dojo/on", "dojo/touch", "../a11yclick", "./_dndContainer"], function (array, connect, declare, kernel, lang, dom, mouse, on, touch, a11yclick, _dndContainer) {
        return declare("dijit.tree._dndSelector", _dndContainer, {constructor:function () {
            this.selection = {};
            this.anchor = null;
            this.events.push(on(this.tree.domNode, touch.press, lang.hitch(this, "onMouseDown")), on(this.tree.domNode, touch.release, lang.hitch(this, "onMouseUp")), on(this.tree.domNode, touch.move, lang.hitch(this, "onMouseMove")), on(this.tree.domNode, a11yclick.press, lang.hitch(this, "onClickPress")), on(this.tree.domNode, a11yclick.release, lang.hitch(this, "onClickRelease")));
        }, singular:false, getSelectedTreeNodes:function () {
            var nodes = [], sel = this.selection;
            for (var i in sel) {
                nodes.push(sel[i]);
            }
            return nodes;
        }, selectNone:function () {
            this.setSelection([]);
            return this;
        }, destroy:function () {
            this.inherited(arguments);
            this.selection = this.anchor = null;
        }, addTreeNode:function (node, isAnchor) {
            this.setSelection(this.getSelectedTreeNodes().concat([node]));
            if (isAnchor) {
                this.anchor = node;
            }
            return node;
        }, removeTreeNode:function (node) {
            var newSelection = array.filter(this.getSelectedTreeNodes(), function (selectedNode) {
                return !dom.isDescendant(selectedNode.domNode, node.domNode);
            });
            this.setSelection(newSelection);
            return node;
        }, isTreeNodeSelected:function (node) {
            return node.id && !!this.selection[node.id];
        }, setSelection:function (newSelection) {
            var oldSelection = this.getSelectedTreeNodes();
            array.forEach(this._setDifference(oldSelection, newSelection), lang.hitch(this, function (node) {
                node.setSelected(false);
                if (this.anchor == node) {
                    delete this.anchor;
                }
                delete this.selection[node.id];
            }));
            array.forEach(this._setDifference(newSelection, oldSelection), lang.hitch(this, function (node) {
                node.setSelected(true);
                this.selection[node.id] = node;
            }));
            this._updateSelectionProperties();
        }, _setDifference:function (xs, ys) {
            array.forEach(ys, function (y) {
                y.__exclude__ = true;
            });
            var ret = array.filter(xs, function (x) {
                return !x.__exclude__;
            });
            array.forEach(ys, function (y) {
                delete y["__exclude__"];
            });
            return ret;
        }, _updateSelectionProperties:function () {
            var selected = this.getSelectedTreeNodes();
            var paths = [], nodes = [], selects = [];
            array.forEach(selected, function (node) {
                var ary = node.getTreePath(), model = this.tree.model;
                nodes.push(node);
                paths.push(ary);
                ary = array.map(ary, function (item) {
                    return model.getIdentity(item);
                }, this);
                selects.push(ary.join("/"));
            }, this);
            var items = array.map(nodes, function (node) {
                return node.item;
            });
            this.tree._set("paths", paths);
            this.tree._set("path", paths[0] || []);
            this.tree._set("selectedNodes", nodes);
            this.tree._set("selectedNode", nodes[0] || null);
            this.tree._set("selectedItems", items);
            this.tree._set("selectedItem", items[0] || null);
        }, onClickPress:function (e) {
            if (this.current && this.current.isExpandable && this.tree.isExpandoNode(e.target, this.current)) {
                return;
            }
            if (mouse.isLeft(e)) {
                e.preventDefault();
            }
            var treeNode = e.type == "keydown" ? this.tree.focusedChild : this.current;
            if (!treeNode) {
                return;
            }
            var copy = connect.isCopyKey(e), id = treeNode.id;
            if (!this.singular && !e.shiftKey && this.selection[id]) {
                this._doDeselect = true;
                return;
            } else {
                this._doDeselect = false;
            }
            this.userSelect(treeNode, copy, e.shiftKey);
        }, onClickRelease:function (e) {
            if (!this._doDeselect) {
                return;
            }
            this._doDeselect = false;
            this.userSelect(e.type == "keyup" ? this.tree.focusedChild : this.current, connect.isCopyKey(e), e.shiftKey);
        }, onMouseMove:function () {
            this._doDeselect = false;
        }, onMouseDown:function () {
        }, onMouseUp:function () {
        }, _compareNodes:function (n1, n2) {
            if (n1 === n2) {
                return 0;
            }
            if ("sourceIndex" in document.documentElement) {
                return n1.sourceIndex - n2.sourceIndex;
            } else {
                if ("compareDocumentPosition" in document.documentElement) {
                    return n1.compareDocumentPosition(n2) & 2 ? 1 : -1;
                } else {
                    if (document.createRange) {
                        var r1 = doc.createRange();
                        r1.setStartBefore(n1);
                        var r2 = doc.createRange();
                        r2.setStartBefore(n2);
                        return r1.compareBoundaryPoints(r1.END_TO_END, r2);
                    } else {
                        throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
                    }
                }
            }
        }, userSelect:function (node, multi, range) {
            if (this.singular) {
                if (this.anchor == node && multi) {
                    this.selectNone();
                } else {
                    this.setSelection([node]);
                    this.anchor = node;
                }
            } else {
                if (range && this.anchor) {
                    var cr = this._compareNodes(this.anchor.rowNode, node.rowNode), begin, end, anchor = this.anchor;
                    if (cr < 0) {
                        begin = anchor;
                        end = node;
                    } else {
                        begin = node;
                        end = anchor;
                    }
                    var nodes = [];
                    while (begin != end) {
                        nodes.push(begin);
                        begin = this.tree._getNext(begin);
                    }
                    nodes.push(end);
                    this.setSelection(nodes);
                } else {
                    if (this.selection[node.id] && multi) {
                        this.removeTreeNode(node);
                    } else {
                        if (multi) {
                            this.addTreeNode(node, true);
                        } else {
                            this.setSelection([node]);
                            this.anchor = node;
                        }
                    }
                }
            }
        }, getItem:function (key) {
            var widget = this.selection[key];
            return {data:widget, type:["treeNode"]};
        }, forInSelectedItems:function (f, o) {
            o = o || kernel.global;
            for (var id in this.selection) {
                f.call(o, this.getItem(id), id, this);
            }
        }});
    });
}, "dojo/cldr/monetary":function () {
    define(["../_base/kernel", "../_base/lang"], function (dojo, lang) {
        var monetary = {};
        lang.setObject("dojo.cldr.monetary", monetary);
        monetary.getData = function (code) {
            var placesData = {ADP:0, AFN:0, ALL:0, AMD:0, BHD:3, BIF:0, BYR:0, CLF:0, CLP:0, COP:0, CRC:0, DJF:0, ESP:0, GNF:0, GYD:0, HUF:0, IDR:0, IQD:0, IRR:3, ISK:0, ITL:0, JOD:3, JPY:0, KMF:0, KPW:0, KRW:0, KWD:3, LAK:0, LBP:0, LUF:0, LYD:3, MGA:0, MGF:0, MMK:0, MNT:0, MRO:0, MUR:0, OMR:3, PKR:0, PYG:0, RSD:0, RWF:0, SLL:0, SOS:0, STD:0, SYP:0, TMM:0, TND:3, TRL:0, TZS:0, UGX:0, UZS:0, VND:0, VUV:0, XAF:0, XOF:0, XPF:0, YER:0, ZMK:0, ZWD:0};
            var roundingData = {};
            var places = placesData[code], round = roundingData[code];
            if (typeof places == "undefined") {
                places = 2;
            }
            if (typeof round == "undefined") {
                round = 0;
            }
            return {places:places, round:round};
        };
        return monetary;
    });
}, "dijit/_OnDijitClickMixin":function () {
    define(["dojo/on", "dojo/_base/array", "dojo/keys", "dojo/_base/declare", "dojo/has", "./a11yclick"], function (on, array, keys, declare, has, a11yclick) {
        var ret = declare("dijit._OnDijitClickMixin", null, {connect:function (obj, event, method) {
            return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
        }});
        ret.a11yclick = a11yclick;
        return ret;
    });
}, "dojox/grid/enhanced/plugins/NestedSorting":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/html", "dojo/_base/event", "dojo/_base/window", "dojo/keys", "dojo/query", "dojo/string", "../_Plugin", "../../EnhancedGrid"], function (declare, array, connect, lang, html, evt, win, keys, query, string, _Plugin, EnhancedGrid) {
        var NestedSorting = declare("dojox.grid.enhanced.plugins.NestedSorting", _Plugin, {name:"nestedSorting", _currMainSort:"none", _currRegionIdx:-1, _a11yText:{"dojoxGridDescending":"&#9662;", "dojoxGridAscending":"&#9652;", "dojoxGridAscendingTip":"&#1784;", "dojoxGridDescendingTip":"&#1783;", "dojoxGridUnsortedTip":"x"}, constructor:function () {
            this._sortDef = [];
            this._sortData = {};
            this._headerNodes = {};
            this._excludedColIdx = [];
            this.nls = this.grid._nls;
            this.grid.setSortInfo = function () {
            };
            this.grid.setSortIndex = lang.hitch(this, "_setGridSortIndex");
            this.grid.getSortIndex = function () {
            };
            this.grid.getSortProps = lang.hitch(this, "getSortProps");
            if (this.grid.sortFields) {
                this._setGridSortIndex(this.grid.sortFields, null, true);
            }
            this.connect(this.grid.views, "render", "_initSort");
            this.initCookieHandler();
            if (this.grid.plugin("rearrange")) {
                this.subscribe("dojox/grid/rearrange/move/" + this.grid.id, lang.hitch(this, "_onColumnDnD"));
            } else {
                this.connect(this.grid.layout, "moveColumn", "_onMoveColumn");
            }
        }, onStartUp:function () {
            this.inherited(arguments);
            this.connect(this.grid, "onHeaderCellClick", "_onHeaderCellClick");
            this.connect(this.grid, "onHeaderCellMouseOver", "_onHeaderCellMouseOver");
            this.connect(this.grid, "onHeaderCellMouseOut", "_onHeaderCellMouseOut");
        }, _onMoveColumn:function (sourceViewIndex, destViewIndex, cellIndex, targetIndex, before) {
            var cr = this._getCurrentRegion(), idx = cr && this._getRegionHeader(cr).getAttribute("idx"), c = this._headerNodes[idx], sortData = this._sortData, newSortData = {}, sortIndex, data;
            if (cr) {
                this._blurRegion(cr);
                this._currRegionIdx = array.indexOf(this._getRegions(), c.firstChild);
            }
            if (targetIndex < cellIndex) {
                for (sortIndex in sortData) {
                    sortIndex = parseInt(sortIndex, 10);
                    data = sortData[sortIndex];
                    if (data) {
                        if (sortIndex >= targetIndex && sortIndex < cellIndex) {
                            newSortData[sortIndex + 1] = data;
                        } else {
                            if (sortIndex == cellIndex) {
                                newSortData[targetIndex] = data;
                            } else {
                                newSortData[sortIndex] = data;
                            }
                        }
                    }
                }
            } else {
                if (targetIndex > cellIndex + 1) {
                    if (!before) {
                        targetIndex++;
                    }
                    for (sortIndex in sortData) {
                        sortIndex = parseInt(sortIndex, 10);
                        data = sortData[sortIndex];
                        if (data) {
                            if (sortIndex > cellIndex && sortIndex < targetIndex) {
                                newSortData[sortIndex - 1] = data;
                            } else {
                                if (sortIndex == cellIndex) {
                                    newSortData[targetIndex - 1] = data;
                                } else {
                                    newSortData[sortIndex] = data;
                                }
                            }
                        }
                    }
                }
            }
            this._sortData = newSortData;
            this._initSort(false);
        }, _onColumnDnD:function (type, mapping) {
            if (type !== "col") {
                return;
            }
            var m = mapping, obj = {}, d = this._sortData, p;
            var cr = this._getCurrentRegion();
            this._blurRegion(cr);
            var idx = this._getRegionHeader(cr).getAttribute("idx");
            for (p in m) {
                if (d[p]) {
                    obj[m[p]] = d[p];
                    delete d[p];
                }
                if (p === idx) {
                    idx = m[p];
                }
            }
            for (p in obj) {
                d[p] = obj[p];
            }
            var c = this._headerNodes[idx];
            this._currRegionIdx = array.indexOf(this._getRegions(), c.firstChild);
            this._initSort(false);
        }, _setGridSortIndex:function (inIndex, inAsc, noRefresh) {
            if (lang.isArray(inIndex)) {
                var i, d, cell;
                for (i = 0; i < inIndex.length; i++) {
                    d = inIndex[i];
                    cell = this.grid.getCellByField(d.attribute);
                    if (!cell) {
                        console.warn("Invalid sorting option, column ", d.attribute, " not found.");
                        return;
                    }
                    if (cell["nosort"] || !this.grid.canSort(cell.index, cell.field)) {
                        console.warn("Invalid sorting option, column ", d.attribute, " is unsortable.");
                        return;
                    }
                }
                this.clearSort();
                array.forEach(inIndex, function (d, i) {
                    cell = this.grid.getCellByField(d.attribute);
                    this.setSortData(cell.index, "index", i);
                    this.setSortData(cell.index, "order", d.descending ? "desc" : "asc");
                }, this);
            } else {
                if (!isNaN(inIndex)) {
                    if (inAsc === undefined) {
                        return;
                    }
                    this.setSortData(inIndex, "order", inAsc ? "asc" : "desc");
                } else {
                    return;
                }
            }
            this._updateSortDef();
            if (!noRefresh) {
                this.grid.sort();
            }
        }, getSortProps:function () {
            return this._sortDef.length ? this._sortDef : null;
        }, _initSort:function (postSort) {
            var g = this.grid, n = g.domNode, len = this._sortDef.length;
            html.toggleClass(n, "dojoxGridSorted", !!len);
            html.toggleClass(n, "dojoxGridSingleSorted", len === 1);
            html.toggleClass(n, "dojoxGridNestSorted", len > 1);
            if (len > 0) {
                this._currMainSort = this._sortDef[0].descending ? "desc" : "asc";
            }
            var idx, excluded = this._excludedCoIdx = [];
            this._headerNodes = query("th", g.viewsHeaderNode).forEach(function (n) {
                idx = parseInt(n.getAttribute("idx"), 10);
                if (html.style(n, "display") === "none" || g.layout.cells[idx]["nosort"] || (g.canSort && !g.canSort(idx, g.layout.cells[idx]["field"]))) {
                    excluded.push(idx);
                }
            });
            this._headerNodes.forEach(this._initHeaderNode, this);
            this._initFocus();
            if (postSort) {
                this._focusHeader();
            }
        }, _initHeaderNode:function (node) {
            html.toggleClass(node, "dojoxGridSortNoWrap", true);
            var sortNode = query(".dojoxGridSortNode", node)[0];
            if (sortNode) {
                html.toggleClass(sortNode, "dojoxGridSortNoWrap", true);
            }
            if (array.indexOf(this._excludedCoIdx, node.getAttribute("idx")) >= 0) {
                html.addClass(node, "dojoxGridNoSort");
                return;
            }
            if (!query(".dojoxGridSortBtn", node).length) {
                this._connects = array.filter(this._connects, function (conn) {
                    if (conn._sort) {
                        connect.disconnect(conn);
                        return false;
                    }
                    return true;
                });
                var n = html.create("a", {className:"dojoxGridSortBtn dojoxGridSortBtnNested", title:string.substitute(this.nls.sortingState, [this.nls.nestedSort, this.nls.ascending]), innerHTML:"1"}, node.firstChild, "last");
                n.onmousedown = evt.stop;
                n = html.create("a", {className:"dojoxGridSortBtn dojoxGridSortBtnSingle", title:string.substitute(this.nls.sortingState, [this.nls.singleSort, this.nls.ascending])}, node.firstChild, "last");
                n.onmousedown = evt.stop;
            } else {
                var a1 = query(".dojoxGridSortBtnSingle", node)[0];
                var a2 = query(".dojoxGridSortBtnNested", node)[0];
                a1.className = "dojoxGridSortBtn dojoxGridSortBtnSingle";
                a2.className = "dojoxGridSortBtn dojoxGridSortBtnNested";
                a2.innerHTML = "1";
                html.removeClass(node, "dojoxGridCellShowIndex");
                html.removeClass(node.firstChild, "dojoxGridSortNodeSorted");
                html.removeClass(node.firstChild, "dojoxGridSortNodeAsc");
                html.removeClass(node.firstChild, "dojoxGridSortNodeDesc");
                html.removeClass(node.firstChild, "dojoxGridSortNodeMain");
                html.removeClass(node.firstChild, "dojoxGridSortNodeSub");
            }
            this._updateHeaderNodeUI(node);
        }, _onHeaderCellClick:function (e) {
            this._focusRegion(e.target);
            if (html.hasClass(e.target, "dojoxGridSortBtn")) {
                this._onSortBtnClick(e);
                evt.stop(e);
                this._focusRegion(this._getCurrentRegion());
            }
        }, _onHeaderCellMouseOver:function (e) {
            if (!e.cell) {
                return;
            }
            if (this._sortDef.length > 1) {
                return;
            }
            if (this._sortData[e.cellIndex] && this._sortData[e.cellIndex].index === 0) {
                return;
            }
            var p;
            for (p in this._sortData) {
                if (this._sortData[p] && this._sortData[p].index === 0) {
                    html.addClass(this._headerNodes[p], "dojoxGridCellShowIndex");
                    break;
                }
            }
            if (!html.hasClass(win.body(), "dijit_a11y")) {
                return;
            }
            var i = e.cell.index, node = e.cellNode;
            var singleSortBtn = query(".dojoxGridSortBtnSingle", node)[0];
            var nestedSortBtn = query(".dojoxGridSortBtnNested", node)[0];
            var sortMode = "none";
            if (html.hasClass(this.grid.domNode, "dojoxGridSingleSorted")) {
                sortMode = "single";
            } else {
                if (html.hasClass(this.grid.domNode, "dojoxGridNestSorted")) {
                    sortMode = "nested";
                }
            }
            var nestedIndex = nestedSortBtn.getAttribute("orderIndex");
            if (nestedIndex === null || nestedIndex === undefined) {
                nestedSortBtn.setAttribute("orderIndex", nestedSortBtn.innerHTML);
                nestedIndex = nestedSortBtn.innerHTML;
            }
            if (this.isAsc(i)) {
                nestedSortBtn.innerHTML = nestedIndex + this._a11yText.dojoxGridDescending;
            } else {
                if (this.isDesc(i)) {
                    nestedSortBtn.innerHTML = nestedIndex + this._a11yText.dojoxGridUnsortedTip;
                } else {
                    nestedSortBtn.innerHTML = nestedIndex + this._a11yText.dojoxGridAscending;
                }
            }
            if (this._currMainSort === "none") {
                singleSortBtn.innerHTML = this._a11yText.dojoxGridAscending;
            } else {
                if (this._currMainSort === "asc") {
                    singleSortBtn.innerHTML = this._a11yText.dojoxGridDescending;
                } else {
                    if (this._currMainSort === "desc") {
                        singleSortBtn.innerHTML = this._a11yText.dojoxGridUnsortedTip;
                    }
                }
            }
        }, _onHeaderCellMouseOut:function (e) {
            var p;
            for (p in this._sortData) {
                if (this._sortData[p] && this._sortData[p].index === 0) {
                    html.removeClass(this._headerNodes[p], "dojoxGridCellShowIndex");
                    break;
                }
            }
        }, _onSortBtnClick:function (e) {
            var cellIdx = e.cell.index;
            if (html.hasClass(e.target, "dojoxGridSortBtnSingle")) {
                this._prepareSingleSort(cellIdx);
            } else {
                if (html.hasClass(e.target, "dojoxGridSortBtnNested")) {
                    this._prepareNestedSort(cellIdx);
                } else {
                    return;
                }
            }
            evt.stop(e);
            this._doSort(cellIdx);
        }, _doSort:function (cellIdx) {
            if (!this._sortData[cellIdx] || !this._sortData[cellIdx].order) {
                this.setSortData(cellIdx, "order", "asc");
            } else {
                if (this.isAsc(cellIdx)) {
                    this.setSortData(cellIdx, "order", "desc");
                } else {
                    if (this.isDesc(cellIdx)) {
                        this.removeSortData(cellIdx);
                    }
                }
            }
            this._updateSortDef();
            this.grid.sort();
            this._initSort(true);
        }, setSortData:function (cellIdx, attr, value) {
            var sd = this._sortData[cellIdx];
            if (!sd) {
                sd = this._sortData[cellIdx] = {};
            }
            sd[attr] = value;
        }, removeSortData:function (cellIdx) {
            var d = this._sortData, i = d[cellIdx].index, p;
            delete d[cellIdx];
            for (p in d) {
                if (d[p].index > i) {
                    d[p].index--;
                }
            }
        }, _prepareSingleSort:function (cellIdx) {
            var d = this._sortData, p;
            for (p in d) {
                delete d[p];
            }
            this.setSortData(cellIdx, "index", 0);
            this.setSortData(cellIdx, "order", this._currMainSort === "none" ? null : this._currMainSort);
            if (!this._sortData[cellIdx] || !this._sortData[cellIdx].order) {
                this._currMainSort = "asc";
            } else {
                if (this.isAsc(cellIdx)) {
                    this._currMainSort = "desc";
                } else {
                    if (this.isDesc(cellIdx)) {
                        this._currMainSort = "none";
                    }
                }
            }
        }, _prepareNestedSort:function (cellIdx) {
            var i = this._sortData[cellIdx] ? this._sortData[cellIdx].index : null;
            if (i === 0 || !!i) {
                return;
            }
            this.setSortData(cellIdx, "index", this._sortDef.length);
        }, _updateSortDef:function () {
            this._sortDef.length = 0;
            var d = this._sortData, p;
            for (p in d) {
                this._sortDef[d[p].index] = {attribute:this.grid.layout.cells[p].field, descending:d[p].order === "desc"};
            }
        }, _updateHeaderNodeUI:function (node) {
            var cell = this._getCellByNode(node);
            var cellIdx = cell.index;
            var data = this._sortData[cellIdx];
            var sortNode = query(".dojoxGridSortNode", node)[0];
            var singleSortBtn = query(".dojoxGridSortBtnSingle", node)[0];
            var nestedSortBtn = query(".dojoxGridSortBtnNested", node)[0];
            html.toggleClass(singleSortBtn, "dojoxGridSortBtnAsc", this._currMainSort === "asc");
            html.toggleClass(singleSortBtn, "dojoxGridSortBtnDesc", this._currMainSort === "desc");
            if (this._currMainSort === "asc") {
                singleSortBtn.title = string.substitute(this.nls.sortingState, [this.nls.singleSort, this.nls.descending]);
            } else {
                if (this._currMainSort === "desc") {
                    singleSortBtn.title = string.substitute(this.nls.sortingState, [this.nls.singleSort, this.nls.unsorted]);
                } else {
                    singleSortBtn.title = string.substitute(this.nls.sortingState, [this.nls.singleSort, this.nls.ascending]);
                }
            }
            var _this = this;
            function setWaiState() {
                var columnInfo = "Column " + (cell.index + 1) + " " + cell.field;
                var orderState = "none";
                var orderAction = "ascending";
                if (data) {
                    orderState = data.order === "asc" ? "ascending" : "descending";
                    orderAction = data.order === "asc" ? "descending" : "none";
                }
                var a11ySingleLabel = columnInfo + " - is sorted by " + orderState;
                var a11yNestedLabel = columnInfo + " - is nested sorted by " + orderState;
                var a11ySingleLabelHover = columnInfo + " - choose to sort by " + orderAction;
                var a11yNestedLabelHover = columnInfo + " - choose to nested sort by " + orderAction;
                singleSortBtn.setAttribute("aria-label", a11ySingleLabel);
                nestedSortBtn.setAttribute("aria-label", a11yNestedLabel);
                var handles = [_this.connect(singleSortBtn, "onmouseover", function () {
                    singleSortBtn.setAttribute("aria-label", a11ySingleLabelHover);
                }), _this.connect(singleSortBtn, "onmouseout", function () {
                    singleSortBtn.setAttribute("aria-label", a11ySingleLabel);
                }), _this.connect(nestedSortBtn, "onmouseover", function () {
                    nestedSortBtn.setAttribute("aria-label", a11yNestedLabelHover);
                }), _this.connect(nestedSortBtn, "onmouseout", function () {
                    nestedSortBtn.setAttribute("aria-label", a11yNestedLabel);
                })];
                array.forEach(handles, function (handle) {
                    handle._sort = true;
                });
            }
            setWaiState();
            var a11y = html.hasClass(win.body(), "dijit_a11y");
            if (!data) {
                nestedSortBtn.innerHTML = this._sortDef.length + 1;
                nestedSortBtn.title = string.substitute(this.nls.sortingState, [this.nls.nestedSort, this.nls.ascending]);
                if (a11y) {
                    sortNode.innerHTML = this._a11yText.dojoxGridUnsortedTip;
                }
                return;
            }
            if (data.index || (data.index === 0 && this._sortDef.length > 1)) {
                nestedSortBtn.innerHTML = data.index + 1;
            }
            html.addClass(sortNode, "dojoxGridSortNodeSorted");
            if (this.isAsc(cellIdx)) {
                html.addClass(sortNode, "dojoxGridSortNodeAsc");
                nestedSortBtn.title = string.substitute(this.nls.sortingState, [this.nls.nestedSort, this.nls.descending]);
                if (a11y) {
                    sortNode.innerHTML = this._a11yText.dojoxGridAscendingTip;
                }
            } else {
                if (this.isDesc(cellIdx)) {
                    html.addClass(sortNode, "dojoxGridSortNodeDesc");
                    nestedSortBtn.title = string.substitute(this.nls.sortingState, [this.nls.nestedSort, this.nls.unsorted]);
                    if (a11y) {
                        sortNode.innerHTML = this._a11yText.dojoxGridDescendingTip;
                    }
                }
            }
            html.addClass(sortNode, (data.index === 0 ? "dojoxGridSortNodeMain" : "dojoxGridSortNodeSub"));
        }, isAsc:function (cellIndex) {
            return this._sortData[cellIndex].order === "asc";
        }, isDesc:function (cellIndex) {
            return this._sortData[cellIndex].order === "desc";
        }, _getCellByNode:function (node) {
            var i;
            for (i = 0; i < this._headerNodes.length; i++) {
                if (this._headerNodes[i] === node) {
                    return this.grid.layout.cells[i];
                }
            }
            return null;
        }, clearSort:function () {
            this._sortData = {};
            this._sortDef.length = 0;
        }, initCookieHandler:function () {
            if (this.grid.addCookieHandler) {
                this.grid.addCookieHandler({name:"sortOrder", onLoad:lang.hitch(this, "_loadNestedSortingProps"), onSave:lang.hitch(this, "_saveNestedSortingProps")});
            }
        }, _loadNestedSortingProps:function (sortInfo, grid) {
            this._setGridSortIndex(sortInfo);
        }, _saveNestedSortingProps:function (grid) {
            return this.getSortProps();
        }, _initFocus:function () {
            var f = this.focus = this.grid.focus;
            this._focusRegions = this._getRegions();
            if (!this._headerArea) {
                var area = this._headerArea = f.getArea("header");
                area.onFocus = f.focusHeader = lang.hitch(this, "_focusHeader");
                area.onBlur = f.blurHeader = f._blurHeader = lang.hitch(this, "_blurHeader");
                area.onMove = lang.hitch(this, "_onMove");
                area.onKeyDown = lang.hitch(this, "_onKeyDown");
                area._regions = [];
                area.getRegions = null;
                this.connect(this.grid, "onBlur", "_blurHeader");
            }
        }, _focusHeader:function (e) {
            if (this._currRegionIdx === -1) {
                this._onMove(0, 1, null);
            } else {
                var region = this._getCurrentRegion();
                this._focusRegion(region);
                var view = this._getRegionView(region);
                view.scrollboxNode.scrollLeft = view.headerNode.scrollLeft;
            }
            try {
                if (e) {
                    evt.stop(e);
                }
            }
            catch (e) {
            }
            return true;
        }, _blurHeader:function (e) {
            this._blurRegion(this._getCurrentRegion());
            return true;
        }, _onMove:function (rowStep, colStep, e) {
            var curr = this._currRegionIdx || 0, regions = this._focusRegions;
            var region = regions[curr + colStep];
            if (!region) {
                return;
            } else {
                if (html.style(region, "display") === "none" || html.style(region, "visibility") === "hidden") {
                    this._onMove(rowStep, colStep + (colStep > 0 ? 1 : -1), e);
                    return;
                }
            }
            this._focusRegion(region);
            var view = this._getRegionView(region);
            view.scrollboxNode.scrollLeft = view.headerNode.scrollLeft;
        }, _onKeyDown:function (e, isBubble) {
            if (isBubble) {
                switch (e.keyCode) {
                  case keys.ENTER:
                  case keys.SPACE:
                    if (html.hasClass(e.target, "dojoxGridSortBtnSingle") || html.hasClass(e.target, "dojoxGridSortBtnNested")) {
                        this._onSortBtnClick(e);
                    }
                }
            }
        }, _getRegionView:function (region) {
            var header = region;
            while (header && !html.hasClass(header, "dojoxGridHeader")) {
                header = header.parentNode;
            }
            if (header) {
                return array.filter(this.grid.views.views, function (view) {
                    return view.headerNode === header;
                })[0] || null;
            }
            return null;
        }, _getRegions:function () {
            var regions = [], cells = this.grid.layout.cells;
            this._headerNodes.forEach(function (n, i) {
                if (html.style(n, "display") === "none") {
                    return;
                }
                if (cells[i]["isRowSelector"]) {
                    regions.push(n);
                    return;
                }
                query(".dojoxGridSortNode,.dojoxGridSortBtnNested,.dojoxGridSortBtnSingle", n).forEach(function (node) {
                    node.setAttribute("tabindex", 0);
                    regions.push(node);
                });
            }, this);
            return regions;
        }, _focusRegion:function (region) {
            if (!region) {
                return;
            }
            var currRegion = this._getCurrentRegion();
            if (currRegion && region !== currRegion) {
                this._blurRegion(currRegion);
            }
            var header = this._getRegionHeader(region);
            html.addClass(header, "dojoxGridCellSortFocus");
            if (html.hasClass(region, "dojoxGridSortNode")) {
                html.addClass(region, "dojoxGridSortNodeFocus");
            } else {
                if (html.hasClass(region, "dojoxGridSortBtn")) {
                    html.addClass(region, "dojoxGridSortBtnFocus");
                }
            }
            try {
                region.focus();
            }
            catch (e) {
            }
            this.focus.currentArea("header");
            this._currRegionIdx = array.indexOf(this._focusRegions, region);
        }, _blurRegion:function (region) {
            if (!region) {
                return;
            }
            var header = this._getRegionHeader(region);
            html.removeClass(header, "dojoxGridCellSortFocus");
            if (html.hasClass(region, "dojoxGridSortNode")) {
                html.removeClass(region, "dojoxGridSortNodeFocus");
            } else {
                if (html.hasClass(region, "dojoxGridSortBtn")) {
                    html.removeClass(region, "dojoxGridSortBtnFocus");
                }
            }
            region.blur();
        }, _getCurrentRegion:function () {
            return this._focusRegions ? this._focusRegions[this._currRegionIdx] : null;
        }, _getRegionHeader:function (region) {
            while (region && !html.hasClass(region, "dojoxGridCell")) {
                region = region.parentNode;
            }
            return region;
        }, destroy:function () {
            this._sortDef = this._sortData = null;
            this._headerNodes = this._focusRegions = null;
            this.inherited(arguments);
        }});
        EnhancedGrid.registerPlugin(NestedSorting);
        return NestedSorting;
    });
}, "dojox/timing":function () {
    define(["./timing/_base"], function (timing) {
        return timing;
    });
}, "dijit/layout/StackController":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-construct", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/topic", "../focus", "../registry", "../_Widget", "../_TemplatedMixin", "../_Container", "../form/ToggleButton", "dojo/touch", "dojo/i18n!../nls/common"], function (array, declare, domClass, domConstruct, keys, lang, on, topic, focus, registry, _Widget, _TemplatedMixin, _Container, ToggleButton) {
        var StackButton = declare("dijit.layout._StackButton", ToggleButton, {tabIndex:"-1", closeButton:false, _aria_attr:"aria-selected", buildRendering:function (evt) {
            this.inherited(arguments);
            (this.focusNode || this.domNode).setAttribute("role", "tab");
        }});
        var StackController = declare("dijit.layout.StackController", [_Widget, _TemplatedMixin, _Container], {baseClass:"dijitStackController", templateString:"<span role='tablist' data-dojo-attach-event='onkeydown'></span>", containerId:"", buttonWidget:StackButton, buttonWidgetCloseClass:"dijitStackCloseButton", pane2button:function (id) {
            return registry.byId(this.id + "_" + id);
        }, postCreate:function () {
            this.inherited(arguments);
            this.own(topic.subscribe(this.containerId + "-startup", lang.hitch(this, "onStartup")), topic.subscribe(this.containerId + "-addChild", lang.hitch(this, "onAddChild")), topic.subscribe(this.containerId + "-removeChild", lang.hitch(this, "onRemoveChild")), topic.subscribe(this.containerId + "-selectChild", lang.hitch(this, "onSelectChild")), topic.subscribe(this.containerId + "-containerKeyDown", lang.hitch(this, "onContainerKeyDown")));
            this.containerNode.dojoClick = true;
            this.own(on(this.containerNode, "click", lang.hitch(this, function (evt) {
                var button = registry.getEnclosingWidget(evt.target);
                if (button != this.containerNode && !button.disabled && button.page) {
                    for (var target = evt.target; target !== this.containerNode; target = target.parentNode) {
                        if (domClass.contains(target, this.buttonWidgetCloseClass)) {
                            this.onCloseButtonClick(button.page);
                            break;
                        } else {
                            if (target == button.domNode) {
                                this.onButtonClick(button.page);
                                break;
                            }
                        }
                    }
                }
            })));
        }, onStartup:function (info) {
            this.textDir = info.textDir;
            array.forEach(info.children, this.onAddChild, this);
            if (info.selected) {
                this.onSelectChild(info.selected);
            }
            var containerNode = registry.byId(this.containerId).containerNode, pane2button = lang.hitch(this, "pane2button"), paneToButtonAttr = {"title":"label", "showtitle":"showLabel", "iconclass":"iconClass", "closable":"closeButton", "tooltip":"title", "disabled":"disabled", "textdir":"textdir"}, connectFunc = function (attr, buttonAttr) {
                return on(containerNode, "attrmodified-" + attr, function (evt) {
                    var button = pane2button(evt.detail && evt.detail.widget && evt.detail.widget.id);
                    if (button) {
                        button.set(buttonAttr, evt.detail.newValue);
                    }
                });
            };
            for (var attr in paneToButtonAttr) {
                this.own(connectFunc(attr, paneToButtonAttr[attr]));
            }
        }, destroy:function (preserveDom) {
            this.destroyDescendants(preserveDom);
            this.inherited(arguments);
        }, onAddChild:function (page, insertIndex) {
            var Cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
            var button = new Cls({id:this.id + "_" + page.id, name:this.id + "_" + page.id, label:page.title, disabled:page.disabled, ownerDocument:this.ownerDocument, dir:page.dir, lang:page.lang, textDir:page.textDir || this.textDir, showLabel:page.showTitle, iconClass:page.iconClass, closeButton:page.closable, title:page.tooltip, page:page});
            this.addChild(button, insertIndex);
            page.controlButton = button;
            if (!this._currentChild) {
                this.onSelectChild(page);
            }
            var labelledby = page._wrapper.getAttribute("aria-labelledby") ? page._wrapper.getAttribute("aria-labelledby") + " " + button.id : button.id;
            page._wrapper.removeAttribute("aria-label");
            page._wrapper.setAttribute("aria-labelledby", labelledby);
        }, onRemoveChild:function (page) {
            if (this._currentChild === page) {
                this._currentChild = null;
            }
            var button = this.pane2button(page.id);
            if (button) {
                this.removeChild(button);
                button.destroy();
            }
            delete page.controlButton;
        }, onSelectChild:function (page) {
            if (!page) {
                return;
            }
            if (this._currentChild) {
                var oldButton = this.pane2button(this._currentChild.id);
                oldButton.set("checked", false);
                oldButton.focusNode.setAttribute("tabIndex", "-1");
            }
            var newButton = this.pane2button(page.id);
            newButton.set("checked", true);
            this._currentChild = page;
            newButton.focusNode.setAttribute("tabIndex", "0");
            var container = registry.byId(this.containerId);
        }, onButtonClick:function (page) {
            var button = this.pane2button(page.id);
            focus.focus(button.focusNode);
            if (this._currentChild && this._currentChild.id === page.id) {
                button.set("checked", true);
            }
            var container = registry.byId(this.containerId);
            container.selectChild(page);
        }, onCloseButtonClick:function (page) {
            var container = registry.byId(this.containerId);
            container.closeChild(page);
            if (this._currentChild) {
                var b = this.pane2button(this._currentChild.id);
                if (b) {
                    focus.focus(b.focusNode || b.domNode);
                }
            }
        }, adjacent:function (forward) {
            if (!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))) {
                forward = !forward;
            }
            var children = this.getChildren();
            var idx = array.indexOf(children, this.pane2button(this._currentChild.id)), current = children[idx];
            var child;
            do {
                idx = (idx + (forward ? 1 : children.length - 1)) % children.length;
                child = children[idx];
            } while (child.disabled && child != current);
            return child;
        }, onkeydown:function (e, fromContainer) {
            if (this.disabled || e.altKey) {
                return;
            }
            var forward = null;
            if (e.ctrlKey || !e._djpage) {
                switch (e.keyCode) {
                  case keys.LEFT_ARROW:
                  case keys.UP_ARROW:
                    if (!e._djpage) {
                        forward = false;
                    }
                    break;
                  case keys.PAGE_UP:
                    if (e.ctrlKey) {
                        forward = false;
                    }
                    break;
                  case keys.RIGHT_ARROW:
                  case keys.DOWN_ARROW:
                    if (!e._djpage) {
                        forward = true;
                    }
                    break;
                  case keys.PAGE_DOWN:
                    if (e.ctrlKey) {
                        forward = true;
                    }
                    break;
                  case keys.HOME:
                    var children = this.getChildren();
                    for (var idx = 0; idx < children.length; idx++) {
                        var child = children[idx];
                        if (!child.disabled) {
                            this.onButtonClick(child.page);
                            break;
                        }
                    }
                    e.stopPropagation();
                    e.preventDefault();
                    break;
                  case keys.END:
                    var children = this.getChildren();
                    for (var idx = children.length - 1; idx >= 0; idx--) {
                        var child = children[idx];
                        if (!child.disabled) {
                            this.onButtonClick(child.page);
                            break;
                        }
                    }
                    e.stopPropagation();
                    e.preventDefault();
                    break;
                  case keys.DELETE:
                  case "W".charCodeAt(0):
                    if (this._currentChild.closable && (e.keyCode == keys.DELETE || e.ctrlKey)) {
                        this.onCloseButtonClick(this._currentChild);
                        e.stopPropagation();
                        e.preventDefault();
                    }
                    break;
                  case keys.TAB:
                    if (e.ctrlKey) {
                        this.onButtonClick(this.adjacent(!e.shiftKey).page);
                        e.stopPropagation();
                        e.preventDefault();
                    }
                    break;
                }
                if (forward !== null) {
                    this.onButtonClick(this.adjacent(forward).page);
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        }, onContainerKeyDown:function (info) {
            info.e._djpage = info.page;
            this.onkeydown(info.e);
        }});
        StackController.StackButton = StackButton;
        return StackController;
    });
}, "dojox/color/_base":function () {
    define(["../main", "dojo/_base/lang", "dojo/_base/Color", "dojo/colors"], function (dojox, lang, Color, colors) {
        var cx = lang.getObject("color", true, dojox);
        cx.Color = Color;
        cx.blend = Color.blendColors;
        cx.fromRgb = Color.fromRgb;
        cx.fromHex = Color.fromHex;
        cx.fromArray = Color.fromArray;
        cx.fromString = Color.fromString;
        cx.greyscale = colors.makeGrey;
        lang.mixin(cx, {fromCmy:function (cyan, magenta, yellow) {
            if (lang.isArray(cyan)) {
                magenta = cyan[1], yellow = cyan[2], cyan = cyan[0];
            } else {
                if (lang.isObject(cyan)) {
                    magenta = cyan.m, yellow = cyan.y, cyan = cyan.c;
                }
            }
            cyan /= 100, magenta /= 100, yellow /= 100;
            var r = 1 - cyan, g = 1 - magenta, b = 1 - yellow;
            return new Color({r:Math.round(r * 255), g:Math.round(g * 255), b:Math.round(b * 255)});
        }, fromCmyk:function (cyan, magenta, yellow, black) {
            if (lang.isArray(cyan)) {
                magenta = cyan[1], yellow = cyan[2], black = cyan[3], cyan = cyan[0];
            } else {
                if (lang.isObject(cyan)) {
                    magenta = cyan.m, yellow = cyan.y, black = cyan.b, cyan = cyan.c;
                }
            }
            cyan /= 100, magenta /= 100, yellow /= 100, black /= 100;
            var r, g, b;
            r = 1 - Math.min(1, cyan * (1 - black) + black);
            g = 1 - Math.min(1, magenta * (1 - black) + black);
            b = 1 - Math.min(1, yellow * (1 - black) + black);
            return new Color({r:Math.round(r * 255), g:Math.round(g * 255), b:Math.round(b * 255)});
        }, fromHsl:function (hue, saturation, luminosity) {
            if (lang.isArray(hue)) {
                saturation = hue[1], luminosity = hue[2], hue = hue[0];
            } else {
                if (lang.isObject(hue)) {
                    saturation = hue.s, luminosity = hue.l, hue = hue.h;
                }
            }
            saturation /= 100;
            luminosity /= 100;
            while (hue < 0) {
                hue += 360;
            }
            while (hue >= 360) {
                hue -= 360;
            }
            var r, g, b;
            if (hue < 120) {
                r = (120 - hue) / 60, g = hue / 60, b = 0;
            } else {
                if (hue < 240) {
                    r = 0, g = (240 - hue) / 60, b = (hue - 120) / 60;
                } else {
                    r = (hue - 240) / 60, g = 0, b = (360 - hue) / 60;
                }
            }
            r = 2 * saturation * Math.min(r, 1) + (1 - saturation);
            g = 2 * saturation * Math.min(g, 1) + (1 - saturation);
            b = 2 * saturation * Math.min(b, 1) + (1 - saturation);
            if (luminosity < 0.5) {
                r *= luminosity, g *= luminosity, b *= luminosity;
            } else {
                r = (1 - luminosity) * r + 2 * luminosity - 1;
                g = (1 - luminosity) * g + 2 * luminosity - 1;
                b = (1 - luminosity) * b + 2 * luminosity - 1;
            }
            return new Color({r:Math.round(r * 255), g:Math.round(g * 255), b:Math.round(b * 255)});
        }});
        cx.fromHsv = function (hue, saturation, value) {
            if (lang.isArray(hue)) {
                saturation = hue[1], value = hue[2], hue = hue[0];
            } else {
                if (lang.isObject(hue)) {
                    saturation = hue.s, value = hue.v, hue = hue.h;
                }
            }
            if (hue == 360) {
                hue = 0;
            }
            saturation /= 100;
            value /= 100;
            var r, g, b;
            if (saturation == 0) {
                r = value, b = value, g = value;
            } else {
                var hTemp = hue / 60, i = Math.floor(hTemp), f = hTemp - i;
                var p = value * (1 - saturation);
                var q = value * (1 - (saturation * f));
                var t = value * (1 - (saturation * (1 - f)));
                switch (i) {
                  case 0:
                    r = value, g = t, b = p;
                    break;
                  case 1:
                    r = q, g = value, b = p;
                    break;
                  case 2:
                    r = p, g = value, b = t;
                    break;
                  case 3:
                    r = p, g = q, b = value;
                    break;
                  case 4:
                    r = t, g = p, b = value;
                    break;
                  case 5:
                    r = value, g = p, b = q;
                    break;
                }
            }
            return new Color({r:Math.round(r * 255), g:Math.round(g * 255), b:Math.round(b * 255)});
        };
        lang.extend(Color, {toCmy:function () {
            var cyan = 1 - (this.r / 255), magenta = 1 - (this.g / 255), yellow = 1 - (this.b / 255);
            return {c:Math.round(cyan * 100), m:Math.round(magenta * 100), y:Math.round(yellow * 100)};
        }, toCmyk:function () {
            var cyan, magenta, yellow, black;
            var r = this.r / 255, g = this.g / 255, b = this.b / 255;
            black = Math.min(1 - r, 1 - g, 1 - b);
            cyan = (1 - r - black) / (1 - black);
            magenta = (1 - g - black) / (1 - black);
            yellow = (1 - b - black) / (1 - black);
            return {c:Math.round(cyan * 100), m:Math.round(magenta * 100), y:Math.round(yellow * 100), b:Math.round(black * 100)};
        }, toHsl:function () {
            var r = this.r / 255, g = this.g / 255, b = this.b / 255;
            var min = Math.min(r, b, g), max = Math.max(r, g, b);
            var delta = max - min;
            var h = 0, s = 0, l = (min + max) / 2;
            if (l > 0 && l < 1) {
                s = delta / ((l < 0.5) ? (2 * l) : (2 - 2 * l));
            }
            if (delta > 0) {
                if (max == r && max != g) {
                    h += (g - b) / delta;
                }
                if (max == g && max != b) {
                    h += (2 + (b - r) / delta);
                }
                if (max == b && max != r) {
                    h += (4 + (r - g) / delta);
                }
                h *= 60;
            }
            return {h:h, s:Math.round(s * 100), l:Math.round(l * 100)};
        }, toHsv:function () {
            var r = this.r / 255, g = this.g / 255, b = this.b / 255;
            var min = Math.min(r, b, g), max = Math.max(r, g, b);
            var delta = max - min;
            var h = null, s = (max == 0) ? 0 : (delta / max);
            if (s == 0) {
                h = 0;
            } else {
                if (r == max) {
                    h = 60 * (g - b) / delta;
                } else {
                    if (g == max) {
                        h = 120 + 60 * (b - r) / delta;
                    } else {
                        h = 240 + 60 * (r - g) / delta;
                    }
                }
                if (h < 0) {
                    h += 360;
                }
            }
            return {h:h, s:Math.round(s * 100), v:Math.round(max * 100)};
        }});
        return cx;
    });
}, "dijit/form/DateTextBox":function () {
    define(["dojo/_base/declare", "../Calendar", "./_DateTimeTextBox"], function (declare, Calendar, _DateTimeTextBox) {
        return declare("dijit.form.DateTextBox", _DateTimeTextBox, {baseClass:"dijitTextBox dijitComboBox dijitDateTextBox", popupClass:Calendar, _selector:"date", maxHeight:Infinity, value:new Date("")});
    });
}, "dojo/dom-geometry":function () {
    define(["./sniff", "./_base/window", "./dom", "./dom-style"], function (has, win, dom, style) {
        var geom = {};
        geom.boxModel = "content-box";
        if (has("ie")) {
            geom.boxModel = document.compatMode == "BackCompat" ? "border-box" : "content-box";
        }
        geom.getPadExtents = function getPadExtents(node, computedStyle) {
            node = dom.byId(node);
            var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue, l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
            return {l:l, t:t, r:r, b:b, w:l + r, h:t + b};
        };
        var none = "none";
        geom.getBorderExtents = function getBorderExtents(node, computedStyle) {
            node = dom.byId(node);
            var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node), l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0, t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0, r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0, b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
            return {l:l, t:t, r:r, b:b, w:l + r, h:t + b};
        };
        geom.getPadBorderExtents = function getPadBorderExtents(node, computedStyle) {
            node = dom.byId(node);
            var s = computedStyle || style.getComputedStyle(node), p = geom.getPadExtents(node, s), b = geom.getBorderExtents(node, s);
            return {l:p.l + b.l, t:p.t + b.t, r:p.r + b.r, b:p.b + b.b, w:p.w + b.w, h:p.h + b.h};
        };
        geom.getMarginExtents = function getMarginExtents(node, computedStyle) {
            node = dom.byId(node);
            var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue, l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
            return {l:l, t:t, r:r, b:b, w:l + r, h:t + b};
        };
        geom.getMarginBox = function getMarginBox(node, computedStyle) {
            node = dom.byId(node);
            var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s), l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
            if (has("mozilla")) {
                var sl = parseFloat(s.left), st = parseFloat(s.top);
                if (!isNaN(sl) && !isNaN(st)) {
                    l = sl;
                    t = st;
                } else {
                    if (p && p.style) {
                        pcs = style.getComputedStyle(p);
                        if (pcs.overflow != "visible") {
                            l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
                            t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
                        }
                    }
                }
            } else {
                if (has("opera") || (has("ie") == 8 && !has("quirks"))) {
                    if (p) {
                        pcs = style.getComputedStyle(p);
                        l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
                        t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
                    }
                }
            }
            return {l:l, t:t, w:node.offsetWidth + me.w, h:node.offsetHeight + me.h};
        };
        geom.getContentBox = function getContentBox(node, computedStyle) {
            node = dom.byId(node);
            var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h, pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
            if (!w) {
                w = node.offsetWidth;
                h = node.offsetHeight;
            } else {
                h = node.clientHeight;
                be.w = be.h = 0;
            }
            if (has("opera")) {
                pe.l += be.l;
                pe.t += be.t;
            }
            return {l:pe.l, t:pe.t, w:w - pe.w - be.w, h:h - pe.h - be.h};
        };
        function setBox(node, l, t, w, h, u) {
            u = u || "px";
            var s = node.style;
            if (!isNaN(l)) {
                s.left = l + u;
            }
            if (!isNaN(t)) {
                s.top = t + u;
            }
            if (w >= 0) {
                s.width = w + u;
            }
            if (h >= 0) {
                s.height = h + u;
            }
        }
        function isButtonTag(node) {
            return node.tagName.toLowerCase() == "button" || node.tagName.toLowerCase() == "input" && (node.getAttribute("type") || "").toLowerCase() == "button";
        }
        function usesBorderBox(node) {
            return geom.boxModel == "border-box" || node.tagName.toLowerCase() == "table" || isButtonTag(node);
        }
        geom.setContentSize = function setContentSize(node, box, computedStyle) {
            node = dom.byId(node);
            var w = box.w, h = box.h;
            if (usesBorderBox(node)) {
                var pb = geom.getPadBorderExtents(node, computedStyle);
                if (w >= 0) {
                    w += pb.w;
                }
                if (h >= 0) {
                    h += pb.h;
                }
            }
            setBox(node, NaN, NaN, w, h);
        };
        var nilExtents = {l:0, t:0, w:0, h:0};
        geom.setMarginBox = function setMarginBox(node, box, computedStyle) {
            node = dom.byId(node);
            var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h, pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s), mb = geom.getMarginExtents(node, s);
            if (has("webkit")) {
                if (isButtonTag(node)) {
                    var ns = node.style;
                    if (w >= 0 && !ns.width) {
                        ns.width = "4px";
                    }
                    if (h >= 0 && !ns.height) {
                        ns.height = "4px";
                    }
                }
            }
            if (w >= 0) {
                w = Math.max(w - pb.w - mb.w, 0);
            }
            if (h >= 0) {
                h = Math.max(h - pb.h - mb.h, 0);
            }
            setBox(node, box.l, box.t, w, h);
        };
        geom.isBodyLtr = function isBodyLtr(doc) {
            doc = doc || win.doc;
            return (win.body(doc).dir || doc.documentElement.dir || "ltr").toLowerCase() == "ltr";
        };
        geom.docScroll = function docScroll(doc) {
            doc = doc || win.doc;
            var node = win.doc.parentWindow || win.doc.defaultView;
            return "pageXOffset" in node ? {x:node.pageXOffset, y:node.pageYOffset} : (node = has("quirks") ? win.body(doc) : doc.documentElement) && {x:geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc), y:node.scrollTop || 0};
        };
        if (has("ie")) {
            geom.getIeDocumentElementOffset = function getIeDocumentElementOffset(doc) {
                doc = doc || win.doc;
                var de = doc.documentElement;
                if (has("ie") < 8) {
                    var r = de.getBoundingClientRect(), l = r.left, t = r.top;
                    if (has("ie") < 7) {
                        l += de.clientLeft;
                        t += de.clientTop;
                    }
                    return {x:l < 0 ? 0 : l, y:t < 0 ? 0 : t};
                } else {
                    return {x:0, y:0};
                }
            };
        }
        geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(scrollLeft, doc) {
            doc = doc || win.doc;
            var ie = has("ie");
            if (ie && !geom.isBodyLtr(doc)) {
                var qk = has("quirks"), de = qk ? win.body(doc) : doc.documentElement, pwin = win.global;
                if (ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight) {
                    scrollLeft += de.clientLeft;
                }
                return (ie < 8 || qk) ? (scrollLeft + de.clientWidth - de.scrollWidth) : -scrollLeft;
            }
            return scrollLeft;
        };
        geom.position = function (node, includeScroll) {
            node = dom.byId(node);
            var db = win.body(node.ownerDocument), ret = node.getBoundingClientRect();
            ret = {x:ret.left, y:ret.top, w:ret.right - ret.left, h:ret.bottom - ret.top};
            if (has("ie") < 9) {
                var offset = geom.getIeDocumentElementOffset(node.ownerDocument);
                ret.x -= offset.x + (has("quirks") ? db.clientLeft + db.offsetLeft : 0);
                ret.y -= offset.y + (has("quirks") ? db.clientTop + db.offsetTop : 0);
            }
            if (includeScroll) {
                var scroll = geom.docScroll(node.ownerDocument);
                ret.x += scroll.x;
                ret.y += scroll.y;
            }
            return ret;
        };
        geom.getMarginSize = function getMarginSize(node, computedStyle) {
            node = dom.byId(node);
            var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
            var size = node.getBoundingClientRect();
            return {w:(size.right - size.left) + me.w, h:(size.bottom - size.top) + me.h};
        };
        geom.normalizeEvent = function (event) {
            if (!("layerX" in event)) {
                event.layerX = event.offsetX;
                event.layerY = event.offsetY;
            }
            if (!has("dom-addeventlistener")) {
                var se = event.target;
                var doc = (se && se.ownerDocument) || document;
                var docBody = has("quirks") ? doc.body : doc.documentElement;
                var offset = geom.getIeDocumentElementOffset(doc);
                event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;
                event.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;
            }
        };
        return geom;
    });
}, "dijit/form/_FormValueMixin":function () {
    define(["dojo/_base/declare", "dojo/dom-attr", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/sniff", "./_FormWidgetMixin"], function (declare, domAttr, keys, lang, on, has, _FormWidgetMixin) {
        return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {readOnly:false, _setReadOnlyAttr:function (value) {
            domAttr.set(this.focusNode, "readOnly", value);
            this._set("readOnly", value);
        }, postCreate:function () {
            this.inherited(arguments);
            if (this._resetValue === undefined) {
                this._lastValueReported = this._resetValue = this.value;
            }
        }, _setValueAttr:function (newValue, priorityChange) {
            this._handleOnChange(newValue, priorityChange);
        }, _handleOnChange:function (newValue, priorityChange) {
            this._set("value", newValue);
            this.inherited(arguments);
        }, undo:function () {
            this._setValueAttr(this._lastValueReported, false);
        }, reset:function () {
            this._hasBeenBlurred = false;
            this._setValueAttr(this._resetValue, true);
        }});
    });
}, "dojo/date/stamp":function () {
    define(["../_base/lang", "../_base/array"], function (lang, array) {
        var stamp = {};
        lang.setObject("dojo.date.stamp", stamp);
        stamp.fromISOString = function (formattedString, defaultTime) {
            if (!stamp._isoRegExp) {
                stamp._isoRegExp = /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
            }
            var match = stamp._isoRegExp.exec(formattedString), result = null;
            if (match) {
                match.shift();
                if (match[1]) {
                    match[1]--;
                }
                if (match[6]) {
                    match[6] *= 1000;
                }
                if (defaultTime) {
                    defaultTime = new Date(defaultTime);
                    array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function (prop) {
                        return defaultTime["get" + prop]();
                    }), function (value, index) {
                        match[index] = match[index] || value;
                    });
                }
                result = new Date(match[0] || 1970, match[1] || 0, match[2] || 1, match[3] || 0, match[4] || 0, match[5] || 0, match[6] || 0);
                if (match[0] < 100) {
                    result.setFullYear(match[0] || 1970);
                }
                var offset = 0, zoneSign = match[7] && match[7].charAt(0);
                if (zoneSign != "Z") {
                    offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
                    if (zoneSign != "-") {
                        offset *= -1;
                    }
                }
                if (zoneSign) {
                    offset -= result.getTimezoneOffset();
                }
                if (offset) {
                    result.setTime(result.getTime() + offset * 60000);
                }
            }
            return result;
        };
        stamp.toISOString = function (dateObject, options) {
            var _ = function (n) {
                return (n < 10) ? "0" + n : n;
            };
            options = options || {};
            var formattedDate = [], getter = options.zulu ? "getUTC" : "get", date = "";
            if (options.selector != "time") {
                var year = dateObject[getter + "FullYear"]();
                date = ["0000".substr((year + "").length) + year, _(dateObject[getter + "Month"]() + 1), _(dateObject[getter + "Date"]())].join("-");
            }
            formattedDate.push(date);
            if (options.selector != "date") {
                var time = [_(dateObject[getter + "Hours"]()), _(dateObject[getter + "Minutes"]()), _(dateObject[getter + "Seconds"]())].join(":");
                var millis = dateObject[getter + "Milliseconds"]();
                if (options.milliseconds) {
                    time += "." + (millis < 100 ? "0" : "") + _(millis);
                }
                if (options.zulu) {
                    time += "Z";
                } else {
                    if (options.selector != "time") {
                        var timezoneOffset = dateObject.getTimezoneOffset();
                        var absOffset = Math.abs(timezoneOffset);
                        time += (timezoneOffset > 0 ? "-" : "+") + _(Math.floor(absOffset / 60)) + ":" + _(absOffset % 60);
                    }
                }
                formattedDate.push(time);
            }
            return formattedDate.join("T");
        };
        return stamp;
    });
}, "dijit/layout/AccordionPane":function () {
    define(["dojo/_base/declare", "dojo/_base/kernel", "./ContentPane"], function (declare, kernel, ContentPane) {
        return declare("dijit.layout.AccordionPane", ContentPane, {constructor:function () {
            kernel.deprecated("dijit.layout.AccordionPane deprecated, use ContentPane instead", "", "2.0");
        }, onSelected:function () {
        }});
    });
}, "dojox/grid/_TreeView":function () {
    define(["dijit/registry", "../main", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/event", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-style", "dojo/dom-construct", "dojo/query", "dojo/parser", "dojo/text!./resources/Expando.html", "dijit/_Widget", "dijit/_TemplatedMixin", "./_View", "./_Builder", "./util"], function (dijit, dojox, declare, array, lang, event, domAttr, domClass, domStyle, domCtr, query, parser, template, _Widget, _TemplatedMixin, _View, _Builder, util) {
        declare("dojox.grid._Expando", [_Widget, _TemplatedMixin], {open:false, toggleClass:"", itemId:"", cellIdx:-1, view:null, rowNode:null, rowIdx:-1, expandoCell:null, level:0, templateString:template, _toggleRows:function (toggleClass, open) {
            if (!toggleClass || !this.rowNode) {
                return;
            }
            if (query("table.dojoxGridRowTableNeedsRowUpdate").length) {
                if (this._initialized) {
                    this.view.grid.updateRow(this.rowIdx);
                }
                return;
            }
            var self = this;
            var g = this.view.grid;
            if (g.treeModel) {
                var p = this._tableRow ? domAttr.get(this._tableRow, "dojoxTreeGridPath") : "";
                if (p) {
                    query("tr[dojoxTreeGridPath^=\"" + p + "/\"]", this.rowNode).forEach(function (n) {
                        var en = query(".dojoxGridExpando", n)[0];
                        if (en && en.parentNode && en.parentNode.parentNode && !domClass.contains(en.parentNode.parentNode, "dojoxGridNoChildren")) {
                            var ew = dijit.byNode(en);
                            if (ew) {
                                ew._toggleRows(toggleClass, ew.open && open);
                            }
                        }
                        n.style.display = open ? "" : "none";
                    });
                }
            } else {
                query("tr." + toggleClass, this.rowNode).forEach(function (n) {
                    if (domClass.contains(n, "dojoxGridExpandoRow")) {
                        var en = query(".dojoxGridExpando", n)[0];
                        if (en) {
                            var ew = dijit.byNode(en);
                            var toggleClass = ew ? ew.toggleClass : en.getAttribute("toggleClass");
                            var wOpen = ew ? ew.open : self.expandoCell.getOpenState(en.getAttribute("itemId"));
                            self._toggleRows(toggleClass, wOpen && open);
                        }
                    }
                    n.style.display = open ? "" : "none";
                });
            }
        }, setOpen:function (open) {
            if (open && domClass.contains(this.domNode, "dojoxGridExpandoLoading")) {
                open = false;
            }
            var view = this.view;
            var grid = view.grid;
            var store = grid.store;
            var treeModel = grid.treeModel;
            var d = this;
            var idx = this.rowIdx;
            var me = grid._by_idx[idx];
            if (!me) {
                return;
            }
            if (treeModel && !this._loadedChildren) {
                if (open) {
                    var itm = grid.getItem(domAttr.get(this._tableRow, "dojoxTreeGridPath"));
                    if (itm) {
                        this.expandoInner.innerHTML = "o";
                        domClass.add(this.domNode, "dojoxGridExpandoLoading");
                        treeModel.getChildren(itm, function (items) {
                            d._loadedChildren = true;
                            d._setOpen(open);
                        });
                    } else {
                        this._setOpen(open);
                    }
                } else {
                    this._setOpen(open);
                }
            } else {
                if (!treeModel && store) {
                    if (open) {
                        var data = grid._by_idx[this.rowIdx];
                        if (data && !store.isItemLoaded(data.item)) {
                            this.expandoInner.innerHTML = "o";
                            domClass.add(this.domNode, "dojoxGridExpandoLoading");
                            store.loadItem({item:data.item, onItem:lang.hitch(this, function (i) {
                                var idty = store.getIdentity(i);
                                grid._by_idty[idty] = grid._by_idx[this.rowIdx] = {idty:idty, item:i};
                                this._setOpen(open);
                            })});
                        } else {
                            this._setOpen(open);
                        }
                    } else {
                        this._setOpen(open);
                    }
                } else {
                    this._setOpen(open);
                }
            }
        }, _setOpen:function (open) {
            if (open && this._tableRow && domClass.contains(this._tableRow, "dojoxGridNoChildren")) {
                this._setOpen(false);
                return;
            }
            this.expandoInner.innerHTML = open ? "-" : "+";
            domClass.remove(this.domNode, "dojoxGridExpandoLoading");
            domClass.toggle(this.domNode, "dojoxGridExpandoOpened", open);
            if (this._tableRow) {
                domClass.toggle(this._tableRow, "dojoxGridRowCollapsed", !open);
                var base = domAttr.get(this._tableRow, "dojoxTreeGridBaseClasses");
                var new_base = "";
                if (open) {
                    new_base = lang.trim((" " + base + " ").replace(" dojoxGridRowCollapsed ", " "));
                } else {
                    if ((" " + base + " ").indexOf(" dojoxGridRowCollapsed ") < 0) {
                        new_base = base + (base ? " " : "") + "dojoxGridRowCollapsed";
                    } else {
                        new_base = base;
                    }
                }
                domAttr.set(this._tableRow, "dojoxTreeGridBaseClasses", new_base);
            }
            var changed = (this.open !== open);
            this.open = open;
            if (this.expandoCell && this.itemId) {
                this.expandoCell.openStates[this.itemId] = open;
            }
            var v = this.view;
            var g = v.grid;
            if (this.toggleClass && changed) {
                if (!this._tableRow || !this._tableRow.style.display) {
                    this._toggleRows(this.toggleClass, open);
                }
            }
            if (v && this._initialized && this.rowIdx >= 0) {
                g.rowHeightChanged(this.rowIdx);
                g.postresize();
                v.hasVScrollbar(true);
            }
            this._initialized = true;
        }, onToggle:function (e) {
            this.setOpen(!this.open);
            event.stop(e);
        }, setRowNode:function (rowIdx, rowNode, view) {
            if (this.cellIdx < 0 || !this.itemId) {
                return false;
            }
            this._initialized = false;
            this.view = view;
            this.rowNode = rowNode;
            this.rowIdx = rowIdx;
            this.expandoCell = view.structure.cells[0][this.cellIdx];
            var d = this.domNode;
            if (d && d.parentNode && d.parentNode.parentNode) {
                this._tableRow = d.parentNode.parentNode;
            }
            this.open = this.expandoCell.getOpenState(this.itemId);
            if (view.grid.treeModel) {
                domStyle.set(this.domNode, "marginLeft", (this.level * 18) + "px");
                if (this.domNode.parentNode) {
                    domStyle.set(this.domNode.parentNode, "backgroundPosition", ((this.level * 18) + (3)) + "px");
                }
            }
            this.setOpen(this.open);
            return true;
        }});
        var _TreeContentBuilder = declare("dojox.grid._TreeContentBuilder", _Builder._ContentBuilder, {generateHtml:function (inDataIndex, inRowIndex) {
            var html = this.getTableArray(), v = this.view, row = v.structure.cells[0], item = this.grid.getItem(inRowIndex), grid = this.grid, store = this.grid.store;
            util.fire(this.view, "onBeforeRow", [inRowIndex, [row]]);
            var createRow = function (level, rowItem, summaryRow, toggleClasses, rowStack, shown) {
                if (!shown) {
                    if (html[0].indexOf("dojoxGridRowTableNeedsRowUpdate") == -1) {
                        html[0] = html[0].replace("dojoxGridRowTable", "dojoxGridRowTable dojoxGridRowTableNeedsRowUpdate");
                    }
                    return;
                }
                var rowNodeIdx = html.length;
                toggleClasses = toggleClasses || [];
                var tcJoin = toggleClasses.join("|");
                var tcString = toggleClasses[toggleClasses.length - 1];
                var clString = tcString + (summaryRow ? " dojoxGridSummaryRow" : "");
                var sString = "";
                if (grid.treeModel && rowItem && !grid.treeModel.mayHaveChildren(rowItem)) {
                    clString += " dojoxGridNoChildren";
                }
                html.push("<tr style=\"" + sString + "\" class=\"" + clString + "\" dojoxTreeGridPath=\"" + rowStack.join("/") + "\" dojoxTreeGridBaseClasses=\"" + clString + "\">");
                var nextLevel = level + 1;
                var parentCell = null;
                for (var i = 0, cell; (cell = row[i]); i++) {
                    var m = cell.markup, cc = cell.customClasses = [], cs = cell.customStyles = [];
                    m[5] = cell.formatAtLevel(rowStack, rowItem, level, summaryRow, tcString, cc);
                    m[1] = cc.join(" ");
                    m[3] = cs.join(";");
                    html.push.apply(html, m);
                    if (!parentCell && cell.level === nextLevel && cell.parentCell) {
                        parentCell = cell.parentCell;
                    }
                }
                html.push("</tr>");
                if (rowItem && store && store.isItem(rowItem)) {
                    var idty = store.getIdentity(rowItem);
                    if (typeof grid._by_idty_paths[idty] == "undefined") {
                        grid._by_idty_paths[idty] = rowStack.join("/");
                    }
                }
                var expandoCell;
                var parentOpen;
                var path;
                var values;
                var iStack = rowStack.concat([]);
                if (grid.treeModel && rowItem) {
                    if (grid.treeModel.mayHaveChildren(rowItem)) {
                        expandoCell = v.structure.cells[0][grid.expandoCell || 0];
                        parentOpen = expandoCell.getOpenState(rowItem) && shown;
                        path = new dojox.grid.TreePath(rowStack.join("/"), grid);
                        values = path.children(true) || [];
                        array.forEach(values, function (cItm, idx) {
                            var nToggle = tcJoin.split("|");
                            nToggle.push(nToggle[nToggle.length - 1] + "-" + idx);
                            iStack.push(idx);
                            createRow(nextLevel, cItm, false, nToggle, iStack, parentOpen);
                            iStack.pop();
                        });
                    }
                } else {
                    if (rowItem && parentCell && !summaryRow) {
                        expandoCell = v.structure.cells[0][parentCell.level];
                        parentOpen = expandoCell.getOpenState(rowItem) && shown;
                        if (store.hasAttribute(rowItem, parentCell.field)) {
                            var tToggle = tcJoin.split("|");
                            tToggle.pop();
                            path = new dojox.grid.TreePath(rowStack.join("/"), grid);
                            values = path.children(true) || [];
                            if (values.length) {
                                html[rowNodeIdx] = "<tr class=\"" + tToggle.join(" ") + " dojoxGridExpandoRow\" dojoxTreeGridPath=\"" + rowStack.join("/") + "\">";
                                array.forEach(values, function (cItm, idx) {
                                    var nToggle = tcJoin.split("|");
                                    nToggle.push(nToggle[nToggle.length - 1] + "-" + idx);
                                    iStack.push(idx);
                                    createRow(nextLevel, cItm, false, nToggle, iStack, parentOpen);
                                    iStack.pop();
                                });
                                iStack.push(values.length);
                                createRow(level, rowItem, true, toggleClasses, iStack, parentOpen);
                            } else {
                                html[rowNodeIdx] = "<tr class=\"" + tcString + " dojoxGridNoChildren\" dojoxTreeGridPath=\"" + rowStack.join("/") + "\">";
                            }
                        } else {
                            if (!store.isItemLoaded(rowItem)) {
                                html[0] = html[0].replace("dojoxGridRowTable", "dojoxGridRowTable dojoxGridRowTableNeedsRowUpdate");
                            } else {
                                html[rowNodeIdx] = "<tr class=\"" + tcString + " dojoxGridNoChildren\" dojoxTreeGridPath=\"" + rowStack.join("/") + "\">";
                            }
                        }
                    } else {
                        if (rowItem && !summaryRow && toggleClasses.length > 1) {
                            html[rowNodeIdx] = "<tr class=\"" + toggleClasses[toggleClasses.length - 2] + "\" dojoxTreeGridPath=\"" + rowStack.join("/") + "\">";
                        }
                    }
                }
            };
            createRow(0, item, false, ["dojoxGridRowToggle-" + inRowIndex], [inRowIndex], true);
            html.push("</table>");
            return html.join("");
        }, findTarget:function (inSource, inTag) {
            var n = inSource;
            while (n && (n != this.domNode)) {
                if (n.tagName && n.tagName.toLowerCase() == "tr") {
                    break;
                }
                n = n.parentNode;
            }
            return (n != this.domNode) ? n : null;
        }, getCellNode:function (inRowNode, inCellIndex) {
            var node = query("td[idx='" + inCellIndex + "']", inRowNode)[0];
            if (node && node.parentNode && !domClass.contains(node.parentNode, "dojoxGridSummaryRow")) {
                return node;
            }
        }, decorateEvent:function (e) {
            e.rowNode = this.findRowTarget(e.target);
            if (!e.rowNode) {
                return false;
            }
            e.rowIndex = domAttr.get(e.rowNode, "dojoxTreeGridPath");
            this.baseDecorateEvent(e);
            e.cell = this.grid.getCell(e.cellIndex);
            return true;
        }});
        return declare("dojox.grid._TreeView", _View, {_contentBuilderClass:_TreeContentBuilder, _onDndDrop:function (source, nodes, copy) {
            if (this.grid && this.grid.aggregator) {
                this.grid.aggregator.clearSubtotalCache();
            }
            this.inherited(arguments);
        }, postCreate:function () {
            this.inherited(arguments);
            this.connect(this.grid, "_cleanupExpandoCache", "_cleanupExpandoCache");
        }, _cleanupExpandoCache:function (index, identity, item) {
            if (index == -1) {
                return;
            }
            array.forEach(this.grid.layout.cells, function (cell) {
                if (typeof cell["openStates"] != "undefined") {
                    if (identity in cell.openStates) {
                        delete cell.openStates[identity];
                    }
                }
            });
            if (typeof index == "string" && index.indexOf("/") > -1) {
                var path = new dojox.grid.TreePath(index, this.grid);
                var ppath = path.parent();
                while (ppath) {
                    path = ppath;
                    ppath = path.parent();
                }
                var pitem = path.item();
                if (!pitem) {
                    return;
                }
                var idty = this.grid.store.getIdentity(pitem);
                if (typeof this._expandos[idty] != "undefined") {
                    for (var i in this._expandos[idty]) {
                        var exp = this._expandos[idty][i];
                        if (exp) {
                            exp.destroy();
                        }
                        delete this._expandos[idty][i];
                    }
                    delete this._expandos[idty];
                }
            } else {
                for (var i in this._expandos) {
                    if (typeof this._expandos[i] != "undefined") {
                        for (var j in this._expandos[i]) {
                            var exp = this._expandos[i][j];
                            if (exp) {
                                exp.destroy();
                            }
                        }
                    }
                }
                this._expandos = {};
            }
        }, postMixInProperties:function () {
            this.inherited(arguments);
            this._expandos = {};
        }, onBeforeRow:function (inRowIndex, cells) {
            var g = this.grid;
            if (g._by_idx && g._by_idx[inRowIndex] && g._by_idx[inRowIndex].idty) {
                var idty = g._by_idx[inRowIndex].idty;
                this._expandos[idty] = this._expandos[idty] || {};
            }
            this.inherited(arguments);
        }, onAfterRow:function (inRowIndex, cells, inRowNode) {
            array.forEach(query("span.dojoxGridExpando", inRowNode), function (n) {
                if (n && n.parentNode) {
                    var tc = n.getAttribute("toggleClass");
                    var idty;
                    var expando;
                    var g = this.grid;
                    if (g._by_idx && g._by_idx[inRowIndex] && g._by_idx[inRowIndex].idty) {
                        idty = g._by_idx[inRowIndex].idty;
                        expando = this._expandos[idty][tc];
                    }
                    if (expando) {
                        domCtr.place(expando.domNode, n, "replace");
                        expando.itemId = n.getAttribute("itemId");
                        expando.cellIdx = parseInt(n.getAttribute("cellIdx"), 10);
                        if (isNaN(expando.cellIdx)) {
                            expando.cellIdx = -1;
                        }
                    } else {
                        if (idty) {
                            expando = parser.parse(n.parentNode)[0];
                            this._expandos[idty][tc] = expando;
                        }
                    }
                    if (expando && !expando.setRowNode(inRowIndex, inRowNode, this)) {
                        expando.domNode.parentNode.removeChild(expando.domNode);
                    }
                }
            }, this);
            var alt = false;
            var self = this;
            query("tr[dojoxTreeGridPath]", inRowNode).forEach(function (n) {
                domClass.toggle(n, "dojoxGridSubRowAlt", alt);
                domAttr.set(n, "dojoxTreeGridBaseClasses", n.className);
                alt = !alt;
                self.grid.rows.styleRowNode(domAttr.get(n, "dojoxTreeGridPath"), n);
            });
            this.inherited(arguments);
        }, updateRowStyles:function (inRowIndex) {
            var rowNodes = query("tr[dojoxTreeGridPath='" + inRowIndex + "']", this.domNode);
            if (rowNodes.length) {
                this.styleRowNode(inRowIndex, rowNodes[0]);
            }
        }, getCellNode:function (inRowIndex, inCellIndex) {
            var row = query("tr[dojoxTreeGridPath='" + inRowIndex + "']", this.domNode)[0];
            if (row) {
                return this.content.getCellNode(row, inCellIndex);
            }
        }, destroy:function () {
            this._cleanupExpandoCache();
            this.inherited(arguments);
        }});
    });
}, "dijit/form/_AutoCompleterMixin":function () {
    define(["dojo/aspect", "dojo/_base/declare", "dojo/dom-attr", "dojo/keys", "dojo/_base/lang", "dojo/query", "dojo/regexp", "dojo/sniff", "./DataList", "./_TextBoxMixin", "./_SearchMixin"], function (aspect, declare, domAttr, keys, lang, query, regexp, has, DataList, _TextBoxMixin, SearchMixin) {
        var AutoCompleterMixin = declare("dijit.form._AutoCompleterMixin", SearchMixin, {item:null, autoComplete:true, highlightMatch:"first", labelAttr:"", labelType:"text", maxHeight:-1, _stopClickEvents:false, _getCaretPos:function (element) {
            var pos = 0;
            if (typeof (element.selectionStart) == "number") {
                pos = element.selectionStart;
            } else {
                if (has("ie")) {
                    var tr = element.ownerDocument.selection.createRange().duplicate();
                    var ntr = element.createTextRange();
                    tr.move("character", 0);
                    ntr.move("character", 0);
                    try {
                        ntr.setEndPoint("EndToEnd", tr);
                        pos = String(ntr.text).replace(/\r/g, "").length;
                    }
                    catch (e) {
                    }
                }
            }
            return pos;
        }, _setCaretPos:function (element, location) {
            location = parseInt(location);
            _TextBoxMixin.selectInputText(element, location, location);
        }, _setDisabledAttr:function (value) {
            this.inherited(arguments);
            this.domNode.setAttribute("aria-disabled", value ? "true" : "false");
        }, _onKey:function (evt) {
            if (evt.charCode >= 32) {
                return;
            }
            var key = evt.charCode || evt.keyCode;
            if (key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT) {
                return;
            }
            var pw = this.dropDown;
            var highlighted = null;
            this._abortQuery();
            this.inherited(arguments);
            if (evt.altKey || evt.ctrlKey || evt.metaKey) {
                return;
            }
            if (this._opened) {
                highlighted = pw.getHighlightedOption();
            }
            switch (key) {
              case keys.PAGE_DOWN:
              case keys.DOWN_ARROW:
              case keys.PAGE_UP:
              case keys.UP_ARROW:
                if (this._opened) {
                    this._announceOption(highlighted);
                }
                evt.stopPropagation();
                evt.preventDefault();
                break;
              case keys.ENTER:
                if (highlighted) {
                    if (highlighted == pw.nextButton) {
                        this._nextSearch(1);
                        evt.stopPropagation();
                        evt.preventDefault();
                        break;
                    } else {
                        if (highlighted == pw.previousButton) {
                            this._nextSearch(-1);
                            evt.stopPropagation();
                            evt.preventDefault();
                            break;
                        }
                    }
                    evt.stopPropagation();
                    evt.preventDefault();
                } else {
                    this._setBlurValue();
                    this._setCaretPos(this.focusNode, this.focusNode.value.length);
                }
              case keys.TAB:
                var newvalue = this.get("displayedValue");
                if (pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])) {
                    break;
                }
                if (highlighted) {
                    this._selectOption(highlighted);
                }
              case keys.ESCAPE:
                if (this._opened) {
                    this._lastQuery = null;
                    this.closeDropDown();
                }
                break;
            }
        }, _autoCompleteText:function (text) {
            var fn = this.focusNode;
            _TextBoxMixin.selectInputText(fn, fn.value.length);
            var caseFilter = this.ignoreCase ? "toLowerCase" : "substr";
            if (text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0) {
                var cpos = this.autoComplete ? this._getCaretPos(fn) : fn.value.length;
                if ((cpos + 1) > fn.value.length) {
                    fn.value = text;
                    _TextBoxMixin.selectInputText(fn, cpos);
                }
            } else {
                fn.value = text;
                _TextBoxMixin.selectInputText(fn);
            }
        }, _openResultList:function (results, query, options) {
            var wasSelected = this.dropDown.getHighlightedOption();
            this.dropDown.clearResultList();
            if (!results.length && options.start == 0) {
                this.closeDropDown();
                return;
            }
            this._nextSearch = this.dropDown.onPage = lang.hitch(this, function (direction) {
                results.nextPage(direction !== -1);
                this.focus();
            });
            this.dropDown.createOptions(results, options, lang.hitch(this, "_getMenuLabelFromItem"));
            this._showResultList();
            if ("direction" in options) {
                if (options.direction) {
                    this.dropDown.highlightFirstOption();
                } else {
                    if (!options.direction) {
                        this.dropDown.highlightLastOption();
                    }
                }
                if (wasSelected) {
                    this._announceOption(this.dropDown.getHighlightedOption());
                }
            } else {
                if (this.autoComplete && !this._prev_key_backspace && !/^[*]+$/.test(query[this.searchAttr].toString())) {
                    this._announceOption(this.dropDown.containerNode.firstChild.nextSibling);
                }
            }
        }, _showResultList:function () {
            this.closeDropDown(true);
            this.openDropDown();
            this.domNode.setAttribute("aria-expanded", "true");
        }, loadDropDown:function () {
            this._startSearchAll();
        }, isLoaded:function () {
            return false;
        }, closeDropDown:function () {
            this._abortQuery();
            if (this._opened) {
                this.inherited(arguments);
                this.domNode.setAttribute("aria-expanded", "false");
            }
        }, _setBlurValue:function () {
            var newvalue = this.get("displayedValue");
            var pw = this.dropDown;
            if (pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])) {
                this._setValueAttr(this._lastValueReported, true);
            } else {
                if (typeof this.item == "undefined") {
                    this.item = null;
                    this.set("displayedValue", newvalue);
                } else {
                    if (this.value != this._lastValueReported) {
                        this._handleOnChange(this.value, true);
                    }
                    this._refreshState();
                }
            }
            this.focusNode.removeAttribute("aria-activedescendant");
        }, _setItemAttr:function (item, priorityChange, displayedValue) {
            var value = "";
            if (item) {
                if (!displayedValue) {
                    displayedValue = this.store._oldAPI ? this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
                }
                value = this._getValueField() != this.searchAttr ? this.store.getIdentity(item) : displayedValue;
            }
            this.set("value", value, priorityChange, displayedValue, item);
        }, _announceOption:function (node) {
            if (!node) {
                return;
            }
            var newValue;
            if (node == this.dropDown.nextButton || node == this.dropDown.previousButton) {
                newValue = node.innerHTML;
                this.item = undefined;
                this.value = "";
            } else {
                var item = this.dropDown.items[node.getAttribute("item")];
                newValue = (this.store._oldAPI ? this.store.getValue(item, this.searchAttr) : item[this.searchAttr]).toString();
                this.set("item", item, false, newValue);
            }
            this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
            this.focusNode.setAttribute("aria-activedescendant", domAttr.get(node, "id"));
            this._autoCompleteText(newValue);
        }, _selectOption:function (target) {
            this.closeDropDown();
            if (target) {
                this._announceOption(target);
            }
            this._setCaretPos(this.focusNode, this.focusNode.value.length);
            this._handleOnChange(this.value, true);
            this.focusNode.removeAttribute("aria-activedescendant");
        }, _startSearchAll:function () {
            this._startSearch("");
        }, _startSearchFromInput:function () {
            this.item = undefined;
            this.inherited(arguments);
        }, _startSearch:function (key) {
            if (!this.dropDown) {
                var popupId = this.id + "_popup", dropDownConstructor = lang.isString(this.dropDownClass) ? lang.getObject(this.dropDownClass, false) : this.dropDownClass;
                this.dropDown = new dropDownConstructor({onChange:lang.hitch(this, this._selectOption), id:popupId, dir:this.dir, textDir:this.textDir});
            }
            this._lastInput = key;
            this.inherited(arguments);
        }, _getValueField:function () {
            return this.searchAttr;
        }, postMixInProperties:function () {
            this.inherited(arguments);
            if (!this.store) {
                var srcNodeRef = this.srcNodeRef;
                this.store = new DataList({}, srcNodeRef);
                if (!("value" in this.params)) {
                    var item = (this.item = this.store.fetchSelectedItem());
                    if (item) {
                        var valueField = this._getValueField();
                        this.value = this.store._oldAPI ? this.store.getValue(item, valueField) : item[valueField];
                    }
                }
            }
        }, postCreate:function () {
            var label = query("label[for=\"" + this.id + "\"]");
            if (label.length) {
                if (!label[0].id) {
                    label[0].id = this.id + "_label";
                }
                this.domNode.setAttribute("aria-labelledby", label[0].id);
            }
            this.inherited(arguments);
            aspect.after(this, "onSearch", lang.hitch(this, "_openResultList"), true);
        }, _getMenuLabelFromItem:function (item) {
            var label = this.labelFunc(item, this.store), labelType = this.labelType;
            if (this.highlightMatch != "none" && this.labelType == "text" && this._lastInput) {
                label = this.doHighlight(label, this._lastInput);
                labelType = "html";
            }
            return {html:labelType == "html", label:label};
        }, doHighlight:function (label, find) {
            var modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""), i = this.queryExpr.indexOf("${0}");
            find = regexp.escapeString(find);
            return this._escapeHtml(label.replace(new RegExp((i == 0 ? "^" : "") + "(" + find + ")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers), "\uffff$1\uffff")).replace(/\uFFFF([^\uFFFF]+)\uFFFF/g, "<span class=\"dijitComboBoxHighlightMatch\">$1</span>");
        }, _escapeHtml:function (str) {
            str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
            return str;
        }, reset:function () {
            this.item = null;
            this.inherited(arguments);
        }, labelFunc:function (item, store) {
            return (store._oldAPI ? store.getValue(item, this.labelAttr || this.searchAttr) : item[this.labelAttr || this.searchAttr]).toString();
        }, _setValueAttr:function (value, priorityChange, displayedValue, item) {
            this._set("item", item || null);
            if (value == null) {
                value = "";
            }
            this.inherited(arguments);
        }});
        if (has("dojo-bidi")) {
            AutoCompleterMixin.extend({_setTextDirAttr:function (textDir) {
                this.inherited(arguments);
                if (this.dropDown) {
                    this.dropDown._set("textDir", textDir);
                }
            }});
        }
        return AutoCompleterMixin;
    });
}, "dijit/TitlePane":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-geometry", "dojo/fx", "dojo/has", "dojo/_base/kernel", "dojo/keys", "./_CssStateMixin", "./_TemplatedMixin", "./layout/ContentPane", "dojo/text!./templates/TitlePane.html", "./_base/manager", "./a11yclick"], function (array, declare, dom, domAttr, domClass, domGeometry, fxUtils, has, kernel, keys, _CssStateMixin, _TemplatedMixin, ContentPane, template, manager) {
        var TitlePane = declare("dijit.TitlePane", [ContentPane, _TemplatedMixin, _CssStateMixin], {title:"", _setTitleAttr:{node:"titleNode", type:"innerHTML"}, open:true, toggleable:true, tabIndex:"0", duration:manager.defaultDuration, baseClass:"dijitTitlePane", templateString:template, doLayout:false, _setTooltipAttr:{node:"focusNode", type:"attribute", attribute:"title"}, buildRendering:function () {
            this.inherited(arguments);
            dom.setSelectable(this.titleNode, false);
        }, postCreate:function () {
            this.inherited(arguments);
            if (this.toggleable) {
                this._trackMouseState(this.titleBarNode, this.baseClass + "Title");
            }
            var hideNode = this.hideNode, wipeNode = this.wipeNode;
            this._wipeIn = fxUtils.wipeIn({node:wipeNode, duration:this.duration, beforeBegin:function () {
                hideNode.style.display = "";
            }});
            this._wipeOut = fxUtils.wipeOut({node:wipeNode, duration:this.duration, onEnd:function () {
                hideNode.style.display = "none";
            }});
        }, _setOpenAttr:function (open, animate) {
            array.forEach([this._wipeIn, this._wipeOut], function (animation) {
                if (animation && animation.status() == "playing") {
                    animation.stop();
                }
            });
            if (animate) {
                var anim = this[open ? "_wipeIn" : "_wipeOut"];
                anim.play();
            } else {
                this.hideNode.style.display = this.wipeNode.style.display = open ? "" : "none";
            }
            if (this._started) {
                if (open) {
                    this._onShow();
                } else {
                    this.onHide();
                }
            }
            this.containerNode.setAttribute("aria-hidden", open ? "false" : "true");
            this.focusNode.setAttribute("aria-pressed", open ? "true" : "false");
            this._set("open", open);
            this._setCss();
        }, _setToggleableAttr:function (canToggle) {
            this.focusNode.setAttribute("role", canToggle ? "button" : "heading");
            if (canToggle) {
                this.focusNode.setAttribute("aria-controls", this.id + "_pane");
                this.focusNode.setAttribute("tabIndex", this.tabIndex);
                this.focusNode.setAttribute("aria-pressed", this.open);
            } else {
                domAttr.remove(this.focusNode, "aria-controls");
                domAttr.remove(this.focusNode, "tabIndex");
                domAttr.remove(this.focusNode, "aria-pressed");
            }
            this._set("toggleable", canToggle);
            this._setCss();
        }, _setContentAttr:function (content) {
            if (!this.open || !this._wipeOut || this._wipeOut.status() == "playing") {
                this.inherited(arguments);
            } else {
                if (this._wipeIn && this._wipeIn.status() == "playing") {
                    this._wipeIn.stop();
                }
                domGeometry.setMarginBox(this.wipeNode, {h:domGeometry.getMarginBox(this.wipeNode).h});
                this.inherited(arguments);
                if (this._wipeIn) {
                    this._wipeIn.play();
                } else {
                    this.hideNode.style.display = "";
                }
            }
        }, toggle:function () {
            this._setOpenAttr(!this.open, true);
        }, _setCss:function () {
            var node = this.titleBarNode || this.focusNode;
            var oldCls = this._titleBarClass;
            this._titleBarClass = this.baseClass + "Title" + (this.toggleable ? "" : "Fixed") + (this.open ? "Open" : "Closed");
            domClass.replace(node, this._titleBarClass, oldCls || "");
            domClass.replace(node, this._titleBarClass.replace("TitlePaneTitle", ""), (oldCls || "").replace("TitlePaneTitle", ""));
            this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
        }, _onTitleKey:function (e) {
            if (e.keyCode == keys.DOWN_ARROW && this.open) {
                this.containerNode.focus();
                e.preventDefault();
            }
        }, _onTitleClick:function () {
            if (this.toggleable) {
                this.toggle();
            }
        }, setTitle:function (title) {
            kernel.deprecated("dijit.TitlePane.setTitle() is deprecated.  Use set('title', ...) instead.", "", "2.0");
            this.set("title", title);
        }});
        if (has("dojo-bidi")) {
            TitlePane.extend({_setTitleAttr:function (title) {
                this._set("title", title);
                this.titleNode.innerHTML = title;
                this.applyTextDir(this.titleNode);
            }, _setTooltipAttr:function (tooltip) {
                this._set("tooltip", tooltip);
                if (this.textDir) {
                    tooltip = this.enforceTextDirWithUcc(null, tooltip);
                }
                domAttr.set(this.focusNode, "title", tooltip);
            }, _setTextDirAttr:function (textDir) {
                if (this._created && this.textDir != textDir) {
                    this._set("textDir", textDir);
                    this.set("title", this.title);
                    this.set("tooltip", this.tooltip);
                }
            }});
        }
        return TitlePane;
    });
}, "dojo/dnd/Container":function () {
    define(["../_base/array", "../_base/declare", "../_base/kernel", "../_base/lang", "../_base/window", "../dom", "../dom-class", "../dom-construct", "../Evented", "../has", "../on", "../query", "../touch", "./common"], function (array, declare, kernel, lang, win, dom, domClass, domConstruct, Evented, has, on, query, touch, dnd) {
        var Container = declare("dojo.dnd.Container", Evented, {skipForm:false, allowNested:false, constructor:function (node, params) {
            this.node = dom.byId(node);
            if (!params) {
                params = {};
            }
            this.creator = params.creator || null;
            this.skipForm = params.skipForm;
            this.parent = params.dropParent && dom.byId(params.dropParent);
            this.map = {};
            this.current = null;
            this.containerState = "";
            domClass.add(this.node, "dojoDndContainer");
            if (!(params && params._skipStartup)) {
                this.startup();
            }
            this.events = [on(this.node, touch.over, lang.hitch(this, "onMouseOver")), on(this.node, touch.out, lang.hitch(this, "onMouseOut")), on(this.node, "dragstart", lang.hitch(this, "onSelectStart")), on(this.node, "selectstart", lang.hitch(this, "onSelectStart"))];
        }, creator:function () {
        }, getItem:function (key) {
            return this.map[key];
        }, setItem:function (key, data) {
            this.map[key] = data;
        }, delItem:function (key) {
            delete this.map[key];
        }, forInItems:function (f, o) {
            o = o || kernel.global;
            var m = this.map, e = dnd._empty;
            for (var i in m) {
                if (i in e) {
                    continue;
                }
                f.call(o, m[i], i, this);
            }
            return o;
        }, clearItems:function () {
            this.map = {};
        }, getAllNodes:function () {
            return query((this.allowNested ? "" : "> ") + ".dojoDndItem", this.parent);
        }, sync:function () {
            var map = {};
            this.getAllNodes().forEach(function (node) {
                if (node.id) {
                    var item = this.getItem(node.id);
                    if (item) {
                        map[node.id] = item;
                        return;
                    }
                } else {
                    node.id = dnd.getUniqueId();
                }
                var type = node.getAttribute("dndType"), data = node.getAttribute("dndData");
                map[node.id] = {data:data || node.innerHTML, type:type ? type.split(/\s*,\s*/) : ["text"]};
            }, this);
            this.map = map;
            return this;
        }, insertNodes:function (data, before, anchor) {
            if (!this.parent.firstChild) {
                anchor = null;
            } else {
                if (before) {
                    if (!anchor) {
                        anchor = this.parent.firstChild;
                    }
                } else {
                    if (anchor) {
                        anchor = anchor.nextSibling;
                    }
                }
            }
            var i, t;
            if (anchor) {
                for (i = 0; i < data.length; ++i) {
                    t = this._normalizedCreator(data[i]);
                    this.setItem(t.node.id, {data:t.data, type:t.type});
                    anchor.parentNode.insertBefore(t.node, anchor);
                }
            } else {
                for (i = 0; i < data.length; ++i) {
                    t = this._normalizedCreator(data[i]);
                    this.setItem(t.node.id, {data:t.data, type:t.type});
                    this.parent.appendChild(t.node);
                }
            }
            return this;
        }, destroy:function () {
            array.forEach(this.events, function (handle) {
                handle.remove();
            });
            this.clearItems();
            this.node = this.parent = this.current = null;
        }, markupFactory:function (params, node, Ctor) {
            params._skipStartup = true;
            return new Ctor(node, params);
        }, startup:function () {
            if (!this.parent) {
                this.parent = this.node;
                if (this.parent.tagName.toLowerCase() == "table") {
                    var c = this.parent.getElementsByTagName("tbody");
                    if (c && c.length) {
                        this.parent = c[0];
                    }
                }
            }
            this.defaultCreator = dnd._defaultCreator(this.parent);
            this.sync();
        }, onMouseOver:function (e) {
            var n = e.relatedTarget;
            while (n) {
                if (n == this.node) {
                    break;
                }
                try {
                    n = n.parentNode;
                }
                catch (x) {
                    n = null;
                }
            }
            if (!n) {
                this._changeState("Container", "Over");
                this.onOverEvent();
            }
            n = this._getChildByEvent(e);
            if (this.current == n) {
                return;
            }
            if (this.current) {
                this._removeItemClass(this.current, "Over");
            }
            if (n) {
                this._addItemClass(n, "Over");
            }
            this.current = n;
        }, onMouseOut:function (e) {
            for (var n = e.relatedTarget; n; ) {
                if (n == this.node) {
                    return;
                }
                try {
                    n = n.parentNode;
                }
                catch (x) {
                    n = null;
                }
            }
            if (this.current) {
                this._removeItemClass(this.current, "Over");
                this.current = null;
            }
            this._changeState("Container", "");
            this.onOutEvent();
        }, onSelectStart:function (e) {
            if (!this.skipForm || !dnd.isFormElement(e)) {
                e.stopPropagation();
                e.preventDefault();
            }
        }, onOverEvent:function () {
        }, onOutEvent:function () {
        }, _changeState:function (type, newState) {
            var prefix = "dojoDnd" + type;
            var state = type.toLowerCase() + "State";
            domClass.replace(this.node, prefix + newState, prefix + this[state]);
            this[state] = newState;
        }, _addItemClass:function (node, type) {
            domClass.add(node, "dojoDndItem" + type);
        }, _removeItemClass:function (node, type) {
            domClass.remove(node, "dojoDndItem" + type);
        }, _getChildByEvent:function (e) {
            var node = e.target;
            if (node) {
                for (var parent = node.parentNode; parent; node = parent, parent = node.parentNode) {
                    if ((parent == this.parent || this.allowNested) && domClass.contains(node, "dojoDndItem")) {
                        return node;
                    }
                }
            }
            return null;
        }, _normalizedCreator:function (item, hint) {
            var t = (this.creator || this.defaultCreator).call(this, item, hint);
            if (!lang.isArray(t.type)) {
                t.type = ["text"];
            }
            if (!t.node.id) {
                t.node.id = dnd.getUniqueId();
            }
            domClass.add(t.node, "dojoDndItem");
            return t;
        }});
        dnd._createNode = function (tag) {
            if (!tag) {
                return dnd._createSpan;
            }
            return function (text) {
                return domConstruct.create(tag, {innerHTML:text});
            };
        };
        dnd._createTrTd = function (text) {
            var tr = domConstruct.create("tr");
            domConstruct.create("td", {innerHTML:text}, tr);
            return tr;
        };
        dnd._createSpan = function (text) {
            return domConstruct.create("span", {innerHTML:text});
        };
        dnd._defaultCreatorNodes = {ul:"li", ol:"li", div:"div", p:"div"};
        dnd._defaultCreator = function (node) {
            var tag = node.tagName.toLowerCase();
            var c = tag == "tbody" || tag == "thead" ? dnd._createTrTd : dnd._createNode(dnd._defaultCreatorNodes[tag]);
            return function (item, hint) {
                var isObj = item && lang.isObject(item), data, type, n;
                if (isObj && item.tagName && item.nodeType && item.getAttribute) {
                    data = item.getAttribute("dndData") || item.innerHTML;
                    type = item.getAttribute("dndType");
                    type = type ? type.split(/\s*,\s*/) : ["text"];
                    n = item;
                } else {
                    data = (isObj && item.data) ? item.data : item;
                    type = (isObj && item.type) ? item.type : ["text"];
                    n = (hint == "avatar" ? dnd._createSpan : c)(String(data));
                }
                if (!n.id) {
                    n.id = dnd.getUniqueId();
                }
                return {node:n, data:data, type:type};
            };
        };
        return Container;
    });
}, "dijit/form/CurrencyTextBox":function () {
    define(["dojo/currency", "dojo/_base/declare", "dojo/_base/lang", "./NumberTextBox"], function (currency, declare, lang, NumberTextBox) {
        return declare("dijit.form.CurrencyTextBox", NumberTextBox, {currency:"", baseClass:"dijitTextBox dijitCurrencyTextBox", _formatter:currency.format, _parser:currency.parse, _regExpGenerator:currency.regexp, parse:function (value, constraints) {
            var v = this.inherited(arguments);
            if (isNaN(v) && /\d+/.test(value)) {
                v = lang.hitch(lang.delegate(this, {_parser:NumberTextBox.prototype._parser}), "inherited")(arguments);
            }
            return v;
        }, _setConstraintsAttr:function (constraints) {
            if (!constraints.currency && this.currency) {
                constraints.currency = this.currency;
            }
            this.inherited(arguments, [currency._mixInDefaults(lang.mixin(constraints, {exponent:false}))]);
        }});
    });
}, "dojo/request/handlers":function () {
    define(["../json", "../_base/kernel", "../_base/array", "../has", "../selector/_loader"], function (JSON, kernel, array, has) {
        has.add("activex", typeof ActiveXObject !== "undefined");
        has.add("dom-parser", function (global) {
            return "DOMParser" in global;
        });
        var handleXML;
        if (has("activex")) {
            var dp = ["Msxml2.DOMDocument.6.0", "Msxml2.DOMDocument.4.0", "MSXML2.DOMDocument.3.0", "MSXML.DOMDocument"];
            handleXML = function (response) {
                var result = response.data;
                if (result && has("dom-qsa2.1") && !result.querySelectorAll && has("dom-parser")) {
                    result = new DOMParser().parseFromString(response.text, "application/xml");
                }
                if (!result || !result.documentElement) {
                    var text = response.text;
                    array.some(dp, function (p) {
                        try {
                            var dom = new ActiveXObject(p);
                            dom.async = false;
                            dom.loadXML(text);
                            result = dom;
                        }
                        catch (e) {
                            return false;
                        }
                        return true;
                    });
                }
                return result;
            };
        }
        var handlers = {"javascript":function (response) {
            return kernel.eval(response.text || "");
        }, "json":function (response) {
            return JSON.parse(response.text || null);
        }, "xml":handleXML};
        function handle(response) {
            var handler = handlers[response.options.handleAs];
            response.data = handler ? handler(response) : (response.data || response.text);
            return response;
        }
        handle.register = function (name, handler) {
            handlers[name] = handler;
        };
        return handle;
    });
}, "dijit/place":function () {
    define(["dojo/_base/array", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/kernel", "dojo/_base/window", "./Viewport", "./main"], function (array, domGeometry, domStyle, kernel, win, Viewport, dijit) {
        function _place(node, choices, layoutNode, aroundNodeCoords) {
            var view = Viewport.getEffectiveBox(node.ownerDocument);
            if (!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body") {
                win.body(node.ownerDocument).appendChild(node);
            }
            var best = null;
            array.some(choices, function (choice) {
                var corner = choice.corner;
                var pos = choice.pos;
                var overflow = 0;
                var spaceAvailable = {w:{"L":view.l + view.w - pos.x, "R":pos.x - view.l, "M":view.w}[corner.charAt(1)], h:{"T":view.t + view.h - pos.y, "B":pos.y - view.t, "M":view.h}[corner.charAt(0)]};
                var s = node.style;
                s.left = s.right = "auto";
                if (layoutNode) {
                    var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
                    overflow = typeof res == "undefined" ? 0 : res;
                }
                var style = node.style;
                var oldDisplay = style.display;
                var oldVis = style.visibility;
                if (style.display == "none") {
                    style.visibility = "hidden";
                    style.display = "";
                }
                var bb = domGeometry.position(node);
                style.display = oldDisplay;
                style.visibility = oldVis;
                var startXpos = {"L":pos.x, "R":pos.x - bb.w, "M":Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w)}[corner.charAt(1)], startYpos = {"T":pos.y, "B":pos.y - bb.h, "M":Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)}[corner.charAt(0)], startX = Math.max(view.l, startXpos), startY = Math.max(view.t, startYpos), endX = Math.min(view.l + view.w, startXpos + bb.w), endY = Math.min(view.t + view.h, startYpos + bb.h), width = endX - startX, height = endY - startY;
                overflow += (bb.w - width) + (bb.h - height);
                if (best == null || overflow < best.overflow) {
                    best = {corner:corner, aroundCorner:choice.aroundCorner, x:startX, y:startY, w:width, h:height, overflow:overflow, spaceAvailable:spaceAvailable};
                }
                return !overflow;
            });
            if (best.overflow && layoutNode) {
                layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
            }
            var top = best.y, side = best.x, body = win.body(node.ownerDocument);
            if (/relative|absolute/.test(domStyle.get(body, "position"))) {
                top -= domStyle.get(body, "marginTop");
                side -= domStyle.get(body, "marginLeft");
            }
            var s = node.style;
            s.top = top + "px";
            s.left = side + "px";
            s.right = "auto";
            return best;
        }
        var reverse = {"TL":"BR", "TR":"BL", "BL":"TR", "BR":"TL"};
        var place = {at:function (node, pos, corners, padding, layoutNode) {
            var choices = array.map(corners, function (corner) {
                var c = {corner:corner, aroundCorner:reverse[corner], pos:{x:pos.x, y:pos.y}};
                if (padding) {
                    c.pos.x += corner.charAt(1) == "L" ? padding.x : -padding.x;
                    c.pos.y += corner.charAt(0) == "T" ? padding.y : -padding.y;
                }
                return c;
            });
            return _place(node, choices, layoutNode);
        }, around:function (node, anchor, positions, leftToRight, layoutNode) {
            var aroundNodePos;
            if (typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor) {
                aroundNodePos = domGeometry.position(anchor, true);
                if (/^(above|below)/.test(positions[0])) {
                    var anchorBorder = domGeometry.getBorderExtents(anchor), anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0, l:0, b:0, r:0}, nodeBorder = domGeometry.getBorderExtents(node), nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0, l:0, b:0, r:0};
                    aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
                    aroundNodePos.h -= Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t) + Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
                }
            } else {
                aroundNodePos = anchor;
            }
            if (anchor.parentNode) {
                var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
                var parent = anchor.parentNode;
                while (parent && parent.nodeType == 1 && parent.nodeName != "BODY") {
                    var parentPos = domGeometry.position(parent, true), pcs = domStyle.getComputedStyle(parent);
                    if (/relative|absolute/.test(pcs.position)) {
                        sawPosAbsolute = false;
                    }
                    if (!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)) {
                        var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
                        var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
                        aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
                        aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
                        aroundNodePos.h = bottomYCoord - aroundNodePos.y;
                        aroundNodePos.w = rightXCoord - aroundNodePos.x;
                    }
                    if (pcs.position == "absolute") {
                        sawPosAbsolute = true;
                    }
                    parent = parent.parentNode;
                }
            }
            var x = aroundNodePos.x, y = aroundNodePos.y, width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width), height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:" + x + ", y:" + y + ", height:" + aroundNodePos.height + ", width:" + width + " } has been deprecated.  Please use { x:" + x + ", y:" + y + ", h:" + aroundNodePos.height + ", w:" + width + " }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);
            var choices = [];
            function push(aroundCorner, corner) {
                choices.push({aroundCorner:aroundCorner, corner:corner, pos:{x:{"L":x, "R":x + width, "M":x + (width >> 1)}[aroundCorner.charAt(1)], y:{"T":y, "B":y + height, "M":y + (height >> 1)}[aroundCorner.charAt(0)]}});
            }
            array.forEach(positions, function (pos) {
                var ltr = leftToRight;
                switch (pos) {
                  case "above-centered":
                    push("TM", "BM");
                    break;
                  case "below-centered":
                    push("BM", "TM");
                    break;
                  case "after-centered":
                    ltr = !ltr;
                  case "before-centered":
                    push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
                    break;
                  case "after":
                    ltr = !ltr;
                  case "before":
                    push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
                    push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
                    break;
                  case "below-alt":
                    ltr = !ltr;
                  case "below":
                    push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
                    push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
                    break;
                  case "above-alt":
                    ltr = !ltr;
                  case "above":
                    push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
                    push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
                    break;
                  default:
                    push(pos.aroundCorner, pos.corner);
                }
            });
            var position = _place(node, choices, layoutNode, {w:width, h:height});
            position.aroundNodePos = aroundNodePos;
            return position;
        }};
        return dijit.place = place;
    });
}, "dojox/widget/ColorPicker":function () {
    define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/html", "dojo/_base/connect", "dojo/_base/sniff", "dojo/_base/window", "dojo/_base/event", "dojo/dom", "dojo/dom-class", "dojo/keys", "dojo/fx", "dojo/dnd/move", "dijit/registry", "dijit/_base/focus", "dijit/form/_FormWidget", "dijit/typematic", "dojox/color", "dojo/i18n", "dojo/i18n!./nls/ColorPicker", "dojo/i18n!dojo/cldr/nls/number", "dojo/text!./ColorPicker/ColorPicker.html"], function (kernel, declare, lang, ArrayUtil, html, Hub, has, win, Event, DOM, DOMClass, Keys, fx, move, registry, FocusManager, FormWidget, Typematic, color, i18n, bundle1, bundle2, template) {
        kernel.experimental("dojox.widget.ColorPicker");
        var webSafeFromHex = function (hex) {
            return hex;
        };
        return declare("dojox.widget.ColorPicker", FormWidget, {showRgb:true, showHsv:true, showHex:true, webSafe:true, animatePoint:true, slideDuration:250, liveUpdate:false, PICKER_HUE_H:150, PICKER_SAT_VAL_H:150, PICKER_SAT_VAL_W:150, PICKER_HUE_SELECTOR_H:8, PICKER_SAT_SELECTOR_H:10, PICKER_SAT_SELECTOR_W:10, value:"#ffffff", _underlay:require.toUrl("dojox/widget/ColorPicker/images/underlay.png"), _hueUnderlay:require.toUrl("dojox/widget/ColorPicker/images/hue.png"), _pickerPointer:require.toUrl("dojox/widget/ColorPicker/images/pickerPointer.png"), _huePickerPointer:require.toUrl("dojox/widget/ColorPicker/images/hueHandle.png"), _huePickerPointerAlly:require.toUrl("dojox/widget/ColorPicker/images/hueHandleA11y.png"), templateString:template, postMixInProperties:function () {
            if (DOMClass.contains(win.body(), "dijit_a11y")) {
                this._huePickerPointer = this._huePickerPointerAlly;
            }
            this._uId = registry.getUniqueId(this.id);
            lang.mixin(this, i18n.getLocalization("dojox.widget", "ColorPicker"));
            lang.mixin(this, i18n.getLocalization("dojo.cldr", "number"));
            this.inherited(arguments);
        }, postCreate:function () {
            this.inherited(arguments);
            if (has("ie") < 7) {
                this.colorUnderlay.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this._underlay + "', sizingMethod='scale')";
                this.colorUnderlay.src = this._blankGif.toString();
            }
            if (!this.showRgb) {
                this.rgbNode.style.visibility = "hidden";
            }
            if (!this.showHsv) {
                this.hsvNode.style.visibility = "hidden";
            }
            if (!this.showHex) {
                this.hexNode.style.visibility = "hidden";
            }
            if (!this.webSafe) {
                this.safePreviewNode.style.visibility = "hidden";
            }
        }, startup:function () {
            if (this._started) {
                return;
            }
            this._started = true;
            this.set("value", this.value);
            this._mover = new move.boxConstrainedMoveable(this.cursorNode, {box:{t:-(this.PICKER_SAT_SELECTOR_H / 2), l:-(this.PICKER_SAT_SELECTOR_W / 2), w:this.PICKER_SAT_VAL_W, h:this.PICKER_SAT_VAL_H}});
            this._hueMover = new move.boxConstrainedMoveable(this.hueCursorNode, {box:{t:-(this.PICKER_HUE_SELECTOR_H / 2), l:0, w:0, h:this.PICKER_HUE_H}});
            this._subs = [];
            this._subs.push(Hub.subscribe("/dnd/move/stop", lang.hitch(this, "_clearTimer")));
            this._subs.push(Hub.subscribe("/dnd/move/start", lang.hitch(this, "_setTimer")));
            this._keyListeners = [];
            this._connects.push(Typematic.addKeyListener(this.hueCursorNode, {charOrCode:Keys.UP_ARROW, shiftKey:false, metaKey:false, ctrlKey:false, altKey:false}, this, lang.hitch(this, this._updateHueCursorNode), 25, 25));
            this._connects.push(Typematic.addKeyListener(this.hueCursorNode, {charOrCode:Keys.DOWN_ARROW, shiftKey:false, metaKey:false, ctrlKey:false, altKey:false}, this, lang.hitch(this, this._updateHueCursorNode), 25, 25));
            this._connects.push(Typematic.addKeyListener(this.cursorNode, {charOrCode:Keys.UP_ARROW, shiftKey:false, metaKey:false, ctrlKey:false, altKey:false}, this, lang.hitch(this, this._updateCursorNode), 25, 25));
            this._connects.push(Typematic.addKeyListener(this.cursorNode, {charOrCode:Keys.DOWN_ARROW, shiftKey:false, metaKey:false, ctrlKey:false, altKey:false}, this, lang.hitch(this, this._updateCursorNode), 25, 25));
            this._connects.push(Typematic.addKeyListener(this.cursorNode, {charOrCode:Keys.LEFT_ARROW, shiftKey:false, metaKey:false, ctrlKey:false, altKey:false}, this, lang.hitch(this, this._updateCursorNode), 25, 25));
            this._connects.push(Typematic.addKeyListener(this.cursorNode, {charOrCode:Keys.RIGHT_ARROW, shiftKey:false, metaKey:false, ctrlKey:false, altKey:false}, this, lang.hitch(this, this._updateCursorNode), 25, 25));
        }, _setValueAttr:function (value) {
            if (!this._started) {
                return;
            }
            this.setColor(value, true);
        }, setColor:function (col, force) {
            col = color.fromString(col);
            this._updatePickerLocations(col);
            this._updateColorInputs(col);
            this._updateValue(col, force);
        }, _setTimer:function (mover) {
            if (mover.node != this.cursorNode) {
                return;
            }
            FocusManager.focus(mover.node);
            DOM.setSelectable(this.domNode, false);
            this._timer = setInterval(lang.hitch(this, "_updateColor"), 45);
        }, _clearTimer:function (mover) {
            if (!this._timer) {
                return;
            }
            clearInterval(this._timer);
            this._timer = null;
            this.onChange(this.value);
            DOM.setSelectable(this.domNode, true);
        }, _setHue:function (h) {
            html.style(this.colorUnderlay, "backgroundColor", color.fromHsv(h, 100, 100).toHex());
        }, _updateHueCursorNode:function (count, node, e) {
            if (count !== -1) {
                var y = html.style(this.hueCursorNode, "top");
                var selCenter = this.PICKER_HUE_SELECTOR_H / 2;
                y += selCenter;
                var update = false;
                if (e.charOrCode == Keys.UP_ARROW) {
                    if (y > 0) {
                        y -= 1;
                        update = true;
                    }
                } else {
                    if (e.charOrCode == Keys.DOWN_ARROW) {
                        if (y < this.PICKER_HUE_H) {
                            y += 1;
                            update = true;
                        }
                    }
                }
                y -= selCenter;
                if (update) {
                    html.style(this.hueCursorNode, "top", y + "px");
                }
            } else {
                this._updateColor(true);
            }
        }, _updateCursorNode:function (count, node, e) {
            var selCenterH = this.PICKER_SAT_SELECTOR_H / 2;
            var selCenterW = this.PICKER_SAT_SELECTOR_W / 2;
            if (count !== -1) {
                var y = html.style(this.cursorNode, "top");
                var x = html.style(this.cursorNode, "left");
                y += selCenterH;
                x += selCenterW;
                var update = false;
                if (e.charOrCode == Keys.UP_ARROW) {
                    if (y > 0) {
                        y -= 1;
                        update = true;
                    }
                } else {
                    if (e.charOrCode == Keys.DOWN_ARROW) {
                        if (y < this.PICKER_SAT_VAL_H) {
                            y += 1;
                            update = true;
                        }
                    } else {
                        if (e.charOrCode == Keys.LEFT_ARROW) {
                            if (x > 0) {
                                x -= 1;
                                update = true;
                            }
                        } else {
                            if (e.charOrCode == Keys.RIGHT_ARROW) {
                                if (x < this.PICKER_SAT_VAL_W) {
                                    x += 1;
                                    update = true;
                                }
                            }
                        }
                    }
                }
                if (update) {
                    y -= selCenterH;
                    x -= selCenterW;
                    html.style(this.cursorNode, "top", y + "px");
                    html.style(this.cursorNode, "left", x + "px");
                }
            } else {
                this._updateColor(true);
            }
        }, _updateColor:function (fireChange) {
            var hueSelCenter = this.PICKER_HUE_SELECTOR_H / 2, satSelCenterH = this.PICKER_SAT_SELECTOR_H / 2, satSelCenterW = this.PICKER_SAT_SELECTOR_W / 2;
            var _huetop = html.style(this.hueCursorNode, "top") + hueSelCenter, _pickertop = html.style(this.cursorNode, "top") + satSelCenterH, _pickerleft = html.style(this.cursorNode, "left") + satSelCenterW, h = Math.round(360 - (_huetop / this.PICKER_HUE_H * 360)), col = color.fromHsv(h, _pickerleft / this.PICKER_SAT_VAL_W * 100, 100 - (_pickertop / this.PICKER_SAT_VAL_H * 100));
            this._updateColorInputs(col);
            this._updateValue(col, fireChange);
            if (h != this._hue) {
                this._setHue(h);
            }
        }, _colorInputChange:function (e) {
            var col, hasit = false;
            switch (e.target) {
              case this.hexCode:
                col = color.fromString(e.target.value);
                hasit = true;
                break;
              case this.Rval:
              case this.Gval:
              case this.Bval:
                col = color.fromArray([this.Rval.value, this.Gval.value, this.Bval.value]);
                hasit = true;
                break;
              case this.Hval:
              case this.Sval:
              case this.Vval:
                col = color.fromHsv(this.Hval.value, this.Sval.value, this.Vval.value);
                hasit = true;
                break;
            }
            if (hasit) {
                this._updatePickerLocations(col);
                this._updateColorInputs(col);
                this._updateValue(col, true);
            }
        }, _updateValue:function (col, fireChange) {
            var hex = col.toHex();
            this.value = this.valueNode.value = hex;
            if (fireChange && (!this._timer || this.liveUpdate)) {
                this.onChange(hex);
            }
        }, _updatePickerLocations:function (col) {
            var hueSelCenter = this.PICKER_HUE_SELECTOR_H / 2, satSelCenterH = this.PICKER_SAT_SELECTOR_H / 2, satSelCenterW = this.PICKER_SAT_SELECTOR_W / 2;
            var hsv = col.toHsv(), ypos = Math.round(this.PICKER_HUE_H - hsv.h / 360 * this.PICKER_HUE_H) - hueSelCenter, newLeft = Math.round(hsv.s / 100 * this.PICKER_SAT_VAL_W) - satSelCenterW, newTop = Math.round(this.PICKER_SAT_VAL_H - hsv.v / 100 * this.PICKER_SAT_VAL_H) - satSelCenterH;
            if (this.animatePoint) {
                fx.slideTo({node:this.hueCursorNode, duration:this.slideDuration, top:ypos, left:0}).play();
                fx.slideTo({node:this.cursorNode, duration:this.slideDuration, top:newTop, left:newLeft}).play();
            } else {
                html.style(this.hueCursorNode, "top", ypos + "px");
                html.style(this.cursorNode, {left:newLeft + "px", top:newTop + "px"});
            }
            if (hsv.h != this._hue) {
                this._setHue(hsv.h);
            }
        }, _updateColorInputs:function (col) {
            var hex = col.toHex();
            if (this.showRgb) {
                this.Rval.value = col.r;
                this.Gval.value = col.g;
                this.Bval.value = col.b;
            }
            if (this.showHsv) {
                var hsv = col.toHsv();
                this.Hval.value = Math.round((hsv.h));
                this.Sval.value = Math.round(hsv.s);
                this.Vval.value = Math.round(hsv.v);
            }
            if (this.showHex) {
                this.hexCode.value = hex;
            }
            this.previewNode.style.backgroundColor = hex;
            if (this.webSafe) {
                this.safePreviewNode.style.backgroundColor = webSafeFromHex(hex);
            }
        }, _setHuePoint:function (evt) {
            var selCenter = this.PICKER_HUE_SELECTOR_H / 2;
            var ypos = evt.layerY - selCenter;
            if (this.animatePoint) {
                fx.slideTo({node:this.hueCursorNode, duration:this.slideDuration, top:ypos, left:0, onEnd:lang.hitch(this, function () {
                    this._updateColor(false);
                    FocusManager.focus(this.hueCursorNode);
                })}).play();
            } else {
                html.style(this.hueCursorNode, "top", ypos + "px");
                this._updateColor(false);
            }
        }, _setPoint:function (evt) {
            var satSelCenterH = this.PICKER_SAT_SELECTOR_H / 2;
            var satSelCenterW = this.PICKER_SAT_SELECTOR_W / 2;
            var newTop = evt.layerY - satSelCenterH;
            var newLeft = evt.layerX - satSelCenterW;
            if (evt) {
                FocusManager.focus(evt.target);
            }
            if (this.animatePoint) {
                fx.slideTo({node:this.cursorNode, duration:this.slideDuration, top:newTop, left:newLeft, onEnd:lang.hitch(this, function () {
                    this._updateColor(true);
                    FocusManager.focus(this.cursorNode);
                })}).play();
            } else {
                html.style(this.cursorNode, {left:newLeft + "px", top:newTop + "px"});
                this._updateColor(false);
            }
        }, _handleKey:function (e) {
        }, focus:function () {
            if (!this.focused) {
                FocusManager.focus(this.focusNode);
            }
        }, _stopDrag:function (e) {
            Event.stop(e);
        }, destroy:function () {
            this.inherited(arguments);
            ArrayUtil.forEach(this._subs, function (sub) {
                Hub.unsubscribe(sub);
            });
            delete this._subs;
        }});
    });
}, "dijit/form/ComboBox":function () {
    define(["dojo/_base/declare", "./ValidationTextBox", "./ComboBoxMixin"], function (declare, ValidationTextBox, ComboBoxMixin) {
        return declare("dijit.form.ComboBox", [ValidationTextBox, ComboBoxMixin], {});
    });
}, "dijit/layout/_LayoutWidget":function () {
    define(["dojo/_base/lang", "../_Widget", "../_Container", "../_Contained", "../Viewport", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style"], function (lang, _Widget, _Container, _Contained, Viewport, declare, domClass, domGeometry, domStyle) {
        return declare("dijit.layout._LayoutWidget", [_Widget, _Container, _Contained], {baseClass:"dijitLayoutContainer", isLayoutContainer:true, buildRendering:function () {
            this.inherited(arguments);
            domClass.add(this.domNode, "dijitContainer");
        }, startup:function () {
            if (this._started) {
                return;
            }
            this.inherited(arguments);
            var parent = this.getParent && this.getParent();
            if (!(parent && parent.isLayoutContainer)) {
                this.resize();
                this.own(Viewport.on("resize", lang.hitch(this, "resize")));
            }
        }, resize:function (changeSize, resultSize) {
            var node = this.domNode;
            if (changeSize) {
                domGeometry.setMarginBox(node, changeSize);
            }
            var mb = resultSize || {};
            lang.mixin(mb, changeSize || {});
            if (!("h" in mb) || !("w" in mb)) {
                mb = lang.mixin(domGeometry.getMarginBox(node), mb);
            }
            var cs = domStyle.getComputedStyle(node);
            var me = domGeometry.getMarginExtents(node, cs);
            var be = domGeometry.getBorderExtents(node, cs);
            var bb = (this._borderBox = {w:mb.w - (me.w + be.w), h:mb.h - (me.h + be.h)});
            var pe = domGeometry.getPadExtents(node, cs);
            this._contentBox = {l:domStyle.toPixelValue(node, cs.paddingLeft), t:domStyle.toPixelValue(node, cs.paddingTop), w:bb.w - pe.w, h:bb.h - pe.h};
            this.layout();
        }, layout:function () {
        }, _setupChild:function (child) {
            var cls = this.baseClass + "-child " + (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
            domClass.add(child.domNode, cls);
        }, addChild:function (child, insertIndex) {
            this.inherited(arguments);
            if (this._started) {
                this._setupChild(child);
            }
        }, removeChild:function (child) {
            var cls = this.baseClass + "-child" + (child.baseClass ? " " + this.baseClass + "-" + child.baseClass : "");
            domClass.remove(child.domNode, cls);
            this.inherited(arguments);
        }});
    });
}, "dojo/colors":function () {
    define(["./_base/kernel", "./_base/lang", "./_base/Color", "./_base/array"], function (dojo, lang, Color, ArrayUtil) {
        var ColorExt = {};
        lang.setObject("dojo.colors", ColorExt);
        var hue2rgb = function (m1, m2, h) {
            if (h < 0) {
                ++h;
            }
            if (h > 1) {
                --h;
            }
            var h6 = 6 * h;
            if (h6 < 1) {
                return m1 + (m2 - m1) * h6;
            }
            if (2 * h < 1) {
                return m2;
            }
            if (3 * h < 2) {
                return m1 + (m2 - m1) * (2 / 3 - h) * 6;
            }
            return m1;
        };
        dojo.colorFromRgb = Color.fromRgb = function (color, obj) {
            var m = color.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
            if (m) {
                var c = m[2].split(/\s*,\s*/), l = c.length, t = m[1], a;
                if ((t == "rgb" && l == 3) || (t == "rgba" && l == 4)) {
                    var r = c[0];
                    if (r.charAt(r.length - 1) == "%") {
                        a = ArrayUtil.map(c, function (x) {
                            return parseFloat(x) * 2.56;
                        });
                        if (l == 4) {
                            a[3] = c[3];
                        }
                        return Color.fromArray(a, obj);
                    }
                    return Color.fromArray(c, obj);
                }
                if ((t == "hsl" && l == 3) || (t == "hsla" && l == 4)) {
                    var H = ((parseFloat(c[0]) % 360) + 360) % 360 / 360, S = parseFloat(c[1]) / 100, L = parseFloat(c[2]) / 100, m2 = L <= 0.5 ? L * (S + 1) : L + S - L * S, m1 = 2 * L - m2;
                    a = [hue2rgb(m1, m2, H + 1 / 3) * 256, hue2rgb(m1, m2, H) * 256, hue2rgb(m1, m2, H - 1 / 3) * 256, 1];
                    if (l == 4) {
                        a[3] = c[3];
                    }
                    return Color.fromArray(a, obj);
                }
            }
            return null;
        };
        var confine = function (c, low, high) {
            c = Number(c);
            return isNaN(c) ? high : c < low ? low : c > high ? high : c;
        };
        Color.prototype.sanitize = function () {
            var t = this;
            t.r = Math.round(confine(t.r, 0, 255));
            t.g = Math.round(confine(t.g, 0, 255));
            t.b = Math.round(confine(t.b, 0, 255));
            t.a = confine(t.a, 0, 1);
            return this;
        };
        ColorExt.makeGrey = Color.makeGrey = function (g, a) {
            return Color.fromArray([g, g, g, a]);
        };
        lang.mixin(Color.named, {"aliceblue":[240, 248, 255], "antiquewhite":[250, 235, 215], "aquamarine":[127, 255, 212], "azure":[240, 255, 255], "beige":[245, 245, 220], "bisque":[255, 228, 196], "blanchedalmond":[255, 235, 205], "blueviolet":[138, 43, 226], "brown":[165, 42, 42], "burlywood":[222, 184, 135], "cadetblue":[95, 158, 160], "chartreuse":[127, 255, 0], "chocolate":[210, 105, 30], "coral":[255, 127, 80], "cornflowerblue":[100, 149, 237], "cornsilk":[255, 248, 220], "crimson":[220, 20, 60], "cyan":[0, 255, 255], "darkblue":[0, 0, 139], "darkcyan":[0, 139, 139], "darkgoldenrod":[184, 134, 11], "darkgray":[169, 169, 169], "darkgreen":[0, 100, 0], "darkgrey":[169, 169, 169], "darkkhaki":[189, 183, 107], "darkmagenta":[139, 0, 139], "darkolivegreen":[85, 107, 47], "darkorange":[255, 140, 0], "darkorchid":[153, 50, 204], "darkred":[139, 0, 0], "darksalmon":[233, 150, 122], "darkseagreen":[143, 188, 143], "darkslateblue":[72, 61, 139], "darkslategray":[47, 79, 79], "darkslategrey":[47, 79, 79], "darkturquoise":[0, 206, 209], "darkviolet":[148, 0, 211], "deeppink":[255, 20, 147], "deepskyblue":[0, 191, 255], "dimgray":[105, 105, 105], "dimgrey":[105, 105, 105], "dodgerblue":[30, 144, 255], "firebrick":[178, 34, 34], "floralwhite":[255, 250, 240], "forestgreen":[34, 139, 34], "gainsboro":[220, 220, 220], "ghostwhite":[248, 248, 255], "gold":[255, 215, 0], "goldenrod":[218, 165, 32], "greenyellow":[173, 255, 47], "grey":[128, 128, 128], "honeydew":[240, 255, 240], "hotpink":[255, 105, 180], "indianred":[205, 92, 92], "indigo":[75, 0, 130], "ivory":[255, 255, 240], "khaki":[240, 230, 140], "lavender":[230, 230, 250], "lavenderblush":[255, 240, 245], "lawngreen":[124, 252, 0], "lemonchiffon":[255, 250, 205], "lightblue":[173, 216, 230], "lightcoral":[240, 128, 128], "lightcyan":[224, 255, 255], "lightgoldenrodyellow":[250, 250, 210], "lightgray":[211, 211, 211], "lightgreen":[144, 238, 144], "lightgrey":[211, 211, 211], "lightpink":[255, 182, 193], "lightsalmon":[255, 160, 122], "lightseagreen":[32, 178, 170], "lightskyblue":[135, 206, 250], "lightslategray":[119, 136, 153], "lightslategrey":[119, 136, 153], "lightsteelblue":[176, 196, 222], "lightyellow":[255, 255, 224], "limegreen":[50, 205, 50], "linen":[250, 240, 230], "magenta":[255, 0, 255], "mediumaquamarine":[102, 205, 170], "mediumblue":[0, 0, 205], "mediumorchid":[186, 85, 211], "mediumpurple":[147, 112, 219], "mediumseagreen":[60, 179, 113], "mediumslateblue":[123, 104, 238], "mediumspringgreen":[0, 250, 154], "mediumturquoise":[72, 209, 204], "mediumvioletred":[199, 21, 133], "midnightblue":[25, 25, 112], "mintcream":[245, 255, 250], "mistyrose":[255, 228, 225], "moccasin":[255, 228, 181], "navajowhite":[255, 222, 173], "oldlace":[253, 245, 230], "olivedrab":[107, 142, 35], "orange":[255, 165, 0], "orangered":[255, 69, 0], "orchid":[218, 112, 214], "palegoldenrod":[238, 232, 170], "palegreen":[152, 251, 152], "paleturquoise":[175, 238, 238], "palevioletred":[219, 112, 147], "papayawhip":[255, 239, 213], "peachpuff":[255, 218, 185], "peru":[205, 133, 63], "pink":[255, 192, 203], "plum":[221, 160, 221], "powderblue":[176, 224, 230], "rosybrown":[188, 143, 143], "royalblue":[65, 105, 225], "saddlebrown":[139, 69, 19], "salmon":[250, 128, 114], "sandybrown":[244, 164, 96], "seagreen":[46, 139, 87], "seashell":[255, 245, 238], "sienna":[160, 82, 45], "skyblue":[135, 206, 235], "slateblue":[106, 90, 205], "slategray":[112, 128, 144], "slategrey":[112, 128, 144], "snow":[255, 250, 250], "springgreen":[0, 255, 127], "steelblue":[70, 130, 180], "tan":[210, 180, 140], "thistle":[216, 191, 216], "tomato":[255, 99, 71], "turquoise":[64, 224, 208], "violet":[238, 130, 238], "wheat":[245, 222, 179], "whitesmoke":[245, 245, 245], "yellowgreen":[154, 205, 50]});
        return Color;
    });
}, "dojox/grid/cells/_base":function () {
    define(["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/event", "dojo/_base/connect", "dojo/_base/array", "dojo/_base/sniff", "dojo/dom", "dojo/dom-attr", "dojo/dom-construct", "dijit/_Widget", "../util"], function (dojo, declare, lang, event, connect, array, has, dom, domAttr, domConstruct, _Widget, util) {
        var _DeferredTextWidget = declare("dojox.grid._DeferredTextWidget", _Widget, {deferred:null, _destroyOnRemove:true, postCreate:function () {
            if (this.deferred) {
                this.deferred.addBoth(lang.hitch(this, function (text) {
                    if (this.domNode) {
                        this.domNode.innerHTML = text;
                    }
                }));
            }
        }});
        var focusSelectNode = function (inNode) {
            try {
                util.fire(inNode, "focus");
                util.fire(inNode, "select");
            }
            catch (e) {
            }
        };
        var whenIdle = function () {
            setTimeout(lang.hitch.apply(dojo, arguments), 0);
        };
        var BaseCell = declare("dojox.grid.cells._Base", null, {styles:"", classes:"", editable:false, alwaysEditing:false, formatter:null, defaultValue:"...", value:null, hidden:false, noresize:false, draggable:true, _valueProp:"value", _formatPending:false, constructor:function (inProps) {
            this._props = inProps || {};
            lang.mixin(this, inProps);
            if (this.draggable === undefined) {
                this.draggable = true;
            }
        }, _defaultFormat:function (inValue, callArgs) {
            var s = this.grid.formatterScope || this;
            var f = this.formatter;
            if (f && s && typeof f == "string") {
                f = this.formatter = s[f];
            }
            var v = (inValue != this.defaultValue && f) ? f.apply(s, callArgs) : inValue;
            if (typeof v == "undefined") {
                return this.defaultValue;
            }
            if (v && v.addBoth) {
                v = new _DeferredTextWidget({deferred:v}, domConstruct.create("span", {innerHTML:this.defaultValue}));
            }
            if (v && v.declaredClass && v.startup) {
                return "<div class='dojoxGridStubNode' linkWidget='" + v.id + "' cellIdx='" + this.index + "'>" + this.defaultValue + "</div>";
            }
            return v;
        }, format:function (inRowIndex, inItem) {
            var f, i = this.grid.edit.info, d = this.get ? this.get(inRowIndex, inItem) : (this.value || this.defaultValue);
            d = (d && d.replace && this.grid.escapeHTMLInData) ? d.replace(/&/g, "&amp;").replace(/</g, "&lt;") : d;
            if (this.editable && (this.alwaysEditing || (i.rowIndex == inRowIndex && i.cell == this))) {
                return this.formatEditing(i.value ? i.value : d, inRowIndex);
            } else {
                return this._defaultFormat(d, [d, inRowIndex, this]);
            }
        }, formatEditing:function (inDatum, inRowIndex) {
        }, getNode:function (inRowIndex) {
            return this.view.getCellNode(inRowIndex, this.index);
        }, getHeaderNode:function () {
            return this.view.getHeaderCellNode(this.index);
        }, getEditNode:function (inRowIndex) {
            return (this.getNode(inRowIndex) || 0).firstChild || 0;
        }, canResize:function () {
            var uw = this.unitWidth;
            return uw && (uw !== "auto");
        }, isFlex:function () {
            var uw = this.unitWidth;
            return uw && lang.isString(uw) && (uw == "auto" || uw.slice(-1) == "%");
        }, applyEdit:function (inValue, inRowIndex) {
            if (this.getNode(inRowIndex)) {
                this.grid.edit.applyCellEdit(inValue, this, inRowIndex);
            }
        }, cancelEdit:function (inRowIndex) {
            this.grid.doCancelEdit(inRowIndex);
        }, _onEditBlur:function (inRowIndex) {
            if (this.grid.edit.isEditCell(inRowIndex, this.index)) {
                this.grid.edit.apply();
            }
        }, registerOnBlur:function (inNode, inRowIndex) {
            if (this.commitOnBlur) {
                connect.connect(inNode, "onblur", function (e) {
                    setTimeout(lang.hitch(this, "_onEditBlur", inRowIndex), 250);
                });
            }
        }, needFormatNode:function (inDatum, inRowIndex) {
            this._formatPending = true;
            whenIdle(this, "_formatNode", inDatum, inRowIndex);
        }, cancelFormatNode:function () {
            this._formatPending = false;
        }, _formatNode:function (inDatum, inRowIndex) {
            if (this._formatPending) {
                this._formatPending = false;
                if (!has("ie")) {
                    dom.setSelectable(this.grid.domNode, true);
                }
                this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
            }
        }, formatNode:function (inNode, inDatum, inRowIndex) {
            if (has("ie")) {
                whenIdle(this, "focus", inRowIndex, inNode);
            } else {
                this.focus(inRowIndex, inNode);
            }
        }, dispatchEvent:function (m, e) {
            if (m in this) {
                return this[m](e);
            }
        }, getValue:function (inRowIndex) {
            return this.getEditNode(inRowIndex)[this._valueProp];
        }, setValue:function (inRowIndex, inValue) {
            var n = this.getEditNode(inRowIndex);
            if (n) {
                n[this._valueProp] = inValue;
            }
        }, focus:function (inRowIndex, inNode) {
            focusSelectNode(inNode || this.getEditNode(inRowIndex));
        }, save:function (inRowIndex) {
            this.value = this.value || this.getValue(inRowIndex);
        }, restore:function (inRowIndex) {
            this.setValue(inRowIndex, this.value);
        }, _finish:function (inRowIndex) {
            dom.setSelectable(this.grid.domNode, false);
            this.cancelFormatNode();
        }, apply:function (inRowIndex) {
            this.applyEdit(this.getValue(inRowIndex), inRowIndex);
            this._finish(inRowIndex);
        }, cancel:function (inRowIndex) {
            this.cancelEdit(inRowIndex);
            this._finish(inRowIndex);
        }});
        BaseCell.markupFactory = function (node, cellDef) {
            var formatter = lang.trim(domAttr.get(node, "formatter") || "");
            if (formatter) {
                cellDef.formatter = lang.getObject(formatter) || formatter;
            }
            var get = lang.trim(domAttr.get(node, "get") || "");
            if (get) {
                cellDef.get = lang.getObject(get);
            }
            var getBoolAttr = function (attr, cell, cellAttr) {
                var value = lang.trim(domAttr.get(node, attr) || "");
                if (value) {
                    cell[cellAttr || attr] = !(value.toLowerCase() == "false");
                }
            };
            getBoolAttr("sortDesc", cellDef);
            getBoolAttr("editable", cellDef);
            getBoolAttr("alwaysEditing", cellDef);
            getBoolAttr("noresize", cellDef);
            getBoolAttr("draggable", cellDef);
            var value = lang.trim(domAttr.get(node, "loadingText") || domAttr.get(node, "defaultValue") || "");
            if (value) {
                cellDef.defaultValue = value;
            }
            var getStrAttr = function (attr, cell, cellAttr) {
                var value = lang.trim(domAttr.get(node, attr) || "") || undefined;
                if (value) {
                    cell[cellAttr || attr] = value;
                }
            };
            getStrAttr("styles", cellDef);
            getStrAttr("headerStyles", cellDef);
            getStrAttr("cellStyles", cellDef);
            getStrAttr("classes", cellDef);
            getStrAttr("headerClasses", cellDef);
            getStrAttr("cellClasses", cellDef);
        };
        var Cell = BaseCell.Cell = declare("dojox.grid.cells.Cell", BaseCell, {constructor:function () {
            this.keyFilter = this.keyFilter;
        }, keyFilter:null, formatEditing:function (inDatum, inRowIndex) {
            this.needFormatNode(inDatum, inRowIndex);
            return "<input class=\"dojoxGridInput\" type=\"text\" value=\"" + inDatum + "\">";
        }, formatNode:function (inNode, inDatum, inRowIndex) {
            this.inherited(arguments);
            this.registerOnBlur(inNode, inRowIndex);
        }, doKey:function (e) {
            if (this.keyFilter) {
                var key = String.fromCharCode(e.charCode);
                if (key.search(this.keyFilter) == -1) {
                    event.stop(e);
                }
            }
        }, _finish:function (inRowIndex) {
            this.inherited(arguments);
            var n = this.getEditNode(inRowIndex);
            try {
                util.fire(n, "blur");
            }
            catch (e) {
            }
        }});
        Cell.markupFactory = function (node, cellDef) {
            BaseCell.markupFactory(node, cellDef);
            var keyFilter = lang.trim(domAttr.get(node, "keyFilter") || "");
            if (keyFilter) {
                cellDef.keyFilter = new RegExp(keyFilter);
            }
        };
        var RowIndex = BaseCell.RowIndex = declare("dojox.grid.cells.RowIndex", Cell, {name:"Row", postscript:function () {
            this.editable = false;
        }, get:function (inRowIndex) {
            return inRowIndex + 1;
        }});
        RowIndex.markupFactory = function (node, cellDef) {
            Cell.markupFactory(node, cellDef);
        };
        var Select = BaseCell.Select = declare("dojox.grid.cells.Select", Cell, {options:null, values:null, returnIndex:-1, constructor:function (inCell) {
            this.values = this.values || this.options;
        }, formatEditing:function (inDatum, inRowIndex) {
            this.needFormatNode(inDatum, inRowIndex);
            var h = ["<select class=\"dojoxGridSelect\">"];
            for (var i = 0, o, v; ((o = this.options[i]) !== undefined) && ((v = this.values[i]) !== undefined); i++) {
                v = v.replace ? v.replace(/&/g, "&amp;").replace(/</g, "&lt;") : v;
                o = o.replace ? o.replace(/&/g, "&amp;").replace(/</g, "&lt;") : o;
                h.push("<option", (inDatum == v ? " selected" : ""), " value=\"" + v + "\"", ">", o, "</option>");
            }
            h.push("</select>");
            return h.join("");
        }, _defaultFormat:function (inValue, callArgs) {
            var v = this.inherited(arguments);
            if (!this.formatter && this.values && this.options) {
                var i = array.indexOf(this.values, v);
                if (i >= 0) {
                    v = this.options[i];
                }
            }
            return v;
        }, getValue:function (inRowIndex) {
            var n = this.getEditNode(inRowIndex);
            if (n) {
                var i = n.selectedIndex, o = n.options[i];
                return this.returnIndex > -1 ? i : o.value || o.innerHTML;
            }
        }});
        Select.markupFactory = function (node, cell) {
            Cell.markupFactory(node, cell);
            var options = lang.trim(domAttr.get(node, "options") || "");
            if (options) {
                var o = options.split(",");
                if (o[0] != options) {
                    cell.options = o;
                }
            }
            var values = lang.trim(domAttr.get(node, "values") || "");
            if (values) {
                var v = values.split(",");
                if (v[0] != values) {
                    cell.values = v;
                }
            }
        };
        var AlwaysEdit = BaseCell.AlwaysEdit = declare("dojox.grid.cells.AlwaysEdit", Cell, {alwaysEditing:true, _formatNode:function (inDatum, inRowIndex) {
            this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
        }, applyStaticValue:function (inRowIndex) {
            var e = this.grid.edit;
            e.applyCellEdit(this.getValue(inRowIndex), this, inRowIndex);
            e.start(this, inRowIndex, true);
        }});
        AlwaysEdit.markupFactory = function (node, cell) {
            Cell.markupFactory(node, cell);
        };
        var Bool = BaseCell.Bool = declare("dojox.grid.cells.Bool", AlwaysEdit, {_valueProp:"checked", formatEditing:function (inDatum, inRowIndex) {
            return "<input class=\"dojoxGridInput\" type=\"checkbox\"" + (inDatum ? " checked=\"checked\"" : "") + " style=\"width: auto\" />";
        }, doclick:function (e) {
            if (e.target.tagName == "INPUT") {
                this.applyStaticValue(e.rowIndex);
            }
        }});
        Bool.markupFactory = function (node, cell) {
            AlwaysEdit.markupFactory(node, cell);
        };
        return BaseCell;
    });
}, "dojo/cldr/supplemental":function () {
    define(["../_base/lang", "../i18n"], function (lang, i18n) {
        var supplemental = {};
        lang.setObject("dojo.cldr.supplemental", supplemental);
        supplemental.getFirstDayOfWeek = function (locale) {
            var firstDay = {bd:5, mv:5, ae:6, af:6, bh:6, dj:6, dz:6, eg:6, iq:6, ir:6, jo:6, kw:6, ly:6, ma:6, om:6, qa:6, sa:6, sd:6, sy:6, ye:6, ag:0, ar:0, as:0, au:0, br:0, bs:0, bt:0, bw:0, by:0, bz:0, ca:0, cn:0, co:0, dm:0, "do":0, et:0, gt:0, gu:0, hk:0, hn:0, id:0, ie:0, il:0, "in":0, jm:0, jp:0, ke:0, kh:0, kr:0, la:0, mh:0, mm:0, mo:0, mt:0, mx:0, mz:0, ni:0, np:0, nz:0, pa:0, pe:0, ph:0, pk:0, pr:0, py:0, sg:0, sv:0, th:0, tn:0, tt:0, tw:0, um:0, us:0, ve:0, vi:0, ws:0, za:0, zw:0};
            var country = supplemental._region(locale);
            var dow = firstDay[country];
            return (dow === undefined) ? 1 : dow;
        };
        supplemental._region = function (locale) {
            locale = i18n.normalizeLocale(locale);
            var tags = locale.split("-");
            var region = tags[1];
            if (!region) {
                region = {aa:"et", ab:"ge", af:"za", ak:"gh", am:"et", ar:"eg", as:"in", av:"ru", ay:"bo", az:"az", ba:"ru", be:"by", bg:"bg", bi:"vu", bm:"ml", bn:"bd", bo:"cn", br:"fr", bs:"ba", ca:"es", ce:"ru", ch:"gu", co:"fr", cr:"ca", cs:"cz", cv:"ru", cy:"gb", da:"dk", de:"de", dv:"mv", dz:"bt", ee:"gh", el:"gr", en:"us", es:"es", et:"ee", eu:"es", fa:"ir", ff:"sn", fi:"fi", fj:"fj", fo:"fo", fr:"fr", fy:"nl", ga:"ie", gd:"gb", gl:"es", gn:"py", gu:"in", gv:"gb", ha:"ng", he:"il", hi:"in", ho:"pg", hr:"hr", ht:"ht", hu:"hu", hy:"am", ia:"fr", id:"id", ig:"ng", ii:"cn", ik:"us", "in":"id", is:"is", it:"it", iu:"ca", iw:"il", ja:"jp", ji:"ua", jv:"id", jw:"id", ka:"ge", kg:"cd", ki:"ke", kj:"na", kk:"kz", kl:"gl", km:"kh", kn:"in", ko:"kr", ks:"in", ku:"tr", kv:"ru", kw:"gb", ky:"kg", la:"va", lb:"lu", lg:"ug", li:"nl", ln:"cd", lo:"la", lt:"lt", lu:"cd", lv:"lv", mg:"mg", mh:"mh", mi:"nz", mk:"mk", ml:"in", mn:"mn", mo:"ro", mr:"in", ms:"my", mt:"mt", my:"mm", na:"nr", nb:"no", nd:"zw", ne:"np", ng:"na", nl:"nl", nn:"no", no:"no", nr:"za", nv:"us", ny:"mw", oc:"fr", om:"et", or:"in", os:"ge", pa:"in", pl:"pl", ps:"af", pt:"br", qu:"pe", rm:"ch", rn:"bi", ro:"ro", ru:"ru", rw:"rw", sa:"in", sd:"in", se:"no", sg:"cf", si:"lk", sk:"sk", sl:"si", sm:"ws", sn:"zw", so:"so", sq:"al", sr:"rs", ss:"za", st:"za", su:"id", sv:"se", sw:"tz", ta:"in", te:"in", tg:"tj", th:"th", ti:"et", tk:"tm", tl:"ph", tn:"za", to:"to", tr:"tr", ts:"za", tt:"ru", ty:"pf", ug:"cn", uk:"ua", ur:"pk", uz:"uz", ve:"za", vi:"vn", wa:"be", wo:"sn", xh:"za", yi:"il", yo:"ng", za:"cn", zh:"cn", zu:"za", ace:"id", ady:"ru", agq:"cm", alt:"ru", amo:"ng", asa:"tz", ast:"es", awa:"in", bal:"pk", ban:"id", bas:"cm", bax:"cm", bbc:"id", bem:"zm", bez:"tz", bfq:"in", bft:"pk", bfy:"in", bhb:"in", bho:"in", bik:"ph", bin:"ng", bjj:"in", bku:"ph", bqv:"ci", bra:"in", brx:"in", bss:"cm", btv:"pk", bua:"ru", buc:"yt", bug:"id", bya:"id", byn:"er", cch:"ng", ccp:"in", ceb:"ph", cgg:"ug", chk:"fm", chm:"ru", chp:"ca", chr:"us", cja:"kh", cjm:"vn", ckb:"iq", crk:"ca", csb:"pl", dar:"ru", dav:"ke", den:"ca", dgr:"ca", dje:"ne", doi:"in", dsb:"de", dua:"cm", dyo:"sn", dyu:"bf", ebu:"ke", efi:"ng", ewo:"cm", fan:"gq", fil:"ph", fon:"bj", fur:"it", gaa:"gh", gag:"md", gbm:"in", gcr:"gf", gez:"et", gil:"ki", gon:"in", gor:"id", grt:"in", gsw:"ch", guz:"ke", gwi:"ca", haw:"us", hil:"ph", hne:"in", hnn:"ph", hoc:"in", hoj:"in", ibb:"ng", ilo:"ph", inh:"ru", jgo:"cm", jmc:"tz", kaa:"uz", kab:"dz", kaj:"ng", kam:"ke", kbd:"ru", kcg:"ng", kde:"tz", kdt:"th", kea:"cv", ken:"cm", kfo:"ci", kfr:"in", kha:"in", khb:"cn", khq:"ml", kht:"in", kkj:"cm", kln:"ke", kmb:"ao", koi:"ru", kok:"in", kos:"fm", kpe:"lr", krc:"ru", kri:"sl", krl:"ru", kru:"in", ksb:"tz", ksf:"cm", ksh:"de", kum:"ru", lag:"tz", lah:"pk", lbe:"ru", lcp:"cn", lep:"in", lez:"ru", lif:"np", lis:"cn", lki:"ir", lmn:"in", lol:"cd", lua:"cd", luo:"ke", luy:"ke", lwl:"th", mad:"id", mag:"in", mai:"in", mak:"id", man:"gn", mas:"ke", mdf:"ru", mdh:"ph", mdr:"id", men:"sl", mer:"ke", mfe:"mu", mgh:"mz", mgo:"cm", min:"id", mni:"in", mnk:"gm", mnw:"mm", mos:"bf", mua:"cm", mwr:"in", myv:"ru", nap:"it", naq:"na", nds:"de", "new":"np", niu:"nu", nmg:"cm", nnh:"cm", nod:"th", nso:"za", nus:"sd", nym:"tz", nyn:"ug", pag:"ph", pam:"ph", pap:"bq", pau:"pw", pon:"fm", prd:"ir", raj:"in", rcf:"re", rej:"id", rjs:"np", rkt:"in", rof:"tz", rwk:"tz", saf:"gh", sah:"ru", saq:"ke", sas:"id", sat:"in", saz:"in", sbp:"tz", scn:"it", sco:"gb", sdh:"ir", seh:"mz", ses:"ml", shi:"ma", shn:"mm", sid:"et", sma:"se", smj:"se", smn:"fi", sms:"fi", snk:"ml", srn:"sr", srr:"sn", ssy:"er", suk:"tz", sus:"gn", swb:"yt", swc:"cd", syl:"bd", syr:"sy", tbw:"ph", tcy:"in", tdd:"cn", tem:"sl", teo:"ug", tet:"tl", tig:"er", tiv:"ng", tkl:"tk", tmh:"ne", tpi:"pg", trv:"tw", tsg:"ph", tts:"th", tum:"mw", tvl:"tv", twq:"ne", tyv:"ru", tzm:"ma", udm:"ru", uli:"fm", umb:"ao", unr:"in", unx:"in", vai:"lr", vun:"tz", wae:"ch", wal:"et", war:"ph", xog:"ug", xsr:"np", yao:"mz", yap:"fm", yav:"cm", zza:"tr"}[tags[0]];
            } else {
                if (region.length == 4) {
                    region = tags[2];
                }
            }
            return region;
        };
        supplemental.getWeekend = function (locale) {
            var weekendStart = {"in":0, af:4, dz:4, ir:4, om:4, sa:4, ye:4, ae:5, bh:5, eg:5, il:5, iq:5, jo:5, kw:5, ly:5, ma:5, qa:5, sd:5, sy:5, tn:5}, weekendEnd = {af:5, dz:5, ir:5, om:5, sa:5, ye:5, ae:6, bh:5, eg:6, il:6, iq:6, jo:6, kw:6, ly:6, ma:6, qa:6, sd:6, sy:6, tn:6}, country = supplemental._region(locale), start = weekendStart[country], end = weekendEnd[country];
            if (start === undefined) {
                start = 6;
            }
            if (end === undefined) {
                end = 0;
            }
            return {start:start, end:end};
        };
        return supplemental;
    });
}, "dojo/number":function () {
    define(["./_base/lang", "./i18n", "./i18n!./cldr/nls/number", "./string", "./regexp"], function (lang, i18n, nlsNumber, dstring, dregexp) {
        var number = {};
        lang.setObject("dojo.number", number);
        number.format = function (value, options) {
            options = lang.mixin({}, options || {});
            var locale = i18n.normalizeLocale(options.locale), bundle = i18n.getLocalization("dojo.cldr", "number", locale);
            options.customs = bundle;
            var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
            if (isNaN(value) || Math.abs(value) == Infinity) {
                return null;
            }
            return number._applyPattern(value, pattern, options);
        };
        number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/;
        number._applyPattern = function (value, pattern, options) {
            options = options || {};
            var group = options.customs.group, decimal = options.customs.decimal, patternList = pattern.split(";"), positivePattern = patternList[0];
            pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);
            if (pattern.indexOf("%") != -1) {
                value *= 100;
            } else {
                if (pattern.indexOf("\u2030") != -1) {
                    value *= 1000;
                } else {
                    if (pattern.indexOf("\xa4") != -1) {
                        group = options.customs.currencyGroup || group;
                        decimal = options.customs.currencyDecimal || decimal;
                        pattern = pattern.replace(/\u00a4{1,3}/, function (match) {
                            var prop = ["symbol", "currency", "displayName"][match.length - 1];
                            return options[prop] || options.currency || "";
                        });
                    } else {
                        if (pattern.indexOf("E") != -1) {
                            throw new Error("exponential notation not supported");
                        }
                    }
                }
            }
            var numberPatternRE = number._numberPatternRE;
            var numberPattern = positivePattern.match(numberPatternRE);
            if (!numberPattern) {
                throw new Error("unable to find a number expression in pattern: " + pattern);
            }
            if (options.fractional === false) {
                options.places = 0;
            }
            return pattern.replace(numberPatternRE, number._formatAbsolute(value, numberPattern[0], {decimal:decimal, group:group, places:options.places, round:options.round}));
        };
        number.round = function (value, places, increment) {
            var factor = 10 / (increment || 10);
            return (factor * +value).toFixed(places) / factor;
        };
        if ((0.9).toFixed() == 0) {
            var round = number.round;
            number.round = function (v, p, m) {
                var d = Math.pow(10, -p || 0), a = Math.abs(v);
                if (!v || a >= d) {
                    d = 0;
                } else {
                    a /= d;
                    if (a < 0.5 || a >= 0.95) {
                        d = 0;
                    }
                }
                return round(v, p, m) + (v > 0 ? d : -d);
            };
        }
        number._formatAbsolute = function (value, pattern, options) {
            options = options || {};
            if (options.places === true) {
                options.places = 0;
            }
            if (options.places === Infinity) {
                options.places = 6;
            }
            var patternParts = pattern.split("."), comma = typeof options.places == "string" && options.places.indexOf(","), maxPlaces = options.places;
            if (comma) {
                maxPlaces = options.places.substring(comma + 1);
            } else {
                if (!(maxPlaces >= 0)) {
                    maxPlaces = (patternParts[1] || []).length;
                }
            }
            if (!(options.round < 0)) {
                value = number.round(value, maxPlaces, options.round);
            }
            var valueParts = String(Math.abs(value)).split("."), fractional = valueParts[1] || "";
            if (patternParts[1] || options.places) {
                if (comma) {
                    options.places = options.places.substring(0, comma);
                }
                var pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf("0") + 1);
                if (pad > fractional.length) {
                    valueParts[1] = dstring.pad(fractional, pad, "0", true);
                }
                if (maxPlaces < fractional.length) {
                    valueParts[1] = fractional.substr(0, maxPlaces);
                }
            } else {
                if (valueParts[1]) {
                    valueParts.pop();
                }
            }
            var patternDigits = patternParts[0].replace(",", "");
            pad = patternDigits.indexOf("0");
            if (pad != -1) {
                pad = patternDigits.length - pad;
                if (pad > valueParts[0].length) {
                    valueParts[0] = dstring.pad(valueParts[0], pad);
                }
                if (patternDigits.indexOf("#") == -1) {
                    valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
                }
            }
            var index = patternParts[0].lastIndexOf(","), groupSize, groupSize2;
            if (index != -1) {
                groupSize = patternParts[0].length - index - 1;
                var remainder = patternParts[0].substr(0, index);
                index = remainder.lastIndexOf(",");
                if (index != -1) {
                    groupSize2 = remainder.length - index - 1;
                }
            }
            var pieces = [];
            for (var whole = valueParts[0]; whole; ) {
                var off = whole.length - groupSize;
                pieces.push((off > 0) ? whole.substr(off) : whole);
                whole = (off > 0) ? whole.slice(0, off) : "";
                if (groupSize2) {
                    groupSize = groupSize2;
                    delete groupSize2;
                }
            }
            valueParts[0] = pieces.reverse().join(options.group || ",");
            return valueParts.join(options.decimal || ".");
        };
        number.regexp = function (options) {
            return number._parseInfo(options).regexp;
        };
        number._parseInfo = function (options) {
            options = options || {};
            var locale = i18n.normalizeLocale(options.locale), bundle = i18n.getLocalization("dojo.cldr", "number", locale), pattern = options.pattern || bundle[(options.type || "decimal") + "Format"], group = bundle.group, decimal = bundle.decimal, factor = 1;
            if (pattern.indexOf("%") != -1) {
                factor /= 100;
            } else {
                if (pattern.indexOf("\u2030") != -1) {
                    factor /= 1000;
                } else {
                    var isCurrency = pattern.indexOf("\xa4") != -1;
                    if (isCurrency) {
                        group = bundle.currencyGroup || group;
                        decimal = bundle.currencyDecimal || decimal;
                    }
                }
            }
            var patternList = pattern.split(";");
            if (patternList.length == 1) {
                patternList.push("-" + patternList[0]);
            }
            var re = dregexp.buildGroupRE(patternList, function (pattern) {
                pattern = "(?:" + dregexp.escapeString(pattern, ".") + ")";
                return pattern.replace(number._numberPatternRE, function (format) {
                    var flags = {signed:false, separator:options.strict ? group : [group, ""], fractional:options.fractional, decimal:decimal, exponent:false}, parts = format.split("."), places = options.places;
                    if (parts.length == 1 && factor != 1) {
                        parts[1] = "###";
                    }
                    if (parts.length == 1 || places === 0) {
                        flags.fractional = false;
                    } else {
                        if (places === undefined) {
                            places = options.pattern ? parts[1].lastIndexOf("0") + 1 : Infinity;
                        }
                        if (places && options.fractional == undefined) {
                            flags.fractional = true;
                        }
                        if (!options.places && (places < parts[1].length)) {
                            places += "," + parts[1].length;
                        }
                        flags.places = places;
                    }
                    var groups = parts[0].split(",");
                    if (groups.length > 1) {
                        flags.groupSize = groups.pop().length;
                        if (groups.length > 1) {
                            flags.groupSize2 = groups.pop().length;
                        }
                    }
                    return "(" + number._realNumberRegexp(flags) + ")";
                });
            }, true);
            if (isCurrency) {
                re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function (match, before, target, after) {
                    var prop = ["symbol", "currency", "displayName"][target.length - 1], symbol = dregexp.escapeString(options[prop] || options.currency || "");
                    before = before ? "[\\s\\xa0]" : "";
                    after = after ? "[\\s\\xa0]" : "";
                    if (!options.strict) {
                        if (before) {
                            before += "*";
                        }
                        if (after) {
                            after += "*";
                        }
                        return "(?:" + before + symbol + after + ")?";
                    }
                    return before + symbol + after;
                });
            }
            return {regexp:re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group:group, decimal:decimal, factor:factor};
        };
        number.parse = function (expression, options) {
            var info = number._parseInfo(options), results = (new RegExp("^" + info.regexp + "$")).exec(expression);
            if (!results) {
                return NaN;
            }
            var absoluteMatch = results[1];
            if (!results[1]) {
                if (!results[2]) {
                    return NaN;
                }
                absoluteMatch = results[2];
                info.factor *= -1;
            }
            absoluteMatch = absoluteMatch.replace(new RegExp("[" + info.group + "\\s\\xa0" + "]", "g"), "").replace(info.decimal, ".");
            return absoluteMatch * info.factor;
        };
        number._realNumberRegexp = function (flags) {
            flags = flags || {};
            if (!("places" in flags)) {
                flags.places = Infinity;
            }
            if (typeof flags.decimal != "string") {
                flags.decimal = ".";
            }
            if (!("fractional" in flags) || /^0/.test(flags.places)) {
                flags.fractional = [true, false];
            }
            if (!("exponent" in flags)) {
                flags.exponent = [true, false];
            }
            if (!("eSigned" in flags)) {
                flags.eSigned = [true, false];
            }
            var integerRE = number._integerRegexp(flags), decimalRE = dregexp.buildGroupRE(flags.fractional, function (q) {
                var re = "";
                if (q && (flags.places !== 0)) {
                    re = "\\" + flags.decimal;
                    if (flags.places == Infinity) {
                        re = "(?:" + re + "\\d+)?";
                    } else {
                        re += "\\d{" + flags.places + "}";
                    }
                }
                return re;
            }, true);
            var exponentRE = dregexp.buildGroupRE(flags.exponent, function (q) {
                if (q) {
                    return "([eE]" + number._integerRegexp({signed:flags.eSigned}) + ")";
                }
                return "";
            });
            var realRE = integerRE + decimalRE;
            if (decimalRE) {
                realRE = "(?:(?:" + realRE + ")|(?:" + decimalRE + "))";
            }
            return realRE + exponentRE;
        };
        number._integerRegexp = function (flags) {
            flags = flags || {};
            if (!("signed" in flags)) {
                flags.signed = [true, false];
            }
            if (!("separator" in flags)) {
                flags.separator = "";
            } else {
                if (!("groupSize" in flags)) {
                    flags.groupSize = 3;
                }
            }
            var signRE = dregexp.buildGroupRE(flags.signed, function (q) {
                return q ? "[-+]" : "";
            }, true);
            var numberRE = dregexp.buildGroupRE(flags.separator, function (sep) {
                if (!sep) {
                    return "(?:\\d+)";
                }
                sep = dregexp.escapeString(sep);
                if (sep == " ") {
                    sep = "\\s";
                } else {
                    if (sep == "\xa0") {
                        sep = "\\s\\xa0";
                    }
                }
                var grp = flags.groupSize, grp2 = flags.groupSize2;
                if (grp2) {
                    var grp2RE = "(?:0|[1-9]\\d{0," + (grp2 - 1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
                    return ((grp - grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp - 1) + "}))" : grp2RE;
                }
                return "(?:0|[1-9]\\d{0," + (grp - 1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
            }, true);
            return signRE + numberRE;
        };
        return number;
    });
}, "dijit/layout/_ContentPaneResizeMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/lang", "dojo/query", "dojo/sniff", "../registry", "../Viewport", "./utils"], function (array, declare, domClass, domGeometry, domStyle, lang, query, has, registry, Viewport, layoutUtils) {
        return declare("dijit.layout._ContentPaneResizeMixin", null, {doLayout:true, isLayoutContainer:true, startup:function () {
            if (this._started) {
                return;
            }
            var parent = this.getParent();
            this._childOfLayoutWidget = parent && parent.isLayoutContainer;
            this._needLayout = !this._childOfLayoutWidget;
            this.inherited(arguments);
            if (this._isShown()) {
                this._onShow();
            }
            if (!this._childOfLayoutWidget) {
                this.own(Viewport.on("resize", lang.hitch(this, "resize")));
            }
        }, _checkIfSingleChild:function () {
            var candidateWidgets = [], otherVisibleNodes = false;
            query("> *", this.containerNode).some(function (node) {
                var widget = registry.byNode(node);
                if (widget && widget.resize) {
                    candidateWidgets.push(widget);
                } else {
                    if (!/script|link|style/i.test(node.nodeName) && node.offsetHeight) {
                        otherVisibleNodes = true;
                    }
                }
            });
            this._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ? candidateWidgets[0] : null;
            domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
        }, resize:function (changeSize, resultSize) {
            this._resizeCalled = true;
            this._scheduleLayout(changeSize, resultSize);
        }, _scheduleLayout:function (changeSize, resultSize) {
            if (this._isShown()) {
                this._layout(changeSize, resultSize);
            } else {
                this._needLayout = true;
                this._changeSize = changeSize;
                this._resultSize = resultSize;
            }
        }, _layout:function (changeSize, resultSize) {
            delete this._needLayout;
            if (!this._wasShown && this.open !== false) {
                this._onShow();
            }
            if (changeSize) {
                domGeometry.setMarginBox(this.domNode, changeSize);
            }
            var cn = this.containerNode;
            if (cn === this.domNode) {
                var mb = resultSize || {};
                lang.mixin(mb, changeSize || {});
                if (!("h" in mb) || !("w" in mb)) {
                    mb = lang.mixin(domGeometry.getMarginBox(cn), mb);
                }
                this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
            } else {
                this._contentBox = domGeometry.getContentBox(cn);
            }
            this._layoutChildren();
        }, _layoutChildren:function () {
            if (this.doLayout) {
                this._checkIfSingleChild();
            }
            if (this._singleChild && this._singleChild.resize) {
                var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);
                this._singleChild.resize({w:cb.w, h:cb.h});
            } else {
                var children = this.getChildren(), widget, i = 0;
                while (widget = children[i++]) {
                    if (widget.resize) {
                        widget.resize();
                    }
                }
            }
        }, _isShown:function () {
            if (this._childOfLayoutWidget) {
                if (this._resizeCalled && "open" in this) {
                    return this.open;
                }
                return this._resizeCalled;
            } else {
                if ("open" in this) {
                    return this.open;
                } else {
                    var node = this.domNode, parent = this.domNode.parentNode;
                    return (node.style.display != "none") && (node.style.visibility != "hidden") && !domClass.contains(node, "dijitHidden") && parent && parent.style && (parent.style.display != "none");
                }
            }
        }, _onShow:function () {
            this._wasShown = true;
            if (this._needLayout) {
                this._layout(this._changeSize, this._resultSize);
            }
            this.inherited(arguments);
        }});
    });
}, "dijit/form/_ButtonMixin":function () {
    define(["dojo/_base/declare", "dojo/dom", "dojo/has", "../registry"], function (declare, dom, has, registry) {
        var ButtonMixin = declare("dijit.form._ButtonMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {label:"", type:"button", __onClick:function (e) {
            e.stopPropagation();
            e.preventDefault();
            if (!this.disabled) {
                this.valueNode.click(e);
            }
            return false;
        }, _onClick:function (e) {
            if (this.disabled) {
                e.stopPropagation();
                e.preventDefault();
                return false;
            }
            if (this.onClick(e) === false) {
                e.preventDefault();
            }
            var cancelled = e.defaultPrevented;
            if (!cancelled && this.type == "submit" && !(this.valueNode || this.focusNode).form) {
                for (var node = this.domNode; node.parentNode; node = node.parentNode) {
                    var widget = registry.byNode(node);
                    if (widget && typeof widget._onSubmit == "function") {
                        widget._onSubmit(e);
                        e.preventDefault();
                        cancelled = true;
                        break;
                    }
                }
            }
            return !cancelled;
        }, postCreate:function () {
            this.inherited(arguments);
            dom.setSelectable(this.focusNode, false);
        }, onClick:function () {
            return true;
        }, _setLabelAttr:function (content) {
            this._set("label", content);
            var labelNode = this.containerNode || this.focusNode;
            labelNode.innerHTML = content;
        }});
        if (has("dojo-bidi")) {
            ButtonMixin = declare("dijit.form._ButtonMixin", ButtonMixin, {_setLabelAttr:function () {
                this.inherited(arguments);
                var labelNode = this.containerNode || this.focusNode;
                this.applyTextDir(labelNode);
            }});
        }
        return ButtonMixin;
    });
}, "dojo/promise/tracer":function () {
    define(["../_base/lang", "./Promise", "../Evented"], function (lang, Promise, Evented) {
        "use strict";
        var evented = new Evented;
        var emit = evented.emit;
        evented.emit = null;
        function emitAsync(args) {
            setTimeout(function () {
                emit.apply(evented, args);
            }, 0);
        }
        Promise.prototype.trace = function () {
            var args = lang._toArray(arguments);
            this.then(function (value) {
                emitAsync(["resolved", value].concat(args));
            }, function (error) {
                emitAsync(["rejected", error].concat(args));
            }, function (update) {
                emitAsync(["progress", update].concat(args));
            });
            return this;
        };
        Promise.prototype.traceRejected = function () {
            var args = lang._toArray(arguments);
            this.otherwise(function (error) {
                emitAsync(["rejected", error].concat(args));
            });
            return this;
        };
        return evented;
    });
}, "dijit/tree/TreeStoreModel":function () {
    define(["dojo/_base/array", "dojo/aspect", "dojo/_base/declare", "dojo/_base/lang"], function (array, aspect, declare, lang) {
        return declare("dijit.tree.TreeStoreModel", null, {store:null, childrenAttrs:["children"], newItemIdAttr:"id", labelAttr:"", root:null, query:null, deferItemLoadingUntilExpand:false, constructor:function (args) {
            lang.mixin(this, args);
            this.connects = [];
            var store = this.store;
            if (!store.getFeatures()["dojo.data.api.Identity"]) {
                throw new Error("dijit.tree.TreeStoreModel: store must support dojo.data.Identity");
            }
            if (store.getFeatures()["dojo.data.api.Notification"]) {
                this.connects = this.connects.concat([aspect.after(store, "onNew", lang.hitch(this, "onNewItem"), true), aspect.after(store, "onDelete", lang.hitch(this, "onDeleteItem"), true), aspect.after(store, "onSet", lang.hitch(this, "onSetItem"), true)]);
            }
        }, destroy:function () {
            var h;
            while (h = this.connects.pop()) {
                h.remove();
            }
        }, getRoot:function (onItem, onError) {
            if (this.root) {
                onItem(this.root);
            } else {
                this.store.fetch({query:this.query, onComplete:lang.hitch(this, function (items) {
                    if (items.length != 1) {
                        throw new Error("dijit.tree.TreeStoreModel: root query returned " + items.length + " items, but must return exactly one");
                    }
                    this.root = items[0];
                    onItem(this.root);
                }), onError:onError});
            }
        }, mayHaveChildren:function (item) {
            return array.some(this.childrenAttrs, function (attr) {
                return this.store.hasAttribute(item, attr);
            }, this);
        }, getChildren:function (parentItem, onComplete, onError) {
            var store = this.store;
            if (!store.isItemLoaded(parentItem)) {
                var getChildren = lang.hitch(this, arguments.callee);
                store.loadItem({item:parentItem, onItem:function (parentItem) {
                    getChildren(parentItem, onComplete, onError);
                }, onError:onError});
                return;
            }
            var childItems = [];
            for (var i = 0; i < this.childrenAttrs.length; i++) {
                var vals = store.getValues(parentItem, this.childrenAttrs[i]);
                childItems = childItems.concat(vals);
            }
            var _waitCount = 0;
            if (!this.deferItemLoadingUntilExpand) {
                array.forEach(childItems, function (item) {
                    if (!store.isItemLoaded(item)) {
                        _waitCount++;
                    }
                });
            }
            if (_waitCount == 0) {
                onComplete(childItems);
            } else {
                array.forEach(childItems, function (item, idx) {
                    if (!store.isItemLoaded(item)) {
                        store.loadItem({item:item, onItem:function (item) {
                            childItems[idx] = item;
                            if (--_waitCount == 0) {
                                onComplete(childItems);
                            }
                        }, onError:onError});
                    }
                });
            }
        }, isItem:function (something) {
            return this.store.isItem(something);
        }, fetchItemByIdentity:function (keywordArgs) {
            this.store.fetchItemByIdentity(keywordArgs);
        }, getIdentity:function (item) {
            return this.store.getIdentity(item);
        }, getLabel:function (item) {
            if (this.labelAttr) {
                return this.store.getValue(item, this.labelAttr);
            } else {
                return this.store.getLabel(item);
            }
        }, newItem:function (args, parent, insertIndex) {
            var pInfo = {parent:parent, attribute:this.childrenAttrs[0]}, LnewItem;
            if (this.newItemIdAttr && args[this.newItemIdAttr]) {
                this.fetchItemByIdentity({identity:args[this.newItemIdAttr], scope:this, onItem:function (item) {
                    if (item) {
                        this.pasteItem(item, null, parent, true, insertIndex);
                    } else {
                        LnewItem = this.store.newItem(args, pInfo);
                        if (LnewItem && (insertIndex != undefined)) {
                            this.pasteItem(LnewItem, parent, parent, false, insertIndex);
                        }
                    }
                }});
            } else {
                LnewItem = this.store.newItem(args, pInfo);
                if (LnewItem && (insertIndex != undefined)) {
                    this.pasteItem(LnewItem, parent, parent, false, insertIndex);
                }
            }
        }, pasteItem:function (childItem, oldParentItem, newParentItem, bCopy, insertIndex) {
            var store = this.store, parentAttr = this.childrenAttrs[0];
            if (oldParentItem) {
                array.forEach(this.childrenAttrs, function (attr) {
                    if (store.containsValue(oldParentItem, attr, childItem)) {
                        if (!bCopy) {
                            var values = array.filter(store.getValues(oldParentItem, attr), function (x) {
                                return x != childItem;
                            });
                            store.setValues(oldParentItem, attr, values);
                        }
                        parentAttr = attr;
                    }
                });
            }
            if (newParentItem) {
                if (typeof insertIndex == "number") {
                    var childItems = store.getValues(newParentItem, parentAttr).slice();
                    childItems.splice(insertIndex, 0, childItem);
                    store.setValues(newParentItem, parentAttr, childItems);
                } else {
                    store.setValues(newParentItem, parentAttr, store.getValues(newParentItem, parentAttr).concat(childItem));
                }
            }
        }, onChange:function () {
        }, onChildrenChange:function () {
        }, onDelete:function () {
        }, onNewItem:function (item, parentInfo) {
            if (!parentInfo) {
                return;
            }
            this.getChildren(parentInfo.item, lang.hitch(this, function (children) {
                this.onChildrenChange(parentInfo.item, children);
            }));
        }, onDeleteItem:function (item) {
            this.onDelete(item);
        }, onSetItem:function (item, attribute) {
            if (array.indexOf(this.childrenAttrs, attribute) != -1) {
                this.getChildren(item, lang.hitch(this, function (children) {
                    this.onChildrenChange(item, children);
                }));
            } else {
                this.onChange(item);
            }
        }});
    });
}, "dojo/dnd/TimedMoveable":function () {
    define(["../_base/declare", "./Moveable"], function (declare, Moveable) {
        var oldOnMove = Moveable.prototype.onMove;
        return declare("dojo.dnd.TimedMoveable", Moveable, {timeout:40, constructor:function (node, params) {
            if (!params) {
                params = {};
            }
            if (params.timeout && typeof params.timeout == "number" && params.timeout >= 0) {
                this.timeout = params.timeout;
            }
        }, onMoveStop:function (mover) {
            if (mover._timer) {
                clearTimeout(mover._timer);
                oldOnMove.call(this, mover, mover._leftTop);
            }
            Moveable.prototype.onMoveStop.apply(this, arguments);
        }, onMove:function (mover, leftTop) {
            mover._leftTop = leftTop;
            if (!mover._timer) {
                var _t = this;
                mover._timer = setTimeout(function () {
                    mover._timer = null;
                    oldOnMove.call(_t, mover, mover._leftTop);
                }, this.timeout);
            }
        }});
    });
}, "dijit/a11yclick":function () {
    define(["dojo/keys", "dojo/mouse", "dojo/on", "dojo/touch"], function (keys, mouse, on, touch) {
        function clickKey(e) {
            if ((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)) {
                for (var node = e.target; node; node = node.parentNode) {
                    if (node.dojoClick) {
                        return true;
                    }
                }
            }
        }
        var lastKeyDownNode;
        on(document, "keydown", function (e) {
            if (clickKey(e)) {
                lastKeyDownNode = e.target;
                e.preventDefault();
            } else {
                lastKeyDownNode = null;
            }
        });
        on(document, "keyup", function (e) {
            if (clickKey(e) && e.target == lastKeyDownNode) {
                lastKeyDownNode = null;
                on.emit(e.target, "click", {cancelable:true, bubbles:true, ctrlKey:e.ctrlKey, shiftKey:e.shiftKey, metaKey:e.metaKey, altKey:e.altKey, _origType:e.type});
            }
        });
        var click = function (node, listener) {
            node.dojoClick = true;
            return on(node, "click", listener);
        };
        click.click = click;
        click.press = function (node, listener) {
            var touchListener = on(node, touch.press, function (evt) {
                if (evt.type == "mousedown" && !mouse.isLeft(evt)) {
                    return;
                }
                listener(evt);
            }), keyListener = on(node, "keydown", function (evt) {
                if (evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE) {
                    listener(evt);
                }
            });
            return {remove:function () {
                touchListener.remove();
                keyListener.remove();
            }};
        };
        click.release = function (node, listener) {
            var touchListener = on(node, touch.release, function (evt) {
                if (evt.type == "mouseup" && !mouse.isLeft(evt)) {
                    return;
                }
                listener(evt);
            }), keyListener = on(node, "keyup", function (evt) {
                if (evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE) {
                    listener(evt);
                }
            });
            return {remove:function () {
                touchListener.remove();
                keyListener.remove();
            }};
        };
        click.move = touch.move;
        return click;
    });
}, "dijit/hccss":function () {
    define(["dojo/dom-class", "dojo/hccss", "dojo/domReady", "dojo/_base/window"], function (domClass, has, domReady, win) {
        domReady(function () {
            if (has("highcontrast")) {
                domClass.add(win.body(), "dijit_a11y");
            }
        });
        return has;
    });
}, "dijit/Editor":function () {
    define(["require", "dojo/_base/array", "dojo/_base/declare", "dojo/Deferred", "dojo/i18n", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/keys", "dojo/_base/lang", "dojo/sniff", "dojo/string", "dojo/topic", "./_Container", "./Toolbar", "./ToolbarSeparator", "./layout/_LayoutWidget", "./form/ToggleButton", "./_editor/_Plugin", "./_editor/plugins/EnterKeyHandling", "./_editor/html", "./_editor/range", "./_editor/RichText", "./main", "dojo/i18n!./_editor/nls/commands"], function (require, array, declare, Deferred, i18n, domAttr, domClass, domGeometry, domStyle, keys, lang, has, string, topic, _Container, Toolbar, ToolbarSeparator, _LayoutWidget, ToggleButton, _Plugin, EnterKeyHandling, html, rangeapi, RichText, dijit) {
        var Editor = declare("dijit.Editor", RichText, {plugins:null, extraPlugins:null, constructor:function () {
            if (!lang.isArray(this.plugins)) {
                this.plugins = ["undo", "redo", "|", "cut", "copy", "paste", "|", "bold", "italic", "underline", "strikethrough", "|", "insertOrderedList", "insertUnorderedList", "indent", "outdent", "|", "justifyLeft", "justifyRight", "justifyCenter", "justifyFull", EnterKeyHandling];
            }
            this._plugins = [];
            this._editInterval = this.editActionInterval * 1000;
            if (has("ie") || has("trident")) {
                this.events.push("onBeforeDeactivate");
                this.events.push("onBeforeActivate");
            }
        }, postMixInProperties:function () {
            this.setValueDeferred = new Deferred();
            this.inherited(arguments);
        }, postCreate:function () {
            this.inherited(arguments);
            this._steps = this._steps.slice(0);
            this._undoedSteps = this._undoedSteps.slice(0);
            if (lang.isArray(this.extraPlugins)) {
                this.plugins = this.plugins.concat(this.extraPlugins);
            }
            this.commands = i18n.getLocalization("dijit._editor", "commands", this.lang);
            if (has("webkit")) {
                domStyle.set(this.domNode, "KhtmlUserSelect", "none");
            }
        }, startup:function () {
            this.inherited(arguments);
            if (!this.toolbar) {
                this.toolbar = new Toolbar({ownerDocument:this.ownerDocument, dir:this.dir, lang:this.lang, "aria-label":this.id});
                this.header.appendChild(this.toolbar.domNode);
            }
            array.forEach(this.plugins, this.addPlugin, this);
            this.setValueDeferred.resolve(true);
            domClass.add(this.iframe.parentNode, "dijitEditorIFrameContainer");
            domClass.add(this.iframe, "dijitEditorIFrame");
            domAttr.set(this.iframe, "allowTransparency", true);
            this.toolbar.startup();
            this.onNormalizedDisplayChanged();
        }, destroy:function () {
            array.forEach(this._plugins, function (p) {
                if (p && p.destroy) {
                    p.destroy();
                }
            });
            this._plugins = [];
            this.toolbar.destroyRecursive();
            delete this.toolbar;
            this.inherited(arguments);
        }, addPlugin:function (plugin, index) {
            var args = lang.isString(plugin) ? {name:plugin} : lang.isFunction(plugin) ? {ctor:plugin} : plugin;
            if (!args.setEditor) {
                var o = {"args":args, "plugin":null, "editor":this};
                if (args.name) {
                    if (_Plugin.registry[args.name]) {
                        o.plugin = _Plugin.registry[args.name](args);
                    } else {
                        topic.publish(dijit._scopeName + ".Editor.getPlugin", o);
                    }
                }
                if (!o.plugin) {
                    try {
                        var pc = args.ctor || lang.getObject(args.name) || require(args.name);
                        if (pc) {
                            o.plugin = new pc(args);
                        }
                    }
                    catch (e) {
                        throw new Error(this.id + ": cannot find plugin [" + args.name + "]");
                    }
                }
                if (!o.plugin) {
                    throw new Error(this.id + ": cannot find plugin [" + args.name + "]");
                }
                plugin = o.plugin;
            }
            if (arguments.length > 1) {
                this._plugins[index] = plugin;
            } else {
                this._plugins.push(plugin);
            }
            plugin.setEditor(this);
            if (lang.isFunction(plugin.setToolbar)) {
                plugin.setToolbar(this.toolbar);
            }
        }, resize:function (size) {
            if (size) {
                _LayoutWidget.prototype.resize.apply(this, arguments);
            }
        }, layout:function () {
            var areaHeight = (this._contentBox.h - (this.getHeaderHeight() + this.getFooterHeight() + domGeometry.getPadBorderExtents(this.iframe.parentNode).h + domGeometry.getMarginExtents(this.iframe.parentNode).h));
            this.editingArea.style.height = areaHeight + "px";
            if (this.iframe) {
                this.iframe.style.height = "100%";
            }
            this._layoutMode = true;
        }, _onIEMouseDown:function (e) {
            var outsideClientArea;
            var b = this.document.body;
            var clientWidth = b.clientWidth;
            var clientHeight = b.clientHeight;
            var clientLeft = b.clientLeft;
            var offsetWidth = b.offsetWidth;
            var offsetHeight = b.offsetHeight;
            var offsetLeft = b.offsetLeft;
            if (/^rtl$/i.test(b.dir || "")) {
                if (clientWidth < offsetWidth && e.x > clientWidth && e.x < offsetWidth) {
                    outsideClientArea = true;
                }
            } else {
                if (e.x < clientLeft && e.x > offsetLeft) {
                    outsideClientArea = true;
                }
            }
            if (!outsideClientArea) {
                if (clientHeight < offsetHeight && e.y > clientHeight && e.y < offsetHeight) {
                    outsideClientArea = true;
                }
            }
            if (!outsideClientArea) {
                delete this._cursorToStart;
                delete this._savedSelection;
                if (e.target.tagName == "BODY") {
                    this.defer("placeCursorAtEnd");
                }
                this.inherited(arguments);
            }
        }, onBeforeActivate:function () {
            this._restoreSelection();
        }, onBeforeDeactivate:function (e) {
            if (this.customUndo) {
                this.endEditing(true);
            }
            if (e.target.tagName != "BODY") {
                this._saveSelection();
            }
        }, customUndo:true, editActionInterval:3, beginEditing:function (cmd) {
            if (!this._inEditing) {
                this._inEditing = true;
                this._beginEditing(cmd);
            }
            if (this.editActionInterval > 0) {
                if (this._editTimer) {
                    this._editTimer.remove();
                }
                this._editTimer = this.defer("endEditing", this._editInterval);
            }
        }, _steps:[], _undoedSteps:[], execCommand:function (cmd) {
            if (this.customUndo && (cmd == "undo" || cmd == "redo")) {
                return this[cmd]();
            } else {
                if (this.customUndo) {
                    this.endEditing();
                    this._beginEditing();
                }
                var r = this.inherited(arguments);
                if (this.customUndo) {
                    this._endEditing();
                }
                return r;
            }
        }, _pasteImpl:function () {
            return this._clipboardCommand("paste");
        }, _cutImpl:function () {
            return this._clipboardCommand("cut");
        }, _copyImpl:function () {
            return this._clipboardCommand("copy");
        }, _clipboardCommand:function (cmd) {
            var r;
            try {
                r = this.document.execCommand(cmd, false, null);
                if (has("webkit") && !r) {
                    throw {code:1011};
                }
            }
            catch (e) {
                if (e.code == 1011 || (e.code == 9 && has("opera"))) {
                    var sub = string.substitute, accel = {cut:"X", copy:"C", paste:"V"};
                    alert(sub(this.commands.systemShortcut, [this.commands[cmd], sub(this.commands[has("mac") ? "appleKey" : "ctrlKey"], [accel[cmd]])]));
                }
                r = false;
            }
            return r;
        }, queryCommandEnabled:function (cmd) {
            if (this.customUndo && (cmd == "undo" || cmd == "redo")) {
                return cmd == "undo" ? (this._steps.length > 1) : (this._undoedSteps.length > 0);
            } else {
                return this.inherited(arguments);
            }
        }, _moveToBookmark:function (b) {
            var bookmark = b.mark;
            var mark = b.mark;
            var col = b.isCollapsed;
            var r, sNode, eNode, sel;
            if (mark) {
                if (has("ie") < 9 || (has("ie") === 9 && has("quirks"))) {
                    if (lang.isArray(mark)) {
                        bookmark = [];
                        array.forEach(mark, function (n) {
                            bookmark.push(rangeapi.getNode(n, this.editNode));
                        }, this);
                        this.selection.moveToBookmark({mark:bookmark, isCollapsed:col});
                    } else {
                        if (mark.startContainer && mark.endContainer) {
                            sel = rangeapi.getSelection(this.window);
                            if (sel && sel.removeAllRanges) {
                                sel.removeAllRanges();
                                r = rangeapi.create(this.window);
                                sNode = rangeapi.getNode(mark.startContainer, this.editNode);
                                eNode = rangeapi.getNode(mark.endContainer, this.editNode);
                                if (sNode && eNode) {
                                    r.setStart(sNode, mark.startOffset);
                                    r.setEnd(eNode, mark.endOffset);
                                    sel.addRange(r);
                                }
                            }
                        }
                    }
                } else {
                    sel = rangeapi.getSelection(this.window);
                    if (sel && sel.removeAllRanges) {
                        sel.removeAllRanges();
                        r = rangeapi.create(this.window);
                        sNode = rangeapi.getNode(mark.startContainer, this.editNode);
                        eNode = rangeapi.getNode(mark.endContainer, this.editNode);
                        if (sNode && eNode) {
                            r.setStart(sNode, mark.startOffset);
                            r.setEnd(eNode, mark.endOffset);
                            sel.addRange(r);
                        }
                    }
                }
            }
        }, _changeToStep:function (from, to) {
            this.setValue(to.text);
            var b = to.bookmark;
            if (!b) {
                return;
            }
            this._moveToBookmark(b);
        }, undo:function () {
            var ret = false;
            if (!this._undoRedoActive) {
                this._undoRedoActive = true;
                this.endEditing(true);
                var s = this._steps.pop();
                if (s && this._steps.length > 0) {
                    this.focus();
                    this._changeToStep(s, this._steps[this._steps.length - 1]);
                    this._undoedSteps.push(s);
                    this.onDisplayChanged();
                    delete this._undoRedoActive;
                    ret = true;
                }
                delete this._undoRedoActive;
            }
            return ret;
        }, redo:function () {
            var ret = false;
            if (!this._undoRedoActive) {
                this._undoRedoActive = true;
                this.endEditing(true);
                var s = this._undoedSteps.pop();
                if (s && this._steps.length > 0) {
                    this.focus();
                    this._changeToStep(this._steps[this._steps.length - 1], s);
                    this._steps.push(s);
                    this.onDisplayChanged();
                    ret = true;
                }
                delete this._undoRedoActive;
            }
            return ret;
        }, endEditing:function (ignore_caret) {
            if (this._editTimer) {
                this._editTimer = this._editTimer.remove();
            }
            if (this._inEditing) {
                this._endEditing(ignore_caret);
                this._inEditing = false;
            }
        }, _getBookmark:function () {
            var b = this.selection.getBookmark();
            var tmp = [];
            if (b && b.mark) {
                var mark = b.mark;
                if (has("ie") < 9 || (has("ie") === 9 && has("quirks"))) {
                    var sel = rangeapi.getSelection(this.window);
                    if (!lang.isArray(mark)) {
                        if (sel) {
                            var range;
                            if (sel.rangeCount) {
                                range = sel.getRangeAt(0);
                            }
                            if (range) {
                                b.mark = range.cloneRange();
                            } else {
                                b.mark = this.selection.getBookmark();
                            }
                        }
                    } else {
                        array.forEach(b.mark, function (n) {
                            tmp.push(rangeapi.getIndex(n, this.editNode).o);
                        }, this);
                        b.mark = tmp;
                    }
                }
                try {
                    if (b.mark && b.mark.startContainer) {
                        tmp = rangeapi.getIndex(b.mark.startContainer, this.editNode).o;
                        b.mark = {startContainer:tmp, startOffset:b.mark.startOffset, endContainer:b.mark.endContainer === b.mark.startContainer ? tmp : rangeapi.getIndex(b.mark.endContainer, this.editNode).o, endOffset:b.mark.endOffset};
                    }
                }
                catch (e) {
                    b.mark = null;
                }
            }
            return b;
        }, _beginEditing:function () {
            if (this._steps.length === 0) {
                this._steps.push({"text":html.getChildrenHtml(this.editNode), "bookmark":this._getBookmark()});
            }
        }, _endEditing:function () {
            var v = html.getChildrenHtml(this.editNode);
            this._undoedSteps = [];
            this._steps.push({text:v, bookmark:this._getBookmark()});
        }, onKeyDown:function (e) {
            if (!has("ie") && !this.iframe && e.keyCode == keys.TAB && !this.tabIndent) {
                this._saveSelection();
            }
            if (!this.customUndo) {
                this.inherited(arguments);
                return;
            }
            var k = e.keyCode;
            if (e.ctrlKey && !e.shiftKey && !e.altKey) {
                if (k == 90 || k == 122) {
                    e.stopPropagation();
                    e.preventDefault();
                    this.undo();
                    return;
                } else {
                    if (k == 89 || k == 121) {
                        e.stopPropagation();
                        e.preventDefault();
                        this.redo();
                        return;
                    }
                }
            }
            this.inherited(arguments);
            switch (k) {
              case keys.ENTER:
              case keys.BACKSPACE:
              case keys.DELETE:
                this.beginEditing();
                break;
              case 88:
              case 86:
                if (e.ctrlKey && !e.altKey && !e.metaKey) {
                    this.endEditing();
                    if (e.keyCode == 88) {
                        this.beginEditing("cut");
                    } else {
                        this.beginEditing("paste");
                    }
                    this.defer("endEditing", 1);
                    break;
                }
              default:
                if (!e.ctrlKey && !e.altKey && !e.metaKey && (e.keyCode < keys.F1 || e.keyCode > keys.F15)) {
                    this.beginEditing();
                    break;
                }
              case keys.ALT:
                this.endEditing();
                break;
              case keys.UP_ARROW:
              case keys.DOWN_ARROW:
              case keys.LEFT_ARROW:
              case keys.RIGHT_ARROW:
              case keys.HOME:
              case keys.END:
              case keys.PAGE_UP:
              case keys.PAGE_DOWN:
                this.endEditing(true);
                break;
              case keys.CTRL:
              case keys.SHIFT:
              case keys.TAB:
                break;
            }
        }, _onBlur:function () {
            this.inherited(arguments);
            this.endEditing(true);
        }, _saveSelection:function () {
            try {
                this._savedSelection = this._getBookmark();
            }
            catch (e) {
            }
        }, _restoreSelection:function () {
            if (this._savedSelection) {
                delete this._cursorToStart;
                if (this.selection.isCollapsed()) {
                    this._moveToBookmark(this._savedSelection);
                }
                delete this._savedSelection;
            }
        }, onClick:function () {
            this.endEditing(true);
            this.inherited(arguments);
        }, replaceValue:function (html) {
            if (!this.customUndo) {
                this.inherited(arguments);
            } else {
                if (this.isClosed) {
                    this.setValue(html);
                } else {
                    this.beginEditing();
                    if (!html) {
                        html = "&#160;";
                    }
                    this.setValue(html);
                    this.endEditing();
                }
            }
        }, _setDisabledAttr:function (value) {
            this.setValueDeferred.then(lang.hitch(this, function () {
                if ((!this.disabled && value) || (!this._buttonEnabledPlugins && value)) {
                    array.forEach(this._plugins, function (p) {
                        p.set("disabled", true);
                    });
                } else {
                    if (this.disabled && !value) {
                        array.forEach(this._plugins, function (p) {
                            p.set("disabled", false);
                        });
                    }
                }
            }));
            this.inherited(arguments);
        }, _setStateClass:function () {
            try {
                this.inherited(arguments);
                if (this.document && this.document.body) {
                    domStyle.set(this.document.body, "color", domStyle.get(this.iframe, "color"));
                }
            }
            catch (e) {
            }
        }});
        function simplePluginFactory(args) {
            return new _Plugin({command:args.name});
        }
        function togglePluginFactory(args) {
            return new _Plugin({buttonClass:ToggleButton, command:args.name});
        }
        lang.mixin(_Plugin.registry, {"undo":simplePluginFactory, "redo":simplePluginFactory, "cut":simplePluginFactory, "copy":simplePluginFactory, "paste":simplePluginFactory, "insertOrderedList":simplePluginFactory, "insertUnorderedList":simplePluginFactory, "indent":simplePluginFactory, "outdent":simplePluginFactory, "justifyCenter":simplePluginFactory, "justifyFull":simplePluginFactory, "justifyLeft":simplePluginFactory, "justifyRight":simplePluginFactory, "delete":simplePluginFactory, "selectAll":simplePluginFactory, "removeFormat":simplePluginFactory, "unlink":simplePluginFactory, "insertHorizontalRule":simplePluginFactory, "bold":togglePluginFactory, "italic":togglePluginFactory, "underline":togglePluginFactory, "strikethrough":togglePluginFactory, "subscript":togglePluginFactory, "superscript":togglePluginFactory, "|":function () {
            return new _Plugin({setEditor:function (editor) {
                this.editor = editor;
                this.button = new ToolbarSeparator({ownerDocument:editor.ownerDocument});
            }});
        }});
        return Editor;
    });
}, "dojox/grid/Selection":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/dom-attr"], function (declare, array, lang, domAttr) {
        return declare("dojox.grid.Selection", null, {constructor:function (inGrid) {
            this.grid = inGrid;
            this.selected = [];
            this.setMode(inGrid.selectionMode);
        }, mode:"extended", selected:null, updating:0, selectedIndex:-1, rangeStartIndex:-1, setMode:function (mode) {
            if (this.selected.length) {
                this.deselectAll();
            }
            if (mode != "extended" && mode != "multiple" && mode != "single" && mode != "none") {
                this.mode = "extended";
            } else {
                this.mode = mode;
            }
        }, onCanSelect:function (inIndex) {
            return this.grid.onCanSelect(inIndex);
        }, onCanDeselect:function (inIndex) {
            return this.grid.onCanDeselect(inIndex);
        }, onSelected:function (inIndex) {
        }, onDeselected:function (inIndex) {
        }, onChanging:function () {
        }, onChanged:function () {
        }, isSelected:function (inIndex) {
            if (this.mode == "none") {
                return false;
            }
            return this.selected[inIndex];
        }, getFirstSelected:function () {
            if (!this.selected.length || this.mode == "none") {
                return -1;
            }
            for (var i = 0, l = this.selected.length; i < l; i++) {
                if (this.selected[i]) {
                    return i;
                }
            }
            return -1;
        }, getNextSelected:function (inPrev) {
            if (this.mode == "none") {
                return -1;
            }
            for (var i = inPrev + 1, l = this.selected.length; i < l; i++) {
                if (this.selected[i]) {
                    return i;
                }
            }
            return -1;
        }, getSelected:function () {
            var result = [];
            for (var i = 0, l = this.selected.length; i < l; i++) {
                if (this.selected[i]) {
                    result.push(i);
                }
            }
            return result;
        }, getSelectedCount:function () {
            var c = 0;
            for (var i = 0; i < this.selected.length; i++) {
                if (this.selected[i]) {
                    c++;
                }
            }
            return c;
        }, _beginUpdate:function () {
            if (this.updating === 0) {
                this.onChanging();
            }
            this.updating++;
        }, _endUpdate:function () {
            this.updating--;
            if (this.updating === 0) {
                this.onChanged();
            }
        }, select:function (inIndex) {
            if (this.mode == "none") {
                return;
            }
            if (this.mode != "multiple") {
                this.deselectAll(inIndex);
                this.addToSelection(inIndex);
            } else {
                this.toggleSelect(inIndex);
            }
        }, addToSelection:function (inIndex) {
            if (this.mode == "none") {
                return;
            }
            if (lang.isArray(inIndex)) {
                array.forEach(inIndex, this.addToSelection, this);
                return;
            }
            inIndex = Number(inIndex);
            if (this.selected[inIndex]) {
                this.selectedIndex = inIndex;
            } else {
                if (this.onCanSelect(inIndex) !== false) {
                    this.selectedIndex = inIndex;
                    var rowNode = this.grid.getRowNode(inIndex);
                    if (rowNode) {
                        domAttr.set(rowNode, "aria-selected", "true");
                    }
                    this._beginUpdate();
                    this.selected[inIndex] = true;
                    this.onSelected(inIndex);
                    this._endUpdate();
                }
            }
        }, deselect:function (inIndex) {
            if (this.mode == "none") {
                return;
            }
            if (lang.isArray(inIndex)) {
                array.forEach(inIndex, this.deselect, this);
                return;
            }
            inIndex = Number(inIndex);
            if (this.selectedIndex == inIndex) {
                this.selectedIndex = -1;
            }
            if (this.selected[inIndex]) {
                if (this.onCanDeselect(inIndex) === false) {
                    return;
                }
                var rowNode = this.grid.getRowNode(inIndex);
                if (rowNode) {
                    domAttr.set(rowNode, "aria-selected", "false");
                }
                this._beginUpdate();
                delete this.selected[inIndex];
                this.onDeselected(inIndex);
                this._endUpdate();
            }
        }, setSelected:function (inIndex, inSelect) {
            this[(inSelect ? "addToSelection" : "deselect")](inIndex);
        }, toggleSelect:function (inIndex) {
            if (lang.isArray(inIndex)) {
                array.forEach(inIndex, this.toggleSelect, this);
                return;
            }
            this.setSelected(inIndex, !this.selected[inIndex]);
        }, _range:function (inFrom, inTo, func) {
            var s = (inFrom >= 0 ? inFrom : inTo), e = inTo;
            if (s > e) {
                e = s;
                s = inTo;
            }
            for (var i = s; i <= e; i++) {
                func(i);
            }
        }, selectRange:function (inFrom, inTo) {
            this._range(inFrom, inTo, lang.hitch(this, "addToSelection"));
        }, deselectRange:function (inFrom, inTo) {
            this._range(inFrom, inTo, lang.hitch(this, "deselect"));
        }, insert:function (inIndex) {
            this.selected.splice(inIndex, 0, false);
            if (this.selectedIndex >= inIndex) {
                this.selectedIndex++;
            }
        }, remove:function (inIndex) {
            this.selected.splice(inIndex, 1);
            if (this.selectedIndex >= inIndex) {
                this.selectedIndex--;
            }
        }, deselectAll:function (inExcept) {
            for (var i in this.selected) {
                if ((i != inExcept) && (this.selected[i] === true)) {
                    this.deselect(i);
                }
            }
        }, clickSelect:function (inIndex, inCtrlKey, inShiftKey) {
            if (this.mode == "none") {
                return;
            }
            this._beginUpdate();
            if (this.mode != "extended") {
                this.select(inIndex);
            } else {
                if (!inShiftKey || this.rangeStartIndex < 0) {
                    this.rangeStartIndex = inIndex;
                }
                if (!inCtrlKey) {
                    this.deselectAll(inIndex);
                }
                if (inShiftKey) {
                    this.selectRange(this.rangeStartIndex, inIndex);
                } else {
                    if (inCtrlKey) {
                        this.toggleSelect(inIndex);
                    } else {
                        this.addToSelection(inIndex);
                    }
                }
            }
            this._endUpdate();
        }, clickSelectEvent:function (e) {
            this.clickSelect(e.rowIndex, dojo.isCopyKey(e), e.shiftKey);
        }, clear:function () {
            this._beginUpdate();
            this.deselectAll();
            this._endUpdate();
        }});
    });
}, "dojo/fx/Toggler":function () {
    define(["../_base/lang", "../_base/declare", "../_base/fx", "../aspect"], function (lang, declare, baseFx, aspect) {
        return declare("dojo.fx.Toggler", null, {node:null, showFunc:baseFx.fadeIn, hideFunc:baseFx.fadeOut, showDuration:200, hideDuration:200, constructor:function (args) {
            var _t = this;
            lang.mixin(_t, args);
            _t.node = args.node;
            _t._showArgs = lang.mixin({}, args);
            _t._showArgs.node = _t.node;
            _t._showArgs.duration = _t.showDuration;
            _t.showAnim = _t.showFunc(_t._showArgs);
            _t._hideArgs = lang.mixin({}, args);
            _t._hideArgs.node = _t.node;
            _t._hideArgs.duration = _t.hideDuration;
            _t.hideAnim = _t.hideFunc(_t._hideArgs);
            aspect.after(_t.showAnim, "beforeBegin", lang.hitch(_t.hideAnim, "stop", true), true);
            aspect.after(_t.hideAnim, "beforeBegin", lang.hitch(_t.showAnim, "stop", true), true);
        }, show:function (delay) {
            return this.showAnim.play(delay || 0);
        }, hide:function (delay) {
            return this.hideAnim.play(delay || 0);
        }});
    });
}, "dijit/popup":function () {
    define(["dojo/_base/array", "dojo/aspect", "dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/has", "dojo/keys", "dojo/_base/lang", "dojo/on", "./place", "./BackgroundIframe", "./Viewport", "./main"], function (array, aspect, declare, dom, domAttr, domConstruct, domGeometry, domStyle, has, keys, lang, on, place, BackgroundIframe, Viewport, dijit) {
        function destroyWrapper() {
            if (this._popupWrapper) {
                domConstruct.destroy(this._popupWrapper);
                delete this._popupWrapper;
            }
        }
        var PopupManager = declare(null, {_stack:[], _beginZIndex:1000, _idGen:1, _repositionAll:function () {
            if (this._firstAroundNode) {
                var oldPos = this._firstAroundPosition, newPos = domGeometry.position(this._firstAroundNode, true), dx = newPos.x - oldPos.x, dy = newPos.y - oldPos.y;
                if (dx || dy) {
                    this._firstAroundPosition = newPos;
                    for (var i = 0; i < this._stack.length; i++) {
                        var style = this._stack[i].wrapper.style;
                        style.top = (parseInt(style.top, 10) + dy) + "px";
                        if (style.right == "auto") {
                            style.left = (parseInt(style.left, 10) + dx) + "px";
                        } else {
                            style.right = (parseInt(style.right, 10) - dx) + "px";
                        }
                    }
                }
                this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
            }
        }, _createWrapper:function (widget) {
            var wrapper = widget._popupWrapper, node = widget.domNode;
            if (!wrapper) {
                wrapper = domConstruct.create("div", {"class":"dijitPopup", style:{display:"none"}, role:"region", "aria-label":widget["aria-label"] || widget.label || widget.name || widget.id}, widget.ownerDocumentBody);
                wrapper.appendChild(node);
                var s = node.style;
                s.display = "";
                s.visibility = "";
                s.position = "";
                s.top = "0px";
                widget._popupWrapper = wrapper;
                aspect.after(widget, "destroy", destroyWrapper, true);
            }
            return wrapper;
        }, moveOffScreen:function (widget) {
            var wrapper = this._createWrapper(widget);
            var ltr = domGeometry.isBodyLtr(widget.ownerDocument), style = {visibility:"hidden", top:"-9999px", display:""};
            style[ltr ? "left" : "right"] = "-9999px";
            style[ltr ? "right" : "left"] = "auto";
            domStyle.set(wrapper, style);
            return wrapper;
        }, hide:function (widget) {
            var wrapper = this._createWrapper(widget);
            domStyle.set(wrapper, {display:"none", height:"auto", overflow:"visible", border:""});
            var node = widget.domNode;
            if ("_originalStyle" in node) {
                node.style.cssText = node._originalStyle;
            }
        }, getTopPopup:function () {
            var stack = this._stack;
            for (var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--) {
            }
            return stack[pi];
        }, open:function (args) {
            var stack = this._stack, widget = args.popup, node = widget.domNode, orient = args.orient || ["below", "below-alt", "above", "above-alt"], ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument), around = args.around, id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);
            while (stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))) {
                this.close(stack[stack.length - 1].widget);
            }
            var wrapper = this.moveOffScreen(widget);
            if (widget.startup && !widget._started) {
                widget.startup();
            }
            var maxHeight, popupSize = domGeometry.position(node);
            if ("maxHeight" in args && args.maxHeight != -1) {
                maxHeight = args.maxHeight || Infinity;
            } else {
                var viewport = Viewport.getEffectiveBox(this.ownerDocument), aroundPos = around ? domGeometry.position(around, false) : {y:args.y - (args.padding || 0), h:(args.padding || 0) * 2};
                maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
            }
            if (popupSize.h > maxHeight) {
                var cs = domStyle.getComputedStyle(node), borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;
                domStyle.set(wrapper, {overflowY:"scroll", height:maxHeight + "px", border:borderStyle});
                node._originalStyle = node.style.cssText;
                node.style.border = "none";
            }
            domAttr.set(wrapper, {id:id, style:{zIndex:this._beginZIndex + stack.length}, "class":"dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup", dijitPopupParent:args.parent ? args.parent.id : ""});
            if (stack.length == 0 && around) {
                this._firstAroundNode = around;
                this._firstAroundPosition = domGeometry.position(around, true);
                this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
            }
            if (has("config-bgIframe") && !widget.bgIframe) {
                widget.bgIframe = new BackgroundIframe(wrapper);
            }
            var layoutFunc = widget.orient ? lang.hitch(widget, "orient") : null, best = around ? place.around(wrapper, around, orient, ltr, layoutFunc) : place.at(wrapper, args, orient == "R" ? ["TR", "BR", "TL", "BL"] : ["TL", "BL", "TR", "BR"], args.padding, layoutFunc);
            wrapper.style.visibility = "visible";
            node.style.visibility = "visible";
            var handlers = [];
            handlers.push(on(wrapper, "keydown", lang.hitch(this, function (evt) {
                if (evt.keyCode == keys.ESCAPE && args.onCancel) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    args.onCancel();
                } else {
                    if (evt.keyCode == keys.TAB) {
                        evt.stopPropagation();
                        evt.preventDefault();
                        var topPopup = this.getTopPopup();
                        if (topPopup && topPopup.onCancel) {
                            topPopup.onCancel();
                        }
                    }
                }
            })));
            if (widget.onCancel && args.onCancel) {
                handlers.push(widget.on("cancel", args.onCancel));
            }
            handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function () {
                var topPopup = this.getTopPopup();
                if (topPopup && topPopup.onExecute) {
                    topPopup.onExecute();
                }
            })));
            stack.push({widget:widget, wrapper:wrapper, parent:args.parent, onExecute:args.onExecute, onCancel:args.onCancel, onClose:args.onClose, handlers:handlers});
            if (widget.onOpen) {
                widget.onOpen(best);
            }
            return best;
        }, close:function (popup) {
            var stack = this._stack;
            while ((popup && array.some(stack, function (elem) {
                return elem.widget == popup;
            })) || (!popup && stack.length)) {
                var top = stack.pop(), widget = top.widget, onClose = top.onClose;
                if (widget.onClose) {
                    widget.onClose();
                }
                var h;
                while (h = top.handlers.pop()) {
                    h.remove();
                }
                if (widget && widget.domNode) {
                    this.hide(widget);
                }
                if (onClose) {
                    onClose();
                }
            }
            if (stack.length == 0 && this._aroundMoveListener) {
                clearTimeout(this._aroundMoveListener);
                this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
            }
        }});
        return (dijit.popup = new PopupManager());
    });
}, "dojo/data/ItemFileWriteStore":function () {
    define(["../_base/lang", "../_base/declare", "../_base/array", "../_base/json", "../_base/kernel", "./ItemFileReadStore", "../date/stamp"], function (lang, declare, arrayUtil, jsonUtil, kernel, ItemFileReadStore, dateStamp) {
        return declare("dojo.data.ItemFileWriteStore", ItemFileReadStore, {constructor:function (keywordParameters) {
            this._features["dojo.data.api.Write"] = true;
            this._features["dojo.data.api.Notification"] = true;
            this._pending = {_newItems:{}, _modifiedItems:{}, _deletedItems:{}};
            if (!this._datatypeMap["Date"].serialize) {
                this._datatypeMap["Date"].serialize = function (obj) {
                    return dateStamp.toISOString(obj, {zulu:true});
                };
            }
            if (keywordParameters && (keywordParameters.referenceIntegrity === false)) {
                this.referenceIntegrity = false;
            }
            this._saveInProgress = false;
        }, referenceIntegrity:true, _assert:function (condition) {
            if (!condition) {
                throw new Error("assertion failed in ItemFileWriteStore");
            }
        }, _getIdentifierAttribute:function () {
            return this.getFeatures()["dojo.data.api.Identity"];
        }, newItem:function (keywordArgs, parentInfo) {
            this._assert(!this._saveInProgress);
            if (!this._loadFinished) {
                this._forceLoad();
            }
            if (typeof keywordArgs != "object" && typeof keywordArgs != "undefined") {
                throw new Error("newItem() was passed something other than an object");
            }
            var newIdentity = null;
            var identifierAttribute = this._getIdentifierAttribute();
            if (identifierAttribute === Number) {
                newIdentity = this._arrayOfAllItems.length;
            } else {
                newIdentity = keywordArgs[identifierAttribute];
                if (typeof newIdentity === "undefined") {
                    throw new Error("newItem() was not passed an identity for the new item");
                }
                if (lang.isArray(newIdentity)) {
                    throw new Error("newItem() was not passed an single-valued identity");
                }
            }
            if (this._itemsByIdentity) {
                this._assert(typeof this._itemsByIdentity[newIdentity] === "undefined");
            }
            this._assert(typeof this._pending._newItems[newIdentity] === "undefined");
            this._assert(typeof this._pending._deletedItems[newIdentity] === "undefined");
            var newItem = {};
            newItem[this._storeRefPropName] = this;
            newItem[this._itemNumPropName] = this._arrayOfAllItems.length;
            if (this._itemsByIdentity) {
                this._itemsByIdentity[newIdentity] = newItem;
                newItem[identifierAttribute] = [newIdentity];
            }
            this._arrayOfAllItems.push(newItem);
            var pInfo = null;
            if (parentInfo && parentInfo.parent && parentInfo.attribute) {
                pInfo = {item:parentInfo.parent, attribute:parentInfo.attribute, oldValue:undefined};
                var values = this.getValues(parentInfo.parent, parentInfo.attribute);
                if (values && values.length > 0) {
                    var tempValues = values.slice(0, values.length);
                    if (values.length === 1) {
                        pInfo.oldValue = values[0];
                    } else {
                        pInfo.oldValue = values.slice(0, values.length);
                    }
                    tempValues.push(newItem);
                    this._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);
                    pInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);
                } else {
                    this._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);
                    pInfo.newValue = newItem;
                }
            } else {
                newItem[this._rootItemPropName] = true;
                this._arrayOfTopLevelItems.push(newItem);
            }
            this._pending._newItems[newIdentity] = newItem;
            for (var key in keywordArgs) {
                if (key === this._storeRefPropName || key === this._itemNumPropName) {
                    throw new Error("encountered bug in ItemFileWriteStore.newItem");
                }
                var value = keywordArgs[key];
                if (!lang.isArray(value)) {
                    value = [value];
                }
                newItem[key] = value;
                if (this.referenceIntegrity) {
                    for (var i = 0; i < value.length; i++) {
                        var val = value[i];
                        if (this.isItem(val)) {
                            this._addReferenceToMap(val, newItem, key);
                        }
                    }
                }
            }
            this.onNew(newItem, pInfo);
            return newItem;
        }, _removeArrayElement:function (array, element) {
            var index = arrayUtil.indexOf(array, element);
            if (index != -1) {
                array.splice(index, 1);
                return true;
            }
            return false;
        }, deleteItem:function (item) {
            this._assert(!this._saveInProgress);
            this._assertIsItem(item);
            var indexInArrayOfAllItems = item[this._itemNumPropName];
            var identity = this.getIdentity(item);
            if (this.referenceIntegrity) {
                var attributes = this.getAttributes(item);
                if (item[this._reverseRefMap]) {
                    item["backup_" + this._reverseRefMap] = lang.clone(item[this._reverseRefMap]);
                }
                arrayUtil.forEach(attributes, function (attribute) {
                    arrayUtil.forEach(this.getValues(item, attribute), function (value) {
                        if (this.isItem(value)) {
                            if (!item["backupRefs_" + this._reverseRefMap]) {
                                item["backupRefs_" + this._reverseRefMap] = [];
                            }
                            item["backupRefs_" + this._reverseRefMap].push({id:this.getIdentity(value), attr:attribute});
                            this._removeReferenceFromMap(value, item, attribute);
                        }
                    }, this);
                }, this);
                var references = item[this._reverseRefMap];
                if (references) {
                    for (var itemId in references) {
                        var containingItem = null;
                        if (this._itemsByIdentity) {
                            containingItem = this._itemsByIdentity[itemId];
                        } else {
                            containingItem = this._arrayOfAllItems[itemId];
                        }
                        if (containingItem) {
                            for (var attribute in references[itemId]) {
                                var oldValues = this.getValues(containingItem, attribute) || [];
                                var newValues = arrayUtil.filter(oldValues, function (possibleItem) {
                                    return !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);
                                }, this);
                                this._removeReferenceFromMap(item, containingItem, attribute);
                                if (newValues.length < oldValues.length) {
                                    this._setValueOrValues(containingItem, attribute, newValues, true);
                                }
                            }
                        }
                    }
                }
            }
            this._arrayOfAllItems[indexInArrayOfAllItems] = null;
            item[this._storeRefPropName] = null;
            if (this._itemsByIdentity) {
                delete this._itemsByIdentity[identity];
            }
            this._pending._deletedItems[identity] = item;
            if (item[this._rootItemPropName]) {
                this._removeArrayElement(this._arrayOfTopLevelItems, item);
            }
            this.onDelete(item);
            return true;
        }, setValue:function (item, attribute, value) {
            return this._setValueOrValues(item, attribute, value, true);
        }, setValues:function (item, attribute, values) {
            return this._setValueOrValues(item, attribute, values, true);
        }, unsetAttribute:function (item, attribute) {
            return this._setValueOrValues(item, attribute, [], true);
        }, _setValueOrValues:function (item, attribute, newValueOrValues, callOnSet) {
            this._assert(!this._saveInProgress);
            this._assertIsItem(item);
            this._assert(lang.isString(attribute));
            this._assert(typeof newValueOrValues !== "undefined");
            var identifierAttribute = this._getIdentifierAttribute();
            if (attribute == identifierAttribute) {
                throw new Error("ItemFileWriteStore does not have support for changing the value of an item's identifier.");
            }
            var oldValueOrValues = this._getValueOrValues(item, attribute);
            var identity = this.getIdentity(item);
            if (!this._pending._modifiedItems[identity]) {
                var copyOfItemState = {};
                for (var key in item) {
                    if ((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)) {
                        copyOfItemState[key] = item[key];
                    } else {
                        if (key === this._reverseRefMap) {
                            copyOfItemState[key] = lang.clone(item[key]);
                        } else {
                            copyOfItemState[key] = item[key].slice(0, item[key].length);
                        }
                    }
                }
                this._pending._modifiedItems[identity] = copyOfItemState;
            }
            var success = false;
            if (lang.isArray(newValueOrValues) && newValueOrValues.length === 0) {
                success = delete item[attribute];
                newValueOrValues = undefined;
                if (this.referenceIntegrity && oldValueOrValues) {
                    var oldValues = oldValueOrValues;
                    if (!lang.isArray(oldValues)) {
                        oldValues = [oldValues];
                    }
                    for (var i = 0; i < oldValues.length; i++) {
                        var value = oldValues[i];
                        if (this.isItem(value)) {
                            this._removeReferenceFromMap(value, item, attribute);
                        }
                    }
                }
            } else {
                var newValueArray;
                if (lang.isArray(newValueOrValues)) {
                    newValueArray = newValueOrValues.slice(0, newValueOrValues.length);
                } else {
                    newValueArray = [newValueOrValues];
                }
                if (this.referenceIntegrity) {
                    if (oldValueOrValues) {
                        var oldValues = oldValueOrValues;
                        if (!lang.isArray(oldValues)) {
                            oldValues = [oldValues];
                        }
                        var map = {};
                        arrayUtil.forEach(oldValues, function (possibleItem) {
                            if (this.isItem(possibleItem)) {
                                var id = this.getIdentity(possibleItem);
                                map[id.toString()] = true;
                            }
                        }, this);
                        arrayUtil.forEach(newValueArray, function (possibleItem) {
                            if (this.isItem(possibleItem)) {
                                var id = this.getIdentity(possibleItem);
                                if (map[id.toString()]) {
                                    delete map[id.toString()];
                                } else {
                                    this._addReferenceToMap(possibleItem, item, attribute);
                                }
                            }
                        }, this);
                        for (var rId in map) {
                            var removedItem;
                            if (this._itemsByIdentity) {
                                removedItem = this._itemsByIdentity[rId];
                            } else {
                                removedItem = this._arrayOfAllItems[rId];
                            }
                            this._removeReferenceFromMap(removedItem, item, attribute);
                        }
                    } else {
                        for (var i = 0; i < newValueArray.length; i++) {
                            var value = newValueArray[i];
                            if (this.isItem(value)) {
                                this._addReferenceToMap(value, item, attribute);
                            }
                        }
                    }
                }
                item[attribute] = newValueArray;
                success = true;
            }
            if (callOnSet) {
                this.onSet(item, attribute, oldValueOrValues, newValueOrValues);
            }
            return success;
        }, _addReferenceToMap:function (refItem, parentItem, attribute) {
            var parentId = this.getIdentity(parentItem);
            var references = refItem[this._reverseRefMap];
            if (!references) {
                references = refItem[this._reverseRefMap] = {};
            }
            var itemRef = references[parentId];
            if (!itemRef) {
                itemRef = references[parentId] = {};
            }
            itemRef[attribute] = true;
        }, _removeReferenceFromMap:function (refItem, parentItem, attribute) {
            var identity = this.getIdentity(parentItem);
            var references = refItem[this._reverseRefMap];
            var itemId;
            if (references) {
                for (itemId in references) {
                    if (itemId == identity) {
                        delete references[itemId][attribute];
                        if (this._isEmpty(references[itemId])) {
                            delete references[itemId];
                        }
                    }
                }
                if (this._isEmpty(references)) {
                    delete refItem[this._reverseRefMap];
                }
            }
        }, _dumpReferenceMap:function () {
            var i;
            for (i = 0; i < this._arrayOfAllItems.length; i++) {
                var item = this._arrayOfAllItems[i];
                if (item && item[this._reverseRefMap]) {
                    console.log("Item: [" + this.getIdentity(item) + "] is referenced by: " + jsonUtil.toJson(item[this._reverseRefMap]));
                }
            }
        }, _getValueOrValues:function (item, attribute) {
            var valueOrValues = undefined;
            if (this.hasAttribute(item, attribute)) {
                var valueArray = this.getValues(item, attribute);
                if (valueArray.length == 1) {
                    valueOrValues = valueArray[0];
                } else {
                    valueOrValues = valueArray;
                }
            }
            return valueOrValues;
        }, _flatten:function (value) {
            if (this.isItem(value)) {
                return {_reference:this.getIdentity(value)};
            } else {
                if (typeof value === "object") {
                    for (var type in this._datatypeMap) {
                        var typeMap = this._datatypeMap[type];
                        if (lang.isObject(typeMap) && !lang.isFunction(typeMap)) {
                            if (value instanceof typeMap.type) {
                                if (!typeMap.serialize) {
                                    throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
                                }
                                return {_type:type, _value:typeMap.serialize(value)};
                            }
                        } else {
                            if (value instanceof typeMap) {
                                return {_type:type, _value:value.toString()};
                            }
                        }
                    }
                }
                return value;
            }
        }, _getNewFileContentString:function () {
            var serializableStructure = {};
            var identifierAttribute = this._getIdentifierAttribute();
            if (identifierAttribute !== Number) {
                serializableStructure.identifier = identifierAttribute;
            }
            if (this._labelAttr) {
                serializableStructure.label = this._labelAttr;
            }
            serializableStructure.items = [];
            for (var i = 0; i < this._arrayOfAllItems.length; ++i) {
                var item = this._arrayOfAllItems[i];
                if (item !== null) {
                    var serializableItem = {};
                    for (var key in item) {
                        if (key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName) {
                            var valueArray = this.getValues(item, key);
                            if (valueArray.length == 1) {
                                serializableItem[key] = this._flatten(valueArray[0]);
                            } else {
                                var serializableArray = [];
                                for (var j = 0; j < valueArray.length; ++j) {
                                    serializableArray.push(this._flatten(valueArray[j]));
                                    serializableItem[key] = serializableArray;
                                }
                            }
                        }
                    }
                    serializableStructure.items.push(serializableItem);
                }
            }
            var prettyPrint = true;
            return jsonUtil.toJson(serializableStructure, prettyPrint);
        }, _isEmpty:function (something) {
            var empty = true;
            if (lang.isObject(something)) {
                var i;
                for (i in something) {
                    empty = false;
                    break;
                }
            } else {
                if (lang.isArray(something)) {
                    if (something.length > 0) {
                        empty = false;
                    }
                }
            }
            return empty;
        }, save:function (keywordArgs) {
            this._assert(!this._saveInProgress);
            this._saveInProgress = true;
            var self = this;
            var saveCompleteCallback = function () {
                self._pending = {_newItems:{}, _modifiedItems:{}, _deletedItems:{}};
                self._saveInProgress = false;
                if (keywordArgs && keywordArgs.onComplete) {
                    var scope = keywordArgs.scope || kernel.global;
                    keywordArgs.onComplete.call(scope);
                }
            };
            var saveFailedCallback = function (err) {
                self._saveInProgress = false;
                if (keywordArgs && keywordArgs.onError) {
                    var scope = keywordArgs.scope || kernel.global;
                    keywordArgs.onError.call(scope, err);
                }
            };
            if (this._saveEverything) {
                var newFileContentString = this._getNewFileContentString();
                this._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);
            }
            if (this._saveCustom) {
                this._saveCustom(saveCompleteCallback, saveFailedCallback);
            }
            if (!this._saveEverything && !this._saveCustom) {
                saveCompleteCallback();
            }
        }, revert:function () {
            this._assert(!this._saveInProgress);
            var identity;
            for (identity in this._pending._modifiedItems) {
                var copyOfItemState = this._pending._modifiedItems[identity];
                var modifiedItem = null;
                if (this._itemsByIdentity) {
                    modifiedItem = this._itemsByIdentity[identity];
                } else {
                    modifiedItem = this._arrayOfAllItems[identity];
                }
                copyOfItemState[this._storeRefPropName] = this;
                for (var key in modifiedItem) {
                    delete modifiedItem[key];
                }
                lang.mixin(modifiedItem, copyOfItemState);
            }
            var deletedItem;
            for (identity in this._pending._deletedItems) {
                deletedItem = this._pending._deletedItems[identity];
                deletedItem[this._storeRefPropName] = this;
                var index = deletedItem[this._itemNumPropName];
                if (deletedItem["backup_" + this._reverseRefMap]) {
                    deletedItem[this._reverseRefMap] = deletedItem["backup_" + this._reverseRefMap];
                    delete deletedItem["backup_" + this._reverseRefMap];
                }
                this._arrayOfAllItems[index] = deletedItem;
                if (this._itemsByIdentity) {
                    this._itemsByIdentity[identity] = deletedItem;
                }
                if (deletedItem[this._rootItemPropName]) {
                    this._arrayOfTopLevelItems.push(deletedItem);
                }
            }
            for (identity in this._pending._deletedItems) {
                deletedItem = this._pending._deletedItems[identity];
                if (deletedItem["backupRefs_" + this._reverseRefMap]) {
                    arrayUtil.forEach(deletedItem["backupRefs_" + this._reverseRefMap], function (reference) {
                        var refItem;
                        if (this._itemsByIdentity) {
                            refItem = this._itemsByIdentity[reference.id];
                        } else {
                            refItem = this._arrayOfAllItems[reference.id];
                        }
                        this._addReferenceToMap(refItem, deletedItem, reference.attr);
                    }, this);
                    delete deletedItem["backupRefs_" + this._reverseRefMap];
                }
            }
            for (identity in this._pending._newItems) {
                var newItem = this._pending._newItems[identity];
                newItem[this._storeRefPropName] = null;
                this._arrayOfAllItems[newItem[this._itemNumPropName]] = null;
                if (newItem[this._rootItemPropName]) {
                    this._removeArrayElement(this._arrayOfTopLevelItems, newItem);
                }
                if (this._itemsByIdentity) {
                    delete this._itemsByIdentity[identity];
                }
            }
            this._pending = {_newItems:{}, _modifiedItems:{}, _deletedItems:{}};
            return true;
        }, isDirty:function (item) {
            if (item) {
                var identity = this.getIdentity(item);
                return new Boolean(this._pending._newItems[identity] || this._pending._modifiedItems[identity] || this._pending._deletedItems[identity]).valueOf();
            } else {
                return !this._isEmpty(this._pending._newItems) || !this._isEmpty(this._pending._modifiedItems) || !this._isEmpty(this._pending._deletedItems);
            }
        }, onSet:function (item, attribute, oldValue, newValue) {
        }, onNew:function (newItem, parentInfo) {
        }, onDelete:function (deletedItem) {
        }, close:function (request) {
            if (this.clearOnClose) {
                if (!this.isDirty()) {
                    this.inherited(arguments);
                } else {
                    throw new Error("dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.");
                }
            }
        }});
    });
}, "dijit/layout/TabContainer":function () {
    define(["dojo/_base/lang", "dojo/_base/declare", "./_TabContainerBase", "./TabController", "./ScrollingTabController"], function (lang, declare, _TabContainerBase, TabController, ScrollingTabController) {
        return declare("dijit.layout.TabContainer", _TabContainerBase, {useMenu:true, useSlider:true, controllerWidget:"", _makeController:function (srcNode) {
            var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"), TabController = typeof this.controllerWidget == "string" ? lang.getObject(this.controllerWidget) : this.controllerWidget;
            return new TabController({id:this.id + "_tablist", ownerDocument:this.ownerDocument, dir:this.dir, lang:this.lang, textDir:this.textDir, tabPosition:this.tabPosition, doLayout:this.doLayout, containerId:this.id, "class":cls, nested:this.nested, useMenu:this.useMenu, useSlider:this.useSlider, tabStripClass:this.tabStrip ? this.baseClass + (this.tabStrip ? "" : "No") + "Strip" : null}, srcNode);
        }, postMixInProperties:function () {
            this.inherited(arguments);
            if (!this.controllerWidget) {
                this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ? ScrollingTabController : TabController;
            }
        }});
    });
}, "dijit/_base":function () {
    define(["./main", "./a11y", "./WidgetSet", "./_base/focus", "./_base/manager", "./_base/place", "./_base/popup", "./_base/scroll", "./_base/sniff", "./_base/typematic", "./_base/wai", "./_base/window"], function (dijit) {
        return dijit._base;
    });
}, "dojox/string/BidiComplex":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/sniff", "dojo/keys"], function (dojo, lang, arr, hub, has, keys) {
        dojo.experimental("dojox.string.BidiComplex");
        var bdc = lang.getObject("string.BidiComplex", true, dojox);
        var _str0 = [];
        bdc.attachInput = function (field, pattern) {
            field.alt = pattern;
            hub.connect(field, "onkeydown", this, "_ceKeyDown");
            hub.connect(field, "onkeyup", this, "_ceKeyUp");
            hub.connect(field, "oncut", this, "_ceCutText");
            hub.connect(field, "oncopy", this, "_ceCopyText");
            field.value = bdc.createDisplayString(field.value, field.alt);
        };
        bdc.createDisplayString = function (str, pattern) {
            str = bdc.stripSpecialCharacters(str);
            var segmentsPointers = bdc._parse(str, pattern);
            var buf = "\u202a" + str;
            var shift = 1;
            arr.forEach(segmentsPointers, function (n) {
                if (n != null) {
                    var preStr = buf.substring(0, n + shift);
                    var postStr = buf.substring(n + shift, buf.length);
                    buf = preStr + "\u200e" + postStr;
                    shift++;
                }
            });
            return buf;
        };
        bdc.stripSpecialCharacters = function (str) {
            return str.replace(/[\u200E\u200F\u202A-\u202E]/g, "");
        };
        bdc._ceKeyDown = function (event) {
            var elem = has("ie") ? event.srcElement : event.target;
            _str0 = elem.value;
        };
        bdc._ceKeyUp = function (event) {
            var LRM = "\u200e";
            var elem = has("ie") ? event.srcElement : event.target;
            var str1 = elem.value;
            var ieKey = event.keyCode;
            if ((ieKey == keys.HOME) || (ieKey == keys.END) || (ieKey == keys.SHIFT)) {
                return;
            }
            var cursorStart, cursorEnd;
            var selection = bdc._getCaretPos(event, elem);
            if (selection) {
                cursorStart = selection[0];
                cursorEnd = selection[1];
            }
            if (has("ie")) {
                var cursorStart1 = cursorStart, cursorEnd1 = cursorEnd;
                if (ieKey == keys.LEFT_ARROW) {
                    if ((str1.charAt(cursorEnd - 1) == LRM) && (cursorStart == cursorEnd)) {
                        bdc._setSelectedRange(elem, cursorStart - 1, cursorEnd - 1);
                    }
                    return;
                }
                if (ieKey == keys.RIGHT_ARROW) {
                    if (str1.charAt(cursorEnd - 1) == LRM) {
                        cursorEnd1 = cursorEnd + 1;
                        if (cursorStart == cursorEnd) {
                            cursorStart1 = cursorStart + 1;
                        }
                    }
                    bdc._setSelectedRange(elem, cursorStart1, cursorEnd1);
                    return;
                }
            } else {
                if (ieKey == keys.LEFT_ARROW) {
                    if (str1.charAt(cursorEnd - 1) == LRM) {
                        bdc._setSelectedRange(elem, cursorStart - 1, cursorEnd - 1);
                    }
                    return;
                }
                if (ieKey == keys.RIGHT_ARROW) {
                    if (str1.charAt(cursorEnd - 1) == LRM) {
                        bdc._setSelectedRange(elem, cursorStart + 1, cursorEnd + 1);
                    }
                    return;
                }
            }
            var str2 = bdc.createDisplayString(str1, elem.alt);
            if (str1 != str2) {
                window.status = str1 + " c=" + cursorEnd;
                elem.value = str2;
                if ((ieKey == keys.DELETE) && (str2.charAt(cursorEnd) == LRM)) {
                    elem.value = str2.substring(0, cursorEnd) + str2.substring(cursorEnd + 2, str2.length);
                }
                if (ieKey == keys.DELETE) {
                    bdc._setSelectedRange(elem, cursorStart, cursorEnd);
                } else {
                    if (ieKey == keys.BACKSPACE) {
                        if ((_str0.length >= cursorEnd) && (_str0.charAt(cursorEnd - 1) == LRM)) {
                            bdc._setSelectedRange(elem, cursorStart - 1, cursorEnd - 1);
                        } else {
                            bdc._setSelectedRange(elem, cursorStart, cursorEnd);
                        }
                    } else {
                        if (elem.value.charAt(cursorEnd) != LRM) {
                            bdc._setSelectedRange(elem, cursorStart + 1, cursorEnd + 1);
                        }
                    }
                }
            }
        };
        bdc._processCopy = function (elem, text, isReverse) {
            if (text == null) {
                if (has("ie")) {
                    var range = document.selection.createRange();
                    text = range.text;
                } else {
                    text = elem.value.substring(elem.selectionStart, elem.selectionEnd);
                }
            }
            var textToClipboard = bdc.stripSpecialCharacters(text);
            if (has("ie")) {
                window.clipboardData.setData("Text", textToClipboard);
            }
            return true;
        };
        bdc._ceCopyText = function (elem) {
            if (has("ie")) {
                elem.returnValue = false;
            }
            return bdc._processCopy(elem, null, false);
        };
        bdc._ceCutText = function (elem) {
            var ret = bdc._processCopy(elem, null, false);
            if (!ret) {
                return false;
            }
            if (has("ie")) {
                document.selection.clear();
            } else {
                var curPos = elem.selectionStart;
                elem.value = elem.value.substring(0, curPos) + elem.value.substring(elem.selectionEnd);
                elem.setSelectionRange(curPos, curPos);
            }
            return true;
        };
        bdc._getCaretPos = function (event, elem) {
            if (has("ie")) {
                var position = 0, range = document.selection.createRange().duplicate(), range2 = range.duplicate(), rangeLength = range.text.length;
                if (elem.type == "textarea") {
                    range2.moveToElementText(elem);
                } else {
                    range2.expand("textedit");
                }
                while (range.compareEndPoints("StartToStart", range2) > 0) {
                    range.moveStart("character", -1);
                    ++position;
                }
                return [position, position + rangeLength];
            }
            return [event.target.selectionStart, event.target.selectionEnd];
        };
        bdc._setSelectedRange = function (elem, selectionStart, selectionEnd) {
            if (has("ie")) {
                var range = elem.createTextRange();
                if (range) {
                    if (elem.type == "textarea") {
                        range.moveToElementText(elem);
                    } else {
                        range.expand("textedit");
                    }
                    range.collapse();
                    range.moveEnd("character", selectionEnd);
                    range.moveStart("character", selectionStart);
                    range.select();
                }
            } else {
                elem.selectionStart = selectionStart;
                elem.selectionEnd = selectionEnd;
            }
        };
        var _isBidiChar = function (c) {
            return (c >= "0" && c <= "9") || (c > "\xff");
        };
        var _isLatinChar = function (c) {
            return (c >= "A" && c <= "Z") || (c >= "a" && c <= "z");
        };
        var _isCharBeforeBiDiChar = function (buffer, i, previous) {
            while (i > 0) {
                if (i == previous) {
                    return false;
                }
                i--;
                if (_isBidiChar(buffer.charAt(i))) {
                    return true;
                }
                if (_isLatinChar(buffer.charAt(i))) {
                    return false;
                }
            }
            return false;
        };
        bdc._parse = function (str, pattern) {
            var previous = -1, segmentsPointers = [];
            var delimiters = {FILE_PATH:"/\\:.", URL:"/:.?=&#", XPATH:"/\\:.<>=[]", EMAIL:"<>@.,;"}[pattern];
            switch (pattern) {
              case "FILE_PATH":
              case "URL":
              case "XPATH":
                arr.forEach(str, function (ch, i) {
                    if (delimiters.indexOf(ch) >= 0 && _isCharBeforeBiDiChar(str, i, previous)) {
                        previous = i;
                        segmentsPointers.push(i);
                    }
                });
                break;
              case "EMAIL":
                var inQuotes = false;
                arr.forEach(str, function (ch, i) {
                    if (ch == "\"") {
                        if (_isCharBeforeBiDiChar(str, i, previous)) {
                            previous = i;
                            segmentsPointers.push(i);
                        }
                        i++;
                        var i1 = str.indexOf("\"", i);
                        if (i1 >= i) {
                            i = i1;
                        }
                        if (_isCharBeforeBiDiChar(str, i, previous)) {
                            previous = i;
                            segmentsPointers.push(i);
                        }
                    }
                    if (delimiters.indexOf(ch) >= 0 && _isCharBeforeBiDiChar(str, i, previous)) {
                        previous = i;
                        segmentsPointers.push(i);
                    }
                });
            }
            return segmentsPointers;
        };
        return bdc;
    });
}, "dojox/data/QueryReadStore":function () {
    define(["dojo", "dojox", "dojo/data/util/sorter", "dojo/string"], function (dojo, dojox) {
        return dojo.declare("dojox.data.QueryReadStore", null, {url:"", requestMethod:"get", _className:"dojox.data.QueryReadStore", _items:[], _lastServerQuery:null, _numRows:-1, lastRequestHash:null, doClientPaging:false, doClientSorting:false, _itemsByIdentity:null, _identifier:null, _features:{"dojo.data.api.Read":true, "dojo.data.api.Identity":true}, _labelAttr:"label", constructor:function (params) {
            dojo.mixin(this, params);
        }, getValue:function (item, attribute, defaultValue) {
            this._assertIsItem(item);
            if (!dojo.isString(attribute)) {
                throw new Error(this._className + ".getValue(): Invalid attribute, string expected!");
            }
            if (!this.hasAttribute(item, attribute)) {
                if (defaultValue) {
                    return defaultValue;
                }
            }
            return item.i[attribute];
        }, getValues:function (item, attribute) {
            this._assertIsItem(item);
            var ret = [];
            if (this.hasAttribute(item, attribute)) {
                ret.push(item.i[attribute]);
            }
            return ret;
        }, getAttributes:function (item) {
            this._assertIsItem(item);
            var ret = [];
            for (var i in item.i) {
                ret.push(i);
            }
            return ret;
        }, hasAttribute:function (item, attribute) {
            return this.isItem(item) && typeof item.i[attribute] != "undefined";
        }, containsValue:function (item, attribute, value) {
            var values = this.getValues(item, attribute);
            var len = values.length;
            for (var i = 0; i < len; i++) {
                if (values[i] == value) {
                    return true;
                }
            }
            return false;
        }, isItem:function (something) {
            if (something) {
                return typeof something.r != "undefined" && something.r == this;
            }
            return false;
        }, isItemLoaded:function (something) {
            return this.isItem(something);
        }, loadItem:function (args) {
            if (this.isItemLoaded(args.item)) {
                return;
            }
        }, fetch:function (request) {
            request = request || {};
            if (!request.store) {
                request.store = this;
            }
            var self = this;
            var _errorHandler = function (errorData, requestObject) {
                if (requestObject.onError) {
                    var scope = requestObject.scope || dojo.global;
                    requestObject.onError.call(scope, errorData, requestObject);
                }
            };
            var _fetchHandler = function (items, requestObject, numRows) {
                var oldAbortFunction = requestObject.abort || null;
                var aborted = false;
                var startIndex = requestObject.start ? requestObject.start : 0;
                if (self.doClientPaging == false) {
                    startIndex = 0;
                }
                var endIndex = requestObject.count ? (startIndex + requestObject.count) : items.length;
                requestObject.abort = function () {
                    aborted = true;
                    if (oldAbortFunction) {
                        oldAbortFunction.call(requestObject);
                    }
                };
                var scope = requestObject.scope || dojo.global;
                if (!requestObject.store) {
                    requestObject.store = self;
                }
                if (requestObject.onBegin) {
                    requestObject.onBegin.call(scope, numRows, requestObject);
                }
                if (requestObject.sort && self.doClientSorting) {
                    items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
                }
                if (requestObject.onItem) {
                    for (var i = startIndex; (i < items.length) && (i < endIndex); ++i) {
                        var item = items[i];
                        if (!aborted) {
                            requestObject.onItem.call(scope, item, requestObject);
                        }
                    }
                }
                if (requestObject.onComplete && !aborted) {
                    var subset = null;
                    if (!requestObject.onItem) {
                        subset = items.slice(startIndex, endIndex);
                    }
                    requestObject.onComplete.call(scope, subset, requestObject);
                }
            };
            this._fetchItems(request, _fetchHandler, _errorHandler);
            return request;
        }, getFeatures:function () {
            return this._features;
        }, close:function (request) {
        }, getLabel:function (item) {
            if (this._labelAttr && this.isItem(item)) {
                return this.getValue(item, this._labelAttr);
            }
            return undefined;
        }, getLabelAttributes:function (item) {
            if (this._labelAttr) {
                return [this._labelAttr];
            }
            return null;
        }, _xhrFetchHandler:function (data, request, fetchHandler, errorHandler) {
            data = this._filterResponse(data);
            if (data.label) {
                this._labelAttr = data.label;
            }
            var numRows = data.numRows || -1;
            this._items = [];
            dojo.forEach(data.items, function (e) {
                this._items.push({i:e, r:this});
            }, this);
            var identifier = data.identifier;
            this._itemsByIdentity = {};
            if (identifier) {
                this._identifier = identifier;
                var i;
                for (i = 0; i < this._items.length; ++i) {
                    var item = this._items[i].i;
                    var identity = item[identifier];
                    if (!this._itemsByIdentity[identity]) {
                        this._itemsByIdentity[identity] = item;
                    } else {
                        throw new Error(this._className + ":  The json data as specified by: [" + this.url + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
                    }
                }
            } else {
                this._identifier = Number;
                for (i = 0; i < this._items.length; ++i) {
                    this._items[i].n = i;
                }
            }
            numRows = this._numRows = (numRows === -1) ? this._items.length : numRows;
            fetchHandler(this._items, request, numRows);
            this._numRows = numRows;
        }, _fetchItems:function (request, fetchHandler, errorHandler) {
            var serverQuery = request.serverQuery || request.query || {};
            if (!this.doClientPaging) {
                serverQuery.start = request.start || 0;
                if (request.count) {
                    serverQuery.count = request.count;
                }
            }
            if (!this.doClientSorting && request.sort) {
                var sortInfo = [];
                dojo.forEach(request.sort, function (sort) {
                    if (sort && sort.attribute) {
                        sortInfo.push((sort.descending ? "-" : "") + sort.attribute);
                    }
                });
                serverQuery.sort = sortInfo.join(",");
            }
            if (this.doClientPaging && this._lastServerQuery !== null && dojo.toJson(serverQuery) == dojo.toJson(this._lastServerQuery)) {
                this._numRows = (this._numRows === -1) ? this._items.length : this._numRows;
                fetchHandler(this._items, request, this._numRows);
            } else {
                var xhrFunc = this.requestMethod.toLowerCase() == "post" ? dojo.xhrPost : dojo.xhrGet;
                var xhrHandler = xhrFunc({url:this.url, handleAs:"json-comment-optional", content:serverQuery, failOk:true});
                request.abort = function () {
                    xhrHandler.cancel();
                };
                xhrHandler.addCallback(dojo.hitch(this, function (data) {
                    this._xhrFetchHandler(data, request, fetchHandler, errorHandler);
                }));
                xhrHandler.addErrback(function (error) {
                    errorHandler(error, request);
                });
                this.lastRequestHash = new Date().getTime() + "-" + String(Math.random()).substring(2);
                this._lastServerQuery = dojo.mixin({}, serverQuery);
            }
        }, _filterResponse:function (data) {
            return data;
        }, _assertIsItem:function (item) {
            if (!this.isItem(item)) {
                throw new Error(this._className + ": Invalid item argument.");
            }
        }, _assertIsAttribute:function (attribute) {
            if (typeof attribute !== "string") {
                throw new Error(this._className + ": Invalid attribute argument ('" + attribute + "').");
            }
        }, fetchItemByIdentity:function (keywordArgs) {
            if (this._itemsByIdentity) {
                var item = this._itemsByIdentity[keywordArgs.identity];
                if (!(item === undefined)) {
                    if (keywordArgs.onItem) {
                        var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
                        keywordArgs.onItem.call(scope, {i:item, r:this});
                    }
                    return;
                }
            }
            var _errorHandler = function (errorData, requestObject) {
                var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
                if (keywordArgs.onError) {
                    keywordArgs.onError.call(scope, errorData);
                }
            };
            var _fetchHandler = function (items, requestObject) {
                var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
                try {
                    var item = null;
                    if (items && items.length == 1) {
                        item = items[0];
                    }
                    if (keywordArgs.onItem) {
                        keywordArgs.onItem.call(scope, item);
                    }
                }
                catch (error) {
                    if (keywordArgs.onError) {
                        keywordArgs.onError.call(scope, error);
                    }
                }
            };
            var request = {serverQuery:{id:keywordArgs.identity}};
            this._fetchItems(request, _fetchHandler, _errorHandler);
        }, getIdentity:function (item) {
            var identifier = null;
            if (this._identifier === Number) {
                identifier = item.n;
            } else {
                identifier = item.i[this._identifier];
            }
            return identifier;
        }, getIdentityAttributes:function (item) {
            return [this._identifier];
        }});
    });
}, "dijit/_editor/plugins/EnterKeyHandling":function () {
    define(["dojo/_base/declare", "dojo/dom-construct", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/sniff", "dojo/_base/window", "dojo/window", "../_Plugin", "../RichText", "../range", "../../_base/focus"], function (declare, domConstruct, keys, lang, on, has, win, winUtils, _Plugin, RichText, rangeapi, baseFocus) {
        return declare("dijit._editor.plugins.EnterKeyHandling", _Plugin, {blockNodeForEnter:"BR", constructor:function (args) {
            if (args) {
                if ("blockNodeForEnter" in args) {
                    args.blockNodeForEnter = args.blockNodeForEnter.toUpperCase();
                }
                lang.mixin(this, args);
            }
        }, setEditor:function (editor) {
            if (this.editor === editor) {
                return;
            }
            this.editor = editor;
            if (this.blockNodeForEnter == "BR") {
                this.editor.customUndo = true;
                editor.onLoadDeferred.then(lang.hitch(this, function (d) {
                    this.own(on(editor.document, "keydown", lang.hitch(this, function (e) {
                        if (e.keyCode == keys.ENTER) {
                            var ne = lang.mixin({}, e);
                            ne.shiftKey = true;
                            if (!this.handleEnterKey(ne)) {
                                e.stopPropagation();
                                e.preventDefault();
                            }
                        }
                    })));
                    if (has("ie") >= 9 && has("ie") <= 10) {
                        this.own(on(editor.document, "paste", lang.hitch(this, function (e) {
                            setTimeout(lang.hitch(this, function () {
                                var r = this.editor.document.selection.createRange();
                                r.move("character", -1);
                                r.select();
                                r.move("character", 1);
                                r.select();
                            }), 0);
                        })));
                    }
                    return d;
                }));
            } else {
                if (this.blockNodeForEnter) {
                    var h = lang.hitch(this, "handleEnterKey");
                    editor.addKeyHandler(13, 0, 0, h);
                    editor.addKeyHandler(13, 0, 1, h);
                    this.own(this.editor.on("KeyPressed", lang.hitch(this, "onKeyPressed")));
                }
            }
        }, onKeyPressed:function () {
            if (this._checkListLater) {
                if (win.withGlobal(this.editor.window, "isCollapsed", baseFocus)) {
                    var liparent = this.editor.selection.getAncestorElement("LI");
                    if (!liparent) {
                        RichText.prototype.execCommand.call(this.editor, "formatblock", this.blockNodeForEnter);
                        var block = this.editor.selection.getAncestorElement(this.blockNodeForEnter);
                        if (block) {
                            block.innerHTML = this.bogusHtmlContent;
                            if (has("ie") <= 9) {
                                var r = this.editor.document.selection.createRange();
                                r.move("character", -1);
                                r.select();
                            }
                        } else {
                            console.error("onKeyPressed: Cannot find the new block node");
                        }
                    } else {
                        if (has("mozilla")) {
                            if (liparent.parentNode.parentNode.nodeName == "LI") {
                                liparent = liparent.parentNode.parentNode;
                            }
                        }
                        var fc = liparent.firstChild;
                        if (fc && fc.nodeType == 1 && (fc.nodeName == "UL" || fc.nodeName == "OL")) {
                            liparent.insertBefore(fc.ownerDocument.createTextNode("\xa0"), fc);
                            var newrange = rangeapi.create(this.editor.window);
                            newrange.setStart(liparent.firstChild, 0);
                            var selection = rangeapi.getSelection(this.editor.window, true);
                            selection.removeAllRanges();
                            selection.addRange(newrange);
                        }
                    }
                }
                this._checkListLater = false;
            }
            if (this._pressedEnterInBlock) {
                if (this._pressedEnterInBlock.previousSibling) {
                    this.removeTrailingBr(this._pressedEnterInBlock.previousSibling);
                }
                delete this._pressedEnterInBlock;
            }
        }, bogusHtmlContent:"&#160;", blockNodes:/^(?:P|H1|H2|H3|H4|H5|H6|LI)$/, handleEnterKey:function (e) {
            var selection, range, newrange, startNode, endNode, brNode, doc = this.editor.document, br, rs, txt;
            if (e.shiftKey) {
                var parent = this.editor.selection.getParentElement();
                var header = rangeapi.getAncestor(parent, this.blockNodes);
                if (header) {
                    if (header.tagName == "LI") {
                        return true;
                    }
                    selection = rangeapi.getSelection(this.editor.window);
                    range = selection.getRangeAt(0);
                    if (!range.collapsed) {
                        range.deleteContents();
                        selection = rangeapi.getSelection(this.editor.window);
                        range = selection.getRangeAt(0);
                    }
                    if (rangeapi.atBeginningOfContainer(header, range.startContainer, range.startOffset)) {
                        br = doc.createElement("br");
                        newrange = rangeapi.create(this.editor.window);
                        header.insertBefore(br, header.firstChild);
                        newrange.setStartAfter(br);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                    } else {
                        if (rangeapi.atEndOfContainer(header, range.startContainer, range.startOffset)) {
                            newrange = rangeapi.create(this.editor.window);
                            br = doc.createElement("br");
                            header.appendChild(br);
                            header.appendChild(doc.createTextNode("\xa0"));
                            newrange.setStart(header.lastChild, 0);
                            selection.removeAllRanges();
                            selection.addRange(newrange);
                        } else {
                            rs = range.startContainer;
                            if (rs && rs.nodeType == 3) {
                                txt = rs.nodeValue;
                                startNode = doc.createTextNode(txt.substring(0, range.startOffset));
                                endNode = doc.createTextNode(txt.substring(range.startOffset));
                                brNode = doc.createElement("br");
                                if (endNode.nodeValue == "" && has("webkit")) {
                                    endNode = doc.createTextNode("\xa0");
                                }
                                domConstruct.place(startNode, rs, "after");
                                domConstruct.place(brNode, startNode, "after");
                                domConstruct.place(endNode, brNode, "after");
                                domConstruct.destroy(rs);
                                newrange = rangeapi.create(this.editor.window);
                                newrange.setStart(endNode, 0);
                                selection.removeAllRanges();
                                selection.addRange(newrange);
                                return false;
                            }
                            return true;
                        }
                    }
                } else {
                    selection = rangeapi.getSelection(this.editor.window);
                    if (selection.rangeCount) {
                        range = selection.getRangeAt(0);
                        if (range && range.startContainer) {
                            if (!range.collapsed) {
                                range.deleteContents();
                                selection = rangeapi.getSelection(this.editor.window);
                                range = selection.getRangeAt(0);
                            }
                            rs = range.startContainer;
                            if (rs && rs.nodeType == 3) {
                                var offset = range.startOffset;
                                if (rs.length < offset) {
                                    ret = this._adjustNodeAndOffset(rs, offset);
                                    rs = ret.node;
                                    offset = ret.offset;
                                }
                                txt = rs.nodeValue;
                                startNode = doc.createTextNode(txt.substring(0, offset));
                                endNode = doc.createTextNode(txt.substring(offset));
                                brNode = doc.createElement("br");
                                if (!endNode.length) {
                                    endNode = doc.createTextNode("\xa0");
                                }
                                if (startNode.length) {
                                    domConstruct.place(startNode, rs, "after");
                                } else {
                                    startNode = rs;
                                }
                                domConstruct.place(brNode, startNode, "after");
                                domConstruct.place(endNode, brNode, "after");
                                domConstruct.destroy(rs);
                                newrange = rangeapi.create(this.editor.window);
                                newrange.setStart(endNode, 0);
                                newrange.setEnd(endNode, endNode.length);
                                selection.removeAllRanges();
                                selection.addRange(newrange);
                                this.editor.selection.collapse(true);
                            } else {
                                var targetNode;
                                if (range.startOffset >= 0) {
                                    targetNode = rs.childNodes[range.startOffset];
                                }
                                var brNode = doc.createElement("br");
                                var endNode = doc.createTextNode("\xa0");
                                if (!targetNode) {
                                    rs.appendChild(brNode);
                                    rs.appendChild(endNode);
                                } else {
                                    domConstruct.place(brNode, targetNode, "before");
                                    domConstruct.place(endNode, brNode, "after");
                                }
                                newrange = rangeapi.create(this.editor.window);
                                newrange.setStart(endNode, 0);
                                newrange.setEnd(endNode, endNode.length);
                                selection.removeAllRanges();
                                selection.addRange(newrange);
                                this.editor.selection.collapse(true);
                            }
                        }
                    } else {
                        RichText.prototype.execCommand.call(this.editor, "inserthtml", "<br>");
                    }
                }
                return false;
            }
            var _letBrowserHandle = true;
            selection = rangeapi.getSelection(this.editor.window);
            range = selection.getRangeAt(0);
            if (!range.collapsed) {
                range.deleteContents();
                selection = rangeapi.getSelection(this.editor.window);
                range = selection.getRangeAt(0);
            }
            var block = rangeapi.getBlockAncestor(range.endContainer, null, this.editor.editNode);
            var blockNode = block.blockNode;
            if ((this._checkListLater = (blockNode && (blockNode.nodeName == "LI" || blockNode.parentNode.nodeName == "LI")))) {
                if (has("mozilla")) {
                    this._pressedEnterInBlock = blockNode;
                }
                if (/^(\s|&nbsp;|&#160;|\xA0|<span\b[^>]*\bclass=['"]Apple-style-span['"][^>]*>(\s|&nbsp;|&#160;|\xA0)<\/span>)?(<br>)?$/.test(blockNode.innerHTML)) {
                    blockNode.innerHTML = "";
                    if (has("webkit")) {
                        newrange = rangeapi.create(this.editor.window);
                        newrange.setStart(blockNode, 0);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                    }
                    this._checkListLater = false;
                }
                return true;
            }
            if (!block.blockNode || block.blockNode === this.editor.editNode) {
                try {
                    RichText.prototype.execCommand.call(this.editor, "formatblock", this.blockNodeForEnter);
                }
                catch (e2) {
                }
                block = {blockNode:this.editor.selection.getAncestorElement(this.blockNodeForEnter), blockContainer:this.editor.editNode};
                if (block.blockNode) {
                    if (block.blockNode != this.editor.editNode && (!(block.blockNode.textContent || block.blockNode.innerHTML).replace(/^\s+|\s+$/g, "").length)) {
                        this.removeTrailingBr(block.blockNode);
                        return false;
                    }
                } else {
                    block.blockNode = this.editor.editNode;
                }
                selection = rangeapi.getSelection(this.editor.window);
                range = selection.getRangeAt(0);
            }
            var newblock = doc.createElement(this.blockNodeForEnter);
            newblock.innerHTML = this.bogusHtmlContent;
            this.removeTrailingBr(block.blockNode);
            var endOffset = range.endOffset;
            var node = range.endContainer;
            if (node.length < endOffset) {
                var ret = this._adjustNodeAndOffset(node, endOffset);
                node = ret.node;
                endOffset = ret.offset;
            }
            if (rangeapi.atEndOfContainer(block.blockNode, node, endOffset)) {
                if (block.blockNode === block.blockContainer) {
                    block.blockNode.appendChild(newblock);
                } else {
                    domConstruct.place(newblock, block.blockNode, "after");
                }
                _letBrowserHandle = false;
                newrange = rangeapi.create(this.editor.window);
                newrange.setStart(newblock, 0);
                selection.removeAllRanges();
                selection.addRange(newrange);
                if (this.editor.height) {
                    winUtils.scrollIntoView(newblock);
                }
            } else {
                if (rangeapi.atBeginningOfContainer(block.blockNode, range.startContainer, range.startOffset)) {
                    domConstruct.place(newblock, block.blockNode, block.blockNode === block.blockContainer ? "first" : "before");
                    if (newblock.nextSibling && this.editor.height) {
                        newrange = rangeapi.create(this.editor.window);
                        newrange.setStart(newblock.nextSibling, 0);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                        winUtils.scrollIntoView(newblock.nextSibling);
                    }
                    _letBrowserHandle = false;
                } else {
                    if (block.blockNode === block.blockContainer) {
                        block.blockNode.appendChild(newblock);
                    } else {
                        domConstruct.place(newblock, block.blockNode, "after");
                    }
                    _letBrowserHandle = false;
                    if (block.blockNode.style) {
                        if (newblock.style) {
                            if (block.blockNode.style.cssText) {
                                newblock.style.cssText = block.blockNode.style.cssText;
                            }
                        }
                    }
                    rs = range.startContainer;
                    var firstNodeMoved;
                    if (rs && rs.nodeType == 3) {
                        var nodeToMove, tNode;
                        endOffset = range.endOffset;
                        if (rs.length < endOffset) {
                            ret = this._adjustNodeAndOffset(rs, endOffset);
                            rs = ret.node;
                            endOffset = ret.offset;
                        }
                        txt = rs.nodeValue;
                        startNode = doc.createTextNode(txt.substring(0, endOffset));
                        endNode = doc.createTextNode(txt.substring(endOffset, txt.length));
                        domConstruct.place(startNode, rs, "before");
                        domConstruct.place(endNode, rs, "after");
                        domConstruct.destroy(rs);
                        var parentC = startNode.parentNode;
                        while (parentC !== block.blockNode) {
                            var tg = parentC.tagName;
                            var newTg = doc.createElement(tg);
                            if (parentC.style) {
                                if (newTg.style) {
                                    if (parentC.style.cssText) {
                                        newTg.style.cssText = parentC.style.cssText;
                                    }
                                }
                            }
                            if (parentC.tagName === "FONT") {
                                if (parentC.color) {
                                    newTg.color = parentC.color;
                                }
                                if (parentC.face) {
                                    newTg.face = parentC.face;
                                }
                                if (parentC.size) {
                                    newTg.size = parentC.size;
                                }
                            }
                            nodeToMove = endNode;
                            while (nodeToMove) {
                                tNode = nodeToMove.nextSibling;
                                newTg.appendChild(nodeToMove);
                                nodeToMove = tNode;
                            }
                            domConstruct.place(newTg, parentC, "after");
                            startNode = parentC;
                            endNode = newTg;
                            parentC = parentC.parentNode;
                        }
                        nodeToMove = endNode;
                        if (nodeToMove.nodeType == 1 || (nodeToMove.nodeType == 3 && nodeToMove.nodeValue)) {
                            newblock.innerHTML = "";
                        }
                        firstNodeMoved = nodeToMove;
                        while (nodeToMove) {
                            tNode = nodeToMove.nextSibling;
                            newblock.appendChild(nodeToMove);
                            nodeToMove = tNode;
                        }
                    }
                    newrange = rangeapi.create(this.editor.window);
                    var nodeForCursor;
                    var innerMostFirstNodeMoved = firstNodeMoved;
                    if (this.blockNodeForEnter !== "BR") {
                        while (innerMostFirstNodeMoved) {
                            nodeForCursor = innerMostFirstNodeMoved;
                            tNode = innerMostFirstNodeMoved.firstChild;
                            innerMostFirstNodeMoved = tNode;
                        }
                        if (nodeForCursor && nodeForCursor.parentNode) {
                            newblock = nodeForCursor.parentNode;
                            newrange.setStart(newblock, 0);
                            selection.removeAllRanges();
                            selection.addRange(newrange);
                            if (this.editor.height) {
                                winUtils.scrollIntoView(newblock);
                            }
                            if (has("mozilla")) {
                                this._pressedEnterInBlock = block.blockNode;
                            }
                        } else {
                            _letBrowserHandle = true;
                        }
                    } else {
                        newrange.setStart(newblock, 0);
                        selection.removeAllRanges();
                        selection.addRange(newrange);
                        if (this.editor.height) {
                            winUtils.scrollIntoView(newblock);
                        }
                        if (has("mozilla")) {
                            this._pressedEnterInBlock = block.blockNode;
                        }
                    }
                }
            }
            return _letBrowserHandle;
        }, _adjustNodeAndOffset:function (node, offset) {
            while (node.length < offset && node.nextSibling && node.nextSibling.nodeType == 3) {
                offset = offset - node.length;
                node = node.nextSibling;
            }
            return {"node":node, "offset":offset};
        }, removeTrailingBr:function (container) {
            var para = /P|DIV|LI/i.test(container.tagName) ? container : this.editor.selection.getParentOfType(container, ["P", "DIV", "LI"]);
            if (!para) {
                return;
            }
            if (para.lastChild) {
                if ((para.childNodes.length > 1 && para.lastChild.nodeType == 3 && /^[\s\xAD]*$/.test(para.lastChild.nodeValue)) || para.lastChild.tagName == "BR") {
                    domConstruct.destroy(para.lastChild);
                }
            }
            if (!para.childNodes.length) {
                para.innerHTML = this.bogusHtmlContent;
            }
        }});
    });
}, "dojox/collections/Stack":function () {
    define(["dojo/_base/kernel", "dojo/_base/array", "./_base"], function (dojo, darray, dxc) {
        dxc.Stack = function (arr) {
            var q = [];
            if (arr) {
                q = q.concat(arr);
            }
            this.count = q.length;
            this.clear = function () {
                q = [];
                this.count = q.length;
            };
            this.clone = function () {
                return new dxc.Stack(q);
            };
            this.contains = function (o) {
                for (var i = 0; i < q.length; i++) {
                    if (q[i] == o) {
                        return true;
                    }
                }
                return false;
            };
            this.copyTo = function (arr, i) {
                arr.splice(i, 0, q);
            };
            this.forEach = function (fn, scope) {
                dojo.forEach(q, fn, scope);
            };
            this.getIterator = function () {
                return new dxc.Iterator(q);
            };
            this.peek = function () {
                return q[(q.length - 1)];
            };
            this.pop = function () {
                var r = q.pop();
                this.count = q.length;
                return r;
            };
            this.push = function (o) {
                this.count = q.push(o);
            };
            this.toArray = function () {
                return [].concat(q);
            };
        };
        return dxc.Stack;
    });
}, "dijit/form/_FormValueWidget":function () {
    define(["dojo/_base/declare", "dojo/sniff", "./_FormWidget", "./_FormValueMixin"], function (declare, has, _FormWidget, _FormValueMixin) {
        return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {_layoutHackIE7:function () {
            if (has("ie") == 7) {
                var domNode = this.domNode;
                var parent = domNode.parentNode;
                var pingNode = domNode.firstChild || domNode;
                var origFilter = pingNode.style.filter;
                var _this = this;
                while (parent && parent.clientHeight == 0) {
                    (function ping() {
                        var disconnectHandle = _this.connect(parent, "onscroll", function () {
                            _this.disconnect(disconnectHandle);
                            pingNode.style.filter = (new Date()).getMilliseconds();
                            _this.defer(function () {
                                pingNode.style.filter = origFilter;
                            });
                        });
                    })();
                    parent = parent.parentNode;
                }
            }
        }});
    });
}, "dijit/_BidiSupport":function () {
    define(["dojo/has", "./_WidgetBase", "./_BidiMixin"], function (has, _WidgetBase, _BidiMixin) {
        _WidgetBase.extend(_BidiMixin);
        has.add("dojo-bidi", true);
        return _WidgetBase;
    });
}, "dojo/errors/RequestError":function () {
    define(["./create"], function (create) {
        return create("RequestError", function (message, response) {
            this.response = response;
        });
    });
}, "dijit/tree/_dndContainer":function () {
    define(["dojo/aspect", "dojo/_base/declare", "dojo/dom-class", "dojo/_base/lang", "dojo/on", "dojo/touch"], function (aspect, declare, domClass, lang, on, touch) {
        return declare("dijit.tree._dndContainer", null, {constructor:function (tree, params) {
            this.tree = tree;
            this.node = tree.domNode;
            lang.mixin(this, params);
            this.containerState = "";
            domClass.add(this.node, "dojoDndContainer");
            this.events = [on(this.node, touch.enter, lang.hitch(this, "onOverEvent")), on(this.node, touch.leave, lang.hitch(this, "onOutEvent")), aspect.after(this.tree, "_onNodeMouseEnter", lang.hitch(this, "onMouseOver"), true), aspect.after(this.tree, "_onNodeMouseLeave", lang.hitch(this, "onMouseOut"), true), on(this.node, "dragstart, selectstart", function (evt) {
                evt.preventDefault();
            })];
        }, destroy:function () {
            var h;
            while (h = this.events.pop()) {
                h.remove();
            }
            this.node = this.parent = null;
        }, onMouseOver:function (widget) {
            this.current = widget;
        }, onMouseOut:function () {
            this.current = null;
        }, _changeState:function (type, newState) {
            var prefix = "dojoDnd" + type;
            var state = type.toLowerCase() + "State";
            domClass.replace(this.node, prefix + newState, prefix + this[state]);
            this[state] = newState;
        }, _addItemClass:function (node, type) {
            domClass.add(node, "dojoDndItem" + type);
        }, _removeItemClass:function (node, type) {
            domClass.remove(node, "dojoDndItem" + type);
        }, onOverEvent:function () {
            this._changeState("Container", "Over");
        }, onOutEvent:function () {
            this._changeState("Container", "");
        }});
    });
}, "dijit/focus":function () {
    define(["dojo/aspect", "dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/Evented", "dojo/_base/lang", "dojo/on", "dojo/domReady", "dojo/sniff", "dojo/Stateful", "dojo/_base/window", "dojo/window", "./a11y", "./registry", "./main"], function (aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils, a11y, registry, dijit) {
        var lastFocusin;
        var FocusManager = declare([Stateful, Evented], {curNode:null, activeStack:[], constructor:function () {
            var check = lang.hitch(this, function (node) {
                if (dom.isDescendant(this.curNode, node)) {
                    this.set("curNode", null);
                }
                if (dom.isDescendant(this.prevNode, node)) {
                    this.set("prevNode", null);
                }
            });
            aspect.before(domConstruct, "empty", check);
            aspect.before(domConstruct, "destroy", check);
        }, registerIframe:function (iframe) {
            return this.registerWin(iframe.contentWindow, iframe);
        }, registerWin:function (targetWindow, effectiveNode) {
            var _this = this, body = targetWindow.document && targetWindow.document.body;
            if (body) {
                var mdh = on(targetWindow.document, "mousedown, touchstart", function (evt) {
                    _this._justMouseDowned = true;
                    setTimeout(function () {
                        _this._justMouseDowned = false;
                    }, 13);
                    if (evt && evt.target && evt.target.parentNode == null) {
                        return;
                    }
                    _this._onTouchNode(effectiveNode || evt.target, "mouse");
                });
                var fih = on(body, "focusin", function (evt) {
                    lastFocusin = (new Date()).getTime();
                    if (!evt.target.tagName) {
                        return;
                    }
                    var tag = evt.target.tagName.toLowerCase();
                    if (tag == "#document" || tag == "body") {
                        return;
                    }
                    if (a11y.isFocusable(evt.target)) {
                        _this._onFocusNode(effectiveNode || evt.target);
                    } else {
                        _this._onTouchNode(effectiveNode || evt.target);
                    }
                });
                var foh = on(body, "focusout", function (evt) {
                    if ((new Date()).getTime() < lastFocusin + 100) {
                        return;
                    }
                    _this._onBlurNode(effectiveNode || evt.target);
                });
                return {remove:function () {
                    mdh.remove();
                    fih.remove();
                    foh.remove();
                    mdh = fih = foh = null;
                    body = null;
                }};
            }
        }, _onBlurNode:function (node) {
            if (this._clearFocusTimer) {
                clearTimeout(this._clearFocusTimer);
            }
            this._clearFocusTimer = setTimeout(lang.hitch(this, function () {
                this.set("prevNode", this.curNode);
                this.set("curNode", null);
            }), 0);
            if (this._justMouseDowned) {
                return;
            }
            if (this._clearActiveWidgetsTimer) {
                clearTimeout(this._clearActiveWidgetsTimer);
            }
            this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function () {
                delete this._clearActiveWidgetsTimer;
                this._setStack([]);
            }), 0);
        }, _onTouchNode:function (node, by) {
            if (this._clearActiveWidgetsTimer) {
                clearTimeout(this._clearActiveWidgetsTimer);
                delete this._clearActiveWidgetsTimer;
            }
            if (domClass.contains(node, "dijitPopup")) {
                node = node.firstChild;
            }
            var newStack = [];
            try {
                while (node) {
                    var popupParent = domAttr.get(node, "dijitPopupParent");
                    if (popupParent) {
                        node = registry.byId(popupParent).domNode;
                    } else {
                        if (node.tagName && node.tagName.toLowerCase() == "body") {
                            if (node === win.body()) {
                                break;
                            }
                            node = winUtils.get(node.ownerDocument).frameElement;
                        } else {
                            var id = node.getAttribute && node.getAttribute("widgetId"), widget = id && registry.byId(id);
                            if (widget && !(by == "mouse" && widget.get("disabled"))) {
                                newStack.unshift(id);
                            }
                            node = node.parentNode;
                        }
                    }
                }
            }
            catch (e) {
            }
            this._setStack(newStack, by);
        }, _onFocusNode:function (node) {
            if (!node) {
                return;
            }
            if (node.nodeType == 9) {
                return;
            }
            if (this._clearFocusTimer) {
                clearTimeout(this._clearFocusTimer);
                delete this._clearFocusTimer;
            }
            this._onTouchNode(node);
            if (node == this.curNode) {
                return;
            }
            this.set("prevNode", this.curNode);
            this.set("curNode", node);
        }, _setStack:function (newStack, by) {
            var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;
            if (newStack[lastNewIdx] == oldStack[lastOldIdx]) {
                return;
            }
            this.set("activeStack", newStack);
            var widget, i;
            for (i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--) {
                widget = registry.byId(oldStack[i]);
                if (widget) {
                    widget._hasBeenBlurred = true;
                    widget.set("focused", false);
                    if (widget._focusManager == this) {
                        widget._onBlur(by);
                    }
                    this.emit("widget-blur", widget, by);
                }
            }
            for (i++; i <= lastNewIdx; i++) {
                widget = registry.byId(newStack[i]);
                if (widget) {
                    widget.set("focused", true);
                    if (widget._focusManager == this) {
                        widget._onFocus(by);
                    }
                    this.emit("widget-focus", widget, by);
                }
            }
        }, focus:function (node) {
            if (node) {
                try {
                    node.focus();
                }
                catch (e) {
                }
            }
        }});
        var singleton = new FocusManager();
        domReady(function () {
            var handle = singleton.registerWin(winUtils.get(document));
            if (has("ie")) {
                on(window, "unload", function () {
                    if (handle) {
                        handle.remove();
                        handle = null;
                    }
                });
            }
        });
        dijit.focus = function (node) {
            singleton.focus(node);
        };
        for (var attr in singleton) {
            if (!/^_/.test(attr)) {
                dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
            }
        }
        singleton.watch(function (attr, oldVal, newVal) {
            dijit.focus[attr] = newVal;
        });
        return singleton;
    });
}, "dojo/_base/declare":function () {
    define(["./kernel", "../has", "./lang"], function (dojo, has, lang) {
        var mix = lang.mixin, op = Object.prototype, opts = op.toString, xtor = new Function, counter = 0, cname = "constructor";
        function err(msg, cls) {
            throw new Error("declare" + (cls ? " " + cls : "") + ": " + msg);
        }
        function c3mro(bases, className) {
            var result = [], roots = [{cls:0, refs:[]}], nameMap = {}, clsCount = 1, l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;
            for (; i < l; ++i) {
                base = bases[i];
                if (!base) {
                    err("mixin #" + i + " is unknown. Did you use dojo.require to pull it in?", className);
                } else {
                    if (opts.call(base) != "[object Function]") {
                        err("mixin #" + i + " is not a callable constructor.", className);
                    }
                }
                lin = base._meta ? base._meta.bases : [base];
                top = 0;
                for (j = lin.length - 1; j >= 0; --j) {
                    proto = lin[j].prototype;
                    if (!proto.hasOwnProperty("declaredClass")) {
                        proto.declaredClass = "uniqName_" + (counter++);
                    }
                    name = proto.declaredClass;
                    if (!nameMap.hasOwnProperty(name)) {
                        nameMap[name] = {count:0, refs:[], cls:lin[j]};
                        ++clsCount;
                    }
                    rec = nameMap[name];
                    if (top && top !== rec) {
                        rec.refs.push(top);
                        ++top.count;
                    }
                    top = rec;
                }
                ++top.count;
                roots[0].refs.push(top);
            }
            while (roots.length) {
                top = roots.pop();
                result.push(top.cls);
                --clsCount;
                while (refs = top.refs, refs.length == 1) {
                    top = refs[0];
                    if (!top || --top.count) {
                        top = 0;
                        break;
                    }
                    result.push(top.cls);
                    --clsCount;
                }
                if (top) {
                    for (i = 0, l = refs.length; i < l; ++i) {
                        top = refs[i];
                        if (!--top.count) {
                            roots.push(top);
                        }
                    }
                }
            }
            if (clsCount) {
                err("can't build consistent linearization", className);
            }
            base = bases[0];
            result[0] = base ? base._meta && base === result[result.length - base._meta.bases.length] ? base._meta.bases.length : 1 : 0;
            return result;
        }
        function inherited(args, a, f) {
            var name, chains, bases, caller, meta, base, proto, opf, pos, cache = this._inherited = this._inherited || {};
            if (typeof args == "string") {
                name = args;
                args = a;
                a = f;
            }
            f = 0;
            caller = args.callee;
            name = name || caller.nom;
            if (!name) {
                err("can't deduce a name to call inherited()", this.declaredClass);
            }
            meta = this.constructor._meta;
            bases = meta.bases;
            pos = cache.p;
            if (name != cname) {
                if (cache.c !== caller) {
                    pos = 0;
                    base = bases[0];
                    meta = base._meta;
                    if (meta.hidden[name] !== caller) {
                        chains = meta.chains;
                        if (chains && typeof chains[name] == "string") {
                            err("calling chained method with inherited: " + name, this.declaredClass);
                        }
                        do {
                            meta = base._meta;
                            proto = base.prototype;
                            if (meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)) {
                                break;
                            }
                        } while (base = bases[++pos]);
                        pos = base ? pos : -1;
                    }
                }
                base = bases[++pos];
                if (base) {
                    proto = base.prototype;
                    if (base._meta && proto.hasOwnProperty(name)) {
                        f = proto[name];
                    } else {
                        opf = op[name];
                        do {
                            proto = base.prototype;
                            f = proto[name];
                            if (f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)) {
                                break;
                            }
                        } while (base = bases[++pos]);
                    }
                }
                f = base && f || op[name];
            } else {
                if (cache.c !== caller) {
                    pos = 0;
                    meta = bases[0]._meta;
                    if (meta && meta.ctor !== caller) {
                        chains = meta.chains;
                        if (!chains || chains.constructor !== "manual") {
                            err("calling chained constructor with inherited", this.declaredClass);
                        }
                        while (base = bases[++pos]) {
                            meta = base._meta;
                            if (meta && meta.ctor === caller) {
                                break;
                            }
                        }
                        pos = base ? pos : -1;
                    }
                }
                while (base = bases[++pos]) {
                    meta = base._meta;
                    f = meta ? meta.ctor : base;
                    if (f) {
                        break;
                    }
                }
                f = base && f;
            }
            cache.c = f;
            cache.p = pos;
            if (f) {
                return a === true ? f : f.apply(this, a || args);
            }
        }
        function getInherited(name, args) {
            if (typeof name == "string") {
                return this.__inherited(name, args, true);
            }
            return this.__inherited(name, true);
        }
        function inherited__debug(args, a1, a2) {
            var f = this.getInherited(args, a1);
            if (f) {
                return f.apply(this, a2 || a1 || args);
            }
        }
        var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;
        function isInstanceOf(cls) {
            var bases = this.constructor._meta.bases;
            for (var i = 0, l = bases.length; i < l; ++i) {
                if (bases[i] === cls) {
                    return true;
                }
            }
            return this instanceof cls;
        }
        function mixOwn(target, source) {
            for (var name in source) {
                if (name != cname && source.hasOwnProperty(name)) {
                    target[name] = source[name];
                }
            }
            if (has("bug-for-in-skips-shadowed")) {
                for (var extraNames = lang._extraNames, i = extraNames.length; i; ) {
                    name = extraNames[--i];
                    if (name != cname && source.hasOwnProperty(name)) {
                        target[name] = source[name];
                    }
                }
            }
        }
        function safeMixin(target, source) {
            var name, t;
            for (name in source) {
                t = source[name];
                if ((t !== op[name] || !(name in op)) && name != cname) {
                    if (opts.call(t) == "[object Function]") {
                        t.nom = name;
                    }
                    target[name] = t;
                }
            }
            if (has("bug-for-in-skips-shadowed")) {
                for (var extraNames = lang._extraNames, i = extraNames.length; i; ) {
                    name = extraNames[--i];
                    t = source[name];
                    if ((t !== op[name] || !(name in op)) && name != cname) {
                        if (opts.call(t) == "[object Function]") {
                            t.nom = name;
                        }
                        target[name] = t;
                    }
                }
            }
            return target;
        }
        function extend(source) {
            declare.safeMixin(this.prototype, source);
            return this;
        }
        function createSubclass(mixins, props) {
            return declare([this].concat(mixins), props || {});
        }
        function chainedConstructor(bases, ctorSpecial) {
            return function () {
                var a = arguments, args = a, a0 = a[0], f, i, m, l = bases.length, preArgs;
                if (!(this instanceof a.callee)) {
                    return applyNew(a);
                }
                if (ctorSpecial && (a0 && a0.preamble || this.preamble)) {
                    preArgs = new Array(bases.length);
                    preArgs[0] = a;
                    for (i = 0; ; ) {
                        a0 = a[0];
                        if (a0) {
                            f = a0.preamble;
                            if (f) {
                                a = f.apply(this, a) || a;
                            }
                        }
                        f = bases[i].prototype;
                        f = f.hasOwnProperty("preamble") && f.preamble;
                        if (f) {
                            a = f.apply(this, a) || a;
                        }
                        if (++i == l) {
                            break;
                        }
                        preArgs[i] = a;
                    }
                }
                for (i = l - 1; i >= 0; --i) {
                    f = bases[i];
                    m = f._meta;
                    f = m ? m.ctor : f;
                    if (f) {
                        f.apply(this, preArgs ? preArgs[i] : a);
                    }
                }
                f = this.postscript;
                if (f) {
                    f.apply(this, args);
                }
            };
        }
        function singleConstructor(ctor, ctorSpecial) {
            return function () {
                var a = arguments, t = a, a0 = a[0], f;
                if (!(this instanceof a.callee)) {
                    return applyNew(a);
                }
                if (ctorSpecial) {
                    if (a0) {
                        f = a0.preamble;
                        if (f) {
                            t = f.apply(this, t) || t;
                        }
                    }
                    f = this.preamble;
                    if (f) {
                        f.apply(this, t);
                    }
                }
                if (ctor) {
                    ctor.apply(this, a);
                }
                f = this.postscript;
                if (f) {
                    f.apply(this, a);
                }
            };
        }
        function simpleConstructor(bases) {
            return function () {
                var a = arguments, i = 0, f, m;
                if (!(this instanceof a.callee)) {
                    return applyNew(a);
                }
                for (; f = bases[i]; ++i) {
                    m = f._meta;
                    f = m ? m.ctor : f;
                    if (f) {
                        f.apply(this, a);
                        break;
                    }
                }
                f = this.postscript;
                if (f) {
                    f.apply(this, a);
                }
            };
        }
        function chain(name, bases, reversed) {
            return function () {
                var b, m, f, i = 0, step = 1;
                if (reversed) {
                    i = bases.length - 1;
                    step = -1;
                }
                for (; b = bases[i]; i += step) {
                    m = b._meta;
                    f = (m ? m.hidden : b.prototype)[name];
                    if (f) {
                        f.apply(this, arguments);
                    }
                }
            };
        }
        function forceNew(ctor) {
            xtor.prototype = ctor.prototype;
            var t = new xtor;
            xtor.prototype = null;
            return t;
        }
        function applyNew(args) {
            var ctor = args.callee, t = forceNew(ctor);
            ctor.apply(t, args);
            return t;
        }
        function declare(className, superclass, props) {
            if (typeof className != "string") {
                props = superclass;
                superclass = className;
                className = "";
            }
            props = props || {};
            var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;
            if (opts.call(superclass) == "[object Array]") {
                bases = c3mro(superclass, className);
                t = bases[0];
                mixins = bases.length - t;
                superclass = bases[mixins];
            } else {
                bases = [0];
                if (superclass) {
                    if (opts.call(superclass) == "[object Function]") {
                        t = superclass._meta;
                        bases = bases.concat(t ? t.bases : superclass);
                    } else {
                        err("base class is not a callable constructor.", className);
                    }
                } else {
                    if (superclass !== null) {
                        err("unknown base class. Did you use dojo.require to pull it in?", className);
                    }
                }
            }
            if (superclass) {
                for (i = mixins - 1; ; --i) {
                    proto = forceNew(superclass);
                    if (!i) {
                        break;
                    }
                    t = bases[i];
                    (t._meta ? mixOwn : mix)(proto, t.prototype);
                    ctor = new Function;
                    ctor.superclass = superclass;
                    ctor.prototype = proto;
                    superclass = proto.constructor = ctor;
                }
            } else {
                proto = {};
            }
            declare.safeMixin(proto, props);
            t = props.constructor;
            if (t !== op.constructor) {
                t.nom = cname;
                proto.constructor = t;
            }
            for (i = mixins - 1; i; --i) {
                t = bases[i]._meta;
                if (t && t.chains) {
                    chains = mix(chains || {}, t.chains);
                }
            }
            if (proto["-chains-"]) {
                chains = mix(chains || {}, proto["-chains-"]);
            }
            t = !chains || !chains.hasOwnProperty(cname);
            bases[0] = ctor = (chains && chains.constructor === "manual") ? simpleConstructor(bases) : (bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));
            ctor._meta = {bases:bases, hidden:props, chains:chains, parents:parents, ctor:props.constructor};
            ctor.superclass = superclass && superclass.prototype;
            ctor.extend = extend;
            ctor.createSubclass = createSubclass;
            ctor.prototype = proto;
            proto.constructor = ctor;
            proto.getInherited = getInherited;
            proto.isInstanceOf = isInstanceOf;
            proto.inherited = inheritedImpl;
            proto.__inherited = inherited;
            if (className) {
                proto.declaredClass = className;
                lang.setObject(className, ctor);
            }
            if (chains) {
                for (name in chains) {
                    if (proto[name] && typeof chains[name] == "string" && name != cname) {
                        t = proto[name] = chain(name, bases, chains[name] === "after");
                        t.nom = name;
                    }
                }
            }
            return ctor;
        }
        dojo.safeMixin = declare.safeMixin = safeMixin;
        dojo.declare = declare;
        return declare;
    });
}, "dojo/request/xhr":function () {
    define(["../errors/RequestError", "./watch", "./handlers", "./util", "../has"], function (RequestError, watch, handlers, util, has) {
        has.add("native-xhr", function () {
            return typeof XMLHttpRequest !== "undefined";
        });
        has.add("dojo-force-activex-xhr", function () {
            return has("activex") && !document.addEventListener && window.location.protocol === "file:";
        });
        has.add("native-xhr2", function () {
            if (!has("native-xhr")) {
                return;
            }
            var x = new XMLHttpRequest();
            return typeof x["addEventListener"] !== "undefined" && (typeof opera === "undefined" || typeof x["upload"] !== "undefined");
        });
        has.add("native-formdata", function () {
            return typeof FormData === "function";
        });
        function handleResponse(response, error) {
            var _xhr = response.xhr;
            response.status = response.xhr.status;
            response.text = _xhr.responseText;
            if (response.options.handleAs === "xml") {
                response.data = _xhr.responseXML;
            }
            if (!error) {
                try {
                    handlers(response);
                }
                catch (e) {
                    error = e;
                }
            }
            if (error) {
                this.reject(error);
            } else {
                if (util.checkStatus(_xhr.status)) {
                    this.resolve(response);
                } else {
                    error = new RequestError("Unable to load " + response.url + " status: " + _xhr.status, response);
                    this.reject(error);
                }
            }
        }
        var isValid, isReady, addListeners, cancel;
        if (has("native-xhr2")) {
            isValid = function (response) {
                return !this.isFulfilled();
            };
            cancel = function (dfd, response) {
                response.xhr.abort();
            };
            addListeners = function (_xhr, dfd, response) {
                function onLoad(evt) {
                    dfd.handleResponse(response);
                }
                function onError(evt) {
                    var _xhr = evt.target;
                    var error = new RequestError("Unable to load " + response.url + " status: " + _xhr.status, response);
                    dfd.handleResponse(response, error);
                }
                function onProgress(evt) {
                    if (evt.lengthComputable) {
                        response.loaded = evt.loaded;
                        response.total = evt.total;
                        dfd.progress(response);
                    }
                }
                _xhr.addEventListener("load", onLoad, false);
                _xhr.addEventListener("error", onError, false);
                _xhr.addEventListener("progress", onProgress, false);
                return function () {
                    _xhr.removeEventListener("load", onLoad, false);
                    _xhr.removeEventListener("error", onError, false);
                    _xhr.removeEventListener("progress", onProgress, false);
                    _xhr = null;
                };
            };
        } else {
            isValid = function (response) {
                return response.xhr.readyState;
            };
            isReady = function (response) {
                return 4 === response.xhr.readyState;
            };
            cancel = function (dfd, response) {
                var xhr = response.xhr;
                var _at = typeof xhr.abort;
                if (_at === "function" || _at === "object" || _at === "unknown") {
                    xhr.abort();
                }
            };
        }
        function getHeader(headerName) {
            return this.xhr.getResponseHeader(headerName);
        }
        var undefined, defaultOptions = {data:null, query:null, sync:false, method:"GET"};
        function xhr(url, options, returnDeferred) {
            var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), has("native-formdata") && options && options.data && options.data instanceof FormData);
            url = response.url;
            options = response.options;
            var remover, last = function () {
                remover && remover();
            };
            var dfd = util.deferred(response, cancel, isValid, isReady, handleResponse, last);
            var _xhr = response.xhr = xhr._create();
            if (!_xhr) {
                dfd.cancel(new RequestError("XHR was not created"));
                return returnDeferred ? dfd : dfd.promise;
            }
            response.getHeader = getHeader;
            if (addListeners) {
                remover = addListeners(_xhr, dfd, response);
            }
            var data = options.data, async = !options.sync, method = options.method;
            try {
                _xhr.open(method, url, async, options.user || undefined, options.password || undefined);
                if (options.withCredentials) {
                    _xhr.withCredentials = options.withCredentials;
                }
                var headers = options.headers, contentType = "application/x-www-form-urlencoded";
                if (headers) {
                    for (var hdr in headers) {
                        if (hdr.toLowerCase() === "content-type") {
                            contentType = headers[hdr];
                        } else {
                            if (headers[hdr]) {
                                _xhr.setRequestHeader(hdr, headers[hdr]);
                            }
                        }
                    }
                }
                if (contentType && contentType !== false) {
                    _xhr.setRequestHeader("Content-Type", contentType);
                }
                if (!headers || !("X-Requested-With" in headers)) {
                    _xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                }
                if (util.notify) {
                    util.notify.emit("send", response, dfd.promise.cancel);
                }
                _xhr.send(data);
            }
            catch (e) {
                dfd.reject(e);
            }
            watch(dfd);
            _xhr = null;
            return returnDeferred ? dfd : dfd.promise;
        }
        xhr._create = function () {
            throw new Error("XMLHTTP not available");
        };
        if (has("native-xhr") && !has("dojo-force-activex-xhr")) {
            xhr._create = function () {
                return new XMLHttpRequest();
            };
        } else {
            if (has("activex")) {
                try {
                    new ActiveXObject("Msxml2.XMLHTTP");
                    xhr._create = function () {
                        return new ActiveXObject("Msxml2.XMLHTTP");
                    };
                }
                catch (e) {
                    try {
                        new ActiveXObject("Microsoft.XMLHTTP");
                        xhr._create = function () {
                            return new ActiveXObject("Microsoft.XMLHTTP");
                        };
                    }
                    catch (e) {
                    }
                }
            }
        }
        util.addCommonMethods(xhr);
        return xhr;
    });
}, "dojo/domReady":function () {
    define(["./has"], function (has) {
        var global = this, doc = document, readyStates = {"loaded":1, "complete":1}, fixReadyState = typeof doc.readyState != "string", ready = !!readyStates[doc.readyState], readyQ = [], recursiveGuard;
        function domReady(callback) {
            readyQ.push(callback);
            if (ready) {
                processQ();
            }
        }
        domReady.load = function (id, req, load) {
            domReady(load);
        };
        domReady._Q = readyQ;
        domReady._onQEmpty = function () {
        };
        if (fixReadyState) {
            doc.readyState = "loading";
        }
        function processQ() {
            if (recursiveGuard) {
                return;
            }
            recursiveGuard = true;
            while (readyQ.length) {
                try {
                    (readyQ.shift())(doc);
                }
                catch (err) {
                    console.log("Error on domReady callback: " + err);
                }
            }
            recursiveGuard = false;
            domReady._onQEmpty();
        }
        if (!ready) {
            var tests = [], detectReady = function (evt) {
                evt = evt || global.event;
                if (ready || (evt.type == "readystatechange" && !readyStates[doc.readyState])) {
                    return;
                }
                if (fixReadyState) {
                    doc.readyState = "complete";
                }
                ready = 1;
                processQ();
            }, on = function (node, event) {
                node.addEventListener(event, detectReady, false);
                readyQ.push(function () {
                    node.removeEventListener(event, detectReady, false);
                });
            };
            if (!has("dom-addeventlistener")) {
                on = function (node, event) {
                    event = "on" + event;
                    node.attachEvent(event, detectReady);
                    readyQ.push(function () {
                        node.detachEvent(event, detectReady);
                    });
                };
                var div = doc.createElement("div");
                try {
                    if (div.doScroll && global.frameElement === null) {
                        tests.push(function () {
                            try {
                                div.doScroll("left");
                                return 1;
                            }
                            catch (e) {
                            }
                        });
                    }
                }
                catch (e) {
                }
            }
            on(doc, "DOMContentLoaded");
            on(global, "load");
            if ("onreadystatechange" in doc) {
                on(doc, "readystatechange");
            } else {
                if (!fixReadyState) {
                    tests.push(function () {
                        return readyStates[doc.readyState];
                    });
                }
            }
            if (tests.length) {
                var poller = function () {
                    if (ready) {
                        return;
                    }
                    var i = tests.length;
                    while (i--) {
                        if (tests[i]()) {
                            detectReady("poller");
                            return;
                        }
                    }
                    setTimeout(poller, 30);
                };
                poller();
            }
        }
        return domReady;
    });
}, "dojo/dnd/Target":function () {
    define(["../_base/declare", "../dom-class", "./Source"], function (declare, domClass, Source) {
        return declare("dojo.dnd.Target", Source, {constructor:function () {
            this.isSource = false;
            domClass.remove(this.node, "dojoDndSource");
        }});
    });
}, "dojo/text":function () {
    define(["./_base/kernel", "require", "./has", "./request"], function (dojo, require, has, request) {
        var getText;
        if (1) {
            getText = function (url, sync, load) {
                request(url, {sync:!!sync}).then(load);
            };
        } else {
            if (require.getText) {
                getText = require.getText;
            } else {
                console.error("dojo/text plugin failed to load because loader does not support getText");
            }
        }
        var theCache = {}, strip = function (text) {
            if (text) {
                text = text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
                var matches = text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
                if (matches) {
                    text = matches[1];
                }
            } else {
                text = "";
            }
            return text;
        }, notFound = {}, pending = {};
        dojo.cache = function (module, url, value) {
            var key;
            if (typeof module == "string") {
                if (/\//.test(module)) {
                    key = module;
                    value = url;
                } else {
                    key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
                }
            } else {
                key = module + "";
                value = url;
            }
            var val = (value != undefined && typeof value != "string") ? value.value : value, sanitize = value && value.sanitize;
            if (typeof val == "string") {
                theCache[key] = val;
                return sanitize ? strip(val) : val;
            } else {
                if (val === null) {
                    delete theCache[key];
                    return null;
                } else {
                    if (!(key in theCache)) {
                        getText(key, true, function (text) {
                            theCache[key] = text;
                        });
                    }
                    return sanitize ? strip(theCache[key]) : theCache[key];
                }
            }
        };
        return {dynamic:true, normalize:function (id, toAbsMid) {
            var parts = id.split("!"), url = parts[0];
            return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
        }, load:function (id, require, load) {
            var parts = id.split("!"), stripFlag = parts.length > 1, absMid = parts[0], url = require.toUrl(parts[0]), requireCacheUrl = "url:" + url, text = notFound, finish = function (text) {
                load(stripFlag ? strip(text) : text);
            };
            if (absMid in theCache) {
                text = theCache[absMid];
            } else {
                if (require.cache && requireCacheUrl in require.cache) {
                    text = require.cache[requireCacheUrl];
                } else {
                    if (url in theCache) {
                        text = theCache[url];
                    }
                }
            }
            if (text === notFound) {
                if (pending[url]) {
                    pending[url].push(finish);
                } else {
                    var pendingList = pending[url] = [finish];
                    getText(url, !require.async, function (text) {
                        theCache[absMid] = theCache[url] = text;
                        for (var i = 0; i < pendingList.length; ) {
                            pendingList[i++](text);
                        }
                        delete pending[url];
                    });
                }
            } else {
                finish(text);
            }
        }};
    });
}, "dojo/i18n":function () {
    define(["./_base/kernel", "require", "./has", "./_base/array", "./_base/config", "./_base/lang", "./_base/xhr", "./json", "module"], function (dojo, require, has, array, config, lang, xhr, json, module) {
        has.add("dojo-preload-i18n-Api", 1);
        1 || has.add("dojo-v1x-i18n-Api", 1);
        var thisModule = dojo.i18n = {}, nlsRe = /(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/, getAvailableLocales = function (root, locale, bundlePath, bundleName) {
            for (var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i < localeParts.length; i++) {
                current += (current ? "-" : "") + localeParts[i];
                if (!root || root[current]) {
                    result.push(bundlePath + current + "/" + bundleName);
                    result.specificity = current;
                }
            }
            return result;
        }, cache = {}, getBundleName = function (moduleName, bundleName, locale) {
            locale = locale ? locale.toLowerCase() : dojo.locale;
            moduleName = moduleName.replace(/\./g, "/");
            bundleName = bundleName.replace(/\./g, "/");
            return (/root/i.test(locale)) ? (moduleName + "/nls/" + bundleName) : (moduleName + "/nls/" + locale + "/" + bundleName);
        }, getL10nName = dojo.getL10nName = function (moduleName, bundleName, locale) {
            return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
        }, doLoad = function (require, bundlePathAndName, bundlePath, bundleName, locale, load) {
            require([bundlePathAndName], function (root) {
                var current = lang.clone(root.root || root.ROOT), availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
                require(availableLocales, function () {
                    for (var i = 1; i < availableLocales.length; i++) {
                        current = lang.mixin(lang.clone(current), arguments[i]);
                    }
                    var target = bundlePathAndName + "/" + locale;
                    cache[target] = current;
                    current.$locale = availableLocales.specificity;
                    load();
                });
            });
        }, normalize = function (id, toAbsMid) {
            return /^\./.test(id) ? toAbsMid(id) : id;
        }, getLocalesToLoad = function (targetLocale) {
            var list = config.extraLocale || [];
            list = lang.isArray(list) ? list : [list];
            list.push(targetLocale);
            return list;
        }, load = function (id, require, load) {
            if (has("dojo-preload-i18n-Api")) {
                var split = id.split("*"), preloadDemand = split[1] == "preload";
                if (preloadDemand) {
                    if (!cache[id]) {
                        cache[id] = 1;
                        preloadL10n(split[2], json.parse(split[3]), 1, require);
                    }
                    load(1);
                }
                if (preloadDemand || waitForPreloads(id, require, load)) {
                    return;
                }
            }
            var match = nlsRe.exec(id), bundlePath = match[1] + "/", bundleName = match[5] || match[4], bundlePathAndName = bundlePath + bundleName, localeSpecified = (match[5] && match[4]), targetLocale = localeSpecified || dojo.locale || "", loadTarget = bundlePathAndName + "/" + targetLocale, loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale), remaining = loadList.length, finish = function () {
                if (!--remaining) {
                    load(lang.delegate(cache[loadTarget]));
                }
            };
            array.forEach(loadList, function (locale) {
                var target = bundlePathAndName + "/" + locale;
                if (has("dojo-preload-i18n-Api")) {
                    checkForLegacyModules(target);
                }
                if (!cache[target]) {
                    doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
                } else {
                    finish();
                }
            });
        };
        if (has("dojo-unit-tests")) {
            var unitTests = thisModule.unitTests = [];
        }
        if (has("dojo-preload-i18n-Api") || 1) {
            var normalizeLocale = thisModule.normalizeLocale = function (locale) {
                var result = locale ? locale.toLowerCase() : dojo.locale;
                return result == "root" ? "ROOT" : result;
            }, isXd = function (mid, contextRequire) {
                return (1 && 1) ? contextRequire.isXdUrl(require.toUrl(mid + ".js")) : true;
            }, preloading = 0, preloadWaitQueue = [], preloadL10n = thisModule._preloadLocalizations = function (bundlePrefix, localesGenerated, guaranteedAmdFormat, contextRequire) {
                contextRequire = contextRequire || require;
                function doRequire(mid, callback) {
                    if (isXd(mid, contextRequire) || guaranteedAmdFormat) {
                        contextRequire([mid], callback);
                    } else {
                        syncRequire([mid], callback, contextRequire);
                    }
                }
                function forEachLocale(locale, func) {
                    var parts = locale.split("-");
                    while (parts.length) {
                        if (func(parts.join("-"))) {
                            return;
                        }
                        parts.pop();
                    }
                    func("ROOT");
                }
                function preloadingAddLock() {
                    preloading++;
                }
                function preloadingRelLock() {
                    --preloading;
                    while (!preloading && preloadWaitQueue.length) {
                        load.apply(null, preloadWaitQueue.shift());
                    }
                }
                function cacheId(path, name, loc, require) {
                    return require.toAbsMid(path + name + "/" + loc);
                }
                function preload(locale) {
                    locale = normalizeLocale(locale);
                    forEachLocale(locale, function (loc) {
                        if (array.indexOf(localesGenerated, loc) >= 0) {
                            var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
                            preloadingAddLock();
                            doRequire(mid, function (rollup) {
                                for (var p in rollup) {
                                    var bundle = rollup[p], match = p.match(/(.+)\/([^\/]+)$/), bundleName, bundlePath;
                                    if (!match) {
                                        continue;
                                    }
                                    bundleName = match[2];
                                    bundlePath = match[1] + "/";
                                    bundle._localized = bundle._localized || {};
                                    var localized;
                                    if (loc === "ROOT") {
                                        var root = localized = bundle._localized;
                                        delete bundle._localized;
                                        root.root = bundle;
                                        cache[require.toAbsMid(p)] = root;
                                    } else {
                                        localized = bundle._localized;
                                        cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
                                    }
                                    if (loc !== locale) {
                                        function improveBundle(bundlePath, bundleName, bundle, localized) {
                                            var requiredBundles = [], cacheIds = [];
                                            forEachLocale(locale, function (loc) {
                                                if (localized[loc]) {
                                                    requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
                                                    cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
                                                }
                                            });
                                            if (requiredBundles.length) {
                                                preloadingAddLock();
                                                contextRequire(requiredBundles, function () {
                                                    for (var i = 0; i < requiredBundles.length; i++) {
                                                        bundle = lang.mixin(lang.clone(bundle), arguments[i]);
                                                        cache[cacheIds[i]] = bundle;
                                                    }
                                                    cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
                                                    preloadingRelLock();
                                                });
                                            } else {
                                                cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
                                            }
                                        }
                                        improveBundle(bundlePath, bundleName, bundle, localized);
                                    }
                                }
                                preloadingRelLock();
                            });
                            return true;
                        }
                        return false;
                    });
                }
                preload();
                array.forEach(dojo.config.extraLocale, preload);
            }, waitForPreloads = function (id, require, load) {
                if (preloading) {
                    preloadWaitQueue.push([id, require, load]);
                }
                return preloading;
            }, checkForLegacyModules = function () {
            };
        }
        if (1) {
            var amdValue = {}, evalBundle = new Function("__bundle", "__checkForLegacyModules", "__mid", "__amdValue", "var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;}," + "\t   require = function(){define.called = 1;};" + "try{" + "define.called = 0;" + "eval(__bundle);" + "if(define.called==1)" + "return __amdValue;" + "if((__checkForLegacyModules = __checkForLegacyModules(__mid)))" + "return __checkForLegacyModules;" + "}catch(e){}" + "try{" + "return eval('('+__bundle+')');" + "}catch(e){" + "return e;" + "}"), syncRequire = function (deps, callback, require) {
                var results = [];
                array.forEach(deps, function (mid) {
                    var url = require.toUrl(mid + ".js");
                    function load(text) {
                        var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
                        if (result === amdValue) {
                            results.push(cache[url] = amdValue.result);
                        } else {
                            if (result instanceof Error) {
                                console.error("failed to evaluate i18n bundle; url=" + url, result);
                                result = {};
                            }
                            results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
                        }
                    }
                    if (cache[url]) {
                        results.push(cache[url]);
                    } else {
                        var bundle = require.syncLoadNls(mid);
                        if (bundle) {
                            results.push(bundle);
                        } else {
                            if (!xhr) {
                                try {
                                    require.getText(url, true, load);
                                }
                                catch (e) {
                                    results.push(cache[url] = {});
                                }
                            } else {
                                xhr.get({url:url, sync:true, load:load, error:function () {
                                    results.push(cache[url] = {});
                                }});
                            }
                        }
                    }
                });
                callback && callback.apply(null, results);
            };
            checkForLegacyModules = function (target) {
                for (var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i < names.length - 1; object = object[names[i++]]) {
                }
                if (object) {
                    result = object[names[i]];
                    if (!result) {
                        result = object[names[i].replace(/-/g, "_")];
                    }
                    if (result) {
                        cache[target] = result;
                    }
                }
                return result;
            };
            thisModule.getLocalization = function (moduleName, bundleName, locale) {
                var result, l10nName = getBundleName(moduleName, bundleName, locale);
                load(l10nName, (!isXd(l10nName, require) ? function (deps, callback) {
                    syncRequire(deps, callback, require);
                } : require), function (result_) {
                    result = result_;
                });
                return result;
            };
            if (has("dojo-unit-tests")) {
                unitTests.push(function (doh) {
                    doh.register("tests.i18n.unit", function (t) {
                        var check;
                        check = evalBundle("{prop:1}", checkForLegacyModules, "nonsense", amdValue);
                        t.is({prop:1}, check);
                        t.is(undefined, check[1]);
                        check = evalBundle("({prop:1})", checkForLegacyModules, "nonsense", amdValue);
                        t.is({prop:1}, check);
                        t.is(undefined, check[1]);
                        check = evalBundle("{'prop-x':1}", checkForLegacyModules, "nonsense", amdValue);
                        t.is({"prop-x":1}, check);
                        t.is(undefined, check[1]);
                        check = evalBundle("({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
                        t.is({"prop-x":1}, check);
                        t.is(undefined, check[1]);
                        check = evalBundle("define({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
                        t.is(amdValue, check);
                        t.is({"prop-x":1}, amdValue.result);
                        check = evalBundle("define('some/module', {'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
                        t.is(amdValue, check);
                        t.is({"prop-x":1}, amdValue.result);
                        check = evalBundle("this is total nonsense and should throw an error", checkForLegacyModules, "nonsense", amdValue);
                        t.is(check instanceof Error, true);
                    });
                });
            }
        }
        return lang.mixin(thisModule, {dynamic:true, normalize:normalize, load:load, cache:cache, getL10nName:getL10nName});
    });
}, "dojo/data/util/simpleFetch":function () {
    define(["../../_base/lang", "../../_base/kernel", "./sorter"], function (lang, kernel, sorter) {
        var simpleFetch = {};
        lang.setObject("dojo.data.util.simpleFetch", simpleFetch);
        simpleFetch.errorHandler = function (errorData, requestObject) {
            if (requestObject.onError) {
                var scope = requestObject.scope || kernel.global;
                requestObject.onError.call(scope, errorData, requestObject);
            }
        };
        simpleFetch.fetchHandler = function (items, requestObject) {
            var oldAbortFunction = requestObject.abort || null, aborted = false, startIndex = requestObject.start ? requestObject.start : 0, endIndex = (requestObject.count && (requestObject.count !== Infinity)) ? (startIndex + requestObject.count) : items.length;
            requestObject.abort = function () {
                aborted = true;
                if (oldAbortFunction) {
                    oldAbortFunction.call(requestObject);
                }
            };
            var scope = requestObject.scope || kernel.global;
            if (!requestObject.store) {
                requestObject.store = this;
            }
            if (requestObject.onBegin) {
                requestObject.onBegin.call(scope, items.length, requestObject);
            }
            if (requestObject.sort) {
                items.sort(sorter.createSortFunction(requestObject.sort, this));
            }
            if (requestObject.onItem) {
                for (var i = startIndex; (i < items.length) && (i < endIndex); ++i) {
                    var item = items[i];
                    if (!aborted) {
                        requestObject.onItem.call(scope, item, requestObject);
                    }
                }
            }
            if (requestObject.onComplete && !aborted) {
                var subset = null;
                if (!requestObject.onItem) {
                    subset = items.slice(startIndex, endIndex);
                }
                requestObject.onComplete.call(scope, subset, requestObject);
            }
        };
        simpleFetch.fetch = function (request) {
            request = request || {};
            if (!request.store) {
                request.store = this;
            }
            this._fetchItems(request, lang.hitch(this, "fetchHandler"), lang.hitch(this, "errorHandler"));
            return request;
        };
        return simpleFetch;
    });
}, "dijit/_CssStateMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom", "dojo/dom-class", "dojo/has", "dojo/_base/lang", "dojo/on", "dojo/domReady", "dojo/touch", "dojo/_base/window", "./a11yclick", "./registry"], function (array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry) {
        var CssStateMixin = declare("dijit._CssStateMixin", [], {hovering:false, active:false, _applyAttributes:function () {
            this.inherited(arguments);
            array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function (attr) {
                this.watch(attr, lang.hitch(this, "_setStateClass"));
            }, this);
            for (var ap in this.cssStateNodes || {}) {
                this._trackMouseState(this[ap], this.cssStateNodes[ap]);
            }
            this._trackMouseState(this.domNode, this.baseClass);
            this._setStateClass();
        }, _cssMouseEvent:function (event) {
            if (!this.disabled) {
                switch (event.type) {
                  case "mouseover":
                  case "MSPointerOver":
                  case "pointerover":
                    this._set("hovering", true);
                    this._set("active", this._mouseDown);
                    break;
                  case "mouseout":
                  case "MSPointerOut":
                  case "pointerout":
                    this._set("hovering", false);
                    this._set("active", false);
                    break;
                  case "mousedown":
                  case "touchstart":
                  case "MSPointerDown":
                  case "pointerdown":
                  case "keydown":
                    this._set("active", true);
                    break;
                  case "mouseup":
                  case "dojotouchend":
                  case "MSPointerUp":
                  case "pointerup":
                  case "keyup":
                    this._set("active", false);
                    break;
                }
            }
        }, _setStateClass:function () {
            var newStateClasses = this.baseClass.split(" ");
            function multiply(modifier) {
                newStateClasses = newStateClasses.concat(array.map(newStateClasses, function (c) {
                    return c + modifier;
                }), "dijit" + modifier);
            }
            if (!this.isLeftToRight()) {
                multiply("Rtl");
            }
            var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
            if (this.checked) {
                multiply(checkedState);
            }
            if (this.state) {
                multiply(this.state);
            }
            if (this.selected) {
                multiply("Selected");
            }
            if (this._opened) {
                multiply("Opened");
            }
            if (this.disabled) {
                multiply("Disabled");
            } else {
                if (this.readOnly) {
                    multiply("ReadOnly");
                } else {
                    if (this.active) {
                        multiply("Active");
                    } else {
                        if (this.hovering) {
                            multiply("Hover");
                        }
                    }
                }
            }
            if (this.focused) {
                multiply("Focused");
            }
            var tn = this.stateNode || this.domNode, classHash = {};
            array.forEach(tn.className.split(" "), function (c) {
                classHash[c] = true;
            });
            if ("_stateClasses" in this) {
                array.forEach(this._stateClasses, function (c) {
                    delete classHash[c];
                });
            }
            array.forEach(newStateClasses, function (c) {
                classHash[c] = true;
            });
            var newClasses = [];
            for (var c in classHash) {
                newClasses.push(c);
            }
            tn.className = newClasses.join(" ");
            this._stateClasses = newStateClasses;
        }, _subnodeCssMouseEvent:function (node, clazz, evt) {
            if (this.disabled || this.readOnly) {
                return;
            }
            function hover(isHovering) {
                domClass.toggle(node, clazz + "Hover", isHovering);
            }
            function active(isActive) {
                domClass.toggle(node, clazz + "Active", isActive);
            }
            function focused(isFocused) {
                domClass.toggle(node, clazz + "Focused", isFocused);
            }
            switch (evt.type) {
              case "mouseover":
              case "MSPointerOver":
              case "pointerover":
                hover(true);
                break;
              case "mouseout":
              case "MSPointerOut":
              case "pointerout":
                hover(false);
                active(false);
                break;
              case "mousedown":
              case "touchstart":
              case "MSPointerDown":
              case "pointerdown":
              case "keydown":
                active(true);
                break;
              case "mouseup":
              case "MSPointerUp":
              case "pointerup":
              case "dojotouchend":
              case "keyup":
                active(false);
                break;
              case "focus":
              case "focusin":
                focused(true);
                break;
              case "blur":
              case "focusout":
                focused(false);
                break;
            }
        }, _trackMouseState:function (node, clazz) {
            node._cssState = clazz;
        }});
        domReady(function () {
            function pointerHandler(evt, target, relatedTarget) {
                if (relatedTarget && dom.isDescendant(relatedTarget, target)) {
                    return;
                }
                for (var node = target; node && node != relatedTarget; node = node.parentNode) {
                    if (node._cssState) {
                        var widget = registry.getEnclosingWidget(node);
                        if (widget) {
                            if (node == widget.domNode) {
                                widget._cssMouseEvent(evt);
                            } else {
                                widget._subnodeCssMouseEvent(node, node._cssState, evt);
                            }
                        }
                    }
                }
            }
            var body = win.body(), activeNode;
            on(body, touch.over, function (evt) {
                pointerHandler(evt, evt.target, evt.relatedTarget);
            });
            on(body, touch.out, function (evt) {
                pointerHandler(evt, evt.target, evt.relatedTarget);
            });
            on(body, a11yclick.press, function (evt) {
                activeNode = evt.target;
                pointerHandler(evt, activeNode);
            });
            on(body, a11yclick.release, function (evt) {
                pointerHandler(evt, activeNode);
                activeNode = null;
            });
            on(body, "focusin, focusout", function (evt) {
                var node = evt.target;
                if (node._cssState && !node.getAttribute("widgetId")) {
                    var widget = registry.getEnclosingWidget(node);
                    if (widget) {
                        widget._subnodeCssMouseEvent(node, node._cssState, evt);
                    }
                }
            });
        });
        return CssStateMixin;
    });
}, "dojo/dnd/Source":function () {
    define(["../_base/array", "../_base/declare", "../_base/kernel", "../_base/lang", "../dom-class", "../dom-geometry", "../mouse", "../ready", "../topic", "./common", "./Selector", "./Manager"], function (array, declare, kernel, lang, domClass, domGeom, mouse, ready, topic, dnd, Selector, Manager) {
        if (!kernel.isAsync) {
            ready(0, function () {
                var requires = ["dojo/dnd/AutoSource", "dojo/dnd/Target"];
                require(requires);
            });
        }
        var Source = declare("dojo.dnd.Source", Selector, {isSource:true, horizontal:false, copyOnly:false, selfCopy:false, selfAccept:true, skipForm:false, withHandles:false, autoSync:false, delay:0, accept:["text"], generateText:true, constructor:function (node, params) {
            lang.mixin(this, lang.mixin({}, params));
            var type = this.accept;
            if (type.length) {
                this.accept = {};
                for (var i = 0; i < type.length; ++i) {
                    this.accept[type[i]] = 1;
                }
            }
            this.isDragging = false;
            this.mouseDown = false;
            this.targetAnchor = null;
            this.targetBox = null;
            this.before = true;
            this._lastX = 0;
            this._lastY = 0;
            this.sourceState = "";
            if (this.isSource) {
                domClass.add(this.node, "dojoDndSource");
            }
            this.targetState = "";
            if (this.accept) {
                domClass.add(this.node, "dojoDndTarget");
            }
            if (this.horizontal) {
                domClass.add(this.node, "dojoDndHorizontal");
            }
            this.topics = [topic.subscribe("/dnd/source/over", lang.hitch(this, "onDndSourceOver")), topic.subscribe("/dnd/start", lang.hitch(this, "onDndStart")), topic.subscribe("/dnd/drop", lang.hitch(this, "onDndDrop")), topic.subscribe("/dnd/cancel", lang.hitch(this, "onDndCancel"))];
        }, checkAcceptance:function (source, nodes) {
            if (this == source) {
                return !this.copyOnly || this.selfAccept;
            }
            for (var i = 0; i < nodes.length; ++i) {
                var type = source.getItem(nodes[i].id).type;
                var flag = false;
                for (var j = 0; j < type.length; ++j) {
                    if (type[j] in this.accept) {
                        flag = true;
                        break;
                    }
                }
                if (!flag) {
                    return false;
                }
            }
            return true;
        }, copyState:function (keyPressed, self) {
            if (keyPressed) {
                return true;
            }
            if (arguments.length < 2) {
                self = this == Manager.manager().target;
            }
            if (self) {
                if (this.copyOnly) {
                    return this.selfCopy;
                }
            } else {
                return this.copyOnly;
            }
            return false;
        }, destroy:function () {
            Source.superclass.destroy.call(this);
            array.forEach(this.topics, function (t) {
                t.remove();
            });
            this.targetAnchor = null;
        }, onMouseMove:function (e) {
            if (this.isDragging && this.targetState == "Disabled") {
                return;
            }
            Source.superclass.onMouseMove.call(this, e);
            var m = Manager.manager();
            if (!this.isDragging) {
                if (this.mouseDown && this.isSource && (Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)) {
                    var nodes = this.getSelectedNodes();
                    if (nodes.length) {
                        m.startDrag(this, nodes, this.copyState(dnd.getCopyKeyState(e), true));
                    }
                }
            }
            if (this.isDragging) {
                var before = false;
                if (this.current) {
                    if (!this.targetBox || this.targetAnchor != this.current) {
                        this.targetBox = domGeom.position(this.current, true);
                    }
                    if (this.horizontal) {
                        before = (e.pageX - this.targetBox.x < this.targetBox.w / 2) == domGeom.isBodyLtr(this.current.ownerDocument);
                    } else {
                        before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
                    }
                }
                if (this.current != this.targetAnchor || before != this.before) {
                    this._markTargetAnchor(before);
                    m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
                }
            }
        }, onMouseDown:function (e) {
            if (!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dnd.isFormElement(e))) {
                this.mouseDown = true;
                this._lastX = e.pageX;
                this._lastY = e.pageY;
                Source.superclass.onMouseDown.call(this, e);
            }
        }, onMouseUp:function (e) {
            if (this.mouseDown) {
                this.mouseDown = false;
                Source.superclass.onMouseUp.call(this, e);
            }
        }, onDndSourceOver:function (source) {
            if (this !== source) {
                this.mouseDown = false;
                if (this.targetAnchor) {
                    this._unmarkTargetAnchor();
                }
            } else {
                if (this.isDragging) {
                    var m = Manager.manager();
                    m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
                }
            }
        }, onDndStart:function (source, nodes, copy) {
            if (this.autoSync) {
                this.sync();
            }
            if (this.isSource) {
                this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
            }
            var accepted = this.accept && this.checkAcceptance(source, nodes);
            this._changeState("Target", accepted ? "" : "Disabled");
            if (this == source) {
                Manager.manager().overSource(this);
            }
            this.isDragging = true;
        }, onDndDrop:function (source, nodes, copy, target) {
            if (this == target) {
                this.onDrop(source, nodes, copy);
            }
            this.onDndCancel();
        }, onDndCancel:function () {
            if (this.targetAnchor) {
                this._unmarkTargetAnchor();
                this.targetAnchor = null;
            }
            this.before = true;
            this.isDragging = false;
            this.mouseDown = false;
            this._changeState("Source", "");
            this._changeState("Target", "");
        }, onDrop:function (source, nodes, copy) {
            if (this != source) {
                this.onDropExternal(source, nodes, copy);
            } else {
                this.onDropInternal(nodes, copy);
            }
        }, onDropExternal:function (source, nodes, copy) {
            var oldCreator = this._normalizedCreator;
            if (this.creator) {
                this._normalizedCreator = function (node, hint) {
                    return oldCreator.call(this, source.getItem(node.id).data, hint);
                };
            } else {
                if (copy) {
                    this._normalizedCreator = function (node) {
                        var t = source.getItem(node.id);
                        var n = node.cloneNode(true);
                        n.id = dnd.getUniqueId();
                        return {node:n, data:t.data, type:t.type};
                    };
                } else {
                    this._normalizedCreator = function (node) {
                        var t = source.getItem(node.id);
                        source.delItem(node.id);
                        return {node:node, data:t.data, type:t.type};
                    };
                }
            }
            this.selectNone();
            if (!copy && !this.creator) {
                source.selectNone();
            }
            this.insertNodes(true, nodes, this.before, this.current);
            if (!copy && this.creator) {
                source.deleteSelectedNodes();
            }
            this._normalizedCreator = oldCreator;
        }, onDropInternal:function (nodes, copy) {
            var oldCreator = this._normalizedCreator;
            if (this.current && this.current.id in this.selection) {
                return;
            }
            if (copy) {
                if (this.creator) {
                    this._normalizedCreator = function (node, hint) {
                        return oldCreator.call(this, this.getItem(node.id).data, hint);
                    };
                } else {
                    this._normalizedCreator = function (node) {
                        var t = this.getItem(node.id);
                        var n = node.cloneNode(true);
                        n.id = dnd.getUniqueId();
                        return {node:n, data:t.data, type:t.type};
                    };
                }
            } else {
                if (!this.current) {
                    return;
                }
                this._normalizedCreator = function (node) {
                    var t = this.getItem(node.id);
                    return {node:node, data:t.data, type:t.type};
                };
            }
            this._removeSelection();
            this.insertNodes(true, nodes, this.before, this.current);
            this._normalizedCreator = oldCreator;
        }, onDraggingOver:function () {
        }, onDraggingOut:function () {
        }, onOverEvent:function () {
            Source.superclass.onOverEvent.call(this);
            Manager.manager().overSource(this);
            if (this.isDragging && this.targetState != "Disabled") {
                this.onDraggingOver();
            }
        }, onOutEvent:function () {
            Source.superclass.onOutEvent.call(this);
            Manager.manager().outSource(this);
            if (this.isDragging && this.targetState != "Disabled") {
                this.onDraggingOut();
            }
        }, _markTargetAnchor:function (before) {
            if (this.current == this.targetAnchor && this.before == before) {
                return;
            }
            if (this.targetAnchor) {
                this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
            }
            this.targetAnchor = this.current;
            this.targetBox = null;
            this.before = before;
            if (this.targetAnchor) {
                this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
            }
        }, _unmarkTargetAnchor:function () {
            if (!this.targetAnchor) {
                return;
            }
            this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
            this.targetAnchor = null;
            this.targetBox = null;
            this.before = true;
        }, _markDndStatus:function (copy) {
            this._changeState("Source", copy ? "Copied" : "Moved");
        }, _legalMouseDown:function (e) {
            if (e.type != "touchstart" && !mouse.isLeft(e)) {
                return false;
            }
            if (!this.withHandles) {
                return true;
            }
            for (var node = e.target; node && node !== this.node; node = node.parentNode) {
                if (domClass.contains(node, "dojoDndHandle")) {
                    return true;
                }
                if (domClass.contains(node, "dojoDndItem") || domClass.contains(node, "dojoDndIgnore")) {
                    break;
                }
            }
            return false;
        }});
        return Source;
    });
}, "dojo/errors/RequestTimeoutError":function () {
    define(["./create", "./RequestError"], function (create, RequestError) {
        return create("RequestTimeoutError", null, RequestError, {dojoType:"timeout"});
    });
}, "dojox/grid/cells/dijit":function () {
    define(["dojo/_base/kernel", "../../main", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/json", "dojo/_base/connect", "dojo/_base/sniff", "dojo/dom", "dojo/dom-attr", "dojo/dom-construct", "dojo/dom-style", "dojo/dom-geometry", "dojo/data/ItemFileReadStore", "dijit/form/DateTextBox", "dijit/form/TimeTextBox", "dijit/form/ComboBox", "dijit/form/CheckBox", "dijit/form/TextBox", "dijit/form/NumberSpinner", "dijit/form/NumberTextBox", "dijit/form/CurrencyTextBox", "dijit/form/HorizontalSlider", "dijit/form/_TextBoxMixin", "dijit/Editor", "../util", "./_base"], function (dojo, dojox, declare, array, lang, json, connect, has, dom, domAttr, domConstruct, domStyle, domGeometry, ItemFileReadStore, DateTextBox, TimeTextBox, ComboBox, CheckBox, TextBox, NumberSpinner, NumberTextBox, CurrencyTextBox, HorizontalSlider, _TextBoxMixin, Editor, util, BaseCell) {
        var exports = {};
        var _Widget = exports._Widget = declare("dojox.grid.cells._Widget", BaseCell, {widgetClass:TextBox, constructor:function (inCell) {
            this.widget = null;
            if (typeof this.widgetClass == "string") {
                dojo.deprecated("Passing a string to widgetClass is deprecated", "pass the widget class object instead", "2.0");
                this.widgetClass = lang.getObject(this.widgetClass);
            }
        }, formatEditing:function (inDatum, inRowIndex) {
            this.needFormatNode(inDatum, inRowIndex);
            return "<div></div>";
        }, getValue:function (inRowIndex) {
            return this.widget.get("value");
        }, _unescapeHTML:function (value) {
            return (value && value.replace && this.grid.escapeHTMLInData) ? value.replace(/&lt;/g, "<").replace(/&amp;/g, "&") : value;
        }, setValue:function (inRowIndex, inValue) {
            if (this.widget && this.widget.set) {
                inValue = this._unescapeHTML(inValue);
                if (this.widget.onLoadDeferred) {
                    var self = this;
                    this.widget.onLoadDeferred.addCallback(function () {
                        self.widget.set("value", inValue === null ? "" : inValue);
                    });
                } else {
                    this.widget.set("value", inValue);
                }
            } else {
                this.inherited(arguments);
            }
        }, getWidgetProps:function (inDatum) {
            return lang.mixin({dir:this.dir, lang:this.lang}, this.widgetProps || {}, {constraints:lang.mixin({}, this.constraint) || {}, required:(this.constraint || {}).required, value:this._unescapeHTML(inDatum)});
        }, createWidget:function (inNode, inDatum, inRowIndex) {
            return new this.widgetClass(this.getWidgetProps(inDatum), inNode);
        }, attachWidget:function (inNode, inDatum, inRowIndex) {
            inNode.appendChild(this.widget.domNode);
            this.setValue(inRowIndex, inDatum);
        }, formatNode:function (inNode, inDatum, inRowIndex) {
            if (!this.widgetClass) {
                return inDatum;
            }
            if (!this.widget) {
                this.widget = this.createWidget.apply(this, arguments);
            } else {
                this.attachWidget.apply(this, arguments);
            }
            this.sizeWidget.apply(this, arguments);
            this.grid.views.renormalizeRow(inRowIndex);
            this.grid.scroller.rowHeightChanged(inRowIndex, true);
            this.focus();
            return undefined;
        }, sizeWidget:function (inNode, inDatum, inRowIndex) {
            var p = this.getNode(inRowIndex);
            dojo.marginBox(this.widget.domNode, {w:domStyle.get(p, "width")});
        }, focus:function (inRowIndex, inNode) {
            if (this.widget) {
                setTimeout(lang.hitch(this.widget, function () {
                    util.fire(this, "focus");
                    if (this.focusNode && this.focusNode.tagName === "INPUT") {
                        _TextBoxMixin.selectInputText(this.focusNode);
                    }
                }), 0);
            }
        }, _finish:function (inRowIndex) {
            this.inherited(arguments);
            util.removeNode(this.widget.domNode);
            if (has("ie")) {
                dom.setSelectable(this.widget.domNode, true);
            }
        }});
        _Widget.markupFactory = function (node, cell) {
            BaseCell.markupFactory(node, cell);
            var widgetProps = lang.trim(domAttr.get(node, "widgetProps") || "");
            var constraint = lang.trim(domAttr.get(node, "constraint") || "");
            var widgetClass = lang.trim(domAttr.get(node, "widgetClass") || "");
            if (widgetProps) {
                cell.widgetProps = json.fromJson(widgetProps);
            }
            if (constraint) {
                cell.constraint = json.fromJson(constraint);
            }
            if (widgetClass) {
                cell.widgetClass = lang.getObject(widgetClass);
            }
        };
        var ComboBox = exports.ComboBox = declare("dojox.grid.cells.ComboBox", _Widget, {widgetClass:ComboBox, getWidgetProps:function (inDatum) {
            var items = [];
            array.forEach(this.options, function (o) {
                items.push({name:o, value:o});
            });
            var store = new ItemFileReadStore({data:{identifier:"name", items:items}});
            return lang.mixin({}, this.widgetProps || {}, {value:inDatum, store:store});
        }, getValue:function () {
            var e = this.widget;
            e.set("displayedValue", e.get("displayedValue"));
            return e.get("value");
        }});
        ComboBox.markupFactory = function (node, cell) {
            _Widget.markupFactory(node, cell);
            var options = lang.trim(domAttr.get(node, "options") || "");
            if (options) {
                var o = options.split(",");
                if (o[0] != options) {
                    cell.options = o;
                }
            }
        };
        var DateTextBox = exports.DateTextBox = declare("dojox.grid.cells.DateTextBox", _Widget, {widgetClass:DateTextBox, setValue:function (inRowIndex, inValue) {
            if (this.widget) {
                this.widget.set("value", new Date(inValue));
            } else {
                this.inherited(arguments);
            }
        }, getWidgetProps:function (inDatum) {
            return lang.mixin(this.inherited(arguments), {value:new Date(inDatum)});
        }});
        DateTextBox.markupFactory = function (node, cell) {
            _Widget.markupFactory(node, cell);
        };
        var CheckBox = exports.CheckBox = declare("dojox.grid.cells.CheckBox", _Widget, {widgetClass:CheckBox, getValue:function () {
            return this.widget.checked;
        }, setValue:function (inRowIndex, inValue) {
            if (this.widget && this.widget.attributeMap.checked) {
                this.widget.set("checked", inValue);
            } else {
                this.inherited(arguments);
            }
        }, sizeWidget:function (inNode, inDatum, inRowIndex) {
            return;
        }});
        CheckBox.markupFactory = function (node, cell) {
            _Widget.markupFactory(node, cell);
        };
        var Editor = exports.Editor = declare("dojox.grid.cells.Editor", _Widget, {widgetClass:Editor, getWidgetProps:function (inDatum) {
            return lang.mixin({}, this.widgetProps || {}, {height:this.widgetHeight || "100px"});
        }, createWidget:function (inNode, inDatum, inRowIndex) {
            var widget = new this.widgetClass(this.getWidgetProps(inDatum), inNode);
            widget.onLoadDeferred.then(lang.hitch(this, "populateEditor"));
            return widget;
        }, formatNode:function (inNode, inDatum, inRowIndex) {
            this.content = inDatum;
            this.inherited(arguments);
            if (has("mozilla")) {
                var e = this.widget;
                e.open();
                if (this.widgetToolbar) {
                    domConstruct.place(e.toolbar.domNode, e.editingArea, "before");
                }
            }
        }, populateEditor:function () {
            this.widget.set("value", this.content);
            this.widget.placeCursorAtEnd();
        }});
        Editor.markupFactory = function (node, cell) {
            _Widget.markupFactory(node, cell);
            var h = lang.trim(domAttr.get(node, "widgetHeight") || "");
            if (h) {
                if ((h != "auto") && (h.substr(-2) != "em")) {
                    h = parseInt(h, 10) + "px";
                }
                cell.widgetHeight = h;
            }
        };
        return exports;
    });
}, "dojox/grid/enhanced/plugins/_StoreLayer":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/xhr"], function (declare, array, lang, xhr) {
        var ns = lang.getObject("grid.enhanced.plugins", true, dojox);
        var getPrevTags = function (tags) {
            var tagList = ["reorder", "sizeChange", "normal", "presentation"];
            var idx = tagList.length;
            for (var i = tags.length - 1; i >= 0; --i) {
                var p = array.indexOf(tagList, tags[i]);
                if (p >= 0 && p <= idx) {
                    idx = p;
                }
            }
            if (idx < tagList.length - 1) {
                return tagList.slice(0, idx + 1);
            } else {
                return tagList;
            }
        }, unwrap = function (layerName) {
            var i, layers = this._layers, len = layers.length;
            if (layerName) {
                for (i = len - 1; i >= 0; --i) {
                    if (layers[i].name() == layerName) {
                        layers[i]._unwrap(layers[i + 1]);
                        break;
                    }
                }
                layers.splice(i, 1);
            } else {
                for (i = len - 1; i >= 0; --i) {
                    layers[i]._unwrap();
                }
            }
            if (!layers.length) {
                delete this._layers;
                delete this.layer;
                delete this.unwrap;
                delete this.forEachLayer;
            }
            return this;
        }, getLayer = function (layerName) {
            var i, layers = this._layers;
            if (typeof layerName == "undefined") {
                return layers.length;
            }
            if (typeof layerName == "number") {
                return layers[layerName];
            }
            for (i = layers.length - 1; i >= 0; --i) {
                if (layers[i].name() == layerName) {
                    return layers[i];
                }
            }
            return null;
        }, forEachLayer = function (callback, isInnerToOuter) {
            var len = this._layers.length, start, end, dir;
            if (isInnerToOuter) {
                start = 0;
                end = len;
                dir = 1;
            } else {
                start = len - 1;
                end = -1;
                dir = -1;
            }
            for (var i = start; i != end; i += dir) {
                if (callback(this._layers[i], i) === false) {
                    return i;
                }
            }
            return end;
        };
        ns.wrap = function (store, funcName, layer, layerFuncName) {
            if (!store._layers) {
                store._layers = [];
                store.layer = lang.hitch(store, getLayer);
                store.unwrap = lang.hitch(store, unwrap);
                store.forEachLayer = lang.hitch(store, forEachLayer);
            }
            var prevTags = getPrevTags(layer.tags);
            if (!array.some(store._layers, function (lyr, i) {
                if (array.some(lyr.tags, function (tag) {
                    return array.indexOf(prevTags, tag) >= 0;
                })) {
                    return false;
                } else {
                    store._layers.splice(i, 0, layer);
                    layer._wrap(store, funcName, layerFuncName, lyr);
                    return true;
                }
            })) {
                store._layers.push(layer);
                layer._wrap(store, funcName, layerFuncName);
            }
            return store;
        };
        var _StoreLayer = declare("dojox.grid.enhanced.plugins._StoreLayer", null, {tags:["normal"], layerFuncName:"_fetch", constructor:function () {
            this._store = null;
            this._originFetch = null;
            this.__enabled = true;
        }, initialize:function (store) {
        }, uninitialize:function (store) {
        }, invalidate:function () {
        }, _wrap:function (store, funcName, layerFuncName, nextLayer) {
            this._store = store;
            this._funcName = funcName;
            var fetchFunc = lang.hitch(this, function () {
                return (this.enabled() ? this[layerFuncName || this.layerFuncName] : this.originFetch).apply(this, arguments);
            });
            if (nextLayer) {
                this._originFetch = nextLayer._originFetch;
                nextLayer._originFetch = fetchFunc;
            } else {
                this._originFetch = store[funcName] || function () {
                };
                store[funcName] = fetchFunc;
            }
            this.initialize(store);
        }, _unwrap:function (nextLayer) {
            this.uninitialize(this._store);
            if (nextLayer) {
                nextLayer._originFetch = this._originFetch;
            } else {
                this._store[this._funcName] = this._originFetch;
            }
            this._originFetch = null;
            this._store = null;
        }, enabled:function (toEnable) {
            if (typeof toEnable != "undefined") {
                this.__enabled = !!toEnable;
            }
            return this.__enabled;
        }, name:function () {
            if (!this.__name) {
                var m = this.declaredClass.match(/(?:\.(?:_*)([^\.]+)Layer$)|(?:\.([^\.]+)$)/i);
                this.__name = m ? (m[1] || m[2]).toLowerCase() : this.declaredClass;
            }
            return this.__name;
        }, originFetch:function () {
            return (lang.hitch(this._store, this._originFetch)).apply(this, arguments);
        }});
        var _ServerSideLayer = declare("dojox.grid.enhanced.plugins._ServerSideLayer", _StoreLayer, {constructor:function (args) {
            args = args || {};
            this._url = args.url || "";
            this._isStateful = !!args.isStateful;
            this._onUserCommandLoad = args.onCommandLoad || function () {
            };
            this.__cmds = {cmdlayer:this.name(), enable:true};
            this.useCommands(this._isStateful);
        }, enabled:function (toEnable) {
            var res = this.inherited(arguments);
            this.__cmds.enable = this.__enabled;
            return res;
        }, useCommands:function (toUse) {
            if (typeof toUse != "undefined") {
                this.__cmds.cmdlayer = (toUse && this._isStateful) ? this.name() : null;
            }
            return !!(this.__cmds.cmdlayer);
        }, _fetch:function (userRequest) {
            if (this.__cmds.cmdlayer) {
                xhr.post({url:this._url || this._store.url, content:this.__cmds, load:lang.hitch(this, function (responce) {
                    this.onCommandLoad(responce, userRequest);
                    this.originFetch(userRequest);
                }), error:lang.hitch(this, this.onCommandError)});
            } else {
                this.onCommandLoad("", userRequest);
                this.originFetch(userRequest);
            }
            return userRequest;
        }, command:function (cmdName, cmdContent) {
            var cmds = this.__cmds;
            if (cmdContent === null) {
                delete cmds[cmdName];
            } else {
                if (typeof cmdContent !== "undefined") {
                    cmds[cmdName] = cmdContent;
                }
            }
            return cmds[cmdName];
        }, onCommandLoad:function (response, userRequest) {
            this._onUserCommandLoad(this.__cmds, userRequest, response);
        }, onCommandError:function (error) {
            console.log(error);
            throw error;
        }});
        return {_StoreLayer:_StoreLayer, _ServerSideLayer:_ServerSideLayer, wrap:ns.wrap};
    });
}, "dojo/NodeList-dom":function () {
    define(["./_base/kernel", "./query", "./_base/array", "./_base/lang", "./dom-class", "./dom-construct", "./dom-geometry", "./dom-attr", "./dom-style"], function (dojo, query, array, lang, domCls, domCtr, domGeom, domAttr, domStyle) {
        var magicGuard = function (a) {
            return a.length == 1 && (typeof a[0] == "string");
        };
        var orphan = function (node) {
            var p = node.parentNode;
            if (p) {
                p.removeChild(node);
            }
        };
        var NodeList = query.NodeList, awc = NodeList._adaptWithCondition, aafe = NodeList._adaptAsForEach, aam = NodeList._adaptAsMap;
        function getSet(module) {
            return function (node, name, value) {
                if (arguments.length == 2) {
                    return module[typeof name == "string" ? "get" : "set"](node, name);
                }
                return module.set(node, name, value);
            };
        }
        lang.extend(NodeList, {_normalize:function (content, refNode) {
            var parse = content.parse === true;
            if (typeof content.template == "string") {
                var templateFunc = content.templateFunc || (dojo.string && dojo.string.substitute);
                content = templateFunc ? templateFunc(content.template, content) : content;
            }
            var type = (typeof content);
            if (type == "string" || type == "number") {
                content = domCtr.toDom(content, (refNode && refNode.ownerDocument));
                if (content.nodeType == 11) {
                    content = lang._toArray(content.childNodes);
                } else {
                    content = [content];
                }
            } else {
                if (!lang.isArrayLike(content)) {
                    content = [content];
                } else {
                    if (!lang.isArray(content)) {
                        content = lang._toArray(content);
                    }
                }
            }
            if (parse) {
                content._runParse = true;
            }
            return content;
        }, _cloneNode:function (node) {
            return node.cloneNode(true);
        }, _place:function (ary, refNode, position, useClone) {
            if (refNode.nodeType != 1 && position == "only") {
                return;
            }
            var rNode = refNode, tempNode;
            var length = ary.length;
            for (var i = length - 1; i >= 0; i--) {
                var node = (useClone ? this._cloneNode(ary[i]) : ary[i]);
                if (ary._runParse && dojo.parser && dojo.parser.parse) {
                    if (!tempNode) {
                        tempNode = rNode.ownerDocument.createElement("div");
                    }
                    tempNode.appendChild(node);
                    dojo.parser.parse(tempNode);
                    node = tempNode.firstChild;
                    while (tempNode.firstChild) {
                        tempNode.removeChild(tempNode.firstChild);
                    }
                }
                if (i == length - 1) {
                    domCtr.place(node, rNode, position);
                } else {
                    rNode.parentNode.insertBefore(node, rNode);
                }
                rNode = node;
            }
        }, position:aam(domGeom.position), attr:awc(getSet(domAttr), magicGuard), style:awc(getSet(domStyle), magicGuard), addClass:aafe(domCls.add), removeClass:aafe(domCls.remove), toggleClass:aafe(domCls.toggle), replaceClass:aafe(domCls.replace), empty:aafe(domCtr.empty), removeAttr:aafe(domAttr.remove), marginBox:aam(domGeom.getMarginBox), place:function (queryOrNode, position) {
            var item = query(queryOrNode)[0];
            return this.forEach(function (node) {
                domCtr.place(node, item, position);
            });
        }, orphan:function (filter) {
            return (filter ? query._filterResult(this, filter) : this).forEach(orphan);
        }, adopt:function (queryOrListOrNode, position) {
            return query(queryOrListOrNode).place(this[0], position)._stash(this);
        }, query:function (queryStr) {
            if (!queryStr) {
                return this;
            }
            var ret = new NodeList;
            this.map(function (node) {
                query(queryStr, node).forEach(function (subNode) {
                    if (subNode !== undefined) {
                        ret.push(subNode);
                    }
                });
            });
            return ret._stash(this);
        }, filter:function (filter) {
            var a = arguments, items = this, start = 0;
            if (typeof filter == "string") {
                items = query._filterResult(this, a[0]);
                if (a.length == 1) {
                    return items._stash(this);
                }
                start = 1;
            }
            return this._wrap(array.filter(items, a[start], a[start + 1]), this);
        }, addContent:function (content, position) {
            content = this._normalize(content, this[0]);
            for (var i = 0, node; (node = this[i]); i++) {
                if (content.length) {
                    this._place(content, node, position, i > 0);
                } else {
                    domCtr.empty(node);
                }
            }
            return this;
        }});
        return NodeList;
    });
}, "dijit/form/FilteringSelect":function () {
    define(["dojo/_base/declare", "dojo/_base/lang", "dojo/when", "./MappedTextBox", "./ComboBoxMixin"], function (declare, lang, when, MappedTextBox, ComboBoxMixin) {
        return declare("dijit.form.FilteringSelect", [MappedTextBox, ComboBoxMixin], {required:true, _lastDisplayedValue:"", _isValidSubset:function () {
            return this._opened;
        }, isValid:function () {
            return !!this.item || (!this.required && this.get("displayedValue") == "");
        }, _refreshState:function () {
            if (!this.searchTimer) {
                this.inherited(arguments);
            }
        }, _callbackSetLabel:function (result, query, options, priorityChange) {
            if ((query && query[this.searchAttr] !== this._lastQuery) || (!query && result.length && this.store.getIdentity(result[0]) != this._lastQuery)) {
                return;
            }
            if (!result.length) {
                this.set("value", "", priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
            } else {
                this.set("item", result[0], priorityChange);
            }
        }, _openResultList:function (results, query, options) {
            if (query[this.searchAttr] !== this._lastQuery) {
                return;
            }
            this.inherited(arguments);
            if (this.item === undefined) {
                this.validate(true);
            }
        }, _getValueAttr:function () {
            return this.valueNode.value;
        }, _getValueField:function () {
            return "value";
        }, _setValueAttr:function (value, priorityChange, displayedValue, item) {
            if (!this._onChangeActive) {
                priorityChange = null;
            }
            if (item === undefined) {
                if (value === null || value === "") {
                    value = "";
                    if (!lang.isString(displayedValue)) {
                        this._setDisplayedValueAttr(displayedValue || "", priorityChange);
                        return;
                    }
                }
                var self = this;
                this._lastQuery = value;
                when(this.store.get(value), function (item) {
                    self._callbackSetLabel(item ? [item] : [], undefined, undefined, priorityChange);
                });
            } else {
                this.valueNode.value = value;
                this.inherited(arguments);
            }
        }, _setItemAttr:function (item, priorityChange, displayedValue) {
            this.inherited(arguments);
            this._lastDisplayedValue = this.textbox.value;
        }, _getDisplayQueryString:function (text) {
            return text.replace(/([\\\*\?])/g, "\\$1");
        }, _setDisplayedValueAttr:function (label, priorityChange) {
            if (label == null) {
                label = "";
            }
            if (!this._created) {
                if (!("displayedValue" in this.params)) {
                    return;
                }
                priorityChange = false;
            }
            if (this.store) {
                this.closeDropDown();
                var query = lang.clone(this.query);
                var qs = this._getDisplayQueryString(label), q;
                if (this.store._oldAPI) {
                    q = qs;
                } else {
                    q = this._patternToRegExp(qs);
                    q.toString = function () {
                        return qs;
                    };
                }
                this._lastQuery = query[this.searchAttr] = q;
                this.textbox.value = label;
                this._lastDisplayedValue = label;
                this._set("displayedValue", label);
                var _this = this;
                var options = {queryOptions:{ignoreCase:this.ignoreCase, deep:true}};
                lang.mixin(options, this.fetchProperties);
                this._fetchHandle = this.store.query(query, options);
                when(this._fetchHandle, function (result) {
                    _this._fetchHandle = null;
                    _this._callbackSetLabel(result || [], query, options, priorityChange);
                }, function (err) {
                    _this._fetchHandle = null;
                    if (!_this._cancelingQuery) {
                        console.error("dijit.form.FilteringSelect: " + err.toString());
                    }
                });
            }
        }, undo:function () {
            this.set("displayedValue", this._lastDisplayedValue);
        }});
    });
}, "dijit/_WidgetBase":function () {
    define(["require", "dojo/_base/array", "dojo/aspect", "dojo/_base/config", "dojo/_base/connect", "dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-construct", "dojo/dom-geometry", "dojo/dom-style", "dojo/has", "dojo/_base/kernel", "dojo/_base/lang", "dojo/on", "dojo/ready", "dojo/Stateful", "dojo/topic", "dojo/_base/window", "./Destroyable", "dojo/has!dojo-bidi?./_BidiMixin", "./registry"], function (require, array, aspect, config, connect, declare, dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel, lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry) {
        has.add("dijit-legacy-requires", !kernel.isAsync);
        has.add("dojo-bidi", false);
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/_base/manager"];
                require(requires);
            });
        }
        var tagAttrs = {};
        function getAttrs(obj) {
            var ret = {};
            for (var attr in obj) {
                ret[attr.toLowerCase()] = true;
            }
            return ret;
        }
        function nonEmptyAttrToDom(attr) {
            return function (val) {
                domAttr[val ? "set" : "remove"](this.domNode, attr, val);
                this._set(attr, val);
            };
        }
        function isEqual(a, b) {
            return a === b || (a !== a && b !== b);
        }
        var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {id:"", _setIdAttr:"domNode", lang:"", _setLangAttr:nonEmptyAttrToDom("lang"), dir:"", _setDirAttr:nonEmptyAttrToDom("dir"), "class":"", _setClassAttr:{node:"domNode", type:"class"}, style:"", title:"", tooltip:"", baseClass:"", srcNodeRef:null, domNode:null, containerNode:null, ownerDocument:null, _setOwnerDocumentAttr:function (val) {
            this._set("ownerDocument", val);
        }, attributeMap:{}, _blankGif:config.blankGif || require.toUrl("dojo/resources/blank.gif"), _introspect:function () {
            var ctor = this.constructor;
            if (!ctor._setterAttrs) {
                var proto = ctor.prototype, attrs = ctor._setterAttrs = [], onMap = (ctor._onMap = {});
                for (var name in proto.attributeMap) {
                    attrs.push(name);
                }
                for (name in proto) {
                    if (/^on/.test(name)) {
                        onMap[name.substring(2).toLowerCase()] = name;
                    }
                    if (/^_set[A-Z](.*)Attr$/.test(name)) {
                        name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
                        if (!proto.attributeMap || !(name in proto.attributeMap)) {
                            attrs.push(name);
                        }
                    }
                }
            }
        }, postscript:function (params, srcNodeRef) {
            this.create(params, srcNodeRef);
        }, create:function (params, srcNodeRef) {
            this._introspect();
            this.srcNodeRef = dom.byId(srcNodeRef);
            this._connects = [];
            this._supportingWidgets = [];
            if (this.srcNodeRef && (typeof this.srcNodeRef.id == "string")) {
                this.id = this.srcNodeRef.id;
            }
            if (params) {
                this.params = params;
                lang.mixin(this, params);
            }
            this.postMixInProperties();
            if (!this.id) {
                this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
                if (this.params) {
                    delete this.params.id;
                }
            }
            this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
            this.ownerDocumentBody = win.body(this.ownerDocument);
            registry.add(this);
            this.buildRendering();
            var deleteSrcNodeRef;
            if (this.domNode) {
                this._applyAttributes();
                var source = this.srcNodeRef;
                if (source && source.parentNode && this.domNode !== source) {
                    source.parentNode.replaceChild(this.domNode, source);
                    deleteSrcNodeRef = true;
                }
                this.domNode.setAttribute("widgetId", this.id);
            }
            this.postCreate();
            if (deleteSrcNodeRef) {
                delete this.srcNodeRef;
            }
            this._created = true;
        }, _applyAttributes:function () {
            var params = {};
            for (var key in this.params || {}) {
                params[key] = this._get(key);
            }
            array.forEach(this.constructor._setterAttrs, function (key) {
                if (!(key in params)) {
                    var val = this._get(key);
                    if (val) {
                        this.set(key, val);
                    }
                }
            }, this);
            for (key in params) {
                this.set(key, params[key]);
            }
        }, postMixInProperties:function () {
        }, buildRendering:function () {
            if (!this.domNode) {
                this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
            }
            if (this.baseClass) {
                var classes = this.baseClass.split(" ");
                if (!this.isLeftToRight()) {
                    classes = classes.concat(array.map(classes, function (name) {
                        return name + "Rtl";
                    }));
                }
                domClass.add(this.domNode, classes);
            }
        }, postCreate:function () {
        }, startup:function () {
            if (this._started) {
                return;
            }
            this._started = true;
            array.forEach(this.getChildren(), function (obj) {
                if (!obj._started && !obj._destroyed && lang.isFunction(obj.startup)) {
                    obj.startup();
                    obj._started = true;
                }
            });
        }, destroyRecursive:function (preserveDom) {
            this._beingDestroyed = true;
            this.destroyDescendants(preserveDom);
            this.destroy(preserveDom);
        }, destroy:function (preserveDom) {
            this._beingDestroyed = true;
            this.uninitialize();
            function destroy(w) {
                if (w.destroyRecursive) {
                    w.destroyRecursive(preserveDom);
                } else {
                    if (w.destroy) {
                        w.destroy(preserveDom);
                    }
                }
            }
            array.forEach(this._connects, lang.hitch(this, "disconnect"));
            array.forEach(this._supportingWidgets, destroy);
            if (this.domNode) {
                array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
            }
            this.destroyRendering(preserveDom);
            registry.remove(this.id);
            this._destroyed = true;
        }, destroyRendering:function (preserveDom) {
            if (this.bgIframe) {
                this.bgIframe.destroy(preserveDom);
                delete this.bgIframe;
            }
            if (this.domNode) {
                if (preserveDom) {
                    domAttr.remove(this.domNode, "widgetId");
                } else {
                    domConstruct.destroy(this.domNode);
                }
                delete this.domNode;
            }
            if (this.srcNodeRef) {
                if (!preserveDom) {
                    domConstruct.destroy(this.srcNodeRef);
                }
                delete this.srcNodeRef;
            }
        }, destroyDescendants:function (preserveDom) {
            array.forEach(this.getChildren(), function (widget) {
                if (widget.destroyRecursive) {
                    widget.destroyRecursive(preserveDom);
                }
            });
        }, uninitialize:function () {
            return false;
        }, _setStyleAttr:function (value) {
            var mapNode = this.domNode;
            if (lang.isObject(value)) {
                domStyle.set(mapNode, value);
            } else {
                if (mapNode.style.cssText) {
                    mapNode.style.cssText += "; " + value;
                } else {
                    mapNode.style.cssText = value;
                }
            }
            this._set("style", value);
        }, _attrToDom:function (attr, value, commands) {
            commands = arguments.length >= 3 ? commands : this.attributeMap[attr];
            array.forEach(lang.isArray(commands) ? commands : [commands], function (command) {
                var mapNode = this[command.node || command || "domNode"];
                var type = command.type || "attribute";
                switch (type) {
                  case "attribute":
                    if (lang.isFunction(value)) {
                        value = lang.hitch(this, value);
                    }
                    var attrName = command.attribute ? command.attribute : (/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);
                    if (mapNode.tagName) {
                        domAttr.set(mapNode, attrName, value);
                    } else {
                        mapNode.set(attrName, value);
                    }
                    break;
                  case "innerText":
                    mapNode.innerHTML = "";
                    mapNode.appendChild(this.ownerDocument.createTextNode(value));
                    break;
                  case "innerHTML":
                    mapNode.innerHTML = value;
                    break;
                  case "class":
                    domClass.replace(mapNode, value, this[attr]);
                    break;
                }
            }, this);
        }, get:function (name) {
            var names = this._getAttrNames(name);
            return this[names.g] ? this[names.g]() : this._get(name);
        }, set:function (name, value) {
            if (typeof name === "object") {
                for (var x in name) {
                    this.set(x, name[x]);
                }
                return this;
            }
            var names = this._getAttrNames(name), setter = this[names.s];
            if (lang.isFunction(setter)) {
                var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
            } else {
                var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode", tag = this[defaultNode] && this[defaultNode].tagName, attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))), map = name in this.attributeMap ? this.attributeMap[name] : names.s in this ? this[names.s] : ((attrsForTag && names.l in attrsForTag && typeof value != "function") || /^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
                if (map != null) {
                    this._attrToDom(name, value, map);
                }
                this._set(name, value);
            }
            return result || this;
        }, _attrPairNames:{}, _getAttrNames:function (name) {
            var apn = this._attrPairNames;
            if (apn[name]) {
                return apn[name];
            }
            var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function (c) {
                return c.charAt(c.length - 1).toUpperCase();
            });
            return (apn[name] = {n:name + "Node", s:"_set" + uc + "Attr", g:"_get" + uc + "Attr", l:uc.toLowerCase()});
        }, _set:function (name, value) {
            var oldValue = this[name];
            this[name] = value;
            if (this._created && !isEqual(oldValue, value)) {
                if (this._watchCallbacks) {
                    this._watchCallbacks(name, oldValue, value);
                }
                this.emit("attrmodified-" + name, {detail:{prevValue:oldValue, newValue:value}});
            }
        }, _get:function (name) {
            return this[name];
        }, emit:function (type, eventObj, callbackArgs) {
            eventObj = eventObj || {};
            if (eventObj.bubbles === undefined) {
                eventObj.bubbles = true;
            }
            if (eventObj.cancelable === undefined) {
                eventObj.cancelable = true;
            }
            if (!eventObj.detail) {
                eventObj.detail = {};
            }
            eventObj.detail.widget = this;
            var ret, callback = this["on" + type];
            if (callback) {
                ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
            }
            if (this._started && !this._beingDestroyed) {
                on.emit(this.domNode, type.toLowerCase(), eventObj);
            }
            return ret;
        }, on:function (type, func) {
            var widgetMethod = this._onMap(type);
            if (widgetMethod) {
                return aspect.after(this, widgetMethod, func, true);
            }
            return this.own(on(this.domNode, type, func))[0];
        }, _onMap:function (type) {
            var ctor = this.constructor, map = ctor._onMap;
            if (!map) {
                map = (ctor._onMap = {});
                for (var attr in ctor.prototype) {
                    if (/^on/.test(attr)) {
                        map[attr.replace(/^on/, "").toLowerCase()] = attr;
                    }
                }
            }
            return map[typeof type == "string" && type.toLowerCase()];
        }, toString:function () {
            return "[Widget " + this.declaredClass + ", " + (this.id || "NO ID") + "]";
        }, getChildren:function () {
            return this.containerNode ? registry.findWidgets(this.containerNode) : [];
        }, getParent:function () {
            return registry.getEnclosingWidget(this.domNode.parentNode);
        }, connect:function (obj, event, method) {
            return this.own(connect.connect(obj, event, this, method))[0];
        }, disconnect:function (handle) {
            handle.remove();
        }, subscribe:function (t, method) {
            return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];
        }, unsubscribe:function (handle) {
            handle.remove();
        }, isLeftToRight:function () {
            return this.dir ? (this.dir == "ltr") : domGeometry.isBodyLtr(this.ownerDocument);
        }, isFocusable:function () {
            return this.focus && (domStyle.get(this.domNode, "display") != "none");
        }, placeAt:function (reference, position) {
            var refWidget = !reference.tagName && registry.byId(reference);
            if (refWidget && refWidget.addChild && (!position || typeof position === "number")) {
                refWidget.addChild(this, position);
            } else {
                var ref = refWidget ? (refWidget.containerNode && !/after|before|replace/.test(position || "") ? refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
                domConstruct.place(this.domNode, ref, position);
                if (!this._started && (this.getParent() || {})._started) {
                    this.startup();
                }
            }
            return this;
        }, defer:function (fcn, delay) {
            var timer = setTimeout(lang.hitch(this, function () {
                if (!timer) {
                    return;
                }
                timer = null;
                if (!this._destroyed) {
                    lang.hitch(this, fcn)();
                }
            }), delay || 0);
            return {remove:function () {
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
                return null;
            }};
        }});
        if (has("dojo-bidi")) {
            _WidgetBase.extend(_BidiMixin);
        }
        return _WidgetBase;
    });
}, "dojo/cookie":function () {
    define(["./_base/kernel", "./regexp"], function (dojo, regexp) {
        dojo.cookie = function (name, value, props) {
            var c = document.cookie, ret;
            if (arguments.length == 1) {
                var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
                ret = matches ? decodeURIComponent(matches[1]) : undefined;
            } else {
                props = props || {};
                var exp = props.expires;
                if (typeof exp == "number") {
                    var d = new Date();
                    d.setTime(d.getTime() + exp * 24 * 60 * 60 * 1000);
                    exp = props.expires = d;
                }
                if (exp && exp.toUTCString) {
                    props.expires = exp.toUTCString();
                }
                value = encodeURIComponent(value);
                var updatedCookie = name + "=" + value, propName;
                for (propName in props) {
                    updatedCookie += "; " + propName;
                    var propValue = props[propName];
                    if (propValue !== true) {
                        updatedCookie += "=" + propValue;
                    }
                }
                document.cookie = updatedCookie;
            }
            return ret;
        };
        dojo.cookie.isSupported = function () {
            if (!("cookieEnabled" in navigator)) {
                this("__djCookieTest__", "CookiesAllowed");
                navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
                if (navigator.cookieEnabled) {
                    this("__djCookieTest__", "", {expires:-1});
                }
            }
            return navigator.cookieEnabled;
        };
        return dojo.cookie;
    });
}, "dojox/uuid/_base":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang"], function (dojo) {
        dojo.getObject("uuid", true, dojox);
        dojox.uuid.NIL_UUID = "00000000-0000-0000-0000-000000000000";
        dojox.uuid.version = {UNKNOWN:0, TIME_BASED:1, DCE_SECURITY:2, NAME_BASED_MD5:3, RANDOM:4, NAME_BASED_SHA1:5};
        dojox.uuid.variant = {NCS:"0", DCE:"10", MICROSOFT:"110", UNKNOWN:"111"};
        dojox.uuid.assert = function (booleanValue, message) {
            if (!booleanValue) {
                if (!message) {
                    message = "An assert statement failed.\n" + "The method dojox.uuid.assert() was called with a 'false' value.\n";
                }
                throw new Error(message);
            }
        };
        dojox.uuid.generateNilUuid = function () {
            return dojox.uuid.NIL_UUID;
        };
        dojox.uuid.isValid = function (uuidString) {
            uuidString = uuidString.toString();
            var valid = (dojo.isString(uuidString) && (uuidString.length == 36) && (uuidString == uuidString.toLowerCase()));
            if (valid) {
                var arrayOfParts = uuidString.split("-");
                valid = ((arrayOfParts.length == 5) && (arrayOfParts[0].length == 8) && (arrayOfParts[1].length == 4) && (arrayOfParts[2].length == 4) && (arrayOfParts[3].length == 4) && (arrayOfParts[4].length == 12));
                var HEX_RADIX = 16;
                for (var i in arrayOfParts) {
                    var part = arrayOfParts[i];
                    var integer = parseInt(part, HEX_RADIX);
                    valid = valid && isFinite(integer);
                }
            }
            return valid;
        };
        dojox.uuid.getVariant = function (uuidString) {
            if (!dojox.uuid._ourVariantLookupTable) {
                var variant = dojox.uuid.variant;
                var lookupTable = [];
                lookupTable[0] = variant.NCS;
                lookupTable[1] = variant.NCS;
                lookupTable[2] = variant.NCS;
                lookupTable[3] = variant.NCS;
                lookupTable[4] = variant.NCS;
                lookupTable[5] = variant.NCS;
                lookupTable[6] = variant.NCS;
                lookupTable[7] = variant.NCS;
                lookupTable[8] = variant.DCE;
                lookupTable[9] = variant.DCE;
                lookupTable[10] = variant.DCE;
                lookupTable[11] = variant.DCE;
                lookupTable[12] = variant.MICROSOFT;
                lookupTable[13] = variant.MICROSOFT;
                lookupTable[14] = variant.UNKNOWN;
                lookupTable[15] = variant.UNKNOWN;
                dojox.uuid._ourVariantLookupTable = lookupTable;
            }
            uuidString = uuidString.toString();
            var variantCharacter = uuidString.charAt(19);
            var HEX_RADIX = 16;
            var variantNumber = parseInt(variantCharacter, HEX_RADIX);
            dojox.uuid.assert((variantNumber >= 0) && (variantNumber <= 16));
            return dojox.uuid._ourVariantLookupTable[variantNumber];
        };
        dojox.uuid.getVersion = function (uuidString) {
            var errorMessage = "dojox.uuid.getVersion() was not passed a DCE Variant UUID.";
            dojox.uuid.assert(dojox.uuid.getVariant(uuidString) == dojox.uuid.variant.DCE, errorMessage);
            uuidString = uuidString.toString();
            var versionCharacter = uuidString.charAt(14);
            var HEX_RADIX = 16;
            var versionNumber = parseInt(versionCharacter, HEX_RADIX);
            return versionNumber;
        };
        dojox.uuid.getNode = function (uuidString) {
            var errorMessage = "dojox.uuid.getNode() was not passed a TIME_BASED UUID.";
            dojox.uuid.assert(dojox.uuid.getVersion(uuidString) == dojox.uuid.version.TIME_BASED, errorMessage);
            uuidString = uuidString.toString();
            var arrayOfStrings = uuidString.split("-");
            var nodeString = arrayOfStrings[4];
            return nodeString;
        };
        dojox.uuid.getTimestamp = function (uuidString, returnType) {
            var errorMessage = "dojox.uuid.getTimestamp() was not passed a TIME_BASED UUID.";
            dojox.uuid.assert(dojox.uuid.getVersion(uuidString) == dojox.uuid.version.TIME_BASED, errorMessage);
            uuidString = uuidString.toString();
            if (!returnType) {
                returnType = null;
            }
            switch (returnType) {
              case "string":
              case String:
                return dojox.uuid.getTimestamp(uuidString, Date).toUTCString();
                break;
              case "hex":
                var arrayOfStrings = uuidString.split("-");
                var hexTimeLow = arrayOfStrings[0];
                var hexTimeMid = arrayOfStrings[1];
                var hexTimeHigh = arrayOfStrings[2];
                hexTimeHigh = hexTimeHigh.slice(1);
                var timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
                dojox.uuid.assert(timestampAsHexString.length == 15);
                return timestampAsHexString;
                break;
              case null:
              case "date":
              case Date:
                var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
                var HEX_RADIX = 16;
                var arrayOfParts = uuidString.split("-");
                var timeLow = parseInt(arrayOfParts[0], HEX_RADIX);
                var timeMid = parseInt(arrayOfParts[1], HEX_RADIX);
                var timeHigh = parseInt(arrayOfParts[2], HEX_RADIX);
                var hundredNanosecondIntervalsSince1582 = timeHigh & 4095;
                hundredNanosecondIntervalsSince1582 <<= 16;
                hundredNanosecondIntervalsSince1582 += timeMid;
                hundredNanosecondIntervalsSince1582 *= 4294967296;
                hundredNanosecondIntervalsSince1582 += timeLow;
                var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
                var secondsPerHour = 60 * 60;
                var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
                var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
                var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
                var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
                var timestampAsDate = new Date(millisecondsSince1970);
                return timestampAsDate;
                break;
              default:
                dojox.uuid.assert(false, "dojox.uuid.getTimestamp was not passed a valid returnType: " + returnType);
                break;
            }
        };
        return dojox.uuid;
    });
}, "dojo/_base/fx":function () {
    define(["./kernel", "./config", "./lang", "../Evented", "./Color", "../aspect", "../sniff", "../dom", "../dom-style"], function (dojo, config, lang, Evented, Color, aspect, has, dom, style) {
        var _mixin = lang.mixin;
        var basefx = {};
        var _Line = basefx._Line = function (start, end) {
            this.start = start;
            this.end = end;
        };
        _Line.prototype.getValue = function (n) {
            return ((this.end - this.start) * n) + this.start;
        };
        var Animation = basefx.Animation = function (args) {
            _mixin(this, args);
            if (lang.isArray(this.curve)) {
                this.curve = new _Line(this.curve[0], this.curve[1]);
            }
        };
        Animation.prototype = new Evented();
        lang.extend(Animation, {duration:350, repeat:0, rate:20, _percent:0, _startRepeatCount:0, _getStep:function () {
            var _p = this._percent, _e = this.easing;
            return _e ? _e(_p) : _p;
        }, _fire:function (evt, args) {
            var a = args || [];
            if (this[evt]) {
                if (config.debugAtAllCosts) {
                    this[evt].apply(this, a);
                } else {
                    try {
                        this[evt].apply(this, a);
                    }
                    catch (e) {
                        console.error("exception in animation handler for:", evt);
                        console.error(e);
                    }
                }
            }
            return this;
        }, play:function (delay, gotoStart) {
            var _t = this;
            if (_t._delayTimer) {
                _t._clearTimer();
            }
            if (gotoStart) {
                _t._stopTimer();
                _t._active = _t._paused = false;
                _t._percent = 0;
            } else {
                if (_t._active && !_t._paused) {
                    return _t;
                }
            }
            _t._fire("beforeBegin", [_t.node]);
            var de = delay || _t.delay, _p = lang.hitch(_t, "_play", gotoStart);
            if (de > 0) {
                _t._delayTimer = setTimeout(_p, de);
                return _t;
            }
            _p();
            return _t;
        }, _play:function (gotoStart) {
            var _t = this;
            if (_t._delayTimer) {
                _t._clearTimer();
            }
            _t._startTime = new Date().valueOf();
            if (_t._paused) {
                _t._startTime -= _t.duration * _t._percent;
            }
            _t._active = true;
            _t._paused = false;
            var value = _t.curve.getValue(_t._getStep());
            if (!_t._percent) {
                if (!_t._startRepeatCount) {
                    _t._startRepeatCount = _t.repeat;
                }
                _t._fire("onBegin", [value]);
            }
            _t._fire("onPlay", [value]);
            _t._cycle();
            return _t;
        }, pause:function () {
            var _t = this;
            if (_t._delayTimer) {
                _t._clearTimer();
            }
            _t._stopTimer();
            if (!_t._active) {
                return _t;
            }
            _t._paused = true;
            _t._fire("onPause", [_t.curve.getValue(_t._getStep())]);
            return _t;
        }, gotoPercent:function (percent, andPlay) {
            var _t = this;
            _t._stopTimer();
            _t._active = _t._paused = true;
            _t._percent = percent;
            if (andPlay) {
                _t.play();
            }
            return _t;
        }, stop:function (gotoEnd) {
            var _t = this;
            if (_t._delayTimer) {
                _t._clearTimer();
            }
            if (!_t._timer) {
                return _t;
            }
            _t._stopTimer();
            if (gotoEnd) {
                _t._percent = 1;
            }
            _t._fire("onStop", [_t.curve.getValue(_t._getStep())]);
            _t._active = _t._paused = false;
            return _t;
        }, status:function () {
            if (this._active) {
                return this._paused ? "paused" : "playing";
            }
            return "stopped";
        }, _cycle:function () {
            var _t = this;
            if (_t._active) {
                var curr = new Date().valueOf();
                var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / (_t.duration);
                if (step >= 1) {
                    step = 1;
                }
                _t._percent = step;
                if (_t.easing) {
                    step = _t.easing(step);
                }
                _t._fire("onAnimate", [_t.curve.getValue(step)]);
                if (_t._percent < 1) {
                    _t._startTimer();
                } else {
                    _t._active = false;
                    if (_t.repeat > 0) {
                        _t.repeat--;
                        _t.play(null, true);
                    } else {
                        if (_t.repeat == -1) {
                            _t.play(null, true);
                        } else {
                            if (_t._startRepeatCount) {
                                _t.repeat = _t._startRepeatCount;
                                _t._startRepeatCount = 0;
                            }
                        }
                    }
                    _t._percent = 0;
                    _t._fire("onEnd", [_t.node]);
                    !_t.repeat && _t._stopTimer();
                }
            }
            return _t;
        }, _clearTimer:function () {
            clearTimeout(this._delayTimer);
            delete this._delayTimer;
        }});
        var ctr = 0, timer = null, runner = {run:function () {
        }};
        lang.extend(Animation, {_startTimer:function () {
            if (!this._timer) {
                this._timer = aspect.after(runner, "run", lang.hitch(this, "_cycle"), true);
                ctr++;
            }
            if (!timer) {
                timer = setInterval(lang.hitch(runner, "run"), this.rate);
            }
        }, _stopTimer:function () {
            if (this._timer) {
                this._timer.remove();
                this._timer = null;
                ctr--;
            }
            if (ctr <= 0) {
                clearInterval(timer);
                timer = null;
                ctr = 0;
            }
        }});
        var _makeFadeable = has("ie") ? function (node) {
            var ns = node.style;
            if (!ns.width.length && style.get(node, "width") == "auto") {
                ns.width = "auto";
            }
        } : function () {
        };
        basefx._fade = function (args) {
            args.node = dom.byId(args.node);
            var fArgs = _mixin({properties:{}}, args), props = (fArgs.properties.opacity = {});
            props.start = !("start" in fArgs) ? function () {
                return +style.get(fArgs.node, "opacity") || 0;
            } : fArgs.start;
            props.end = fArgs.end;
            var anim = basefx.animateProperty(fArgs);
            aspect.after(anim, "beforeBegin", lang.partial(_makeFadeable, fArgs.node), true);
            return anim;
        };
        basefx.fadeIn = function (args) {
            return basefx._fade(_mixin({end:1}, args));
        };
        basefx.fadeOut = function (args) {
            return basefx._fade(_mixin({end:0}, args));
        };
        basefx._defaultEasing = function (n) {
            return 0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2);
        };
        var PropLine = function (properties) {
            this._properties = properties;
            for (var p in properties) {
                var prop = properties[p];
                if (prop.start instanceof Color) {
                    prop.tempColor = new Color();
                }
            }
        };
        PropLine.prototype.getValue = function (r) {
            var ret = {};
            for (var p in this._properties) {
                var prop = this._properties[p], start = prop.start;
                if (start instanceof Color) {
                    ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
                } else {
                    if (!lang.isArray(start)) {
                        ret[p] = ((prop.end - start) * r) + start + (p != "opacity" ? prop.units || "px" : 0);
                    }
                }
            }
            return ret;
        };
        basefx.animateProperty = function (args) {
            var n = args.node = dom.byId(args.node);
            if (!args.easing) {
                args.easing = dojo._defaultEasing;
            }
            var anim = new Animation(args);
            aspect.after(anim, "beforeBegin", lang.hitch(anim, function () {
                var pm = {};
                for (var p in this.properties) {
                    if (p == "width" || p == "height") {
                        this.node.display = "block";
                    }
                    var prop = this.properties[p];
                    if (lang.isFunction(prop)) {
                        prop = prop(n);
                    }
                    prop = pm[p] = _mixin({}, (lang.isObject(prop) ? prop : {end:prop}));
                    if (lang.isFunction(prop.start)) {
                        prop.start = prop.start(n);
                    }
                    if (lang.isFunction(prop.end)) {
                        prop.end = prop.end(n);
                    }
                    var isColor = (p.toLowerCase().indexOf("color") >= 0);
                    function getStyle(node, p) {
                        var v = {height:node.offsetHeight, width:node.offsetWidth}[p];
                        if (v !== undefined) {
                            return v;
                        }
                        v = style.get(node, p);
                        return (p == "opacity") ? +v : (isColor ? v : parseFloat(v));
                    }
                    if (!("end" in prop)) {
                        prop.end = getStyle(n, p);
                    } else {
                        if (!("start" in prop)) {
                            prop.start = getStyle(n, p);
                        }
                    }
                    if (isColor) {
                        prop.start = new Color(prop.start);
                        prop.end = new Color(prop.end);
                    } else {
                        prop.start = (p == "opacity") ? +prop.start : parseFloat(prop.start);
                    }
                }
                this.curve = new PropLine(pm);
            }), true);
            aspect.after(anim, "onAnimate", lang.hitch(style, "set", anim.node), true);
            return anim;
        };
        basefx.anim = function (node, properties, duration, easing, onEnd, delay) {
            return basefx.animateProperty({node:node, duration:duration || Animation.prototype.duration, properties:properties, easing:easing, onEnd:onEnd}).play(delay || 0);
        };
        if (1) {
            _mixin(dojo, basefx);
            dojo._Animation = Animation;
        }
        return basefx;
    });
}, "dijit/_editor/html":function () {
    define(["dojo/_base/array", "dojo/_base/lang", "dojo/sniff"], function (array, lang, has) {
        var exports = {};
        lang.setObject("dijit._editor.html", exports);
        var escape = exports.escapeXml = function (str, noSingleQuotes) {
            str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
            if (!noSingleQuotes) {
                str = str.replace(/'/gm, "&#39;");
            }
            return str;
        };
        exports.getNodeHtml = function (node) {
            var output = [];
            exports.getNodeHtmlHelper(node, output);
            return output.join("");
        };
        exports.getNodeHtmlHelper = function (node, output) {
            switch (node.nodeType) {
              case 1:
                var lName = node.nodeName.toLowerCase();
                if (!lName || lName.charAt(0) == "/") {
                    return "";
                }
                output.push("<", lName);
                var attrarray = [], attrhash = {};
                var attr;
                if (has("dom-attributes-explicit") || has("dom-attributes-specified-flag")) {
                    var i = 0;
                    while ((attr = node.attributes[i++])) {
                        var n = attr.name;
                        if (n.substr(0, 3) !== "_dj" && (!has("dom-attributes-specified-flag") || attr.specified) && !(n in attrhash)) {
                            var v = attr.value;
                            if (n == "src" || n == "href") {
                                if (node.getAttribute("_djrealurl")) {
                                    v = node.getAttribute("_djrealurl");
                                }
                            }
                            if (has("ie") === 8 && n === "style") {
                                v = v.replace("HEIGHT:", "height:").replace("WIDTH:", "width:");
                            }
                            attrarray.push([n, v]);
                            attrhash[n] = v;
                        }
                    }
                } else {
                    var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false);
                    var s = clone.outerHTML;
                    var rgxp_attrsMatch = /[\w-]+=("[^"]*"|'[^']*'|\S*)/gi;
                    var attrSplit = s.match(rgxp_attrsMatch);
                    s = s.substr(0, s.indexOf(">"));
                    array.forEach(attrSplit, function (attr) {
                        if (attr) {
                            var idx = attr.indexOf("=");
                            if (idx > 0) {
                                var key = attr.substring(0, idx);
                                if (key.substr(0, 3) != "_dj") {
                                    if (key == "src" || key == "href") {
                                        if (node.getAttribute("_djrealurl")) {
                                            attrarray.push([key, node.getAttribute("_djrealurl")]);
                                            return;
                                        }
                                    }
                                    var val, match;
                                    switch (key) {
                                      case "style":
                                        val = node.style.cssText.toLowerCase();
                                        break;
                                      case "class":
                                        val = node.className;
                                        break;
                                      case "width":
                                        if (lName === "img") {
                                            match = /width=(\S+)/i.exec(s);
                                            if (match) {
                                                val = match[1];
                                            }
                                            break;
                                        }
                                      case "height":
                                        if (lName === "img") {
                                            match = /height=(\S+)/i.exec(s);
                                            if (match) {
                                                val = match[1];
                                            }
                                            break;
                                        }
                                      default:
                                        val = node.getAttribute(key);
                                    }
                                    if (val != null) {
                                        attrarray.push([key, val.toString()]);
                                    }
                                }
                            }
                        }
                    }, this);
                }
                attrarray.sort(function (a, b) {
                    return a[0] < b[0] ? -1 : (a[0] == b[0] ? 0 : 1);
                });
                var j = 0;
                while ((attr = attrarray[j++])) {
                    output.push(" ", attr[0], "=\"", (typeof attr[1] === "string" ? escape(attr[1], true) : attr[1]), "\"");
                }
                switch (lName) {
                  case "br":
                  case "hr":
                  case "img":
                  case "input":
                  case "base":
                  case "meta":
                  case "area":
                  case "basefont":
                    output.push(" />");
                    break;
                  case "script":
                    output.push(">", node.innerHTML, "</", lName, ">");
                    break;
                  default:
                    output.push(">");
                    if (node.hasChildNodes()) {
                        exports.getChildrenHtmlHelper(node, output);
                    }
                    output.push("</", lName, ">");
                }
                break;
              case 4:
              case 3:
                output.push(escape(node.nodeValue, true));
                break;
              case 8:
                output.push("<!--", escape(node.nodeValue, true), "-->");
                break;
              default:
                output.push("<!-- Element not recognized - Type: ", node.nodeType, " Name: ", node.nodeName, "-->");
            }
        };
        exports.getChildrenHtml = function (node) {
            var output = [];
            exports.getChildrenHtmlHelper(node, output);
            return output.join("");
        };
        exports.getChildrenHtmlHelper = function (dom, output) {
            if (!dom) {
                return;
            }
            var nodes = dom["childNodes"] || dom;
            var checkParent = !has("ie") || nodes !== dom;
            var node, i = 0;
            while ((node = nodes[i++])) {
                if (!checkParent || node.parentNode == dom) {
                    exports.getNodeHtmlHelper(node, output);
                }
            }
        };
        return exports;
    });
}, "dojox/layout/ResizeHandle":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/connect", "dojo/_base/array", "dojo/_base/event", "dojo/_base/fx", "dojo/_base/window", "dojo/fx", "dojo/window", "dojo/dom", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dijit/_base/manager", "dijit/_Widget", "dijit/_TemplatedMixin", "dojo/_base/declare"], function (kernel, lang, connect, arrayUtil, eventUtil, fxBase, windowBase, fxUtil, windowUtil, domUtil, domClass, domGeometry, domStyle, manager, Widget, TemplatedMixin, declare) {
        kernel.experimental("dojox.layout.ResizeHandle");
        var ResizeHandle = declare("dojox.layout.ResizeHandle", [Widget, TemplatedMixin], {targetId:"", targetContainer:null, resizeAxis:"xy", activeResize:false, activeResizeClass:"dojoxResizeHandleClone", animateSizing:true, animateMethod:"chain", animateDuration:225, minHeight:100, minWidth:100, constrainMax:false, maxHeight:0, maxWidth:0, fixedAspect:false, intermediateChanges:false, startTopic:"/dojo/resize/start", endTopic:"/dojo/resize/stop", templateString:"<div dojoAttachPoint=\"resizeHandle\" class=\"dojoxResizeHandle\"><div></div></div>", postCreate:function () {
            this.connect(this.resizeHandle, "onmousedown", "_beginSizing");
            if (!this.activeResize) {
                this._resizeHelper = manager.byId("dojoxGlobalResizeHelper");
                if (!this._resizeHelper) {
                    this._resizeHelper = new _ResizeHelper({id:"dojoxGlobalResizeHelper"}).placeAt(windowBase.body());
                    domClass.add(this._resizeHelper.domNode, this.activeResizeClass);
                }
            } else {
                this.animateSizing = false;
            }
            if (!this.minSize) {
                this.minSize = {w:this.minWidth, h:this.minHeight};
            }
            if (this.constrainMax) {
                this.maxSize = {w:this.maxWidth, h:this.maxHeight};
            }
            this._resizeX = this._resizeY = false;
            var addClass = lang.partial(domClass.add, this.resizeHandle);
            switch (this.resizeAxis.toLowerCase()) {
              case "xy":
                this._resizeX = this._resizeY = true;
                addClass("dojoxResizeNW");
                break;
              case "x":
                this._resizeX = true;
                addClass("dojoxResizeW");
                break;
              case "y":
                this._resizeY = true;
                addClass("dojoxResizeN");
                break;
            }
        }, _beginSizing:function (e) {
            if (this._isSizing) {
                return;
            }
            connect.publish(this.startTopic, [this]);
            this.targetWidget = manager.byId(this.targetId);
            this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : domUtil.byId(this.targetId);
            if (this.targetContainer) {
                this.targetDomNode = this.targetContainer;
            }
            if (!this.targetDomNode) {
                return;
            }
            if (!this.activeResize) {
                var c = domGeometry.position(this.targetDomNode, true);
                this._resizeHelper.resize({l:c.x, t:c.y, w:c.w, h:c.h});
                this._resizeHelper.show();
                if (!this.isLeftToRight()) {
                    this._resizeHelper.startPosition = {l:c.x, t:c.y};
                }
            }
            this._isSizing = true;
            this.startPoint = {x:e.clientX, y:e.clientY};
            var style = domStyle.getComputedStyle(this.targetDomNode), borderModel = domGeometry.boxModel === "border-model", padborder = borderModel ? {w:0, h:0} : domGeometry.getPadBorderExtents(this.targetDomNode, style), margin = domGeometry.getMarginExtents(this.targetDomNode, style), mb;
            mb = this.startSize = {w:domStyle.get(this.targetDomNode, "width", style), h:domStyle.get(this.targetDomNode, "height", style), pbw:padborder.w, pbh:padborder.h, mw:margin.w, mh:margin.h};
            if (!this.isLeftToRight() && dojo.style(this.targetDomNode, "position") == "absolute") {
                var p = domGeometry.position(this.targetDomNode, true);
                this.startPosition = {l:p.x, t:p.y};
            }
            this._pconnects = [connect.connect(windowBase.doc, "onmousemove", this, "_updateSizing"), connect.connect(windowBase.doc, "onmouseup", this, "_endSizing")];
            eventUtil.stop(e);
        }, _updateSizing:function (e) {
            if (this.activeResize) {
                this._changeSizing(e);
            } else {
                var tmp = this._getNewCoords(e, "border", this._resizeHelper.startPosition);
                if (tmp === false) {
                    return;
                }
                this._resizeHelper.resize(tmp);
            }
            e.preventDefault();
        }, _getNewCoords:function (e, box, startPosition) {
            try {
                if (!e.clientX || !e.clientY) {
                    return false;
                }
            }
            catch (e) {
                return false;
            }
            this._activeResizeLastEvent = e;
            var dx = (this.isLeftToRight() ? 1 : -1) * (this.startPoint.x - e.clientX), dy = this.startPoint.y - e.clientY, newW = this.startSize.w - (this._resizeX ? dx : 0), newH = this.startSize.h - (this._resizeY ? dy : 0), r = this._checkConstraints(newW, newH);
            startPosition = (startPosition || this.startPosition);
            if (startPosition && this._resizeX) {
                r.l = startPosition.l + dx;
                if (r.w != newW) {
                    r.l += (newW - r.w);
                }
                r.t = startPosition.t;
            }
            switch (box) {
              case "margin":
                r.w += this.startSize.mw;
                r.h += this.startSize.mh;
              case "border":
                r.w += this.startSize.pbw;
                r.h += this.startSize.pbh;
                break;
            }
            return r;
        }, _checkConstraints:function (newW, newH) {
            if (this.minSize) {
                var tm = this.minSize;
                if (newW < tm.w) {
                    newW = tm.w;
                }
                if (newH < tm.h) {
                    newH = tm.h;
                }
            }
            if (this.constrainMax && this.maxSize) {
                var ms = this.maxSize;
                if (newW > ms.w) {
                    newW = ms.w;
                }
                if (newH > ms.h) {
                    newH = ms.h;
                }
            }
            if (this.fixedAspect) {
                var w = this.startSize.w, h = this.startSize.h, delta = w * newH - h * newW;
                if (delta < 0) {
                    newW = newH * w / h;
                } else {
                    if (delta > 0) {
                        newH = newW * h / w;
                    }
                }
            }
            return {w:newW, h:newH};
        }, _changeSizing:function (e) {
            var isWidget = this.targetWidget && lang.isFunction(this.targetWidget.resize), tmp = this._getNewCoords(e, isWidget && "margin");
            if (tmp === false) {
                return;
            }
            if (isWidget) {
                this.targetWidget.resize(tmp);
            } else {
                if (this.animateSizing) {
                    var anim = fxUtil[this.animateMethod]([fxBase.animateProperty({node:this.targetDomNode, properties:{width:{start:this.startSize.w, end:tmp.w}}, duration:this.animateDuration}), fxBase.animateProperty({node:this.targetDomNode, properties:{height:{start:this.startSize.h, end:tmp.h}}, duration:this.animateDuration})]);
                    anim.play();
                } else {
                    domStyle.set(this.targetDomNode, {width:tmp.w + "px", height:tmp.h + "px"});
                }
            }
            if (this.intermediateChanges) {
                this.onResize(e);
            }
        }, _endSizing:function (e) {
            arrayUtil.forEach(this._pconnects, connect.disconnect);
            var pub = lang.partial(connect.publish, this.endTopic, [this]);
            if (!this.activeResize) {
                this._resizeHelper.hide();
                this._changeSizing(e);
                setTimeout(pub, this.animateDuration + 15);
            } else {
                pub();
            }
            this._isSizing = false;
            this.onResize(e);
        }, onResize:function (e) {
        }});
        var _ResizeHelper = dojo.declare("dojox.layout._ResizeHelper", Widget, {show:function () {
            domStyle.set(this.domNode, "display", "");
        }, hide:function () {
            domStyle.set(this.domNode, "display", "none");
        }, resize:function (dim) {
            domGeometry.setMarginBox(this.domNode, dim);
        }});
        return ResizeHandle;
    });
}, "dojo/uacss":function () {
    define(["./dom-geometry", "./_base/lang", "./domReady", "./sniff", "./_base/window"], function (geometry, lang, domReady, has, baseWindow) {
        var html = baseWindow.doc.documentElement, ie = has("ie"), opera = has("opera"), maj = Math.floor, ff = has("ff"), boxModel = geometry.boxModel.replace(/-/, ""), classes = {"dj_quirks":has("quirks"), "dj_opera":opera, "dj_khtml":has("khtml"), "dj_webkit":has("webkit"), "dj_safari":has("safari"), "dj_chrome":has("chrome"), "dj_gecko":has("mozilla"), "dj_ios":has("ios"), "dj_android":has("android")};
        if (ie) {
            classes["dj_ie"] = true;
            classes["dj_ie" + maj(ie)] = true;
            classes["dj_iequirks"] = has("quirks");
        }
        if (ff) {
            classes["dj_ff" + maj(ff)] = true;
        }
        classes["dj_" + boxModel] = true;
        var classStr = "";
        for (var clz in classes) {
            if (classes[clz]) {
                classStr += clz + " ";
            }
        }
        html.className = lang.trim(html.className + " " + classStr);
        domReady(function () {
            if (!geometry.isBodyLtr()) {
                var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
                html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
            }
        });
        return has;
    });
}, "dojo/_base/NodeList":function () {
    define(["./kernel", "../query", "./array", "./html", "../NodeList-dom"], function (dojo, query, array) {
        var NodeList = query.NodeList, nlp = NodeList.prototype;
        nlp.connect = NodeList._adaptAsForEach(function () {
            return dojo.connect.apply(this, arguments);
        });
        nlp.coords = NodeList._adaptAsMap(dojo.coords);
        NodeList.events = ["blur", "focus", "change", "click", "error", "keydown", "keypress", "keyup", "load", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup", "submit"];
        array.forEach(NodeList.events, function (evt) {
            var _oe = "on" + evt;
            nlp[_oe] = function (a, b) {
                return this.connect(_oe, a, b);
            };
        });
        dojo.NodeList = NodeList;
        return NodeList;
    });
}, "dojox/grid/enhanced/plugins/IndirectSelection":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/event", "dojo/_base/lang", "dojo/_base/html", "dojo/_base/window", "dojo/_base/connect", "dojo/_base/sniff", "dojo/query", "dojo/keys", "dojo/string", "../_Plugin", "../../EnhancedGrid", "../../cells/dijit"], function (declare, array, evt, lang, html, win, connect, has, query, keys, string, _Plugin, EnhancedGrid) {
        var gridCells = lang.getObject("dojox.grid.cells");
        var RowSelector = declare("dojox.grid.cells.RowSelector", gridCells._Widget, {inputType:"", map:null, disabledMap:null, isRowSelector:true, _connects:null, _subscribes:null, checkedText:"&#10003;", unCheckedText:"O", constructor:function () {
            this.map = {};
            this.disabledMap = {};
            this.disabledCount = 0;
            this._connects = [];
            this._subscribes = [];
            this.inA11YMode = html.hasClass(win.body(), "dijit_a11y");
            this.baseClass = "dojoxGridRowSelector dijitReset dijitInline dijit" + this.inputType;
            this.checkedClass = " dijit" + this.inputType + "Checked";
            this.disabledClass = " dijit" + this.inputType + "Disabled";
            this.checkedDisabledClass = " dijit" + this.inputType + "CheckedDisabled";
            this.statusTextClass = " dojoxGridRowSelectorStatusText";
            this._connects.push(connect.connect(this.grid, "dokeyup", this, "_dokeyup"));
            this._connects.push(connect.connect(this.grid.selection, "onSelected", this, "_onSelected"));
            this._connects.push(connect.connect(this.grid.selection, "onDeselected", this, "_onDeselected"));
            this._connects.push(connect.connect(this.grid.scroller, "invalidatePageNode", this, "_pageDestroyed"));
            this._connects.push(connect.connect(this.grid, "onCellClick", this, "_onClick"));
            this._connects.push(connect.connect(this.grid, "updateRow", this, "_onUpdateRow"));
        }, formatter:function (data, rowIndex, scope) {
            var _this = scope;
            var clazz = _this.baseClass;
            var checked = !!_this.getValue(rowIndex);
            var disabled = !!_this.disabledMap[rowIndex];
            if (checked) {
                clazz += _this.checkedClass;
                if (disabled) {
                    clazz += _this.checkedDisabledClass;
                }
            } else {
                if (disabled) {
                    clazz += _this.disabledClass;
                }
            }
            return ["<div tabindex = -1 ", "id = '" + _this.grid.id + "_rowSelector_" + rowIndex + "' ", "name = '" + _this.grid.id + "_rowSelector' class = '" + clazz + "' ", "role = " + _this.inputType + " aria-checked = '" + checked + "' aria-disabled = '" + disabled + "' aria-label = '" + string.substitute(_this.grid._nls["indirectSelection" + _this.inputType], [rowIndex + 1]) + "'>", "<span class = '" + _this.statusTextClass + "'>" + (checked ? _this.checkedText : _this.unCheckedText) + "</span>", "</div>"].join("");
        }, setValue:function (rowIndex, inValue) {
        }, getValue:function (rowIndex) {
            return this.grid.selection.isSelected(rowIndex);
        }, toggleRow:function (index, value) {
            this._nativeSelect(index, value);
        }, setDisabled:function (index, disabled) {
            if (index < 0) {
                return;
            }
            this._toggleDisabledStyle(index, disabled);
        }, disabled:function (index) {
            return !!this.disabledMap[index];
        }, _onClick:function (e) {
            if (e.cell === this) {
                this._selectRow(e);
            }
        }, _dokeyup:function (e) {
            if (e.cellIndex == this.index && e.rowIndex >= 0 && e.keyCode == keys.SPACE) {
                this._selectRow(e);
            }
        }, focus:function (rowIndex) {
            var selector = this.map[rowIndex];
            if (selector) {
                selector.focus();
            }
        }, _focusEndingCell:function (rowIndex, cellIndex) {
            var cell = this.grid.getCell(cellIndex);
            this.grid.focus.setFocusCell(cell, rowIndex);
        }, _nativeSelect:function (index, value) {
            this.grid.selection[value ? "select" : "deselect"](index);
        }, _onSelected:function (index) {
            this._toggleCheckedStyle(index, true);
        }, _onDeselected:function (index) {
            this._toggleCheckedStyle(index, false);
        }, _onUpdateRow:function (index) {
            delete this.map[index];
        }, _toggleCheckedStyle:function (index, value) {
            var selector = this._getSelector(index);
            if (selector) {
                html.toggleClass(selector, this.checkedClass, value);
                if (this.disabledMap[index]) {
                    html.toggleClass(selector, this.checkedDisabledClass, value);
                }
                selector.setAttribute("aria-checked", value);
                if (this.inA11YMode) {
                    selector.firstChild.innerHTML = (value ? this.checkedText : this.unCheckedText);
                }
            }
        }, _toggleDisabledStyle:function (index, disabled) {
            var selector = this._getSelector(index);
            if (selector) {
                html.toggleClass(selector, this.disabledClass, disabled);
                if (this.getValue(index)) {
                    html.toggleClass(selector, this.checkedDisabledClass, disabled);
                }
                selector.setAttribute("aria-disabled", disabled);
            }
            this.disabledMap[index] = disabled;
            if (index >= 0) {
                this.disabledCount += disabled ? 1 : -1;
            }
        }, _getSelector:function (index) {
            var selector = this.map[index];
            if (!selector) {
                var rowNode = this.view.rowNodes[index];
                if (rowNode) {
                    selector = query(".dojoxGridRowSelector", rowNode)[0];
                    if (selector) {
                        this.map[index] = selector;
                    }
                }
            }
            return selector;
        }, _pageDestroyed:function (pageIndex) {
            var rowsPerPage = this.grid.scroller.rowsPerPage;
            var start = pageIndex * rowsPerPage, end = start + rowsPerPage - 1;
            for (var i = start; i <= end; i++) {
                if (!this.map[i]) {
                    continue;
                }
                html.destroy(this.map[i]);
                delete this.map[i];
            }
        }, destroy:function () {
            for (var i in this.map) {
                html.destroy(this.map[i]);
                delete this.map[i];
            }
            for (i in this.disabledMap) {
                delete this.disabledMap[i];
            }
            array.forEach(this._connects, connect.disconnect);
            array.forEach(this._subscribes, connect.unsubscribe);
            delete this._connects;
            delete this._subscribes;
        }});
        var SingleRowSelector = declare("dojox.grid.cells.SingleRowSelector", RowSelector, {inputType:"Radio", _selectRow:function (e) {
            var index = e.rowIndex;
            if (this.disabledMap[index]) {
                return;
            }
            this._focusEndingCell(index, e.cellIndex);
            this._nativeSelect(index, !this.grid.selection.selected[index]);
        }});
        var MultipleRowSelector = declare("dojox.grid.cells.MultipleRowSelector", RowSelector, {inputType:"CheckBox", swipeStartRowIndex:-1, swipeMinRowIndex:-1, swipeMaxRowIndex:-1, toSelect:false, lastClickRowIdx:-1, unCheckedText:"&#9633;", constructor:function () {
            this._connects.push(connect.connect(win.doc, "onmouseup", this, "_domouseup"));
            this._connects.push(connect.connect(this.grid, "onRowMouseOver", this, "_onRowMouseOver"));
            this._connects.push(connect.connect(this.grid.focus, "move", this, "_swipeByKey"));
            this._connects.push(connect.connect(this.grid, "onCellMouseDown", this, "_onMouseDown"));
            if (this.headerSelector) {
                this._connects.push(connect.connect(this.grid.views, "render", this, "_addHeaderSelector"));
                this._connects.push(connect.connect(this.grid, "_onFetchComplete", this, "_addHeaderSelector"));
                this._connects.push(connect.connect(this.grid, "onSelectionChanged", this, "_onSelectionChanged"));
                this._connects.push(connect.connect(this.grid, "onKeyDown", this, function (e) {
                    if (e.rowIndex == -1 && e.cellIndex == this.index && e.keyCode == keys.SPACE) {
                        this._toggletHeader();
                    }
                }));
            }
        }, toggleAllSelection:function (checked) {
            var grid = this.grid, selection = grid.selection;
            if (checked) {
                selection.selectRange(0, grid.rowCount - 1);
            } else {
                selection.deselectAll();
            }
        }, _onMouseDown:function (e) {
            if (e.cell == this) {
                this._startSelection(e.rowIndex);
                evt.stop(e);
            }
        }, _onRowMouseOver:function (e) {
            this._updateSelection(e, 0);
        }, _domouseup:function (e) {
            if (has("ie")) {
                this.view.content.decorateEvent(e);
            }
            var inSwipeSelection = e.cellIndex >= 0 && this.inSwipeSelection() && !this.grid.edit.isEditRow(e.rowIndex);
            if (inSwipeSelection) {
                this._focusEndingCell(e.rowIndex, e.cellIndex);
            }
            this._finishSelect();
        }, _dokeyup:function (e) {
            this.inherited(arguments);
            if (!e.shiftKey) {
                this._finishSelect();
            }
        }, _startSelection:function (rowIndex) {
            this.swipeStartRowIndex = this.swipeMinRowIndex = this.swipeMaxRowIndex = rowIndex;
            this.toSelect = !this.getValue(rowIndex);
        }, _updateSelection:function (e, delta) {
            if (!this.inSwipeSelection()) {
                return;
            }
            var byKey = delta !== 0;
            var currRow = e.rowIndex, deltaRow = currRow - this.swipeStartRowIndex + delta;
            if (deltaRow > 0 && this.swipeMaxRowIndex < currRow + delta) {
                this.swipeMaxRowIndex = currRow + delta;
            }
            if (deltaRow < 0 && this.swipeMinRowIndex > currRow + delta) {
                this.swipeMinRowIndex = currRow + delta;
            }
            var min = deltaRow > 0 ? this.swipeStartRowIndex : currRow + delta;
            var max = deltaRow > 0 ? currRow + delta : this.swipeStartRowIndex;
            for (var i = this.swipeMinRowIndex; i <= this.swipeMaxRowIndex; i++) {
                if (this.disabledMap[i] || i < 0) {
                    continue;
                }
                if (i >= min && i <= max) {
                    this._nativeSelect(i, this.toSelect);
                } else {
                    if (!byKey) {
                        this._nativeSelect(i, !this.toSelect);
                    }
                }
            }
        }, _swipeByKey:function (rowOffset, colOffset, e) {
            if (!e || rowOffset === 0 || !e.shiftKey || e.cellIndex != this.index || this.grid.focus.rowIndex < 0) {
                return;
            }
            var rowIndex = e.rowIndex;
            if (this.swipeStartRowIndex < 0) {
                this.swipeStartRowIndex = rowIndex;
                if (rowOffset > 0) {
                    this.swipeMaxRowIndex = rowIndex + rowOffset;
                    this.swipeMinRowIndex = rowIndex;
                } else {
                    this.swipeMinRowIndex = rowIndex + rowOffset;
                    this.swipeMaxRowIndex = rowIndex;
                }
                this.toSelect = this.getValue(rowIndex);
            }
            this._updateSelection(e, rowOffset);
        }, _finishSelect:function () {
            this.swipeStartRowIndex = -1;
            this.swipeMinRowIndex = -1;
            this.swipeMaxRowIndex = -1;
            this.toSelect = false;
        }, inSwipeSelection:function () {
            return this.swipeStartRowIndex >= 0;
        }, _nativeSelect:function (index, value) {
            this.grid.selection[value ? "addToSelection" : "deselect"](index);
        }, _selectRow:function (e) {
            var rowIndex = e.rowIndex;
            if (this.disabledMap[rowIndex]) {
                return;
            }
            evt.stop(e);
            this._focusEndingCell(rowIndex, e.cellIndex);
            var delta = rowIndex - this.lastClickRowIdx;
            var newValue = !this.grid.selection.selected[rowIndex];
            if (this.lastClickRowIdx >= 0 && !e.ctrlKey && !e.altKey && e.shiftKey) {
                var min = delta > 0 ? this.lastClickRowIdx : rowIndex;
                var max = delta > 0 ? rowIndex : this.lastClickRowIdx;
                for (var i = min; i >= 0 && i <= max; i++) {
                    this._nativeSelect(i, newValue);
                }
            } else {
                this._nativeSelect(rowIndex, newValue);
            }
            this.lastClickRowIdx = rowIndex;
        }, getValue:function (rowIndex) {
            if (rowIndex == -1) {
                var g = this.grid;
                return g.rowCount > 0 && g.rowCount <= g.selection.getSelectedCount();
            }
            return this.inherited(arguments);
        }, _addHeaderSelector:function () {
            var headerCellNode = this.view.getHeaderCellNode(this.index);
            if (!headerCellNode) {
                return;
            }
            html.empty(headerCellNode);
            var g = this.grid;
            var selector = headerCellNode.appendChild(html.create("div", {"aria-label":g._nls["selectAll"], "tabindex":-1, "id":g.id + "_rowSelector_-1", "class":this.baseClass, "role":"Checkbox", "innerHTML":"<span class = '" + this.statusTextClass + "'></span><span style='height: 0; width: 0; overflow: hidden; display: block;'>" + g._nls["selectAll"] + "</span>"}));
            this.map[-1] = selector;
            var idx = this._headerSelectorConnectIdx;
            if (idx !== undefined) {
                connect.disconnect(this._connects[idx]);
                this._connects.splice(idx, 1);
            }
            this._headerSelectorConnectIdx = this._connects.length;
            this._connects.push(connect.connect(selector, "onclick", this, "_toggletHeader"));
            this._onSelectionChanged();
        }, _toggletHeader:function () {
            if (!!this.disabledMap[-1]) {
                return;
            }
            this.grid._selectingRange = true;
            this.toggleAllSelection(!this.getValue(-1));
            this._onSelectionChanged();
            this.grid._selectingRange = false;
        }, _onSelectionChanged:function () {
            var g = this.grid;
            if (!this.map[-1] || g._selectingRange) {
                return;
            }
            g.allItemsSelected = this.getValue(-1);
            this._toggleCheckedStyle(-1, g.allItemsSelected);
        }, _toggleDisabledStyle:function (index, disabled) {
            this.inherited(arguments);
            if (this.headerSelector) {
                var allDisabled = (this.grid.rowCount == this.disabledCount);
                if (allDisabled != !!this.disabledMap[-1]) {
                    arguments[0] = -1;
                    arguments[1] = allDisabled;
                    this.inherited(arguments);
                }
            }
        }});
        var IndirectSelection = declare("dojox.grid.enhanced.plugins.IndirectSelection", _Plugin, {name:"indirectSelection", constructor:function () {
            var layout = this.grid.layout;
            this.connect(layout, "setStructure", lang.hitch(layout, this.addRowSelectCell, this.option));
        }, addRowSelectCell:function (option) {
            if (!this.grid.indirectSelection || this.grid.selectionMode == "none") {
                return;
            }
            var rowSelectCellAdded = false, inValidFields = ["get", "formatter", "field", "fields"], defaultCellDef = {type:MultipleRowSelector, name:"", width:"30px", styles:"text-align: center;"};
            if (option.headerSelector) {
                option.name = "";
            }
            if (this.grid.rowSelectCell) {
                this.grid.rowSelectCell.destroy();
            }
            array.forEach(this.structure, function (view) {
                var cells = view.cells;
                if (cells && cells.length > 0 && !rowSelectCellAdded) {
                    var firstRow = cells[0];
                    if (firstRow[0] && firstRow[0].isRowSelector) {
                        console.debug("addRowSelectCell() - row selector cells already added, return.");
                        rowSelectCellAdded = true;
                        return;
                    }
                    var selectDef, cellType = this.grid.selectionMode == "single" ? SingleRowSelector : MultipleRowSelector;
                    selectDef = lang.mixin(defaultCellDef, option, {type:cellType, editable:false, notselectable:true, filterable:false, navigatable:true, nosort:true});
                    array.forEach(inValidFields, function (field) {
                        if (field in selectDef) {
                            delete selectDef[field];
                        }
                    });
                    if (cells.length > 1) {
                        selectDef.rowSpan = cells.length;
                    }
                    array.forEach(this.cells, function (cell, i) {
                        if (cell.index >= 0) {
                            cell.index += 1;
                        } else {
                            console.warn("Error:IndirectSelection.addRowSelectCell()-  cell " + i + " has no index!");
                        }
                    });
                    var rowSelectCell = this.addCellDef(0, 0, selectDef);
                    rowSelectCell.index = 0;
                    firstRow.unshift(rowSelectCell);
                    this.cells.unshift(rowSelectCell);
                    this.grid.rowSelectCell = rowSelectCell;
                    rowSelectCellAdded = true;
                }
            }, this);
            this.cellCount = this.cells.length;
        }, destroy:function () {
            this.grid.rowSelectCell.destroy();
            delete this.grid.rowSelectCell;
            this.inherited(arguments);
        }});
        EnhancedGrid.registerPlugin(IndirectSelection, {"preInit":true});
        return IndirectSelection;
    });
}, "dijit/form/_FormWidget":function () {
    define(["dojo/_base/declare", "dojo/sniff", "dojo/_base/kernel", "dojo/ready", "../_Widget", "../_CssStateMixin", "../_TemplatedMixin", "./_FormWidgetMixin"], function (declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin) {
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/form/_FormValueWidget"];
                require(requires);
            });
        }
        return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {setDisabled:function (disabled) {
            kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
            this.set("disabled", disabled);
        }, setValue:function (value) {
            kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
            this.set("value", value);
        }, getValue:function () {
            kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
            return this.get("value");
        }, postMixInProperties:function () {
            this.nameAttrSetting = (this.name && !has("msapp")) ? ("name=\"" + this.name.replace(/"/g, "&quot;") + "\"") : "";
            this.inherited(arguments);
        }, _setTypeAttr:null});
    });
}, "dojo/query":function () {
    define(["./_base/kernel", "./has", "./dom", "./on", "./_base/array", "./_base/lang", "./selector/_loader", "./selector/_loader!default"], function (dojo, has, dom, on, array, lang, loader, defaultEngine) {
        "use strict";
        has.add("array-extensible", function () {
            return lang.delegate([], {length:1}).length == 1 && !has("bug-for-in-skips-shadowed");
        });
        var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;
        var tnl = function (a, parent, NodeListCtor) {
            var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
            return parent ? nodeList._stash(parent) : nodeList;
        };
        var loopBody = function (f, a, o) {
            a = [0].concat(aps.call(a, 0));
            o = o || dojo.global;
            return function (node) {
                a[0] = node;
                return f.apply(o, a);
            };
        };
        var adaptAsForEach = function (f, o) {
            return function () {
                this.forEach(loopBody(f, arguments, o));
                return this;
            };
        };
        var adaptAsMap = function (f, o) {
            return function () {
                return this.map(loopBody(f, arguments, o));
            };
        };
        var adaptAsFilter = function (f, o) {
            return function () {
                return this.filter(loopBody(f, arguments, o));
            };
        };
        var adaptWithCondition = function (f, g, o) {
            return function () {
                var a = arguments, body = loopBody(f, a, o);
                if (g.call(o || dojo.global, a)) {
                    return this.map(body);
                }
                this.forEach(body);
                return this;
            };
        };
        var NodeList = function (array) {
            var isNew = this instanceof nl && has("array-extensible");
            if (typeof array == "number") {
                array = Array(array);
            }
            var nodeArray = (array && "length" in array) ? array : arguments;
            if (isNew || !nodeArray.sort) {
                var target = isNew ? this : [], l = target.length = nodeArray.length;
                for (var i = 0; i < l; i++) {
                    target[i] = nodeArray[i];
                }
                if (isNew) {
                    return target;
                }
                nodeArray = target;
            }
            lang._mixin(nodeArray, nlp);
            nodeArray._NodeListCtor = function (array) {
                return nl(array);
            };
            return nodeArray;
        };
        var nl = NodeList, nlp = nl.prototype = has("array-extensible") ? [] : {};
        nl._wrap = nlp._wrap = tnl;
        nl._adaptAsMap = adaptAsMap;
        nl._adaptAsForEach = adaptAsForEach;
        nl._adaptAsFilter = adaptAsFilter;
        nl._adaptWithCondition = adaptWithCondition;
        forEach(["slice", "splice"], function (name) {
            var f = ap[name];
            nlp[name] = function () {
                return this._wrap(f.apply(this, arguments), name == "slice" ? this : null);
            };
        });
        forEach(["indexOf", "lastIndexOf", "every", "some"], function (name) {
            var f = array[name];
            nlp[name] = function () {
                return f.apply(dojo, [this].concat(aps.call(arguments, 0)));
            };
        });
        lang.extend(NodeList, {constructor:nl, _NodeListCtor:nl, toString:function () {
            return this.join(",");
        }, _stash:function (parent) {
            this._parent = parent;
            return this;
        }, on:function (eventName, listener) {
            var handles = this.map(function (node) {
                return on(node, eventName, listener);
            });
            handles.remove = function () {
                for (var i = 0; i < handles.length; i++) {
                    handles[i].remove();
                }
            };
            return handles;
        }, end:function () {
            if (this._parent) {
                return this._parent;
            } else {
                return new this._NodeListCtor(0);
            }
        }, concat:function (item) {
            var t = aps.call(this, 0), m = array.map(arguments, function (a) {
                return aps.call(a, 0);
            });
            return this._wrap(apc.apply(t, m), this);
        }, map:function (func, obj) {
            return this._wrap(array.map(this, func, obj), this);
        }, forEach:function (callback, thisObj) {
            forEach(this, callback, thisObj);
            return this;
        }, filter:function (filter) {
            var a = arguments, items = this, start = 0;
            if (typeof filter == "string") {
                items = query._filterResult(this, a[0]);
                if (a.length == 1) {
                    return items._stash(this);
                }
                start = 1;
            }
            return this._wrap(array.filter(items, a[start], a[start + 1]), this);
        }, instantiate:function (declaredClass, properties) {
            var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
            properties = properties || {};
            return this.forEach(function (node) {
                new c(properties, node);
            });
        }, at:function () {
            var t = new this._NodeListCtor(0);
            forEach(arguments, function (i) {
                if (i < 0) {
                    i = this.length + i;
                }
                if (this[i]) {
                    t.push(this[i]);
                }
            }, this);
            return t._stash(this);
        }});
        function queryForEngine(engine, NodeList) {
            var query = function (query, root) {
                if (typeof root == "string") {
                    root = dom.byId(root);
                    if (!root) {
                        return new NodeList([]);
                    }
                }
                var results = typeof query == "string" ? engine(query, root) : query ? (query.end && query.on) ? query : [query] : [];
                if (results.end && results.on) {
                    return results;
                }
                return new NodeList(results);
            };
            query.matches = engine.match || function (node, selector, root) {
                return query.filter([node], selector, root).length > 0;
            };
            query.filter = engine.filter || function (nodes, selector, root) {
                return query(selector, root).filter(function (node) {
                    return array.indexOf(nodes, node) > -1;
                });
            };
            if (typeof engine != "function") {
                var search = engine.search;
                engine = function (selector, root) {
                    return search(root || document, selector);
                };
            }
            return query;
        }
        var query = queryForEngine(defaultEngine, NodeList);
        dojo.query = queryForEngine(defaultEngine, function (array) {
            return NodeList(array);
        });
        query.load = function (id, parentRequire, loaded) {
            loader.load(id, parentRequire, function (engine) {
                loaded(queryForEngine(engine, NodeList));
            });
        };
        dojo._filterQueryResult = query._filterResult = function (nodes, selector, root) {
            return new NodeList(query.filter(nodes, selector, root));
        };
        dojo.NodeList = query.NodeList = NodeList;
        return query;
    });
}, "dojox/timing/_base":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang"], function (dojo) {
        dojo.experimental("dojox.timing");
        dojo.getObject("timing", true, dojox);
        dojox.timing.Timer = function (interval) {
            this.timer = null;
            this.isRunning = false;
            this.interval = interval;
            this.onStart = null;
            this.onStop = null;
        };
        dojo.extend(dojox.timing.Timer, {onTick:function () {
        }, setInterval:function (interval) {
            if (this.isRunning) {
                window.clearInterval(this.timer);
            }
            this.interval = interval;
            if (this.isRunning) {
                this.timer = window.setInterval(dojo.hitch(this, "onTick"), this.interval);
            }
        }, start:function () {
            if (typeof this.onStart == "function") {
                this.onStart();
            }
            this.isRunning = true;
            this.timer = window.setInterval(dojo.hitch(this, "onTick"), this.interval);
        }, stop:function () {
            if (typeof this.onStop == "function") {
                this.onStop();
            }
            this.isRunning = false;
            window.clearInterval(this.timer);
        }});
        return dojox.timing;
    });
}, "dojo/request/util":function () {
    define(["exports", "../errors/RequestError", "../errors/CancelError", "../Deferred", "../io-query", "../_base/array", "../_base/lang", "../promise/Promise"], function (exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise) {
        exports.deepCopy = function deepCopy(target, source) {
            for (var name in source) {
                var tval = target[name], sval = source[name];
                if (tval !== sval) {
                    if (tval && typeof tval === "object" && sval && typeof sval === "object") {
                        exports.deepCopy(tval, sval);
                    } else {
                        target[name] = sval;
                    }
                }
            }
            return target;
        };
        exports.deepCreate = function deepCreate(source, properties) {
            properties = properties || {};
            var target = lang.delegate(source), name, value;
            for (name in source) {
                value = source[name];
                if (value && typeof value === "object") {
                    target[name] = exports.deepCreate(value, properties[name]);
                }
            }
            return exports.deepCopy(target, properties);
        };
        var freeze = Object.freeze || function (obj) {
            return obj;
        };
        function okHandler(response) {
            return freeze(response);
        }
        function dataHandler(response) {
            return response.data || response.text;
        }
        exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last) {
            var def = new Deferred(function (reason) {
                cancel && cancel(def, response);
                if (!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)) {
                    return new CancelError("Request canceled", response);
                }
                return reason;
            });
            def.response = response;
            def.isValid = isValid;
            def.isReady = isReady;
            def.handleResponse = handleResponse;
            function errHandler(error) {
                error.response = response;
                throw error;
            }
            var responsePromise = def.then(okHandler).otherwise(errHandler);
            if (exports.notify) {
                responsePromise.then(lang.hitch(exports.notify, "emit", "load"), lang.hitch(exports.notify, "emit", "error"));
            }
            var dataPromise = responsePromise.then(dataHandler);
            var promise = new Promise();
            for (var prop in dataPromise) {
                if (dataPromise.hasOwnProperty(prop)) {
                    promise[prop] = dataPromise[prop];
                }
            }
            promise.response = responsePromise;
            freeze(promise);
            if (last) {
                def.then(function (response) {
                    last.call(def, response);
                }, function (error) {
                    last.call(def, response, error);
                });
            }
            def.promise = promise;
            def.then = promise.then;
            return def;
        };
        exports.addCommonMethods = function addCommonMethods(provider, methods) {
            array.forEach(methods || ["GET", "POST", "PUT", "DELETE"], function (method) {
                provider[(method === "DELETE" ? "DEL" : method).toLowerCase()] = function (url, options) {
                    options = lang.delegate(options || {});
                    options.method = method;
                    return provider(url, options);
                };
            });
        };
        exports.parseArgs = function parseArgs(url, options, skipData) {
            var data = options.data, query = options.query;
            if (data && !skipData) {
                if (typeof data === "object") {
                    options.data = ioQuery.objectToQuery(data);
                }
            }
            if (query) {
                if (typeof query === "object") {
                    query = ioQuery.objectToQuery(query);
                }
                if (options.preventCache) {
                    query += (query ? "&" : "") + "request.preventCache=" + (+(new Date));
                }
            } else {
                if (options.preventCache) {
                    query = "request.preventCache=" + (+(new Date));
                }
            }
            if (url && query) {
                url += (~url.indexOf("?") ? "&" : "?") + query;
            }
            return {url:url, options:options, getHeader:function (headerName) {
                return null;
            }};
        };
        exports.checkStatus = function (stat) {
            stat = stat || 0;
            return (stat >= 200 && stat < 300) || stat === 304 || stat === 1223 || !stat;
        };
    });
}, "dijit/dijit":function () {
    define(["./main", "./_base", "dojo/parser", "./_Widget", "./_TemplatedMixin", "./_Container", "./layout/_LayoutWidget", "./form/_FormWidget", "./form/_FormValueWidget"], function (dijit) {
        return dijit;
    });
}, "dijit/form/NumberSpinner":function () {
    define(["dojo/_base/declare", "dojo/keys", "./_Spinner", "./NumberTextBox"], function (declare, keys, _Spinner, NumberTextBox) {
        return declare("dijit.form.NumberSpinner", [_Spinner, NumberTextBox.Mixin], {baseClass:"dijitTextBox dijitSpinner dijitNumberTextBox", adjust:function (val, delta) {
            var tc = this.constraints, v = isNaN(val), gotMax = !isNaN(tc.max), gotMin = !isNaN(tc.min);
            if (v && delta != 0) {
                val = (delta > 0) ? gotMin ? tc.min : gotMax ? tc.max : 0 : gotMax ? this.constraints.max : gotMin ? tc.min : 0;
            }
            var newval = val + delta;
            if (v || isNaN(newval)) {
                return val;
            }
            if (gotMax && (newval > tc.max)) {
                newval = tc.max;
            }
            if (gotMin && (newval < tc.min)) {
                newval = tc.min;
            }
            return newval;
        }, _onKeyDown:function (e) {
            if (this.disabled || this.readOnly) {
                return;
            }
            if ((e.keyCode == keys.HOME || e.keyCode == keys.END) && !(e.ctrlKey || e.altKey || e.metaKey) && typeof this.get("value") != "undefined") {
                var value = this.constraints[(e.keyCode == keys.HOME ? "min" : "max")];
                if (typeof value == "number") {
                    this._setValueAttr(value, false);
                }
                e.stopPropagation();
                e.preventDefault();
            }
        }});
    });
}, "dijit/MenuItem":function () {
    define(["dojo/_base/declare", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/_base/kernel", "dojo/sniff", "dojo/_base/lang", "./_Widget", "./_TemplatedMixin", "./_Contained", "./_CssStateMixin", "dojo/text!./templates/MenuItem.html"], function (declare, dom, domAttr, domClass, kernel, has, lang, _Widget, _TemplatedMixin, _Contained, _CssStateMixin, template) {
        var MenuItem = declare("dijit.MenuItem" + (has("dojo-bidi") ? "_NoBidi" : ""), [_Widget, _TemplatedMixin, _Contained, _CssStateMixin], {templateString:template, baseClass:"dijitMenuItem", label:"", _setLabelAttr:function (val) {
            this._set("label", val);
            var shortcutKey = "";
            var text;
            var ndx = val.search(/{\S}/);
            if (ndx >= 0) {
                shortcutKey = val.charAt(ndx + 1);
                var prefix = val.substr(0, ndx);
                var suffix = val.substr(ndx + 3);
                text = prefix + shortcutKey + suffix;
                val = prefix + "<span class=\"dijitMenuItemShortcutKey\">" + shortcutKey + "</span>" + suffix;
            } else {
                text = val;
            }
            this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
            this.containerNode.innerHTML = val;
            this._set("shortcutKey", shortcutKey);
        }, iconClass:"dijitNoIcon", _setIconClassAttr:{node:"iconNode", type:"class"}, accelKey:"", disabled:false, _fillContent:function (source) {
            if (source && !("label" in this.params)) {
                this._set("label", source.innerHTML);
            }
        }, buildRendering:function () {
            this.inherited(arguments);
            var label = this.id + "_text";
            domAttr.set(this.containerNode, "id", label);
            if (this.accelKeyNode) {
                domAttr.set(this.accelKeyNode, "id", this.id + "_accel");
            }
            dom.setSelectable(this.domNode, false);
        }, onClick:function () {
        }, focus:function () {
            try {
                if (has("ie") == 8) {
                    this.containerNode.focus();
                }
                this.focusNode.focus();
            }
            catch (e) {
            }
        }, _onFocus:function () {
            this.getParent()._onItemFocus(this);
            this.inherited(arguments);
        }, _setSelected:function (selected) {
            domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
        }, setLabel:function (content) {
            kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
            this.set("label", content);
        }, setDisabled:function (disabled) {
            kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
            this.set("disabled", disabled);
        }, _setDisabledAttr:function (value) {
            this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
            this._set("disabled", value);
        }, _setAccelKeyAttr:function (value) {
            if (this.accelKeyNode) {
                this.accelKeyNode.style.display = value ? "" : "none";
                this.accelKeyNode.innerHTML = value;
                domAttr.set(this.containerNode, "colSpan", value ? "1" : "2");
            }
            this._set("accelKey", value);
        }});
        if (has("dojo-bidi")) {
            MenuItem = declare("dijit.MenuItem", MenuItem, {_setLabelAttr:function (val) {
                this.inherited(arguments);
                if (this.textDir === "auto") {
                    this.applyTextDir(this.textDirNode);
                }
            }});
        }
        return MenuItem;
    });
}, "dijit/_AttachMixin":function () {
    define(["require", "dojo/_base/array", "dojo/_base/connect", "dojo/_base/declare", "dojo/_base/lang", "dojo/mouse", "dojo/on", "dojo/touch", "./_WidgetBase"], function (require, array, connect, declare, lang, mouse, on, touch, _WidgetBase) {
        var synthEvents = lang.delegate(touch, {"mouseenter":mouse.enter, "mouseleave":mouse.leave, "keypress":connect._keypress});
        var a11yclick;
        var _AttachMixin = declare("dijit._AttachMixin", null, {constructor:function () {
            this._attachPoints = [];
            this._attachEvents = [];
        }, buildRendering:function () {
            this.inherited(arguments);
            this._attachTemplateNodes(this.domNode);
            this._beforeFillContent();
        }, _beforeFillContent:function () {
        }, _attachTemplateNodes:function (rootNode) {
            var node = rootNode;
            while (true) {
                if (node.nodeType == 1 && (this._processTemplateNode(node, function (n, p) {
                    return n.getAttribute(p);
                }, this._attach) || this.searchContainerNode) && node.firstChild) {
                    node = node.firstChild;
                } else {
                    if (node == rootNode) {
                        return;
                    }
                    while (!node.nextSibling) {
                        node = node.parentNode;
                        if (node == rootNode) {
                            return;
                        }
                    }
                    node = node.nextSibling;
                }
            }
        }, _processTemplateNode:function (baseNode, getAttrFunc, attachFunc) {
            var ret = true;
            var _attachScope = this.attachScope || this, attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
            if (attachPoint) {
                var point, points = attachPoint.split(/\s*,\s*/);
                while ((point = points.shift())) {
                    if (lang.isArray(_attachScope[point])) {
                        _attachScope[point].push(baseNode);
                    } else {
                        _attachScope[point] = baseNode;
                    }
                    ret = (point != "containerNode");
                    this._attachPoints.push(point);
                }
            }
            var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
            if (attachEvent) {
                var event, events = attachEvent.split(/\s*,\s*/);
                var trim = lang.trim;
                while ((event = events.shift())) {
                    if (event) {
                        var thisFunc = null;
                        if (event.indexOf(":") != -1) {
                            var funcNameArr = event.split(":");
                            event = trim(funcNameArr[0]);
                            thisFunc = trim(funcNameArr[1]);
                        } else {
                            event = trim(event);
                        }
                        if (!thisFunc) {
                            thisFunc = event;
                        }
                        this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
                    }
                }
            }
            return ret;
        }, _attach:function (node, type, func) {
            type = type.replace(/^on/, "").toLowerCase();
            if (type == "dijitclick") {
                type = a11yclick || (a11yclick = require("./a11yclick"));
            } else {
                type = synthEvents[type] || type;
            }
            return on(node, type, func);
        }, _detachTemplateNodes:function () {
            var _attachScope = this.attachScope || this;
            array.forEach(this._attachPoints, function (point) {
                delete _attachScope[point];
            });
            this._attachPoints = [];
            array.forEach(this._attachEvents, function (handle) {
                handle.remove();
            });
            this._attachEvents = [];
        }, destroyRendering:function () {
            this._detachTemplateNodes();
            this.inherited(arguments);
        }});
        lang.extend(_WidgetBase, {dojoAttachEvent:"", dojoAttachPoint:""});
        return _AttachMixin;
    });
}, "dojox/grid/_EditManager":function () {
    define(["dojo/_base/lang", "dojo/_base/array", "dojo/_base/declare", "dojo/_base/connect", "dojo/_base/sniff", "./util"], function (lang, array, declare, connect, has, util) {
        return declare("dojox.grid._EditManager", null, {constructor:function (inGrid) {
            this.grid = inGrid;
            this.connections = !has("ie") ? [] : [connect.connect(document.body, "onfocus", lang.hitch(this, "_boomerangFocus"))];
            this.connections.push(connect.connect(this.grid, "onBlur", this, "apply"));
            this.connections.push(connect.connect(this.grid, "prerender", this, "_onPreRender"));
        }, info:{}, destroy:function () {
            array.forEach(this.connections, connect.disconnect);
        }, cellFocus:function (inCell, inRowIndex) {
            if (this.grid.singleClickEdit || this.isEditRow(inRowIndex)) {
                this.setEditCell(inCell, inRowIndex);
            } else {
                this.apply();
            }
            if (this.isEditing() || (inCell && inCell.editable && inCell.alwaysEditing)) {
                this._focusEditor(inCell, inRowIndex);
            }
        }, rowClick:function (e) {
            if (this.isEditing() && !this.isEditRow(e.rowIndex)) {
                this.apply();
            }
        }, styleRow:function (inRow) {
            if (inRow.index == this.info.rowIndex) {
                inRow.customClasses += " dojoxGridRowEditing";
            }
        }, dispatchEvent:function (e) {
            var c = e.cell, ed = (c && c["editable"]) ? c : 0;
            return ed && ed.dispatchEvent(e.dispatch, e);
        }, isEditing:function () {
            return this.info.rowIndex !== undefined;
        }, isEditCell:function (inRowIndex, inCellIndex) {
            return (this.info.rowIndex === inRowIndex) && (this.info.cell.index == inCellIndex);
        }, isEditRow:function (inRowIndex) {
            return this.info.rowIndex === inRowIndex;
        }, setEditCell:function (inCell, inRowIndex) {
            if (!this.isEditCell(inRowIndex, inCell.index) && this.grid.canEdit && this.grid.canEdit(inCell, inRowIndex)) {
                this.start(inCell, inRowIndex, this.isEditRow(inRowIndex) || inCell.editable);
            }
        }, _focusEditor:function (inCell, inRowIndex) {
            util.fire(inCell, "focus", [inRowIndex]);
        }, focusEditor:function () {
            if (this.isEditing()) {
                this._focusEditor(this.info.cell, this.info.rowIndex);
            }
        }, _boomerangWindow:500, _shouldCatchBoomerang:function () {
            return this._catchBoomerang > new Date().getTime();
        }, _boomerangFocus:function () {
            if (this._shouldCatchBoomerang()) {
                this.grid.focus.focusGrid();
                this.focusEditor();
                this._catchBoomerang = 0;
            }
        }, _doCatchBoomerang:function () {
            if (has("ie")) {
                this._catchBoomerang = new Date().getTime() + this._boomerangWindow;
            }
        }, start:function (inCell, inRowIndex, inEditing) {
            if (!this._isValidInput()) {
                return;
            }
            this.grid.beginUpdate();
            this.editorApply();
            if (this.isEditing() && !this.isEditRow(inRowIndex)) {
                this.applyRowEdit();
                this.grid.updateRow(inRowIndex);
            }
            if (inEditing) {
                this.info = {cell:inCell, rowIndex:inRowIndex};
                this.grid.doStartEdit(inCell, inRowIndex);
                this.grid.updateRow(inRowIndex);
            } else {
                this.info = {};
            }
            this.grid.endUpdate();
            this.grid.focus.focusGrid();
            this._focusEditor(inCell, inRowIndex);
            this._doCatchBoomerang();
        }, _editorDo:function (inMethod) {
            var c = this.info.cell;
            if (c && c.editable) {
                c[inMethod](this.info.rowIndex);
            }
        }, editorApply:function () {
            this._editorDo("apply");
        }, editorCancel:function () {
            this._editorDo("cancel");
        }, applyCellEdit:function (inValue, inCell, inRowIndex) {
            if (this.grid.canEdit(inCell, inRowIndex)) {
                this.grid.doApplyCellEdit(inValue, inRowIndex, inCell.field);
            }
        }, applyRowEdit:function () {
            this.grid.doApplyEdit(this.info.rowIndex, this.info.cell.field);
        }, apply:function () {
            if (this.isEditing() && this._isValidInput()) {
                this.grid.beginUpdate();
                this.editorApply();
                this.applyRowEdit();
                this.info = {};
                this.grid.endUpdate();
                this.grid.focus.focusGrid();
                this._doCatchBoomerang();
            }
        }, cancel:function () {
            if (this.isEditing()) {
                this.grid.beginUpdate();
                this.editorCancel();
                this.info = {};
                this.grid.endUpdate();
                this.grid.focus.focusGrid();
                this._doCatchBoomerang();
            }
        }, save:function (inRowIndex, inView) {
            var c = this.info.cell;
            if (this.isEditRow(inRowIndex) && (!inView || c.view == inView) && c.editable) {
                c.save(c, this.info.rowIndex);
            }
        }, restore:function (inView, inRowIndex) {
            var c = this.info.cell;
            if (this.isEditRow(inRowIndex) && c.view == inView && c.editable) {
                c.restore(this.info.rowIndex);
            }
        }, _isValidInput:function () {
            var w = (this.info.cell || {}).widget;
            if (!w || !w.isValid) {
                return true;
            }
            w.focused = true;
            return w.isValid(true);
        }, _onPreRender:function () {
            if (this.isEditing()) {
                this.info.value = this.info.cell.getValue();
            }
        }});
    });
}, "dojox/grid/_ViewManager":function () {
    define(["dojo/_base/declare", "dojo/_base/sniff", "dojo/dom-class"], function (declare, has, domClass) {
        return declare("dojox.grid._ViewManager", null, {constructor:function (inGrid) {
            this.grid = inGrid;
        }, defaultWidth:200, views:[], resize:function () {
            this.onEach("resize");
        }, render:function () {
            this.onEach("render");
        }, addView:function (inView) {
            inView.idx = this.views.length;
            this.views.push(inView);
        }, destroyViews:function () {
            for (var i = 0, v; v = this.views[i]; i++) {
                v.destroy();
            }
            this.views = [];
        }, getContentNodes:function () {
            var nodes = [];
            for (var i = 0, v; v = this.views[i]; i++) {
                nodes.push(v.contentNode);
            }
            return nodes;
        }, forEach:function (inCallback) {
            for (var i = 0, v; v = this.views[i]; i++) {
                inCallback(v, i);
            }
        }, onEach:function (inMethod, inArgs) {
            inArgs = inArgs || [];
            for (var i = 0, v; v = this.views[i]; i++) {
                if (inMethod in v) {
                    v[inMethod].apply(v, inArgs);
                }
            }
        }, normalizeHeaderNodeHeight:function () {
            var rowNodes = [];
            for (var i = 0, v; (v = this.views[i]); i++) {
                if (v.headerContentNode.firstChild) {
                    rowNodes.push(v.headerContentNode);
                }
            }
            this.normalizeRowNodeHeights(rowNodes);
        }, normalizeRowNodeHeights:function (inRowNodes) {
            var h = 0;
            var currHeights = [];
            if (this.grid.rowHeight) {
                h = this.grid.rowHeight;
            } else {
                if (inRowNodes.length <= 1) {
                    return;
                }
                for (var i = 0, n; (n = inRowNodes[i]); i++) {
                    if (!domClass.contains(n, "dojoxGridNonNormalizedCell")) {
                        currHeights[i] = n.firstChild.offsetHeight;
                        h = Math.max(h, currHeights[i]);
                    }
                }
                h = (h >= 0 ? h : 0);
                if ((has("mozilla") || has("ie") > 8) && h) {
                    h++;
                }
            }
            for (i = 0; (n = inRowNodes[i]); i++) {
                if (currHeights[i] != h) {
                    n.firstChild.style.height = h + "px";
                }
            }
        }, resetHeaderNodeHeight:function () {
            for (var i = 0, v, n; (v = this.views[i]); i++) {
                n = v.headerContentNode.firstChild;
                if (n) {
                    n.style.height = "";
                }
            }
        }, renormalizeRow:function (inRowIndex) {
            var rowNodes = [];
            for (var i = 0, v, n; (v = this.views[i]) && (n = v.getRowNode(inRowIndex)); i++) {
                n.firstChild.style.height = "";
                rowNodes.push(n);
            }
            this.normalizeRowNodeHeights(rowNodes);
        }, getViewWidth:function (inIndex) {
            return this.views[inIndex].getWidth() || this.defaultWidth;
        }, measureHeader:function () {
            this.resetHeaderNodeHeight();
            this.forEach(function (inView) {
                inView.headerContentNode.style.height = "";
            });
            var h = 0;
            this.forEach(function (inView) {
                h = Math.max(inView.headerNode.offsetHeight, h);
            });
            return h;
        }, measureContent:function () {
            var h = 0;
            this.forEach(function (inView) {
                h = Math.max(inView.domNode.offsetHeight, h);
            });
            return h;
        }, findClient:function (inAutoWidth) {
            var c = this.grid.elasticView || -1;
            if (c < 0) {
                for (var i = 1, v; (v = this.views[i]); i++) {
                    if (v.viewWidth) {
                        for (i = 1; (v = this.views[i]); i++) {
                            if (!v.viewWidth) {
                                c = i;
                                break;
                            }
                        }
                        break;
                    }
                }
            }
            if (c < 0) {
                c = Math.floor(this.views.length / 2);
            }
            return c;
        }, arrange:function (l, w) {
            var i, v, vw, len = this.views.length, self = this;
            var c = (w <= 0 ? len : this.findClient());
            var setPosition = function (v, l) {
                var ds = v.domNode.style;
                var hs = v.headerNode.style;
                if (!self.grid.isLeftToRight()) {
                    ds.right = l + "px";
                    if (has("ff") < 4) {
                        hs.right = l + v.getScrollbarWidth() + "px";
                    } else {
                        hs.right = l + "px";
                    }
                    if (!has("webkit") && hs.width != "auto") {
                        hs.width = parseInt(hs.width, 10) - v.getScrollbarWidth() + "px";
                    }
                } else {
                    ds.left = l + "px";
                    hs.left = l + "px";
                }
                ds.top = 0 + "px";
                hs.top = 0;
            };
            for (i = 0; (v = this.views[i]) && (i < c); i++) {
                vw = this.getViewWidth(i);
                v.setSize(vw, 0);
                setPosition(v, l);
                if (v.headerContentNode && v.headerContentNode.firstChild) {
                    vw = v.getColumnsWidth() + v.getScrollbarWidth();
                } else {
                    vw = v.domNode.offsetWidth;
                }
                l += vw;
            }
            i++;
            var r = w;
            for (var j = len - 1; (v = this.views[j]) && (i <= j); j--) {
                vw = this.getViewWidth(j);
                v.setSize(vw, 0);
                vw = v.domNode.offsetWidth;
                r -= vw;
                setPosition(v, r);
            }
            if (c < len) {
                v = this.views[c];
                vw = Math.max(1, r - l);
                v.setSize(vw + "px", 0);
                setPosition(v, l);
            }
            return l;
        }, renderRow:function (inRowIndex, inNodes, skipRenorm) {
            var rowNodes = [];
            for (var i = 0, v, n, rowNode; (v = this.views[i]) && (n = inNodes[i]); i++) {
                rowNode = v.renderRow(inRowIndex);
                n.appendChild(rowNode);
                rowNodes.push(rowNode);
            }
            if (!skipRenorm) {
                this.normalizeRowNodeHeights(rowNodes);
            }
        }, rowRemoved:function (inRowIndex) {
            this.onEach("rowRemoved", [inRowIndex]);
        }, updateRow:function (inRowIndex, skipRenorm) {
            for (var i = 0, v; v = this.views[i]; i++) {
                v.updateRow(inRowIndex);
            }
            if (!skipRenorm) {
                this.renormalizeRow(inRowIndex);
            }
        }, updateRowStyles:function (inRowIndex) {
            this.onEach("updateRowStyles", [inRowIndex]);
        }, setScrollTop:function (inTop) {
            var top = inTop;
            for (var i = 0, v; v = this.views[i]; i++) {
                top = v.setScrollTop(inTop);
                if (has("ie") && v.headerNode && v.scrollboxNode) {
                    v.headerNode.scrollLeft = v.scrollboxNode.scrollLeft;
                }
            }
            return top;
        }, getFirstScrollingView:function () {
            for (var i = 0, v; (v = this.views[i]); i++) {
                if (v.hasHScrollbar() || v.hasVScrollbar()) {
                    return v;
                }
            }
            return null;
        }});
    });
}, "dojo/ready":function () {
    define(["./_base/kernel", "./has", "require", "./domReady", "./_base/lang"], function (dojo, has, require, domReady, lang) {
        var isDomReady = 0, loadQ = [], onLoadRecursiveGuard = 0, handleDomReady = function () {
            isDomReady = 1;
            dojo._postLoad = dojo.config.afterOnLoad = true;
            onEvent();
        }, onEvent = function () {
            if (onLoadRecursiveGuard) {
                return;
            }
            onLoadRecursiveGuard = 1;
            while (isDomReady && (!domReady || domReady._Q.length == 0) && (require.idle ? require.idle() : true) && loadQ.length) {
                var f = loadQ.shift();
                try {
                    f();
                }
                catch (e) {
                    e.info = e.message;
                    if (require.signal) {
                        require.signal("error", e);
                    } else {
                        throw e;
                    }
                }
            }
            onLoadRecursiveGuard = 0;
        };
        require.on && require.on("idle", onEvent);
        if (domReady) {
            domReady._onQEmpty = onEvent;
        }
        var ready = dojo.ready = dojo.addOnLoad = function (priority, context, callback) {
            var hitchArgs = lang._toArray(arguments);
            if (typeof priority != "number") {
                callback = context;
                context = priority;
                priority = 1000;
            } else {
                hitchArgs.shift();
            }
            callback = callback ? lang.hitch.apply(dojo, hitchArgs) : function () {
                context();
            };
            callback.priority = priority;
            for (var i = 0; i < loadQ.length && priority >= loadQ[i].priority; i++) {
            }
            loadQ.splice(i, 0, callback);
            onEvent();
        };
        1 || has.add("dojo-config-addOnLoad", 1);
        if (1) {
            var dca = dojo.config.addOnLoad;
            if (dca) {
                ready[(lang.isArray(dca) ? "apply" : "call")](dojo, dca);
            }
        }
        if (1 && dojo.config.parseOnLoad && !dojo.isAsync) {
            ready(99, function () {
                if (!dojo.parser) {
                    dojo.deprecated("Add explicit require(['dojo/parser']);", "", "2.0");
                    require(["dojo/parser"]);
                }
            });
        }
        if (domReady) {
            domReady(handleDomReady);
        } else {
            handleDomReady();
        }
        return ready;
    });
}, "dijit/DropDownMenu":function () {
    define(["dojo/_base/declare", "dojo/keys", "dojo/text!./templates/Menu.html", "./_OnDijitClickMixin", "./_MenuBase"], function (declare, keys, template, _OnDijitClickMixin, _MenuBase) {
        return declare("dijit.DropDownMenu", [_MenuBase, _OnDijitClickMixin], {templateString:template, baseClass:"dijitMenu", _onUpArrow:function () {
            this.focusPrev();
        }, _onDownArrow:function () {
            this.focusNext();
        }, _onRightArrow:function (evt) {
            this._moveToPopup(evt);
            evt.stopPropagation();
            evt.preventDefault();
        }, _onLeftArrow:function (evt) {
            if (this.parentMenu) {
                if (this.parentMenu._isMenuBar) {
                    this.parentMenu.focusPrev();
                } else {
                    this.onCancel(false);
                }
            } else {
                evt.stopPropagation();
                evt.preventDefault();
            }
        }});
    });
}, "dojo/mouse":function () {
    define(["./_base/kernel", "./on", "./has", "./dom", "./_base/window"], function (dojo, on, has, dom, win) {
        has.add("dom-quirks", win.doc && win.doc.compatMode == "BackCompat");
        has.add("events-mouseenter", win.doc && "onmouseenter" in win.doc.createElement("div"));
        has.add("events-mousewheel", win.doc && "onmousewheel" in win.doc);
        var mouseButtons;
        if ((has("dom-quirks") && has("ie")) || !has("dom-addeventlistener")) {
            mouseButtons = {LEFT:1, MIDDLE:4, RIGHT:2, isButton:function (e, button) {
                return e.button & button;
            }, isLeft:function (e) {
                return e.button & 1;
            }, isMiddle:function (e) {
                return e.button & 4;
            }, isRight:function (e) {
                return e.button & 2;
            }};
        } else {
            mouseButtons = {LEFT:0, MIDDLE:1, RIGHT:2, isButton:function (e, button) {
                return e.button == button;
            }, isLeft:function (e) {
                return e.button == 0;
            }, isMiddle:function (e) {
                return e.button == 1;
            }, isRight:function (e) {
                return e.button == 2;
            }};
        }
        dojo.mouseButtons = mouseButtons;
        function eventHandler(type, selectHandler) {
            var handler = function (node, listener) {
                return on(node, type, function (evt) {
                    if (selectHandler) {
                        return selectHandler(evt, listener);
                    }
                    if (!dom.isDescendant(evt.relatedTarget, node)) {
                        return listener.call(this, evt);
                    }
                });
            };
            handler.bubble = function (select) {
                return eventHandler(type, function (evt, listener) {
                    var target = select(evt.target);
                    var relatedTarget = evt.relatedTarget;
                    if (target && (target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget)))) {
                        return listener.call(target, evt);
                    }
                });
            };
            return handler;
        }
        var wheel;
        if (has("events-mousewheel")) {
            wheel = "mousewheel";
        } else {
            wheel = function (node, listener) {
                return on(node, "DOMMouseScroll", function (evt) {
                    evt.wheelDelta = -evt.detail;
                    listener.call(this, evt);
                });
            };
        }
        return {_eventHandler:eventHandler, enter:eventHandler("mouseover"), leave:eventHandler("mouseout"), wheel:wheel, isLeft:mouseButtons.isLeft, isMiddle:mouseButtons.isMiddle, isRight:mouseButtons.isRight};
    });
}, "dijit/_base/typematic":function () {
    define(["../typematic"], function () {
    });
}, "dojo/aspect":function () {
    define([], function () {
        "use strict";
        var undefined, nextId = 0;
        function advise(dispatcher, type, advice, receiveArguments) {
            var previous = dispatcher[type];
            var around = type == "around";
            var signal;
            if (around) {
                var advised = advice(function () {
                    return previous.advice(this, arguments);
                });
                signal = {remove:function () {
                    if (advised) {
                        advised = dispatcher = advice = null;
                    }
                }, advice:function (target, args) {
                    return advised ? advised.apply(target, args) : previous.advice(target, args);
                }};
            } else {
                signal = {remove:function () {
                    if (signal.advice) {
                        var previous = signal.previous;
                        var next = signal.next;
                        if (!next && !previous) {
                            delete dispatcher[type];
                        } else {
                            if (previous) {
                                previous.next = next;
                            } else {
                                dispatcher[type] = next;
                            }
                            if (next) {
                                next.previous = previous;
                            }
                        }
                        dispatcher = advice = signal.advice = null;
                    }
                }, id:nextId++, advice:advice, receiveArguments:receiveArguments};
            }
            if (previous && !around) {
                if (type == "after") {
                    while (previous.next && (previous = previous.next)) {
                    }
                    previous.next = signal;
                    signal.previous = previous;
                } else {
                    if (type == "before") {
                        dispatcher[type] = signal;
                        signal.next = previous;
                        previous.previous = signal;
                    }
                }
            } else {
                dispatcher[type] = signal;
            }
            return signal;
        }
        function aspect(type) {
            return function (target, methodName, advice, receiveArguments) {
                var existing = target[methodName], dispatcher;
                if (!existing || existing.target != target) {
                    target[methodName] = dispatcher = function () {
                        var executionId = nextId;
                        var args = arguments;
                        var before = dispatcher.before;
                        while (before) {
                            args = before.advice.apply(this, args) || args;
                            before = before.next;
                        }
                        if (dispatcher.around) {
                            var results = dispatcher.around.advice(this, args);
                        }
                        var after = dispatcher.after;
                        while (after && after.id < executionId) {
                            if (after.receiveArguments) {
                                var newResults = after.advice.apply(this, args);
                                results = newResults === undefined ? results : newResults;
                            } else {
                                results = after.advice.call(this, results, args);
                            }
                            after = after.next;
                        }
                        return results;
                    };
                    if (existing) {
                        dispatcher.around = {advice:function (target, args) {
                            return existing.apply(target, args);
                        }};
                    }
                    dispatcher.target = target;
                }
                var results = advise((dispatcher || existing), type, advice, receiveArguments);
                advice = null;
                return results;
            };
        }
        var after = aspect("after");
        var before = aspect("before");
        var around = aspect("around");
        return {before:before, around:around, after:after};
    });
}, "dojo/_base/sniff":function () {
    define(["./kernel", "./lang", "../sniff"], function (dojo, lang, has) {
        if (!1) {
            return has;
        }
        dojo._name = "browser";
        lang.mixin(dojo, {isBrowser:true, isFF:has("ff"), isIE:has("ie"), isKhtml:has("khtml"), isWebKit:has("webkit"), isMozilla:has("mozilla"), isMoz:has("mozilla"), isOpera:has("opera"), isSafari:has("safari"), isChrome:has("chrome"), isMac:has("mac"), isIos:has("ios"), isAndroid:has("android"), isWii:has("wii"), isQuirks:has("quirks"), isAir:has("air")});
        return has;
    });
}, "dojox/grid/bidi/_BidiMixin":function () {
    define(["../../main", "dojo/_base/lang", "../_Builder", "dijit/_BidiSupport", "../_Grid", "../cells/_base", "../cells/dijit"], function (dojox, lang, _Builder, _BidiSupport, _Grid, BaseCell, cellsDijit) {
        lang.extend(_Grid, {setCellNodeTextDirection:function (inColIndex, inRowIndex, textDir) {
            this.getCell(inColIndex).getNode(inRowIndex).style.direction = textDir || "";
        }, getCellNodeTextDirection:function (inColIndex, inRowIndex) {
            return this.getCell(inColIndex).getNode(inRowIndex).style.direction;
        }, _setTextDirAttr:function (textDir) {
            this.textDir = textDir;
            this.render();
        }});
        lang.extend(_Builder._ContentBuilder, {_getTextDirStyle:function (textDir, inCell, inRowIndex) {
            var item = this.grid.getItem(inRowIndex), ret = "";
            if (textDir === "auto") {
                var name = inCell.get ? inCell.get(inRowIndex, item) : (inCell.value || inCell.defaultValue);
                if (name) {
                    textDir = _BidiSupport.prototype._checkContextual(name);
                }
            }
            ret = " direction:" + textDir + ";";
            return ret;
        }});
        lang.extend(_Builder._HeaderBuilder, {_getTextDirStyle:function (textDir, inCell, inValue) {
            if (textDir === "auto") {
                var name = inValue || inCell.name || inCell.grid.getCellName(inCell);
                if (name) {
                    textDir = _BidiSupport.prototype._checkContextual(name);
                }
            }
            return (" direction:" + textDir + "; ");
        }});
        lang.extend(BaseCell.Cell, {LRE:"\u202a", RLE:"\u202b", PDF:"\u202c", KEY_HANDLER:"onkeyup=' javascript:(function(){" + "var target; if (event.target) target = event.target; else if (event.srcElement) target = event.srcElement; if(!target) return;" + "var regExMatch = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(target.value);" + "target.dir = regExMatch ? ( regExMatch[0] <= \"z\" ? \"ltr\" : \"rtl\" ) : target.dir ? target.dir : \"ltr\"; })();'", _getTextDirMarkup:function (inDatum) {
            var textDirMarkup = "", textDir = this.textDir || this.grid.textDir;
            if (textDir) {
                if (textDir === "auto") {
                    textDirMarkup = this.KEY_HANDLER;
                    textDir = _BidiSupport.prototype._checkContextual(inDatum);
                }
                textDirMarkup += " dir='" + textDir + "'; ";
            }
            return textDirMarkup;
        }, formatEditing:function (inDatum, inRowIndex) {
            this.needFormatNode(inDatum, inRowIndex);
            return "<input class=\"dojoxGridInput\" " + this._getTextDirMarkup(inDatum) + " type=\"text\" value=\"" + inDatum + "\">";
        }, _enforceTextDirWithUcc:function (textDir, text) {
            textDir = (textDir === "auto") ? _BidiSupport.prototype._checkContextual(text) : textDir;
            return (textDir === "rtl" ? this.RLE : this.LRE) + text + this.PDF;
        }});
        lang.extend(BaseCell.Select, {_getValueCallOrig:dojox.grid.cells.Select.prototype.getValue, getValue:function (inRowIndex) {
            var ret = this._getValueCallOrig(inRowIndex);
            if (ret && (this.textDir || this.grid.textDir)) {
                ret = ret.replace(/\u202A|\u202B|\u202C/g, "");
            }
            return ret;
        }, formatEditing:function (inDatum, inRowIndex) {
            this.needFormatNode(inDatum, inRowIndex);
            var h = ["<select dir = \"" + (this.grid.isLeftToRight() ? "ltr" : "rtl") + "\" class=\"dojoxGridSelect\">"];
            for (var i = 0, o, v; ((o = this.options[i]) !== undefined) && ((v = this.values[i]) !== undefined); i++) {
                v = v.replace ? v.replace(/&/g, "&amp;").replace(/</g, "&lt;") : v;
                o = o.replace ? o.replace(/&/g, "&amp;").replace(/</g, "&lt;") : o;
                if (this.textDir || this.grid.textDir) {
                    o = this._enforceTextDirWithUcc(this.textDir || this.grid.textDir, o);
                }
                h.push("<option", (inDatum == v ? " selected" : ""), " value = \"" + v + "\"", ">", o, "</option>");
            }
            h.push("</select>");
            return h.join("");
        }});
        lang.extend(cellsDijit.ComboBox, {getWidgetPropsCallOrig:dojox.grid.cells.ComboBox.prototype.getWidgetProps, getWidgetProps:function (inDatum) {
            var ret = this.getWidgetPropsCallOrig(inDatum);
            if (this.textDir || this.grid.textDir) {
                ret.textDir = this.textDir || this.grid.textDir;
            }
            return ret;
        }});
        lang.extend(cellsDijit._Widget, {getWidgetPropsCallOrig:dojox.grid.cells._Widget.prototype.getWidgetProps, getWidgetProps:function (inDatum) {
            var ret = this.getWidgetPropsCallOrig(inDatum);
            if (this.textDir || this.grid.textDir) {
                ret.textDir = this.textDir || this.grid.textDir;
            }
            return ret;
        }});
    });
}, "dojox/grid/_Grid":function () {
    define(["dojo/_base/kernel", "../main", "dojo/_base/declare", "./_Events", "./_Scroller", "./_Layout", "./_View", "./_ViewManager", "./_RowManager", "./_FocusManager", "./_EditManager", "./Selection", "./_RowSelector", "./util", "dijit/_Widget", "dijit/_TemplatedMixin", "dijit/CheckedMenuItem", "dojo/text!./resources/_Grid.html", "dojo/string", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/sniff", "dojox/html/metrics", "dojo/_base/html", "dojo/query", "dojo/dnd/common", "dojo/i18n!dijit/nls/loading"], function (dojo, dojox, declare, _Events, _Scroller, _Layout, _View, _ViewManager, _RowManager, _FocusManager, _EditManager, Selection, _RowSelector, util, _Widget, _TemplatedMixin, CheckedMenuItem, template, string, array, lang, has, metrics, html, query) {
        if (!dojo.isCopyKey) {
            dojo.isCopyKey = dojo.dnd.getCopyKeyState;
        }
        var _Grid = declare("dojox.grid._Grid", [_Widget, _TemplatedMixin, _Events], {templateString:template, classTag:"dojoxGrid", rowCount:5, keepRows:75, rowsPerPage:25, autoWidth:false, initialWidth:"", autoHeight:"", rowHeight:0, autoRender:true, defaultHeight:"15em", height:"", structure:null, elasticView:-1, singleClickEdit:false, selectionMode:"extended", rowSelector:"", columnReordering:false, headerMenu:null, placeholderLabel:"GridColumns", selectable:false, _click:null, loadingMessage:"<span class='dojoxGridLoading'>${loadingState}</span>", errorMessage:"<span class='dojoxGridError'>${errorState}</span>", noDataMessage:"", escapeHTMLInData:true, formatterScope:null, editable:false, summary:"", _setSummaryAttr:"domNode", sortInfo:0, _placeholders:null, _layoutClass:_Layout, buildRendering:function () {
            this.inherited(arguments);
            if (!this.domNode.getAttribute("tabIndex")) {
                this.domNode.tabIndex = "0";
            }
            this.createScroller();
            this.createLayout();
            this.createViews();
            this.createManagers();
            this.createSelection();
            this.connect(this.selection, "onSelected", "onSelected");
            this.connect(this.selection, "onDeselected", "onDeselected");
            this.connect(this.selection, "onChanged", "onSelectionChanged");
            metrics.initOnFontResize();
            this.connect(metrics, "onFontResize", "textSizeChanged");
            util.funnelEvents(this.domNode, this, "doKeyEvent", util.keyEvents);
            if (this.selectionMode != "none") {
                this.domNode.setAttribute("aria-multiselectable", this.selectionMode == "single" ? "false" : "true");
            }
            html.addClass(this.domNode, this.classTag);
            if (!this.isLeftToRight()) {
                html.addClass(this.domNode, this.classTag + "Rtl");
            }
            if (this.rowHeight > 0) {
                html.addClass(this.viewsNode, this.classTag + "FixedRowHeight");
            }
        }, postMixInProperties:function () {
            this.inherited(arguments);
            var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
            this.loadingMessage = string.substitute(this.loadingMessage, messages);
            this.errorMessage = string.substitute(this.errorMessage, messages);
            if (this.srcNodeRef && this.srcNodeRef.style.height) {
                this.height = this.srcNodeRef.style.height;
            }
            this._setAutoHeightAttr(this.autoHeight, true);
            this.lastScrollTop = this.scrollTop = 0;
        }, postCreate:function () {
            this._placeholders = [];
            this._setHeaderMenuAttr(this.headerMenu);
            this._setStructureAttr(this.structure);
            this._click = [];
            this.inherited(arguments);
            if (this.domNode && this.autoWidth && this.initialWidth) {
                this.domNode.style.width = this.initialWidth;
            }
            if (this.domNode && !this.editable) {
                html.attr(this.domNode, "aria-readonly", "true");
            }
        }, destroy:function () {
            this.domNode.onReveal = null;
            this.domNode.onSizeChange = null;
            delete this._click;
            if (this.scroller) {
                this.scroller.destroy();
                delete this.scroller;
            }
            this.edit.destroy();
            delete this.edit;
            this.views.destroyViews();
            if (this.focus) {
                this.focus.destroy();
                delete this.focus;
            }
            if (this.headerMenu && this._placeholders.length) {
                array.forEach(this._placeholders, function (p) {
                    p.unReplace(true);
                });
                this.headerMenu.unBindDomNode(this.viewsHeaderNode);
            }
            this.inherited(arguments);
        }, _setAutoHeightAttr:function (ah, skipRender) {
            if (typeof ah == "string") {
                if (!ah || ah == "false") {
                    ah = false;
                } else {
                    if (ah == "true") {
                        ah = true;
                    } else {
                        ah = window.parseInt(ah, 10);
                    }
                }
            }
            if (typeof ah == "number") {
                if (isNaN(ah)) {
                    ah = false;
                }
                if (ah < 0) {
                    ah = true;
                } else {
                    if (ah === 0) {
                        ah = false;
                    }
                }
            }
            this.autoHeight = ah;
            if (typeof ah == "boolean") {
                this._autoHeight = ah;
            } else {
                if (typeof ah == "number") {
                    this._autoHeight = (ah >= this.get("rowCount"));
                } else {
                    this._autoHeight = false;
                }
            }
            if (this._started && !skipRender) {
                this.render();
            }
        }, _getRowCountAttr:function () {
            return this.updating && this.invalidated && this.invalidated.rowCount != undefined ? this.invalidated.rowCount : this.rowCount;
        }, textSizeChanged:function () {
            this.render();
        }, sizeChange:function () {
            this.update();
        }, createManagers:function () {
            this.rows = new _RowManager(this);
            this.focus = new _FocusManager(this);
            this.edit = new _EditManager(this);
        }, createSelection:function () {
            this.selection = new Selection(this);
        }, createScroller:function () {
            this.scroller = new _Scroller();
            this.scroller.grid = this;
            this.scroller.renderRow = lang.hitch(this, "renderRow");
            this.scroller.removeRow = lang.hitch(this, "rowRemoved");
        }, createLayout:function () {
            this.layout = new this._layoutClass(this);
            this.connect(this.layout, "moveColumn", "onMoveColumn");
        }, onMoveColumn:function () {
            this.update();
        }, onResizeColumn:function (cellIdx) {
        }, createViews:function () {
            this.views = new _ViewManager(this);
            this.views.createView = lang.hitch(this, "createView");
        }, createView:function (inClass, idx) {
            var c = lang.getObject(inClass);
            var view = new c({grid:this, index:idx});
            this.viewsNode.appendChild(view.domNode);
            this.viewsHeaderNode.appendChild(view.headerNode);
            this.views.addView(view);
            html.attr(this.domNode, "align", this.isLeftToRight() ? "left" : "right");
            return view;
        }, buildViews:function () {
            for (var i = 0, vs; (vs = this.layout.structure[i]); i++) {
                this.createView(vs.type || dojox._scopeName + ".grid._View", i).setStructure(vs);
            }
            this.scroller.setContentNodes(this.views.getContentNodes());
        }, _setStructureAttr:function (structure) {
            var s = structure;
            if (s && lang.isString(s)) {
                dojo.deprecated("dojox.grid._Grid.set('structure', 'objVar')", "use dojox.grid._Grid.set('structure', objVar) instead", "2.0");
                s = lang.getObject(s);
            }
            this.structure = s;
            if (!s) {
                if (this.layout.structure) {
                    s = this.layout.structure;
                } else {
                    return;
                }
            }
            this.views.destroyViews();
            this.focus.focusView = null;
            if (s !== this.layout.structure) {
                this.layout.setStructure(s);
            }
            this._structureChanged();
        }, setStructure:function (inStructure) {
            dojo.deprecated("dojox.grid._Grid.setStructure(obj)", "use dojox.grid._Grid.set('structure', obj) instead.", "2.0");
            this._setStructureAttr(inStructure);
        }, getColumnTogglingItems:function () {
            var items, checkedItems = [];
            items = array.map(this.layout.cells, function (cell) {
                if (!cell.menuItems) {
                    cell.menuItems = [];
                }
                var self = this;
                var item = new CheckedMenuItem({label:cell.name, checked:!cell.hidden, _gridCell:cell, onChange:function (checked) {
                    if (self.layout.setColumnVisibility(this._gridCell.index, checked)) {
                        var items = this._gridCell.menuItems;
                        if (items.length > 1) {
                            array.forEach(items, function (item) {
                                if (item !== this) {
                                    item.setAttribute("checked", checked);
                                }
                            }, this);
                        }
                        checked = array.filter(self.layout.cells, function (c) {
                            if (c.menuItems.length > 1) {
                                array.forEach(c.menuItems, "item.set('disabled', false);");
                            } else {
                                c.menuItems[0].set("disabled", false);
                            }
                            return !c.hidden;
                        });
                        if (checked.length == 1) {
                            array.forEach(checked[0].menuItems, "item.set('disabled', true);");
                        }
                    }
                }, destroy:function () {
                    var index = array.indexOf(this._gridCell.menuItems, this);
                    this._gridCell.menuItems.splice(index, 1);
                    delete this._gridCell;
                    CheckedMenuItem.prototype.destroy.apply(this, arguments);
                }});
                cell.menuItems.push(item);
                if (!cell.hidden) {
                    checkedItems.push(item);
                }
                return item;
            }, this);
            if (checkedItems.length == 1) {
                checkedItems[0].set("disabled", true);
            }
            return items;
        }, _setHeaderMenuAttr:function (menu) {
            if (this._placeholders && this._placeholders.length) {
                array.forEach(this._placeholders, function (p) {
                    p.unReplace(true);
                });
                this._placeholders = [];
            }
            if (this.headerMenu) {
                this.headerMenu.unBindDomNode(this.viewsHeaderNode);
            }
            this.headerMenu = menu;
            if (!menu) {
                return;
            }
            this.headerMenu.bindDomNode(this.viewsHeaderNode);
            if (this.headerMenu.getPlaceholders) {
                this._placeholders = this.headerMenu.getPlaceholders(this.placeholderLabel);
            }
        }, setHeaderMenu:function (menu) {
            dojo.deprecated("dojox.grid._Grid.setHeaderMenu(obj)", "use dojox.grid._Grid.set('headerMenu', obj) instead.", "2.0");
            this._setHeaderMenuAttr(menu);
        }, setupHeaderMenu:function () {
            if (this._placeholders && this._placeholders.length) {
                array.forEach(this._placeholders, function (p) {
                    if (p._replaced) {
                        p.unReplace(true);
                    }
                    p.replace(this.getColumnTogglingItems());
                }, this);
            }
        }, _fetch:function (start) {
            this.setScrollTop(0);
        }, getItem:function (inRowIndex) {
            return null;
        }, showMessage:function (message) {
            if (message) {
                this.messagesNode.innerHTML = message;
                this.messagesNode.style.display = "";
            } else {
                this.messagesNode.innerHTML = "";
                this.messagesNode.style.display = "none";
            }
        }, _structureChanged:function () {
            this.buildViews();
            if (this.autoRender && this._started) {
                this.render();
            }
        }, hasLayout:function () {
            return this.layout.cells.length;
        }, resize:function (changeSize, resultSize) {
            this._pendingChangeSize = changeSize;
            this._pendingResultSize = resultSize;
            this.sizeChange();
        }, _getPadBorder:function () {
            this._padBorder = this._padBorder || html._getPadBorderExtents(this.domNode);
            return this._padBorder;
        }, _getHeaderHeight:function () {
            var vns = this.viewsHeaderNode.style, t = vns.display == "none" ? 0 : this.views.measureHeader();
            vns.height = t + "px";
            this.views.normalizeHeaderNodeHeight();
            return t;
        }, _resize:function (changeSize, resultSize) {
            changeSize = changeSize || this._pendingChangeSize;
            resultSize = resultSize || this._pendingResultSize;
            delete this._pendingChangeSize;
            delete this._pendingResultSize;
            if (!this.domNode) {
                return;
            }
            var pn = this.domNode.parentNode;
            if (!pn || pn.nodeType != 1 || !this.hasLayout() || pn.style.visibility == "hidden" || pn.style.display == "none") {
                return;
            }
            var padBorder = this._getPadBorder();
            var hh = undefined;
            var h;
            if (this._autoHeight) {
                this.domNode.style.height = "auto";
            } else {
                if (typeof this.autoHeight == "number") {
                    h = hh = this._getHeaderHeight();
                    h += (this.scroller.averageRowHeight * this.autoHeight);
                    this.domNode.style.height = h + "px";
                } else {
                    if (this.domNode.clientHeight <= padBorder.h) {
                        if (pn == document.body) {
                            this.domNode.style.height = this.defaultHeight;
                        } else {
                            if (this.height) {
                                this.domNode.style.height = this.height;
                            } else {
                                this.fitTo = "parent";
                            }
                        }
                    }
                }
            }
            if (resultSize) {
                changeSize = resultSize;
            }
            if (!this._autoHeight && changeSize) {
                html.marginBox(this.domNode, changeSize);
                this.height = this.domNode.style.height;
                delete this.fitTo;
            } else {
                if (this.fitTo == "parent") {
                    h = this._parentContentBoxHeight = (this._parentContentBoxHeight > 0 ? this._parentContentBoxHeight : html._getContentBox(pn).h);
                    this.domNode.style.height = Math.max(0, h) + "px";
                }
            }
            var hasFlex = array.some(this.views.views, function (v) {
                return v.flexCells;
            });
            if (!this._autoHeight && (h || html._getContentBox(this.domNode).h) === 0) {
                this.viewsHeaderNode.style.display = "none";
            } else {
                this.viewsHeaderNode.style.display = "block";
                if (!hasFlex && hh === undefined) {
                    hh = this._getHeaderHeight();
                }
            }
            if (hasFlex) {
                hh = undefined;
            }
            this.adaptWidth();
            this.adaptHeight(hh);
            this.postresize();
        }, adaptWidth:function () {
            var doAutoWidth = (!this.initialWidth && this.autoWidth);
            var w = doAutoWidth ? 0 : this.domNode.clientWidth || (this.domNode.offsetWidth - this._getPadBorder().w), vw = this.views.arrange(1, w);
            this.views.onEach("adaptWidth");
            if (doAutoWidth) {
                this.domNode.style.width = vw + "px";
            }
        }, adaptHeight:function (inHeaderHeight) {
            var t = inHeaderHeight === undefined ? this._getHeaderHeight() : inHeaderHeight;
            var h = (this._autoHeight ? -1 : Math.max(this.domNode.clientHeight - t, 0) || 0);
            this.views.onEach("setSize", [0, h]);
            this.views.onEach("adaptHeight");
            if (!this._autoHeight) {
                var numScroll = 0, numNoScroll = 0;
                var noScrolls = array.filter(this.views.views, function (v) {
                    var has = v.hasHScrollbar();
                    if (has) {
                        numScroll++;
                    } else {
                        numNoScroll++;
                    }
                    return (!has);
                });
                if (numScroll > 0 && numNoScroll > 0) {
                    array.forEach(noScrolls, function (v) {
                        v.adaptHeight(true);
                    });
                }
            }
            if (this.autoHeight === true || h != -1 || (typeof this.autoHeight == "number" && this.autoHeight >= this.get("rowCount"))) {
                this.scroller.windowHeight = h;
            } else {
                this.scroller.windowHeight = Math.max(this.domNode.clientHeight - t, 0);
            }
        }, startup:function () {
            if (this._started) {
                return;
            }
            this.inherited(arguments);
            if (this.autoRender) {
                this.render();
            }
        }, render:function () {
            if (!this.domNode) {
                return;
            }
            if (!this._started) {
                return;
            }
            if (!this.hasLayout()) {
                this.scroller.init(0, this.keepRows, this.rowsPerPage);
                return;
            }
            this.update = this.defaultUpdate;
            this._render();
        }, _render:function () {
            this.scroller.init(this.get("rowCount"), this.keepRows, this.rowsPerPage);
            this.prerender();
            this.setScrollTop(0);
            this.postrender();
        }, prerender:function () {
            this.keepRows = this._autoHeight ? 0 : this.keepRows;
            this.scroller.setKeepInfo(this.keepRows);
            this.views.render();
            this._resize();
        }, postrender:function () {
            this.postresize();
            this.focus.initFocusView();
            html.setSelectable(this.domNode, this.selectable);
        }, postresize:function () {
            if (this._autoHeight) {
                var size = Math.max(this.views.measureContent()) + "px";
                this.viewsNode.style.height = size;
            }
        }, renderRow:function (inRowIndex, inNodes) {
            this.views.renderRow(inRowIndex, inNodes, this._skipRowRenormalize);
        }, rowRemoved:function (inRowIndex) {
            this.views.rowRemoved(inRowIndex);
        }, invalidated:null, updating:false, beginUpdate:function () {
            this.invalidated = [];
            this.updating = true;
        }, endUpdate:function () {
            this.updating = false;
            var i = this.invalidated, r;
            if (i.all) {
                this.update();
            } else {
                if (i.rowCount != undefined) {
                    this.updateRowCount(i.rowCount);
                } else {
                    for (r in i) {
                        this.updateRow(Number(r));
                    }
                }
            }
            this.invalidated = [];
        }, defaultUpdate:function () {
            if (!this.domNode) {
                return;
            }
            if (this.updating) {
                this.invalidated.all = true;
                return;
            }
            this.lastScrollTop = this.scrollTop;
            this.prerender();
            this.scroller.invalidateNodes();
            this.setScrollTop(this.lastScrollTop);
            this.postrender();
        }, update:function () {
            this.render();
        }, updateRow:function (inRowIndex) {
            inRowIndex = Number(inRowIndex);
            if (this.updating) {
                this.invalidated[inRowIndex] = true;
            } else {
                this.views.updateRow(inRowIndex);
                this.scroller.rowHeightChanged(inRowIndex);
            }
        }, updateRows:function (startIndex, howMany) {
            startIndex = Number(startIndex);
            howMany = Number(howMany);
            var i;
            if (this.updating) {
                for (i = 0; i < howMany; i++) {
                    this.invalidated[i + startIndex] = true;
                }
            } else {
                for (i = 0; i < howMany; i++) {
                    this.views.updateRow(i + startIndex, this._skipRowRenormalize);
                }
                this.scroller.rowHeightChanged(startIndex);
            }
        }, updateRowCount:function (inRowCount) {
            if (this.updating) {
                this.invalidated.rowCount = inRowCount;
            } else {
                this.rowCount = inRowCount;
                this._setAutoHeightAttr(this.autoHeight, true);
                if (this.layout.cells.length) {
                    this.scroller.updateRowCount(inRowCount);
                }
                this._resize();
                if (this.layout.cells.length) {
                    this.setScrollTop(this.scrollTop);
                }
            }
        }, updateRowStyles:function (inRowIndex) {
            this.views.updateRowStyles(inRowIndex);
        }, getRowNode:function (inRowIndex) {
            if (this.focus.focusView && !(this.focus.focusView instanceof _RowSelector)) {
                return this.focus.focusView.rowNodes[inRowIndex];
            } else {
                for (var i = 0, cView; (cView = this.views.views[i]); i++) {
                    if (!(cView instanceof _RowSelector)) {
                        return cView.rowNodes[inRowIndex];
                    }
                }
            }
            return null;
        }, rowHeightChanged:function (inRowIndex) {
            this.views.renormalizeRow(inRowIndex);
            this.scroller.rowHeightChanged(inRowIndex);
        }, fastScroll:true, delayScroll:false, scrollRedrawThreshold:(has("ie") ? 100 : 50), scrollTo:function (inTop) {
            if (!this.fastScroll) {
                this.setScrollTop(inTop);
                return;
            }
            var delta = Math.abs(this.lastScrollTop - inTop);
            this.lastScrollTop = inTop;
            if (delta > this.scrollRedrawThreshold || this.delayScroll) {
                this.delayScroll = true;
                this.scrollTop = inTop;
                this.views.setScrollTop(inTop);
                if (this._pendingScroll) {
                    window.clearTimeout(this._pendingScroll);
                }
                var _this = this;
                this._pendingScroll = window.setTimeout(function () {
                    delete _this._pendingScroll;
                    _this.finishScrollJob();
                }, 200);
            } else {
                this.setScrollTop(inTop);
            }
        }, finishScrollJob:function () {
            this.delayScroll = false;
            this.setScrollTop(this.scrollTop);
        }, setScrollTop:function (inTop) {
            this.scroller.scroll(this.views.setScrollTop(inTop));
        }, scrollToRow:function (inRowIndex) {
            this.setScrollTop(this.scroller.findScrollTop(inRowIndex) + 1);
        }, styleRowNode:function (inRowIndex, inRowNode) {
            if (inRowNode) {
                this.rows.styleRowNode(inRowIndex, inRowNode);
            }
        }, _mouseOut:function (e) {
            this.rows.setOverRow(-2);
        }, getCell:function (inIndex) {
            return this.layout.cells[inIndex];
        }, setCellWidth:function (inIndex, inUnitWidth) {
            this.getCell(inIndex).unitWidth = inUnitWidth;
        }, getCellName:function (inCell) {
            return "Cell " + inCell.index;
        }, canSort:function (inSortInfo) {
        }, sort:function () {
        }, getSortAsc:function (inSortInfo) {
            inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
            return Boolean(inSortInfo > 0);
        }, getSortIndex:function (inSortInfo) {
            inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
            return Math.abs(inSortInfo) - 1;
        }, setSortIndex:function (inIndex, inAsc) {
            var si = inIndex + 1;
            if (inAsc != undefined) {
                si *= (inAsc ? 1 : -1);
            } else {
                if (this.getSortIndex() == inIndex) {
                    si = -this.sortInfo;
                }
            }
            this.setSortInfo(si);
        }, setSortInfo:function (inSortInfo) {
            if (this.canSort(inSortInfo)) {
                this.sortInfo = inSortInfo;
                this.sort();
                this.update();
            }
        }, doKeyEvent:function (e) {
            e.dispatch = "do" + e.type;
            this.onKeyEvent(e);
        }, _dispatch:function (m, e) {
            if (m in this) {
                return this[m](e);
            }
            return false;
        }, dispatchKeyEvent:function (e) {
            this._dispatch(e.dispatch, e);
        }, dispatchContentEvent:function (e) {
            this.edit.dispatchEvent(e) || e.sourceView.dispatchContentEvent(e) || this._dispatch(e.dispatch, e);
        }, dispatchHeaderEvent:function (e) {
            e.sourceView.dispatchHeaderEvent(e) || this._dispatch("doheader" + e.type, e);
        }, dokeydown:function (e) {
            this.onKeyDown(e);
        }, doclick:function (e) {
            if (e.cellNode) {
                this.onCellClick(e);
            } else {
                this.onRowClick(e);
            }
        }, dodblclick:function (e) {
            if (e.cellNode) {
                this.onCellDblClick(e);
            } else {
                this.onRowDblClick(e);
            }
        }, docontextmenu:function (e) {
            if (e.cellNode) {
                this.onCellContextMenu(e);
            } else {
                this.onRowContextMenu(e);
            }
        }, doheaderclick:function (e) {
            if (e.cellNode) {
                this.onHeaderCellClick(e);
            } else {
                this.onHeaderClick(e);
            }
        }, doheaderdblclick:function (e) {
            if (e.cellNode) {
                this.onHeaderCellDblClick(e);
            } else {
                this.onHeaderDblClick(e);
            }
        }, doheadercontextmenu:function (e) {
            if (e.cellNode) {
                this.onHeaderCellContextMenu(e);
            } else {
                this.onHeaderContextMenu(e);
            }
        }, doStartEdit:function (inCell, inRowIndex) {
            this.onStartEdit(inCell, inRowIndex);
        }, doApplyCellEdit:function (inValue, inRowIndex, inFieldIndex) {
            this.onApplyCellEdit(inValue, inRowIndex, inFieldIndex);
        }, doCancelEdit:function (inRowIndex) {
            this.onCancelEdit(inRowIndex);
        }, doApplyEdit:function (inRowIndex) {
            this.onApplyEdit(inRowIndex);
        }, addRow:function () {
            this.updateRowCount(this.get("rowCount") + 1);
        }, removeSelectedRows:function () {
            if (this.allItemsSelected) {
                this.updateRowCount(0);
            } else {
                this.updateRowCount(Math.max(0, this.get("rowCount") - this.selection.getSelected().length));
            }
            this.selection.clear();
        }});
        _Grid.markupFactory = function (props, node, ctor, cellFunc) {
            var widthFromAttr = function (n) {
                var w = html.attr(n, "width") || "auto";
                if ((w != "auto") && (w.slice(-2) != "em") && (w.slice(-1) != "%")) {
                    w = parseInt(w, 10) + "px";
                }
                return w;
            };
            if (!props.structure && node.nodeName.toLowerCase() == "table") {
                props.structure = query("> colgroup", node).map(function (cg) {
                    var sv = html.attr(cg, "span");
                    var v = {noscroll:(html.attr(cg, "noscroll") == "true") ? true : false, __span:(!!sv ? parseInt(sv, 10) : 1), cells:[]};
                    if (html.hasAttr(cg, "width")) {
                        v.width = widthFromAttr(cg);
                    }
                    return v;
                });
                if (!props.structure.length) {
                    props.structure.push({__span:Infinity, cells:[]});
                }
                query("thead > tr", node).forEach(function (tr, tr_idx) {
                    var cellCount = 0;
                    var viewIdx = 0;
                    var lastViewIdx;
                    var cView = null;
                    query("> th", tr).map(function (th) {
                        if (!cView) {
                            lastViewIdx = 0;
                            cView = props.structure[0];
                        } else {
                            if (cellCount >= (lastViewIdx + cView.__span)) {
                                viewIdx++;
                                lastViewIdx += cView.__span;
                                var lastView = cView;
                                cView = props.structure[viewIdx];
                            }
                        }
                        var cell = {name:lang.trim(html.attr(th, "name") || th.innerHTML), colSpan:parseInt(html.attr(th, "colspan") || 1, 10), type:lang.trim(html.attr(th, "cellType") || ""), id:lang.trim(html.attr(th, "id") || "")};
                        cellCount += cell.colSpan;
                        var rowSpan = html.attr(th, "rowspan");
                        if (rowSpan) {
                            cell.rowSpan = rowSpan;
                        }
                        if (html.hasAttr(th, "width")) {
                            cell.width = widthFromAttr(th);
                        }
                        if (html.hasAttr(th, "relWidth")) {
                            cell.relWidth = window.parseInt(html.attr(th, "relWidth"), 10);
                        }
                        if (html.hasAttr(th, "hidden")) {
                            cell.hidden = (html.attr(th, "hidden") == "true" || html.attr(th, "hidden") === true);
                        }
                        if (cellFunc) {
                            cellFunc(th, cell);
                        }
                        cell.type = cell.type ? lang.getObject(cell.type) : dojox.grid.cells.Cell;
                        if (cell.type && cell.type.markupFactory) {
                            cell.type.markupFactory(th, cell);
                        }
                        if (!cView.cells[tr_idx]) {
                            cView.cells[tr_idx] = [];
                        }
                        cView.cells[tr_idx].push(cell);
                    });
                });
            }
            return new ctor(props, node);
        };
        return _Grid;
    });
}, "dojo/store/Memory":function () {
    define(["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine"], function (declare, QueryResults, SimpleQueryEngine) {
        var base = null;
        return declare("dojo.store.Memory", base, {constructor:function (options) {
            for (var i in options) {
                this[i] = options[i];
            }
            this.setData(this.data || []);
        }, data:null, idProperty:"id", index:null, queryEngine:SimpleQueryEngine, get:function (id) {
            return this.data[this.index[id]];
        }, getIdentity:function (object) {
            return object[this.idProperty];
        }, put:function (object, options) {
            var data = this.data, index = this.index, idProperty = this.idProperty;
            var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
            if (id in index) {
                if (options && options.overwrite === false) {
                    throw new Error("Object already exists");
                }
                data[index[id]] = object;
            } else {
                index[id] = data.push(object) - 1;
            }
            return id;
        }, add:function (object, options) {
            (options = options || {}).overwrite = false;
            return this.put(object, options);
        }, remove:function (id) {
            var index = this.index;
            var data = this.data;
            if (id in index) {
                data.splice(index[id], 1);
                this.setData(data);
                return true;
            }
        }, query:function (query, options) {
            return QueryResults(this.queryEngine(query, options)(this.data));
        }, setData:function (data) {
            if (data.items) {
                this.idProperty = data.identifier || this.idProperty;
                data = this.data = data.items;
            } else {
                this.data = data;
            }
            this.index = {};
            for (var i = 0, l = data.length; i < l; i++) {
                this.index[data[i][this.idProperty]] = i;
            }
        }});
    });
}, "dojo/hccss":function () {
    define(["require", "./_base/config", "./dom-class", "./dom-style", "./has", "./domReady", "./_base/window"], function (require, config, domClass, domStyle, has, domReady, win) {
        has.add("highcontrast", function () {
            var div = win.doc.createElement("div");
            div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" + "background-image: url(" + (config.blankGif || require.toUrl("./resources/blank.gif")) + ");";
            win.body().appendChild(div);
            var cs = domStyle.getComputedStyle(div), bkImg = cs.backgroundImage, hc = (cs.borderTopColor == cs.borderRightColor) || (bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)"));
            if (has("ie") <= 8) {
                div.outerHTML = "";
            } else {
                win.body().removeChild(div);
            }
            return hc;
        });
        domReady(function () {
            if (has("highcontrast")) {
                domClass.add(win.body(), "dj_a11y");
            }
        });
        return has;
    });
}, "dojo/request/iframe":function () {
    define(["module", "require", "./watch", "./util", "./handlers", "../_base/lang", "../io-query", "../query", "../has", "../dom", "../dom-construct", "../_base/window", "../NodeList-dom"], function (module, require, watch, util, handlers, lang, ioQuery, query, has, dom, domConstruct, win) {
        var mid = module.id.replace(/[\/\.\-]/g, "_"), onload = mid + "_onload";
        if (!win.global[onload]) {
            win.global[onload] = function () {
                var dfd = iframe._currentDfd;
                if (!dfd) {
                    iframe._fireNextRequest();
                    return;
                }
                var response = dfd.response, options = response.options, formNode = dom.byId(options.form) || dfd._tmpForm;
                if (formNode) {
                    var toClean = dfd._contentToClean;
                    for (var i = 0; i < toClean.length; i++) {
                        var key = toClean[i];
                        for (var j = 0; j < formNode.childNodes.length; j++) {
                            var childNode = formNode.childNodes[j];
                            if (childNode.name === key) {
                                domConstruct.destroy(childNode);
                                break;
                            }
                        }
                    }
                    dfd._originalAction && formNode.setAttribute("action", dfd._originalAction);
                    if (dfd._originalMethod) {
                        formNode.setAttribute("method", dfd._originalMethod);
                        formNode.method = dfd._originalMethod;
                    }
                    if (dfd._originalTarget) {
                        formNode.setAttribute("target", dfd._originalTarget);
                        formNode.target = dfd._originalTarget;
                    }
                }
                if (dfd._tmpForm) {
                    domConstruct.destroy(dfd._tmpForm);
                    delete dfd._tmpForm;
                }
                dfd._finished = true;
            };
        }
        function create(name, onloadstr, uri) {
            if (win.global[name]) {
                return win.global[name];
            }
            if (win.global.frames[name]) {
                return win.global.frames[name];
            }
            if (!uri) {
                if (has("config-useXDomain") && !has("config-dojoBlankHtmlUrl")) {
                    console.warn("dojo/request/iframe: When using cross-domain Dojo builds," + " please save dojo/resources/blank.html to your domain and set dojoConfig.dojoBlankHtmlUrl" + " to the path on your domain to blank.html");
                }
                uri = (has("config-dojoBlankHtmlUrl") || require.toUrl("dojo/resources/blank.html"));
            }
            var frame = domConstruct.place("<iframe id=\"" + name + "\" name=\"" + name + "\" src=\"" + uri + "\" onload=\"" + onloadstr + "\" style=\"position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden\">", win.body());
            win.global[name] = frame;
            return frame;
        }
        function setSrc(_iframe, src, replace) {
            var frame = win.global.frames[_iframe.name];
            if (frame.contentWindow) {
                frame = frame.contentWindow;
            }
            try {
                if (!replace) {
                    frame.location = src;
                } else {
                    frame.location.replace(src);
                }
            }
            catch (e) {
                console.log("dojo/request/iframe.setSrc: ", e);
            }
        }
        function doc(iframeNode) {
            if (iframeNode.contentDocument) {
                return iframeNode.contentDocument;
            }
            var name = iframeNode.name;
            if (name) {
                var iframes = win.doc.getElementsByTagName("iframe");
                if (iframeNode.document && iframes[name].contentWindow && iframes[name].contentWindow.document) {
                    return iframes[name].contentWindow.document;
                } else {
                    if (win.doc.frames[name] && win.doc.frames[name].document) {
                        return win.doc.frames[name].document;
                    }
                }
            }
            return null;
        }
        function createForm() {
            return domConstruct.create("form", {name:mid + "_form", style:{position:"absolute", top:"-1000px", left:"-1000px"}}, win.body());
        }
        function fireNextRequest() {
            var dfd;
            try {
                if (iframe._currentDfd || !iframe._dfdQueue.length) {
                    return;
                }
                do {
                    dfd = iframe._currentDfd = iframe._dfdQueue.shift();
                } while (dfd && (dfd.canceled || (dfd.isCanceled && dfd.isCanceled())) && iframe._dfdQueue.length);
                if (!dfd || dfd.canceled || (dfd.isCanceled && dfd.isCanceled())) {
                    iframe._currentDfd = null;
                    return;
                }
                var response = dfd.response, options = response.options, c2c = dfd._contentToClean = [], formNode = dom.byId(options.form), notify = util.notify, data = options.data || null, queryStr;
                if (!dfd._legacy && options.method === "POST" && !formNode) {
                    formNode = dfd._tmpForm = createForm();
                } else {
                    if (options.method === "GET" && formNode && response.url.indexOf("?") > -1) {
                        queryStr = response.url.slice(response.url.indexOf("?") + 1);
                        data = lang.mixin(ioQuery.queryToObject(queryStr), data);
                    }
                }
                if (formNode) {
                    if (!dfd._legacy) {
                        var parentNode = formNode;
                        do {
                            parentNode = parentNode.parentNode;
                        } while (parentNode !== win.doc.documentElement);
                        if (!parentNode) {
                            formNode.style.position = "absolute";
                            formNode.style.left = "-1000px";
                            formNode.style.top = "-1000px";
                            win.body().appendChild(formNode);
                        }
                        if (!formNode.name) {
                            formNode.name = mid + "_form";
                        }
                    }
                    if (data) {
                        var createInput = function (name, value) {
                            domConstruct.create("input", {type:"hidden", name:name, value:value}, formNode);
                            c2c.push(name);
                        };
                        for (var x in data) {
                            var val = data[x];
                            if (lang.isArray(val) && val.length > 1) {
                                for (var i = 0; i < val.length; i++) {
                                    createInput(x, val[i]);
                                }
                            } else {
                                if (!formNode[x]) {
                                    createInput(x, val);
                                } else {
                                    formNode[x].value = val;
                                }
                            }
                        }
                    }
                    var actionNode = formNode.getAttributeNode("action"), methodNode = formNode.getAttributeNode("method"), targetNode = formNode.getAttributeNode("target");
                    if (response.url) {
                        dfd._originalAction = actionNode ? actionNode.value : null;
                        if (actionNode) {
                            actionNode.value = response.url;
                        } else {
                            formNode.setAttribute("action", response.url);
                        }
                    }
                    if (!dfd._legacy) {
                        dfd._originalMethod = methodNode ? methodNode.value : null;
                        if (methodNode) {
                            methodNode.value = options.method;
                        } else {
                            formNode.setAttribute("method", options.method);
                        }
                    } else {
                        if (!methodNode || !methodNode.value) {
                            if (methodNode) {
                                methodNode.value = options.method;
                            } else {
                                formNode.setAttribute("method", options.method);
                            }
                        }
                    }
                    dfd._originalTarget = targetNode ? targetNode.value : null;
                    if (targetNode) {
                        targetNode.value = iframe._iframeName;
                    } else {
                        formNode.setAttribute("target", iframe._iframeName);
                    }
                    formNode.target = iframe._iframeName;
                    notify && notify.emit("send", response, dfd.promise.cancel);
                    iframe._notifyStart(response);
                    formNode.submit();
                } else {
                    var extra = "";
                    if (response.options.data) {
                        extra = response.options.data;
                        if (typeof extra !== "string") {
                            extra = ioQuery.objectToQuery(extra);
                        }
                    }
                    var tmpUrl = response.url + (response.url.indexOf("?") > -1 ? "&" : "?") + extra;
                    notify && notify.emit("send", response, dfd.promise.cancel);
                    iframe._notifyStart(response);
                    iframe.setSrc(iframe._frame, tmpUrl, true);
                }
            }
            catch (e) {
                dfd.reject(e);
            }
        }
        function isValid(response) {
            return !this.isFulfilled();
        }
        function isReady(response) {
            return !!this._finished;
        }
        function handleResponse(response, error) {
            if (!error) {
                try {
                    var options = response.options, doc = iframe.doc(iframe._frame), handleAs = options.handleAs;
                    if (handleAs !== "html") {
                        if (handleAs === "xml") {
                            if (doc.documentElement.tagName.toLowerCase() === "html") {
                                query("a", doc.documentElement).orphan();
                                var xmlText = doc.documentElement.innerText;
                                xmlText = xmlText.replace(/>\s+</g, "><");
                                response.text = lang.trim(xmlText);
                            } else {
                                response.data = doc;
                            }
                        } else {
                            response.text = doc.getElementsByTagName("textarea")[0].value;
                        }
                        handlers(response);
                    } else {
                        response.data = doc;
                    }
                }
                catch (e) {
                    error = e;
                }
            }
            if (error) {
                this.reject(error);
            } else {
                if (this._finished) {
                    this.resolve(response);
                } else {
                    this.reject(new Error("Invalid dojo/request/iframe request state"));
                }
            }
        }
        function last(response) {
            this._callNext();
        }
        var defaultOptions = {method:"POST"};
        function iframe(url, options, returnDeferred) {
            var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), true);
            url = response.url;
            options = response.options;
            if (options.method !== "GET" && options.method !== "POST") {
                throw new Error(options.method + " not supported by dojo/request/iframe");
            }
            if (!iframe._frame) {
                iframe._frame = iframe.create(iframe._iframeName, onload + "();");
            }
            var dfd = util.deferred(response, null, isValid, isReady, handleResponse, last);
            dfd._callNext = function () {
                if (!this._calledNext) {
                    this._calledNext = true;
                    iframe._currentDfd = null;
                    iframe._fireNextRequest();
                }
            };
            dfd._legacy = returnDeferred;
            iframe._dfdQueue.push(dfd);
            iframe._fireNextRequest();
            watch(dfd);
            return returnDeferred ? dfd : dfd.promise;
        }
        iframe.create = create;
        iframe.doc = doc;
        iframe.setSrc = setSrc;
        iframe._iframeName = mid + "_IoIframe";
        iframe._notifyStart = function () {
        };
        iframe._dfdQueue = [];
        iframe._currentDfd = null;
        iframe._fireNextRequest = fireNextRequest;
        util.addCommonMethods(iframe, ["GET", "POST"]);
        return iframe;
    });
}, "dojox/grid/_Events":function () {
    define(["dojo/keys", "dojo/dom-class", "dojo/_base/declare", "dojo/_base/event", "dojo/_base/sniff"], function (keys, domClass, declare, event, has) {
        return declare("dojox.grid._Events", null, {cellOverClass:"dojoxGridCellOver", onKeyEvent:function (e) {
            this.dispatchKeyEvent(e);
        }, onContentEvent:function (e) {
            this.dispatchContentEvent(e);
        }, onHeaderEvent:function (e) {
            this.dispatchHeaderEvent(e);
        }, onStyleRow:function (inRow) {
            var i = inRow;
            i.customClasses += (i.odd ? " dojoxGridRowOdd" : "") + (i.selected ? " dojoxGridRowSelected" : "") + (i.over ? " dojoxGridRowOver" : "");
            this.focus.styleRow(inRow);
            this.edit.styleRow(inRow);
        }, onKeyDown:function (e) {
            if (e.altKey || e.metaKey) {
                return;
            }
            var colIdx;
            switch (e.keyCode) {
              case keys.ESCAPE:
                this.edit.cancel();
                break;
              case keys.ENTER:
                if (!this.edit.isEditing()) {
                    colIdx = this.focus.getHeaderIndex();
                    if (colIdx >= 0) {
                        this.setSortIndex(colIdx);
                        break;
                    } else {
                        this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
                    }
                    event.stop(e);
                }
                if (!e.shiftKey) {
                    var isEditing = this.edit.isEditing();
                    this.edit.apply();
                    if (!isEditing) {
                        this.edit.setEditCell(this.focus.cell, this.focus.rowIndex);
                    }
                }
                if (!this.edit.isEditing()) {
                    var curView = this.focus.focusView || this.views.views[0];
                    curView.content.decorateEvent(e);
                    this.onRowClick(e);
                    event.stop(e);
                }
                break;
              case keys.SPACE:
                if (!this.edit.isEditing()) {
                    colIdx = this.focus.getHeaderIndex();
                    if (colIdx >= 0) {
                        this.setSortIndex(colIdx);
                        break;
                    } else {
                        this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
                    }
                    event.stop(e);
                }
                break;
              case keys.TAB:
                this.focus[e.shiftKey ? "previousKey" : "nextKey"](e);
                break;
              case keys.LEFT_ARROW:
              case keys.RIGHT_ARROW:
                if (!this.edit.isEditing()) {
                    var keyCode = e.keyCode;
                    event.stop(e);
                    colIdx = this.focus.getHeaderIndex();
                    if (colIdx >= 0 && (e.shiftKey && e.ctrlKey)) {
                        this.focus.colSizeAdjust(e, colIdx, (keyCode == keys.LEFT_ARROW ? -1 : 1) * 5);
                    } else {
                        var offset = (keyCode == keys.LEFT_ARROW) ? 1 : -1;
                        if (this.isLeftToRight()) {
                            offset *= -1;
                        }
                        this.focus.move(0, offset);
                    }
                }
                break;
              case keys.UP_ARROW:
                if (!this.edit.isEditing() && this.focus.rowIndex !== 0) {
                    event.stop(e);
                    this.focus.move(-1, 0);
                }
                break;
              case keys.DOWN_ARROW:
                if (!this.edit.isEditing() && this.focus.rowIndex + 1 != this.rowCount) {
                    event.stop(e);
                    this.focus.move(1, 0);
                }
                break;
              case keys.PAGE_UP:
                if (!this.edit.isEditing() && this.focus.rowIndex !== 0) {
                    event.stop(e);
                    if (this.focus.rowIndex != this.scroller.firstVisibleRow + 1) {
                        this.focus.move(this.scroller.firstVisibleRow - this.focus.rowIndex, 0);
                    } else {
                        this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex - 1));
                        this.focus.move(this.scroller.firstVisibleRow - this.scroller.lastVisibleRow + 1, 0);
                    }
                }
                break;
              case keys.PAGE_DOWN:
                if (!this.edit.isEditing() && this.focus.rowIndex + 1 != this.rowCount) {
                    event.stop(e);
                    if (this.focus.rowIndex != this.scroller.lastVisibleRow - 1) {
                        this.focus.move(this.scroller.lastVisibleRow - this.focus.rowIndex - 1, 0);
                    } else {
                        this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex + 1));
                        this.focus.move(this.scroller.lastVisibleRow - this.scroller.firstVisibleRow - 1, 0);
                    }
                }
                break;
              default:
                break;
            }
        }, onMouseOver:function (e) {
            e.rowIndex == -1 ? this.onHeaderCellMouseOver(e) : this.onCellMouseOver(e);
        }, onMouseOut:function (e) {
            e.rowIndex == -1 ? this.onHeaderCellMouseOut(e) : this.onCellMouseOut(e);
        }, onMouseDown:function (e) {
            e.rowIndex == -1 ? this.onHeaderCellMouseDown(e) : this.onCellMouseDown(e);
        }, onMouseOverRow:function (e) {
            if (!this.rows.isOver(e.rowIndex)) {
                this.rows.setOverRow(e.rowIndex);
                e.rowIndex == -1 ? this.onHeaderMouseOver(e) : this.onRowMouseOver(e);
            }
        }, onMouseOutRow:function (e) {
            if (this.rows.isOver(-1)) {
                this.onHeaderMouseOut(e);
            } else {
                if (!this.rows.isOver(-2)) {
                    this.rows.setOverRow(-2);
                    this.onRowMouseOut(e);
                }
            }
        }, onMouseDownRow:function (e) {
            if (e.rowIndex != -1) {
                this.onRowMouseDown(e);
            }
        }, onCellMouseOver:function (e) {
            if (e.cellNode) {
                domClass.add(e.cellNode, this.cellOverClass);
            }
        }, onCellMouseOut:function (e) {
            if (e.cellNode) {
                domClass.remove(e.cellNode, this.cellOverClass);
            }
        }, onCellMouseDown:function (e) {
        }, onCellClick:function (e) {
            this._click[0] = this._click[1];
            this._click[1] = e;
            if (!this.edit.isEditCell(e.rowIndex, e.cellIndex)) {
                this.focus.setFocusCell(e.cell, e.rowIndex);
            }
            if (this._click.length > 1 && this._click[0] == null) {
                this._click.shift();
            }
            this.onRowClick(e);
        }, onCellDblClick:function (e) {
            var event;
            if (this._click.length > 1 && has("ie")) {
                event = this._click[1];
            } else {
                if (this._click.length > 1 && this._click[0].rowIndex != this._click[1].rowIndex) {
                    event = this._click[0];
                } else {
                    event = e;
                }
            }
            this.focus.setFocusCell(event.cell, event.rowIndex);
            this.edit.setEditCell(event.cell, event.rowIndex);
            this.onRowDblClick(e);
        }, onCellContextMenu:function (e) {
            this.onRowContextMenu(e);
        }, onCellFocus:function (inCell, inRowIndex) {
            this.edit.cellFocus(inCell, inRowIndex);
        }, onRowClick:function (e) {
            this.edit.rowClick(e);
            this.selection.clickSelectEvent(e);
        }, onRowDblClick:function (e) {
        }, onRowMouseOver:function (e) {
        }, onRowMouseOut:function (e) {
        }, onRowMouseDown:function (e) {
        }, onRowContextMenu:function (e) {
            event.stop(e);
        }, onHeaderMouseOver:function (e) {
        }, onHeaderMouseOut:function (e) {
        }, onHeaderCellMouseOver:function (e) {
            if (e.cellNode) {
                domClass.add(e.cellNode, this.cellOverClass);
            }
        }, onHeaderCellMouseOut:function (e) {
            if (e.cellNode) {
                domClass.remove(e.cellNode, this.cellOverClass);
            }
        }, onHeaderCellMouseDown:function (e) {
        }, onHeaderClick:function (e) {
        }, onHeaderCellClick:function (e) {
            this.setSortIndex(e.cell.index);
            this.onHeaderClick(e);
        }, onHeaderDblClick:function (e) {
        }, onHeaderCellDblClick:function (e) {
            this.onHeaderDblClick(e);
        }, onHeaderCellContextMenu:function (e) {
            this.onHeaderContextMenu(e);
        }, onHeaderContextMenu:function (e) {
            if (!this.headerMenu) {
                event.stop(e);
            }
        }, onStartEdit:function (inCell, inRowIndex) {
        }, onApplyCellEdit:function (inValue, inRowIndex, inFieldIndex) {
        }, onCancelEdit:function (inRowIndex) {
        }, onApplyEdit:function (inRowIndex) {
        }, onCanSelect:function (inRowIndex) {
            return true;
        }, onCanDeselect:function (inRowIndex) {
            return true;
        }, onSelected:function (inRowIndex) {
            this.updateRowStyles(inRowIndex);
        }, onDeselected:function (inRowIndex) {
            this.updateRowStyles(inRowIndex);
        }, onSelectionChanged:function () {
        }});
    });
}, "dojo/on":function () {
    define(["./has!dom-addeventlistener?:./aspect", "./_base/kernel", "./sniff"], function (aspect, dojo, has) {
        "use strict";
        if (1) {
            var major = window.ScriptEngineMajorVersion;
            has.add("jscript", major && (major() + ScriptEngineMinorVersion() / 10));
            has.add("event-orientationchange", has("touch") && !has("android"));
            has.add("event-stopimmediatepropagation", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
            has.add("event-focusin", function (global, doc, element) {
                return "onfocusin" in element;
            });
        }
        var on = function (target, type, listener, dontFix) {
            if (typeof target.on == "function" && typeof type != "function" && !target.nodeType) {
                return target.on(type, listener);
            }
            return on.parse(target, type, listener, addListener, dontFix, this);
        };
        on.pausable = function (target, type, listener, dontFix) {
            var paused;
            var signal = on(target, type, function () {
                if (!paused) {
                    return listener.apply(this, arguments);
                }
            }, dontFix);
            signal.pause = function () {
                paused = true;
            };
            signal.resume = function () {
                paused = false;
            };
            return signal;
        };
        on.once = function (target, type, listener, dontFix) {
            var signal = on(target, type, function () {
                signal.remove();
                return listener.apply(this, arguments);
            });
            return signal;
        };
        on.parse = function (target, type, listener, addListener, dontFix, matchesTarget) {
            if (type.call) {
                return type.call(matchesTarget, target, listener);
            }
            if (type.indexOf(",") > -1) {
                var events = type.split(/\s*,\s*/);
                var handles = [];
                var i = 0;
                var eventName;
                while (eventName = events[i++]) {
                    handles.push(addListener(target, eventName, listener, dontFix, matchesTarget));
                }
                handles.remove = function () {
                    for (var i = 0; i < handles.length; i++) {
                        handles[i].remove();
                    }
                };
                return handles;
            }
            return addListener(target, type, listener, dontFix, matchesTarget);
        };
        var touchEvents = /^touch/;
        function addListener(target, type, listener, dontFix, matchesTarget) {
            var selector = type.match(/(.*):(.*)/);
            if (selector) {
                type = selector[2];
                selector = selector[1];
                return on.selector(selector, type).call(matchesTarget, target, listener);
            }
            if (has("touch")) {
                if (touchEvents.test(type)) {
                    listener = fixTouchListener(listener);
                }
                if (!has("event-orientationchange") && (type == "orientationchange")) {
                    type = "resize";
                    target = window;
                    listener = fixTouchListener(listener);
                }
            }
            if (addStopImmediate) {
                listener = addStopImmediate(listener);
            }
            if (target.addEventListener) {
                var capture = type in captures, adjustedType = capture ? captures[type] : type;
                target.addEventListener(adjustedType, listener, capture);
                return {remove:function () {
                    target.removeEventListener(adjustedType, listener, capture);
                }};
            }
            type = "on" + type;
            if (fixAttach && target.attachEvent) {
                return fixAttach(target, type, listener);
            }
            throw new Error("Target must be an event emitter");
        }
        on.selector = function (selector, eventType, children) {
            return function (target, listener) {
                var matchesTarget = typeof selector == "function" ? {matches:selector} : this, bubble = eventType.bubble;
                function select(eventTarget) {
                    matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
                    while (!matchesTarget.matches(eventTarget, selector, target)) {
                        if (eventTarget == target || children === false || !(eventTarget = eventTarget.parentNode) || eventTarget.nodeType != 1) {
                            return;
                        }
                    }
                    return eventTarget;
                }
                if (bubble) {
                    return on(target, bubble(select), listener);
                }
                return on(target, eventType, function (event) {
                    var eventTarget = select(event.target);
                    return eventTarget && listener.call(eventTarget, event);
                });
            };
        };
        function syntheticPreventDefault() {
            this.cancelable = false;
            this.defaultPrevented = true;
        }
        function syntheticStopPropagation() {
            this.bubbles = false;
        }
        var slice = [].slice, syntheticDispatch = on.emit = function (target, type, event) {
            var args = slice.call(arguments, 2);
            var method = "on" + type;
            if ("parentNode" in target) {
                var newEvent = args[0] = {};
                for (var i in event) {
                    newEvent[i] = event[i];
                }
                newEvent.preventDefault = syntheticPreventDefault;
                newEvent.stopPropagation = syntheticStopPropagation;
                newEvent.target = target;
                newEvent.type = type;
                event = newEvent;
            }
            do {
                target[method] && target[method].apply(target, args);
            } while (event && event.bubbles && (target = target.parentNode));
            return event && event.cancelable && event;
        };
        var captures = has("event-focusin") ? {} : {focusin:"focus", focusout:"blur"};
        if (!has("event-stopimmediatepropagation")) {
            var stopImmediatePropagation = function () {
                this.immediatelyStopped = true;
                this.modified = true;
            };
            var addStopImmediate = function (listener) {
                return function (event) {
                    if (!event.immediatelyStopped) {
                        event.stopImmediatePropagation = stopImmediatePropagation;
                        return listener.apply(this, arguments);
                    }
                };
            };
        }
        if (has("dom-addeventlistener")) {
            on.emit = function (target, type, event) {
                if (target.dispatchEvent && document.createEvent) {
                    var ownerDocument = target.ownerDocument || document;
                    var nativeEvent = ownerDocument.createEvent("HTMLEvents");
                    nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
                    for (var i in event) {
                        if (!(i in nativeEvent)) {
                            nativeEvent[i] = event[i];
                        }
                    }
                    return target.dispatchEvent(nativeEvent) && nativeEvent;
                }
                return syntheticDispatch.apply(on, arguments);
            };
        } else {
            on._fixEvent = function (evt, sender) {
                if (!evt) {
                    var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
                    evt = w.event;
                }
                if (!evt) {
                    return evt;
                }
                try {
                    if (lastEvent && evt.type == lastEvent.type && evt.srcElement == lastEvent.target) {
                        evt = lastEvent;
                    }
                }
                catch (e) {
                }
                if (!evt.target) {
                    evt.target = evt.srcElement;
                    evt.currentTarget = (sender || evt.srcElement);
                    if (evt.type == "mouseover") {
                        evt.relatedTarget = evt.fromElement;
                    }
                    if (evt.type == "mouseout") {
                        evt.relatedTarget = evt.toElement;
                    }
                    if (!evt.stopPropagation) {
                        evt.stopPropagation = stopPropagation;
                        evt.preventDefault = preventDefault;
                    }
                    switch (evt.type) {
                      case "keypress":
                        var c = ("charCode" in evt ? evt.charCode : evt.keyCode);
                        if (c == 10) {
                            c = 0;
                            evt.keyCode = 13;
                        } else {
                            if (c == 13 || c == 27) {
                                c = 0;
                            } else {
                                if (c == 3) {
                                    c = 99;
                                }
                            }
                        }
                        evt.charCode = c;
                        _setKeyChar(evt);
                        break;
                    }
                }
                return evt;
            };
            var lastEvent, IESignal = function (handle) {
                this.handle = handle;
            };
            IESignal.prototype.remove = function () {
                delete _dojoIEListeners_[this.handle];
            };
            var fixListener = function (listener) {
                return function (evt) {
                    evt = on._fixEvent(evt, this);
                    var result = listener.call(this, evt);
                    if (evt.modified) {
                        if (!lastEvent) {
                            setTimeout(function () {
                                lastEvent = null;
                            });
                        }
                        lastEvent = evt;
                    }
                    return result;
                };
            };
            var fixAttach = function (target, type, listener) {
                listener = fixListener(listener);
                if (((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || has("jscript") < 5.8) && !has("config-_allow_leaks")) {
                    if (typeof _dojoIEListeners_ == "undefined") {
                        _dojoIEListeners_ = [];
                    }
                    var emitter = target[type];
                    if (!emitter || !emitter.listeners) {
                        var oldListener = emitter;
                        emitter = Function("event", "var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}");
                        emitter.listeners = [];
                        target[type] = emitter;
                        emitter.global = this;
                        if (oldListener) {
                            emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
                        }
                    }
                    var handle;
                    emitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));
                    return new IESignal(handle);
                }
                return aspect.after(target, type, listener, true);
            };
            var _setKeyChar = function (evt) {
                evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : "";
                evt.charOrCode = evt.keyChar || evt.keyCode;
            };
            var stopPropagation = function () {
                this.cancelBubble = true;
            };
            var preventDefault = on._preventDefault = function () {
                this.bubbledKeyCode = this.keyCode;
                if (this.ctrlKey) {
                    try {
                        this.keyCode = 0;
                    }
                    catch (e) {
                    }
                }
                this.defaultPrevented = true;
                this.returnValue = false;
                this.modified = true;
            };
        }
        if (has("touch")) {
            var Event = function () {
            };
            var windowOrientation = window.orientation;
            var fixTouchListener = function (listener) {
                return function (originalEvent) {
                    var event = originalEvent.corrected;
                    if (!event) {
                        var type = originalEvent.type;
                        try {
                            delete originalEvent.type;
                        }
                        catch (e) {
                        }
                        if (originalEvent.type) {
                            if (has("mozilla")) {
                                var event = {};
                                for (var name in originalEvent) {
                                    event[name] = originalEvent[name];
                                }
                            } else {
                                Event.prototype = originalEvent;
                                var event = new Event;
                            }
                            event.preventDefault = function () {
                                originalEvent.preventDefault();
                            };
                            event.stopPropagation = function () {
                                originalEvent.stopPropagation();
                            };
                        } else {
                            event = originalEvent;
                            event.type = type;
                        }
                        originalEvent.corrected = event;
                        if (type == "resize") {
                            if (windowOrientation == window.orientation) {
                                return null;
                            }
                            windowOrientation = window.orientation;
                            event.type = "orientationchange";
                            return listener.call(this, event);
                        }
                        if (!("rotation" in event)) {
                            event.rotation = 0;
                            event.scale = 1;
                        }
                        var firstChangeTouch = event.changedTouches[0];
                        for (var i in firstChangeTouch) {
                            delete event[i];
                            event[i] = firstChangeTouch[i];
                        }
                    }
                    return listener.call(this, event);
                };
            };
        }
        return on;
    });
}, "dojo/errors/create":function () {
    define(["../_base/lang"], function (lang) {
        return function (name, ctor, base, props) {
            base = base || Error;
            var ErrorCtor = function (message) {
                if (base === Error) {
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, ErrorCtor);
                    }
                    var err = Error.call(this, message), prop;
                    for (prop in err) {
                        if (err.hasOwnProperty(prop)) {
                            this[prop] = err[prop];
                        }
                    }
                    this.message = message;
                    this.stack = err.stack;
                } else {
                    base.apply(this, arguments);
                }
                if (ctor) {
                    ctor.apply(this, arguments);
                }
            };
            ErrorCtor.prototype = lang.delegate(base.prototype, props);
            ErrorCtor.prototype.name = name;
            ErrorCtor.prototype.constructor = ErrorCtor;
            return ErrorCtor;
        };
    });
}, "dijit/form/_ListBase":function () {
    define(["dojo/_base/declare", "dojo/on", "dojo/window"], function (declare, on, winUtils) {
        return declare("dijit.form._ListBase", null, {selected:null, _listConnect:function (eventType, callbackFuncName) {
            var self = this;
            return self.own(on(self.containerNode, on.selector(function (eventTarget, selector, target) {
                return eventTarget.parentNode == target;
            }, eventType), function (evt) {
                self[callbackFuncName](evt, this);
            }));
        }, selectFirstNode:function () {
            var first = this.containerNode.firstChild;
            while (first && first.style.display == "none") {
                first = first.nextSibling;
            }
            this._setSelectedAttr(first, true);
        }, selectLastNode:function () {
            var last = this.containerNode.lastChild;
            while (last && last.style.display == "none") {
                last = last.previousSibling;
            }
            this._setSelectedAttr(last, true);
        }, selectNextNode:function () {
            var selectedNode = this.selected;
            if (!selectedNode) {
                this.selectFirstNode();
            } else {
                var next = selectedNode.nextSibling;
                while (next && next.style.display == "none") {
                    next = next.nextSibling;
                }
                if (!next) {
                    this.selectFirstNode();
                } else {
                    this._setSelectedAttr(next, true);
                }
            }
        }, selectPreviousNode:function () {
            var selectedNode = this.selected;
            if (!selectedNode) {
                this.selectLastNode();
            } else {
                var prev = selectedNode.previousSibling;
                while (prev && prev.style.display == "none") {
                    prev = prev.previousSibling;
                }
                if (!prev) {
                    this.selectLastNode();
                } else {
                    this._setSelectedAttr(prev, true);
                }
            }
        }, _setSelectedAttr:function (node, scroll) {
            if (this.selected != node) {
                var selectedNode = this.selected;
                if (selectedNode) {
                    this.onDeselect(selectedNode);
                }
                if (node) {
                    if (scroll) {
                        winUtils.scrollIntoView(node);
                    }
                    this.onSelect(node);
                }
                this._set("selected", node);
            } else {
                if (node) {
                    this.onSelect(node);
                }
            }
        }});
    });
}, "dijit/typematic":function () {
    define(["dojo/_base/array", "dojo/_base/connect", "dojo/_base/lang", "dojo/on", "dojo/sniff", "./main"], function (array, connect, lang, on, has, dijit) {
        var typematic = (dijit.typematic = {_fireEventAndReload:function () {
            this._timer = null;
            this._callback(++this._count, this._node, this._evt);
            this._currentTimeout = Math.max(this._currentTimeout < 0 ? this._initialDelay : (this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)), this._minDelay);
            this._timer = setTimeout(lang.hitch(this, "_fireEventAndReload"), this._currentTimeout);
        }, trigger:function (evt, _this, node, callback, obj, subsequentDelay, initialDelay, minDelay) {
            if (obj != this._obj) {
                this.stop();
                this._initialDelay = initialDelay || 500;
                this._subsequentDelay = subsequentDelay || 0.9;
                this._minDelay = minDelay || 10;
                this._obj = obj;
                this._node = node;
                this._currentTimeout = -1;
                this._count = -1;
                this._callback = lang.hitch(_this, callback);
                this._evt = {faux:true};
                for (var attr in evt) {
                    if (attr != "layerX" && attr != "layerY") {
                        var v = evt[attr];
                        if (typeof v != "function" && typeof v != "undefined") {
                            this._evt[attr] = v;
                        }
                    }
                }
                this._fireEventAndReload();
            }
        }, stop:function () {
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }
            if (this._obj) {
                this._callback(-1, this._node, this._evt);
                this._obj = null;
            }
        }, addKeyListener:function (node, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay) {
            var type = "keyCode" in keyObject ? "keydown" : "charCode" in keyObject ? "keypress" : connect._keypress, attr = "keyCode" in keyObject ? "keyCode" : "charCode" in keyObject ? "charCode" : "charOrCode";
            var handles = [on(node, type, lang.hitch(this, function (evt) {
                if (evt[attr] == keyObject[attr] && (keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) && (keyObject.altKey === undefined || keyObject.altKey == evt.altKey) && (keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && (keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)) {
                    evt.stopPropagation();
                    evt.preventDefault();
                    typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
                } else {
                    if (typematic._obj == keyObject) {
                        typematic.stop();
                    }
                }
            })), on(node, "keyup", lang.hitch(this, function () {
                if (typematic._obj == keyObject) {
                    typematic.stop();
                }
            }))];
            return {remove:function () {
                array.forEach(handles, function (h) {
                    h.remove();
                });
            }};
        }, addMouseListener:function (node, _this, callback, subsequentDelay, initialDelay, minDelay) {
            var handles = [on(node, "mousedown", lang.hitch(this, function (evt) {
                evt.preventDefault();
                typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
            })), on(node, "mouseup", lang.hitch(this, function (evt) {
                if (this._obj) {
                    evt.preventDefault();
                }
                typematic.stop();
            })), on(node, "mouseout", lang.hitch(this, function (evt) {
                if (this._obj) {
                    evt.preventDefault();
                }
                typematic.stop();
            })), on(node, "dblclick", lang.hitch(this, function (evt) {
                evt.preventDefault();
                if (has("ie") < 9) {
                    typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
                    setTimeout(lang.hitch(this, typematic.stop), 50);
                }
            }))];
            return {remove:function () {
                array.forEach(handles, function (h) {
                    h.remove();
                });
            }};
        }, addListener:function (mouseNode, keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay) {
            var handles = [this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay), this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay)];
            return {remove:function () {
                array.forEach(handles, function (h) {
                    h.remove();
                });
            }};
        }});
        return typematic;
    });
}, "dojox/grid/enhanced/plugins/Menu":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/html", "dojo/_base/event", "dojo/keys", "../_Plugin", "../../EnhancedGrid"], function (declare, array, lang, html, evt, keys, _Plugin, EnhancedGrid) {
        var Menu = declare("dojox.grid.enhanced.plugins.Menu", _Plugin, {name:"menus", types:["headerMenu", "rowMenu", "cellMenu", "selectedRegionMenu"], constructor:function () {
            var g = this.grid;
            g.showMenu = lang.hitch(g, this.showMenu);
            g._setRowMenuAttr = lang.hitch(this, "_setRowMenuAttr");
            g._setCellMenuAttr = lang.hitch(this, "_setCellMenuAttr");
            g._setSelectedRegionMenuAttr = lang.hitch(this, "_setSelectedRegionMenuAttr");
        }, onStartUp:function () {
            var type, option = this.option;
            for (type in option) {
                if (array.indexOf(this.types, type) >= 0 && option[type]) {
                    this._initMenu(type, option[type]);
                }
            }
        }, _initMenu:function (menuType, menu) {
            var g = this.grid;
            if (!g[menuType]) {
                var m = this._getMenuWidget(menu);
                if (!m) {
                    return;
                }
                g.set(menuType, m);
                if (menuType != "headerMenu") {
                    m._scheduleOpen = function () {
                        return;
                    };
                } else {
                    g.setupHeaderMenu();
                }
            }
        }, _getMenuWidget:function (menu) {
            return (menu instanceof dijit.Menu) ? menu : dijit.byId(menu);
        }, _setRowMenuAttr:function (menu) {
            this._setMenuAttr(menu, "rowMenu");
        }, _setCellMenuAttr:function (menu) {
            this._setMenuAttr(menu, "cellMenu");
        }, _setSelectedRegionMenuAttr:function (menu) {
            this._setMenuAttr(menu, "selectedRegionMenu");
        }, _setMenuAttr:function (menu, menuType) {
            var g = this.grid, n = g.domNode;
            if (!menu || !(menu instanceof dijit.Menu)) {
                console.warn(menuType, " of Grid ", g.id, " is not existed!");
                return;
            }
            if (g[menuType]) {
                g[menuType].unBindDomNode(n);
            }
            g[menuType] = menu;
            g[menuType].bindDomNode(n);
        }, showMenu:function (e) {
            var inSelectedRegion = (e.cellNode && html.hasClass(e.cellNode, "dojoxGridRowSelected") || e.rowNode && (html.hasClass(e.rowNode, "dojoxGridRowSelected") || html.hasClass(e.rowNode, "dojoxGridRowbarSelected")));
            if (inSelectedRegion && this.selectedRegionMenu) {
                this.onSelectedRegionContextMenu(e);
                return;
            }
            var info = {target:e.target, coords:e.keyCode !== keys.F10 && "pageX" in e ? {x:e.pageX, y:e.pageY} : null};
            if (this.rowMenu && (!this.cellMenu || this.selection.isSelected(e.rowIndex) || e.rowNode && html.hasClass(e.rowNode, "dojoxGridRowbar"))) {
                this.rowMenu._openMyself(info);
                evt.stop(e);
                return;
            }
            if (this.cellMenu) {
                this.cellMenu._openMyself(info);
            }
            evt.stop(e);
        }, destroy:function () {
            var g = this.grid;
            if (g.headerMenu) {
                g.headerMenu.unBindDomNode(g.viewsHeaderNode);
            }
            if (g.rowMenu) {
                g.rowMenu.unBindDomNode(g.domNode);
            }
            if (g.cellMenu) {
                g.cellMenu.unBindDomNode(g.domNode);
            }
            if (g.selectedRegionMenu) {
                g.selectedRegionMenu.destroy();
            }
            this.inherited(arguments);
        }});
        EnhancedGrid.registerPlugin(Menu);
        return Menu;
    });
}, "dojo/dnd/move":function () {
    define(["../_base/declare", "../dom-geometry", "../dom-style", "./common", "./Mover", "./Moveable"], function (declare, domGeom, domStyle, dnd, Mover, Moveable) {
        var constrainedMoveable = declare("dojo.dnd.move.constrainedMoveable", Moveable, {constraints:function () {
        }, within:false, constructor:function (node, params) {
            if (!params) {
                params = {};
            }
            this.constraints = params.constraints;
            this.within = params.within;
        }, onFirstMove:function (mover) {
            var c = this.constraintBox = this.constraints.call(this, mover);
            c.r = c.l + c.w;
            c.b = c.t + c.h;
            if (this.within) {
                var mb = domGeom.getMarginSize(mover.node);
                c.r -= mb.w;
                c.b -= mb.h;
            }
        }, onMove:function (mover, leftTop) {
            var c = this.constraintBox, s = mover.node.style;
            this.onMoving(mover, leftTop);
            leftTop.l = leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l;
            leftTop.t = leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t;
            s.left = leftTop.l + "px";
            s.top = leftTop.t + "px";
            this.onMoved(mover, leftTop);
        }});
        var boxConstrainedMoveable = declare("dojo.dnd.move.boxConstrainedMoveable", constrainedMoveable, {box:{}, constructor:function (node, params) {
            var box = params && params.box;
            this.constraints = function () {
                return box;
            };
        }});
        var parentConstrainedMoveable = declare("dojo.dnd.move.parentConstrainedMoveable", constrainedMoveable, {area:"content", constructor:function (node, params) {
            var area = params && params.area;
            this.constraints = function () {
                var n = this.node.parentNode, s = domStyle.getComputedStyle(n), mb = domGeom.getMarginBox(n, s);
                if (area == "margin") {
                    return mb;
                }
                var t = domGeom.getMarginExtents(n, s);
                mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
                if (area == "border") {
                    return mb;
                }
                t = domGeom.getBorderExtents(n, s);
                mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
                if (area == "padding") {
                    return mb;
                }
                t = domGeom.getPadExtents(n, s);
                mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
                return mb;
            };
        }});
        return {constrainedMoveable:constrainedMoveable, boxConstrainedMoveable:boxConstrainedMoveable, parentConstrainedMoveable:parentConstrainedMoveable};
    });
}, "dojo/promise/instrumentation":function () {
    define(["./tracer", "../has", "../_base/lang", "../_base/array"], function (tracer, has, lang, arrayUtil) {
        has.add("config-useDeferredInstrumentation", "report-unhandled-rejections");
        function logError(error, rejection, deferred) {
            var stack = "";
            if (error && error.stack) {
                stack += error.stack;
            }
            if (rejection && rejection.stack) {
                stack += "\n    ----------------------------------------\n    rejected" + rejection.stack.split("\n").slice(1).join("\n").replace(/^\s+/, " ");
            }
            if (deferred && deferred.stack) {
                stack += "\n    ----------------------------------------\n" + deferred.stack;
            }
            console.error(error, stack);
        }
        function reportRejections(error, handled, rejection, deferred) {
            if (!handled) {
                logError(error, rejection, deferred);
            }
        }
        var errors = [];
        var activeTimeout = false;
        var unhandledWait = 1000;
        function trackUnhandledRejections(error, handled, rejection, deferred) {
            if (handled) {
                arrayUtil.some(errors, function (obj, ix) {
                    if (obj.error === error) {
                        errors.splice(ix, 1);
                        return true;
                    }
                });
            } else {
                if (!arrayUtil.some(errors, function (obj) {
                    return obj.error === error;
                })) {
                    errors.push({error:error, rejection:rejection, deferred:deferred, timestamp:new Date().getTime()});
                }
            }
            if (!activeTimeout) {
                activeTimeout = setTimeout(logRejected, unhandledWait);
            }
        }
        function logRejected() {
            var now = new Date().getTime();
            var reportBefore = now - unhandledWait;
            errors = arrayUtil.filter(errors, function (obj) {
                if (obj.timestamp < reportBefore) {
                    logError(obj.error, obj.rejection, obj.deferred);
                    return false;
                }
                return true;
            });
            if (errors.length) {
                activeTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);
            } else {
                activeTimeout = false;
            }
        }
        return function (Deferred) {
            var usage = has("config-useDeferredInstrumentation");
            if (usage) {
                tracer.on("resolved", lang.hitch(console, "log", "resolved"));
                tracer.on("rejected", lang.hitch(console, "log", "rejected"));
                tracer.on("progress", lang.hitch(console, "log", "progress"));
                var args = [];
                if (typeof usage === "string") {
                    args = usage.split(",");
                    usage = args.shift();
                }
                if (usage === "report-rejections") {
                    Deferred.instrumentRejected = reportRejections;
                } else {
                    if (usage === "report-unhandled-rejections" || usage === true || usage === 1) {
                        Deferred.instrumentRejected = trackUnhandledRejections;
                        unhandledWait = parseInt(args[0], 10) || unhandledWait;
                    } else {
                        throw new Error("Unsupported instrumentation usage <" + usage + ">");
                    }
                }
            }
        };
    });
}, "dojo/_base/connect":function () {
    define(["./kernel", "../on", "../topic", "../aspect", "./event", "../mouse", "./sniff", "./lang", "../keys"], function (dojo, on, hub, aspect, eventModule, mouse, has, lang) {
        has.add("events-keypress-typed", function () {
            var testKeyEvent = {charCode:0};
            try {
                testKeyEvent = document.createEvent("KeyboardEvent");
                (testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, "keypress", true, true, null, false, false, false, false, 9, 3);
            }
            catch (e) {
            }
            return testKeyEvent.charCode == 0 && !has("opera");
        });
        function connect_(obj, event, context, method, dontFix) {
            method = lang.hitch(context, method);
            if (!obj || !(obj.addEventListener || obj.attachEvent)) {
                return aspect.after(obj || dojo.global, event, method, true);
            }
            if (typeof event == "string" && event.substring(0, 2) == "on") {
                event = event.substring(2);
            }
            if (!obj) {
                obj = dojo.global;
            }
            if (!dontFix) {
                switch (event) {
                  case "keypress":
                    event = keypress;
                    break;
                  case "mouseenter":
                    event = mouse.enter;
                    break;
                  case "mouseleave":
                    event = mouse.leave;
                    break;
                }
            }
            return on(obj, event, method, dontFix);
        }
        var _punctMap = {106:42, 111:47, 186:59, 187:43, 188:44, 189:45, 190:46, 191:47, 192:96, 219:91, 220:92, 221:93, 222:39, 229:113};
        var evtCopyKey = has("mac") ? "metaKey" : "ctrlKey";
        var _synthesizeEvent = function (evt, props) {
            var faux = lang.mixin({}, evt, props);
            setKeyChar(faux);
            faux.preventDefault = function () {
                evt.preventDefault();
            };
            faux.stopPropagation = function () {
                evt.stopPropagation();
            };
            return faux;
        };
        function setKeyChar(evt) {
            evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : "";
            evt.charOrCode = evt.keyChar || evt.keyCode;
        }
        var keypress;
        if (has("events-keypress-typed")) {
            var _trySetKeyCode = function (e, code) {
                try {
                    return (e.keyCode = code);
                }
                catch (e) {
                    return 0;
                }
            };
            keypress = function (object, listener) {
                var keydownSignal = on(object, "keydown", function (evt) {
                    var k = evt.keyCode;
                    var unprintable = (k != 13) && k != 32 && (k != 27 || !has("ie")) && (k < 48 || k > 90) && (k < 96 || k > 111) && (k < 186 || k > 192) && (k < 219 || k > 222) && k != 229;
                    if (unprintable || evt.ctrlKey) {
                        var c = unprintable ? 0 : k;
                        if (evt.ctrlKey) {
                            if (k == 3 || k == 13) {
                                return listener.call(evt.currentTarget, evt);
                            } else {
                                if (c > 95 && c < 106) {
                                    c -= 48;
                                } else {
                                    if ((!evt.shiftKey) && (c >= 65 && c <= 90)) {
                                        c += 32;
                                    } else {
                                        c = _punctMap[c] || c;
                                    }
                                }
                            }
                        }
                        var faux = _synthesizeEvent(evt, {type:"keypress", faux:true, charCode:c});
                        listener.call(evt.currentTarget, faux);
                        if (has("ie")) {
                            _trySetKeyCode(evt, faux.keyCode);
                        }
                    }
                });
                var keypressSignal = on(object, "keypress", function (evt) {
                    var c = evt.charCode;
                    c = c >= 32 ? c : 0;
                    evt = _synthesizeEvent(evt, {charCode:c, faux:true});
                    return listener.call(this, evt);
                });
                return {remove:function () {
                    keydownSignal.remove();
                    keypressSignal.remove();
                }};
            };
        } else {
            if (has("opera")) {
                keypress = function (object, listener) {
                    return on(object, "keypress", function (evt) {
                        var c = evt.which;
                        if (c == 3) {
                            c = 99;
                        }
                        c = c < 32 && !evt.shiftKey ? 0 : c;
                        if (evt.ctrlKey && !evt.shiftKey && c >= 65 && c <= 90) {
                            c += 32;
                        }
                        return listener.call(this, _synthesizeEvent(evt, {charCode:c}));
                    });
                };
            } else {
                keypress = function (object, listener) {
                    return on(object, "keypress", function (evt) {
                        setKeyChar(evt);
                        return listener.call(this, evt);
                    });
                };
            }
        }
        var connect = {_keypress:keypress, connect:function (obj, event, context, method, dontFix) {
            var a = arguments, args = [], i = 0;
            args.push(typeof a[0] == "string" ? null : a[i++], a[i++]);
            var a1 = a[i + 1];
            args.push(typeof a1 == "string" || typeof a1 == "function" ? a[i++] : null, a[i++]);
            for (var l = a.length; i < l; i++) {
                args.push(a[i]);
            }
            return connect_.apply(this, args);
        }, disconnect:function (handle) {
            if (handle) {
                handle.remove();
            }
        }, subscribe:function (topic, context, method) {
            return hub.subscribe(topic, lang.hitch(context, method));
        }, publish:function (topic, args) {
            return hub.publish.apply(hub, [topic].concat(args));
        }, connectPublisher:function (topic, obj, event) {
            var pf = function () {
                connect.publish(topic, arguments);
            };
            return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf);
        }, isCopyKey:function (e) {
            return e[evtCopyKey];
        }};
        connect.unsubscribe = connect.disconnect;
        1 && lang.mixin(dojo, connect);
        return connect;
    });
}, "dojo/io/iframe":function () {
    define(["../_base/config", "../_base/json", "../_base/kernel", "../_base/lang", "../_base/xhr", "../sniff", "../_base/window", "../dom", "../dom-construct", "../query", "require", "../aspect", "../request/iframe"], function (config, json, kernel, lang, xhr, has, win, dom, domConstruct, query, require, aspect, _iframe) {
        kernel.deprecated("dojo/io/iframe", "Use dojo/request/iframe.", "2.0");
        var mid = _iframe._iframeName;
        mid = mid.substring(0, mid.lastIndexOf("_"));
        var iframe = lang.delegate(_iframe, {create:function () {
            return iframe._frame = _iframe.create.apply(_iframe, arguments);
        }, get:null, post:null, send:function (args) {
            var rDfd;
            var dfd = xhr._ioSetArgs(args, function (dfd) {
                rDfd && rDfd.cancel();
            }, function (dfd) {
                var value = null, ioArgs = dfd.ioArgs;
                try {
                    var handleAs = ioArgs.handleAs;
                    if (handleAs === "xml" || handleAs === "html") {
                        value = rDfd.response.data;
                    } else {
                        value = rDfd.response.text;
                        if (handleAs === "json") {
                            value = json.fromJson(value);
                        } else {
                            if (handleAs === "javascript") {
                                value = kernel.eval(value);
                            }
                        }
                    }
                }
                catch (e) {
                    value = e;
                }
                return value;
            }, function (error, dfd) {
                dfd.ioArgs._hasError = true;
                return error;
            });
            var ioArgs = dfd.ioArgs;
            var method = "GET", form = dom.byId(args.form);
            if (args.method && args.method.toUpperCase() === "POST" && form) {
                method = "POST";
            }
            var options = {method:method, handleAs:args.handleAs === "json" || args.handleAs === "javascript" ? "text" : args.handleAs, form:args.form, query:form ? null : args.content, data:form ? args.content : null, timeout:args.timeout, ioArgs:ioArgs};
            if (options.method) {
                options.method = options.method.toUpperCase();
            }
            if (config.ioPublish && kernel.publish && ioArgs.args.ioPublish !== false) {
                var start = aspect.after(_iframe, "_notifyStart", function (data) {
                    if (data.options.ioArgs === ioArgs) {
                        start.remove();
                        xhr._ioNotifyStart(dfd);
                    }
                }, true);
            }
            rDfd = _iframe(ioArgs.url, options, true);
            ioArgs._callNext = rDfd._callNext;
            rDfd.then(function () {
                dfd.resolve(dfd);
            }).otherwise(function (error) {
                dfd.ioArgs.error = error;
                dfd.reject(error);
            });
            return dfd;
        }, _iframeOnload:win.global[mid + "_onload"]});
        lang.setObject("dojo.io.iframe", iframe);
        return iframe;
    });
}, "dijit/form/_FormSelectWidget":function () {
    define(["dojo/_base/array", "dojo/_base/Deferred", "dojo/aspect", "dojo/data/util/sorter", "dojo/_base/declare", "dojo/dom", "dojo/dom-class", "dojo/_base/kernel", "dojo/_base/lang", "dojo/query", "dojo/when", "dojo/store/util/QueryResults", "./_FormValueWidget"], function (array, Deferred, aspect, sorter, declare, dom, domClass, kernel, lang, query, when, QueryResults, _FormValueWidget) {
        var _FormSelectWidget = declare("dijit.form._FormSelectWidget", _FormValueWidget, {multiple:false, options:null, store:null, query:null, queryOptions:null, labelAttr:"", onFetch:null, sortByLabel:true, loadChildrenOnOpen:false, onLoadDeferred:null, getOptions:function (valueOrIdx) {
            var opts = this.options || [];
            if (valueOrIdx == null) {
                return opts;
            }
            if (lang.isArray(valueOrIdx)) {
                return array.map(valueOrIdx, "return this.getOptions(item);", this);
            }
            if (lang.isString(valueOrIdx)) {
                valueOrIdx = {value:valueOrIdx};
            }
            if (lang.isObject(valueOrIdx)) {
                if (!array.some(opts, function (option, idx) {
                    for (var a in valueOrIdx) {
                        if (!(a in option) || option[a] != valueOrIdx[a]) {
                            return false;
                        }
                    }
                    valueOrIdx = idx;
                    return true;
                })) {
                    valueOrIdx = -1;
                }
            }
            if (valueOrIdx >= 0 && valueOrIdx < opts.length) {
                return opts[valueOrIdx];
            }
            return null;
        }, addOption:function (option) {
            array.forEach(lang.isArray(option) ? option : [option], function (i) {
                if (i && lang.isObject(i)) {
                    this.options.push(i);
                }
            }, this);
            this._loadChildren();
        }, removeOption:function (valueOrIdx) {
            var oldOpts = this.getOptions(lang.isArray(valueOrIdx) ? valueOrIdx : [valueOrIdx]);
            array.forEach(oldOpts, function (option) {
                if (option) {
                    this.options = array.filter(this.options, function (node) {
                        return (node.value !== option.value || node.label !== option.label);
                    });
                    this._removeOptionItem(option);
                }
            }, this);
            this._loadChildren();
        }, updateOption:function (newOption) {
            array.forEach(lang.isArray(newOption) ? newOption : [newOption], function (i) {
                var oldOpt = this.getOptions({value:i.value}), k;
                if (oldOpt) {
                    for (k in i) {
                        oldOpt[k] = i[k];
                    }
                }
            }, this);
            this._loadChildren();
        }, setStore:function (store, selectedValue, fetchArgs) {
            var oStore = this.store;
            fetchArgs = fetchArgs || {};
            if (oStore !== store) {
                var h;
                while ((h = this._notifyConnections.pop())) {
                    h.remove();
                }
                if (!store.get) {
                    lang.mixin(store, {_oldAPI:true, get:function (id) {
                        var deferred = new Deferred();
                        this.fetchItemByIdentity({identity:id, onItem:function (object) {
                            deferred.resolve(object);
                        }, onError:function (error) {
                            deferred.reject(error);
                        }});
                        return deferred.promise;
                    }, query:function (query, options) {
                        var deferred = new Deferred(function () {
                            if (fetchHandle.abort) {
                                fetchHandle.abort();
                            }
                        });
                        deferred.total = new Deferred();
                        var fetchHandle = this.fetch(lang.mixin({query:query, onBegin:function (count) {
                            deferred.total.resolve(count);
                        }, onComplete:function (results) {
                            deferred.resolve(results);
                        }, onError:function (error) {
                            deferred.reject(error);
                        }}, options));
                        return new QueryResults(deferred);
                    }});
                    if (store.getFeatures()["dojo.data.api.Notification"]) {
                        this._notifyConnections = [aspect.after(store, "onNew", lang.hitch(this, "_onNewItem"), true), aspect.after(store, "onDelete", lang.hitch(this, "_onDeleteItem"), true), aspect.after(store, "onSet", lang.hitch(this, "_onSetItem"), true)];
                    }
                }
                this._set("store", store);
            }
            if (this.options && this.options.length) {
                this.removeOption(this.options);
            }
            if (this._queryRes && this._queryRes.close) {
                this._queryRes.close();
            }
            if (this._observeHandle && this._observeHandle.remove) {
                this._observeHandle.remove();
                this._observeHandle = null;
            }
            if (fetchArgs.query) {
                this._set("query", fetchArgs.query);
                this._set("queryOptions", fetchArgs.queryOptions);
            }
            if (store) {
                this._loadingStore = true;
                this.onLoadDeferred = new Deferred();
                this._queryRes = store.query(this.query, this.queryOptions);
                when(this._queryRes, lang.hitch(this, function (items) {
                    if (this.sortByLabel && !fetchArgs.sort && items.length) {
                        if (store.getValue) {
                            items.sort(sorter.createSortFunction([{attribute:store.getLabelAttributes(items[0])[0]}], store));
                        } else {
                            var labelAttr = this.labelAttr;
                            items.sort(function (a, b) {
                                return a[labelAttr] > b[labelAttr] ? 1 : b[labelAttr] > a[labelAttr] ? -1 : 0;
                            });
                        }
                    }
                    if (fetchArgs.onFetch) {
                        items = fetchArgs.onFetch.call(this, items, fetchArgs);
                    }
                    array.forEach(items, function (i) {
                        this._addOptionForItem(i);
                    }, this);
                    if (this._queryRes.observe) {
                        this._observeHandle = this._queryRes.observe(lang.hitch(this, function (object, deletedFrom, insertedInto) {
                            if (deletedFrom == insertedInto) {
                                this._onSetItem(object);
                            } else {
                                if (deletedFrom != -1) {
                                    this._onDeleteItem(object);
                                }
                                if (insertedInto != -1) {
                                    this._onNewItem(object);
                                }
                            }
                        }), true);
                    }
                    this._loadingStore = false;
                    this.set("value", "_pendingValue" in this ? this._pendingValue : selectedValue);
                    delete this._pendingValue;
                    if (!this.loadChildrenOnOpen) {
                        this._loadChildren();
                    } else {
                        this._pseudoLoadChildren(items);
                    }
                    this.onLoadDeferred.resolve(true);
                    this.onSetStore();
                }), function (err) {
                    console.error("dijit.form.Select: " + err.toString());
                    this.onLoadDeferred.reject(err);
                });
            }
            return oStore;
        }, _setValueAttr:function (newValue, priorityChange) {
            if (!this._onChangeActive) {
                priorityChange = null;
            }
            if (this._loadingStore) {
                this._pendingValue = newValue;
                return;
            }
            if (newValue == null) {
                return;
            }
            if (lang.isArray(newValue)) {
                newValue = array.map(newValue, function (value) {
                    return lang.isObject(value) ? value : {value:value};
                });
            } else {
                if (lang.isObject(newValue)) {
                    newValue = [newValue];
                } else {
                    newValue = [{value:newValue}];
                }
            }
            newValue = array.filter(this.getOptions(newValue), function (i) {
                return i && i.value;
            });
            var opts = this.getOptions() || [];
            if (!this.multiple && (!newValue[0] || !newValue[0].value) && !!opts.length) {
                newValue[0] = opts[0];
            }
            array.forEach(opts, function (opt) {
                opt.selected = array.some(newValue, function (v) {
                    return v.value === opt.value;
                });
            });
            var val = array.map(newValue, function (opt) {
                return opt.value;
            });
            if (typeof val == "undefined" || typeof val[0] == "undefined") {
                return;
            }
            var disp = array.map(newValue, function (opt) {
                return opt.label;
            });
            this._setDisplay(this.multiple ? disp : disp[0]);
            this.inherited(arguments, [this.multiple ? val : val[0], priorityChange]);
            this._updateSelection();
        }, _getDisplayedValueAttr:function () {
            var ret = array.map([].concat(this.get("selectedOptions")), function (v) {
                if (v && "label" in v) {
                    return v.label;
                } else {
                    if (v) {
                        return v.value;
                    }
                }
                return null;
            }, this);
            return this.multiple ? ret : ret[0];
        }, _setDisplayedValueAttr:function (label) {
            this.set("value", this.getOptions(typeof label == "string" ? {label:label} : label));
        }, _loadChildren:function () {
            if (this._loadingStore) {
                return;
            }
            array.forEach(this._getChildren(), function (child) {
                child.destroyRecursive();
            });
            array.forEach(this.options, this._addOptionItem, this);
            this._updateSelection();
        }, _updateSelection:function () {
            this.focusedChild = null;
            this._set("value", this._getValueFromOpts());
            var val = [].concat(this.value);
            if (val && val[0]) {
                var self = this;
                array.forEach(this._getChildren(), function (child) {
                    var isSelected = array.some(val, function (v) {
                        return child.option && (v === child.option.value);
                    });
                    if (isSelected && !self.multiple) {
                        self.focusedChild = child;
                    }
                    domClass.toggle(child.domNode, this.baseClass.replace(/\s+|$/g, "SelectedOption "), isSelected);
                    child.domNode.setAttribute("aria-selected", isSelected ? "true" : "false");
                }, this);
            }
        }, _getValueFromOpts:function () {
            var opts = this.getOptions() || [];
            if (!this.multiple && opts.length) {
                var opt = array.filter(opts, function (i) {
                    return i.selected;
                })[0];
                if (opt && opt.value) {
                    return opt.value;
                } else {
                    opts[0].selected = true;
                    return opts[0].value;
                }
            } else {
                if (this.multiple) {
                    return array.map(array.filter(opts, function (i) {
                        return i.selected;
                    }), function (i) {
                        return i.value;
                    }) || [];
                }
            }
            return "";
        }, _onNewItem:function (item, parentInfo) {
            if (!parentInfo || !parentInfo.parent) {
                this._addOptionForItem(item);
            }
        }, _onDeleteItem:function (item) {
            var store = this.store;
            this.removeOption({value:store.getIdentity(item)});
        }, _onSetItem:function (item) {
            this.updateOption(this._getOptionObjForItem(item));
        }, _getOptionObjForItem:function (item) {
            var store = this.store, label = (this.labelAttr && this.labelAttr in item) ? item[this.labelAttr] : store.getLabel(item), value = (label ? store.getIdentity(item) : null);
            return {value:value, label:label, item:item};
        }, _addOptionForItem:function (item) {
            var store = this.store;
            if (store.isItemLoaded && !store.isItemLoaded(item)) {
                store.loadItem({item:item, onItem:function (i) {
                    this._addOptionForItem(i);
                }, scope:this});
                return;
            }
            var newOpt = this._getOptionObjForItem(item);
            this.addOption(newOpt);
        }, constructor:function (params) {
            this._oValue = (params || {}).value || null;
            this._notifyConnections = [];
        }, buildRendering:function () {
            this.inherited(arguments);
            dom.setSelectable(this.focusNode, false);
        }, _fillContent:function () {
            if (!this.options) {
                this.options = this.srcNodeRef ? query("> *", this.srcNodeRef).map(function (node) {
                    if (node.getAttribute("type") === "separator") {
                        return {value:"", label:"", selected:false, disabled:false};
                    }
                    return {value:(node.getAttribute("data-" + kernel._scopeName + "-value") || node.getAttribute("value")), label:String(node.innerHTML), selected:node.getAttribute("selected") || false, disabled:node.getAttribute("disabled") || false};
                }, this) : [];
            }
            if (!this.value) {
                this._set("value", this._getValueFromOpts());
            } else {
                if (this.multiple && typeof this.value == "string") {
                    this._set("value", this.value.split(","));
                }
            }
        }, postCreate:function () {
            this.inherited(arguments);
            aspect.after(this, "onChange", lang.hitch(this, "_updateSelection"));
            var store = this.store;
            if (store && (store.getIdentity || store.getFeatures()["dojo.data.api.Identity"])) {
                this.store = null;
                this.setStore(store, this._oValue);
            }
        }, startup:function () {
            this._loadChildren();
            this.inherited(arguments);
        }, destroy:function () {
            var h;
            while ((h = this._notifyConnections.pop())) {
                h.remove();
            }
            if (this._queryRes && this._queryRes.close) {
                this._queryRes.close();
            }
            if (this._observeHandle && this._observeHandle.remove) {
                this._observeHandle.remove();
                this._observeHandle = null;
            }
            this.inherited(arguments);
        }, _addOptionItem:function () {
        }, _removeOptionItem:function () {
        }, _setDisplay:function () {
        }, _getChildren:function () {
            return [];
        }, _getSelectedOptionsAttr:function () {
            return this.getOptions({selected:true});
        }, _pseudoLoadChildren:function () {
        }, onSetStore:function () {
        }});
        return _FormSelectWidget;
    });
}, "dijit/form/_ComboBoxMenu":function () {
    define(["dojo/_base/declare", "dojo/dom-class", "dojo/dom-style", "dojo/keys", "../_WidgetBase", "../_TemplatedMixin", "./_ComboBoxMenuMixin", "./_ListMouseMixin"], function (declare, domClass, domStyle, keys, _WidgetBase, _TemplatedMixin, _ComboBoxMenuMixin, _ListMouseMixin) {
        return declare("dijit.form._ComboBoxMenu", [_WidgetBase, _TemplatedMixin, _ListMouseMixin, _ComboBoxMenuMixin], {templateString:"<div class='dijitReset dijitMenu' data-dojo-attach-point='containerNode' style='overflow: auto; overflow-x: hidden;' role='listbox'>" + "<div class='dijitMenuItem dijitMenuPreviousButton' data-dojo-attach-point='previousButton' role='option'></div>" + "<div class='dijitMenuItem dijitMenuNextButton' data-dojo-attach-point='nextButton' role='option'></div>" + "</div>", baseClass:"dijitComboBoxMenu", postCreate:function () {
            this.inherited(arguments);
            if (!this.isLeftToRight()) {
                domClass.add(this.previousButton, "dijitMenuItemRtl");
                domClass.add(this.nextButton, "dijitMenuItemRtl");
            }
            this.containerNode.setAttribute("role", "listbox");
        }, _createMenuItem:function () {
            var item = this.ownerDocument.createElement("div");
            item.className = "dijitReset dijitMenuItem" + (this.isLeftToRight() ? "" : " dijitMenuItemRtl");
            item.setAttribute("role", "option");
            return item;
        }, onHover:function (node) {
            domClass.add(node, "dijitMenuItemHover");
        }, onUnhover:function (node) {
            domClass.remove(node, "dijitMenuItemHover");
        }, onSelect:function (node) {
            domClass.add(node, "dijitMenuItemSelected");
        }, onDeselect:function (node) {
            domClass.remove(node, "dijitMenuItemSelected");
        }, _page:function (up) {
            var scrollamount = 0;
            var oldscroll = this.domNode.scrollTop;
            var height = domStyle.get(this.domNode, "height");
            if (!this.getHighlightedOption()) {
                this.selectNextNode();
            }
            while (scrollamount < height) {
                var highlighted_option = this.getHighlightedOption();
                if (up) {
                    if (!highlighted_option.previousSibling || highlighted_option.previousSibling.style.display == "none") {
                        break;
                    }
                    this.selectPreviousNode();
                } else {
                    if (!highlighted_option.nextSibling || highlighted_option.nextSibling.style.display == "none") {
                        break;
                    }
                    this.selectNextNode();
                }
                var newscroll = this.domNode.scrollTop;
                scrollamount += (newscroll - oldscroll) * (up ? -1 : 1);
                oldscroll = newscroll;
            }
        }, handleKey:function (evt) {
            switch (evt.keyCode) {
              case keys.DOWN_ARROW:
                this.selectNextNode();
                return false;
              case keys.PAGE_DOWN:
                this._page(false);
                return false;
              case keys.UP_ARROW:
                this.selectPreviousNode();
                return false;
              case keys.PAGE_UP:
                this._page(true);
                return false;
              default:
                return true;
            }
        }});
    });
}, "dijit/layout/_TabContainerBase":function () {
    define(["dojo/text!./templates/TabContainer.html", "./StackContainer", "./utils", "../_TemplatedMixin", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style"], function (template, StackContainer, layoutUtils, _TemplatedMixin, declare, domClass, domGeometry, domStyle) {
        return declare("dijit.layout._TabContainerBase", [StackContainer, _TemplatedMixin], {tabPosition:"top", baseClass:"dijitTabContainer", tabStrip:false, nested:false, templateString:template, postMixInProperties:function () {
            this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");
            this.srcNodeRef && domStyle.set(this.srcNodeRef, "visibility", "hidden");
            this.inherited(arguments);
        }, buildRendering:function () {
            this.inherited(arguments);
            this.tablist = this._makeController(this.tablistNode);
            if (!this.doLayout) {
                domClass.add(this.domNode, "dijitTabContainerNoLayout");
            }
            if (this.nested) {
                domClass.add(this.domNode, "dijitTabContainerNested");
                domClass.add(this.tablist.containerNode, "dijitTabContainerTabListNested");
                domClass.add(this.tablistSpacer, "dijitTabContainerSpacerNested");
                domClass.add(this.containerNode, "dijitTabPaneWrapperNested");
            } else {
                domClass.add(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
            }
        }, _setupChild:function (tab) {
            domClass.add(tab.domNode, "dijitTabPane");
            this.inherited(arguments);
        }, startup:function () {
            if (this._started) {
                return;
            }
            this.tablist.startup();
            this.inherited(arguments);
        }, layout:function () {
            if (!this._contentBox || typeof (this._contentBox.l) == "undefined") {
                return;
            }
            var sc = this.selectedChildWidget;
            if (this.doLayout) {
                var titleAlign = this.tabPosition.replace(/-h/, "");
                this.tablist.region = titleAlign;
                var children = [this.tablist, {domNode:this.tablistSpacer, region:titleAlign}, {domNode:this.containerNode, region:"center"}];
                layoutUtils.layoutChildren(this.domNode, this._contentBox, children);
                this._containerContentBox = layoutUtils.marginBox2contentBox(this.containerNode, children[2]);
                if (sc && sc.resize) {
                    sc.resize(this._containerContentBox);
                }
            } else {
                if (this.tablist.resize) {
                    var s = this.tablist.domNode.style;
                    s.width = "0";
                    var width = domGeometry.getContentBox(this.domNode).w;
                    s.width = "";
                    this.tablist.resize({w:width});
                }
                if (sc && sc.resize) {
                    sc.resize();
                }
            }
        }, destroy:function (preserveDom) {
            if (this.tablist) {
                this.tablist.destroy(preserveDom);
            }
            this.inherited(arguments);
        }});
    });
}, "dijit/_KeyNavContainer":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-attr", "dojo/_base/kernel", "dojo/keys", "dojo/_base/lang", "./registry", "./_Container", "./_FocusMixin", "./_KeyNavMixin"], function (array, declare, domAttr, kernel, keys, lang, registry, _Container, _FocusMixin, _KeyNavMixin) {
        return declare("dijit._KeyNavContainer", [_FocusMixin, _KeyNavMixin, _Container], {connectKeyNavHandlers:function (prevKeyCodes, nextKeyCodes) {
            var keyCodes = (this._keyNavCodes = {});
            var prev = lang.hitch(this, "focusPrev");
            var next = lang.hitch(this, "focusNext");
            array.forEach(prevKeyCodes, function (code) {
                keyCodes[code] = prev;
            });
            array.forEach(nextKeyCodes, function (code) {
                keyCodes[code] = next;
            });
            keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
            keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
        }, startupKeyNavChildren:function () {
            kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
        }, startup:function () {
            this.inherited(arguments);
            array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
        }, addChild:function (widget, insertIndex) {
            this.inherited(arguments);
            this._startupChild(widget);
        }, _startupChild:function (widget) {
            widget.set("tabIndex", "-1");
        }, _getFirst:function () {
            var children = this.getChildren();
            return children.length ? children[0] : null;
        }, _getLast:function () {
            var children = this.getChildren();
            return children.length ? children[children.length - 1] : null;
        }, focusNext:function () {
            this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
        }, focusPrev:function () {
            this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
        }, childSelector:function (node) {
            var node = registry.byNode(node);
            return node && node.getParent() == this;
        }});
    });
}, "dijit/form/DataList":function () {
    define(["dojo/_base/declare", "dojo/dom", "dojo/_base/lang", "dojo/query", "dojo/store/Memory", "../registry"], function (declare, dom, lang, query, MemoryStore, registry) {
        function toItem(option) {
            return {id:option.value, value:option.value, name:lang.trim(option.innerText || option.textContent || "")};
        }
        return declare("dijit.form.DataList", MemoryStore, {constructor:function (params, srcNodeRef) {
            this.domNode = dom.byId(srcNodeRef);
            lang.mixin(this, params);
            if (this.id) {
                registry.add(this);
            }
            this.domNode.style.display = "none";
            this.inherited(arguments, [{data:query("option", this.domNode).map(toItem)}]);
        }, destroy:function () {
            registry.remove(this.id);
        }, fetchSelectedItem:function () {
            var option = query("> option[selected]", this.domNode)[0] || query("> option", this.domNode)[0];
            return option && toItem(option);
        }});
    });
}, "dijit/Tooltip":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/_base/fx", "dojo/dom", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/lang", "dojo/mouse", "dojo/on", "dojo/sniff", "./_base/manager", "./place", "./_Widget", "./_TemplatedMixin", "./BackgroundIframe", "dojo/text!./templates/Tooltip.html", "./main"], function (array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has, manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit) {
        var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {duration:manager.defaultDuration, templateString:template, postCreate:function () {
            this.ownerDocumentBody.appendChild(this.domNode);
            this.bgIframe = new BackgroundIframe(this.domNode);
            this.fadeIn = fx.fadeIn({node:this.domNode, duration:this.duration, onEnd:lang.hitch(this, "_onShow")});
            this.fadeOut = fx.fadeOut({node:this.domNode, duration:this.duration, onEnd:lang.hitch(this, "_onHide")});
        }, show:function (innerHTML, aroundNode, position, rtl, textDir) {
            if (this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML) {
                return;
            }
            if (this.fadeOut.status() == "playing") {
                this._onDeck = arguments;
                return;
            }
            this.containerNode.innerHTML = innerHTML;
            if (textDir) {
                this.set("textDir", textDir);
            }
            this.containerNode.align = rtl ? "right" : "left";
            var pos = place.around(this.domNode, aroundNode, position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));
            var aroundNodeCoords = pos.aroundNodePos;
            if (pos.corner.charAt(0) == "M" && pos.aroundCorner.charAt(0) == "M") {
                this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
                this.connectorNode.style.left = "";
            } else {
                if (pos.corner.charAt(1) == "M" && pos.aroundCorner.charAt(1) == "M") {
                    this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
                } else {
                    this.connectorNode.style.left = "";
                    this.connectorNode.style.top = "";
                }
            }
            domStyle.set(this.domNode, "opacity", 0);
            this.fadeIn.play();
            this.isShowingNow = true;
            this.aroundNode = aroundNode;
        }, orient:function (node, aroundCorner, tooltipCorner, spaceAvailable, aroundNodeCoords) {
            this.connectorNode.style.top = "";
            var heightAvailable = spaceAvailable.h, widthAvailable = spaceAvailable.w;
            node.className = "dijitTooltip " + {"MR-ML":"dijitTooltipRight", "ML-MR":"dijitTooltipLeft", "TM-BM":"dijitTooltipAbove", "BM-TM":"dijitTooltipBelow", "BL-TL":"dijitTooltipBelow dijitTooltipABLeft", "TL-BL":"dijitTooltipAbove dijitTooltipABLeft", "BR-TR":"dijitTooltipBelow dijitTooltipABRight", "TR-BR":"dijitTooltipAbove dijitTooltipABRight", "BR-BL":"dijitTooltipRight", "BL-BR":"dijitTooltipLeft"}[aroundCorner + "-" + tooltipCorner];
            this.domNode.style.width = "auto";
            var size = domGeometry.position(this.domNode);
            if (has("ie") == 9) {
                size.w += 2;
            }
            var width = Math.min((Math.max(widthAvailable, 1)), size.w);
            domGeometry.setMarginBox(this.domNode, {w:width});
            if (tooltipCorner.charAt(0) == "B" && aroundCorner.charAt(0) == "B") {
                var bb = domGeometry.position(node);
                var tooltipConnectorHeight = this.connectorNode.offsetHeight;
                if (bb.h > heightAvailable) {
                    var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
                    this.connectorNode.style.top = aroundNodePlacement + "px";
                    this.connectorNode.style.bottom = "";
                } else {
                    this.connectorNode.style.bottom = Math.min(Math.max(aroundNodeCoords.h / 2 - tooltipConnectorHeight / 2, 0), bb.h - tooltipConnectorHeight) + "px";
                    this.connectorNode.style.top = "";
                }
            } else {
                this.connectorNode.style.top = "";
                this.connectorNode.style.bottom = "";
            }
            return Math.max(0, size.w - widthAvailable);
        }, _onShow:function () {
            if (has("ie")) {
                this.domNode.style.filter = "";
            }
        }, hide:function (aroundNode) {
            if (this._onDeck && this._onDeck[1] == aroundNode) {
                this._onDeck = null;
            } else {
                if (this.aroundNode === aroundNode) {
                    this.fadeIn.stop();
                    this.isShowingNow = false;
                    this.aroundNode = null;
                    this.fadeOut.play();
                } else {
                }
            }
        }, _onHide:function () {
            this.domNode.style.cssText = "";
            this.containerNode.innerHTML = "";
            if (this._onDeck) {
                this.show.apply(this, this._onDeck);
                this._onDeck = null;
            }
        }});
        if (has("dojo-bidi")) {
            MasterTooltip.extend({_setAutoTextDir:function (node) {
                this.applyTextDir(node);
                array.forEach(node.children, function (child) {
                    this._setAutoTextDir(child);
                }, this);
            }, _setTextDirAttr:function (textDir) {
                this._set("textDir", textDir);
                if (textDir == "auto") {
                    this._setAutoTextDir(this.containerNode);
                } else {
                    this.containerNode.dir = this.textDir;
                }
            }});
        }
        dijit.showTooltip = function (innerHTML, aroundNode, position, rtl, textDir) {
            if (position) {
                position = array.map(position, function (val) {
                    return {after:"after-centered", before:"before-centered"}[val] || val;
                });
            }
            if (!Tooltip._masterTT) {
                dijit._masterTT = Tooltip._masterTT = new MasterTooltip();
            }
            return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir);
        };
        dijit.hideTooltip = function (aroundNode) {
            return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
        };
        var Tooltip = declare("dijit.Tooltip", _Widget, {label:"", showDelay:400, connectId:[], position:[], selector:"", _setConnectIdAttr:function (newId) {
            array.forEach(this._connections || [], function (nested) {
                array.forEach(nested, function (handle) {
                    handle.remove();
                });
            }, this);
            this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []), function (id) {
                return dom.byId(id, this.ownerDocument);
            }, this);
            this._connections = array.map(this._connectIds, function (id) {
                var node = dom.byId(id, this.ownerDocument), selector = this.selector, delegatedEvent = selector ? function (eventType) {
                    return on.selector(selector, eventType);
                } : function (eventType) {
                    return eventType;
                }, self = this;
                return [on(node, delegatedEvent(mouse.enter), function () {
                    self._onHover(this);
                }), on(node, delegatedEvent("focusin"), function () {
                    self._onHover(this);
                }), on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")), on(node, delegatedEvent("focusout"), lang.hitch(self, "_onUnHover"))];
            }, this);
            this._set("connectId", newId);
        }, addTarget:function (node) {
            var id = node.id || node;
            if (array.indexOf(this._connectIds, id) == -1) {
                this.set("connectId", this._connectIds.concat(id));
            }
        }, removeTarget:function (node) {
            var id = node.id || node, idx = array.indexOf(this._connectIds, id);
            if (idx >= 0) {
                this._connectIds.splice(idx, 1);
                this.set("connectId", this._connectIds);
            }
        }, buildRendering:function () {
            this.inherited(arguments);
            domClass.add(this.domNode, "dijitTooltipData");
        }, startup:function () {
            this.inherited(arguments);
            var ids = this.connectId;
            array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
        }, getContent:function (node) {
            return this.label || this.domNode.innerHTML;
        }, _onHover:function (target) {
            if (!this._showTimer) {
                this._showTimer = this.defer(function () {
                    this.open(target);
                }, this.showDelay);
            }
        }, _onUnHover:function () {
            if (this._showTimer) {
                this._showTimer.remove();
                delete this._showTimer;
            }
            this.close();
        }, open:function (target) {
            if (this._showTimer) {
                this._showTimer.remove();
                delete this._showTimer;
            }
            var content = this.getContent(target);
            if (!content) {
                return;
            }
            Tooltip.show(content, target, this.position, !this.isLeftToRight(), this.textDir);
            this._connectNode = target;
            this.onShow(target, this.position);
        }, close:function () {
            if (this._connectNode) {
                Tooltip.hide(this._connectNode);
                delete this._connectNode;
                this.onHide();
            }
            if (this._showTimer) {
                this._showTimer.remove();
                delete this._showTimer;
            }
        }, onShow:function () {
        }, onHide:function () {
        }, destroy:function () {
            this.close();
            array.forEach(this._connections || [], function (nested) {
                array.forEach(nested, function (handle) {
                    handle.remove();
                });
            }, this);
            this.inherited(arguments);
        }});
        Tooltip._MasterTooltip = MasterTooltip;
        Tooltip.show = dijit.showTooltip;
        Tooltip.hide = dijit.hideTooltip;
        Tooltip.defaultPosition = ["after-centered", "before-centered"];
        return Tooltip;
    });
}, "dijit/PopupMenuItem":function () {
    define(["dojo/_base/declare", "dojo/dom-style", "dojo/_base/lang", "dojo/query", "./popup", "./registry", "./MenuItem", "./hccss"], function (declare, domStyle, lang, query, pm, registry, MenuItem) {
        return declare("dijit.PopupMenuItem", MenuItem, {_fillContent:function () {
            if (this.srcNodeRef) {
                var nodes = query("*", this.srcNodeRef);
                this.inherited(arguments, [nodes[0]]);
                this.dropDownContainer = this.srcNodeRef;
            }
        }, _openPopup:function (params, focus) {
            var popup = this.popup;
            pm.open(lang.delegate(params, {popup:this.popup, around:this.domNode}));
            if (focus && popup.focus) {
                popup.focus();
            }
        }, _closePopup:function () {
            pm.close(this.popup);
            this.popup.parentMenu = null;
        }, startup:function () {
            if (this._started) {
                return;
            }
            this.inherited(arguments);
            if (!this.popup) {
                var node = query("[widgetId]", this.dropDownContainer)[0];
                this.popup = registry.byNode(node);
            }
            this.ownerDocumentBody.appendChild(this.popup.domNode);
            this.popup.domNode.setAttribute("aria-labelledby", this.containerNode.id);
            this.popup.startup();
            this.popup.domNode.style.display = "none";
            if (this.arrowWrapper) {
                domStyle.set(this.arrowWrapper, "visibility", "");
            }
            this.focusNode.setAttribute("aria-haspopup", "true");
        }, destroyDescendants:function (preserveDom) {
            if (this.popup) {
                if (!this.popup._destroyed) {
                    this.popup.destroyRecursive(preserveDom);
                }
                delete this.popup;
            }
            this.inherited(arguments);
        }});
    });
}, "dojo/selector/acme":function () {
    define(["../dom", "../sniff", "../_base/array", "../_base/lang", "../_base/window"], function (dom, has, array, lang, win) {
        var trim = lang.trim;
        var each = array.forEach;
        var getDoc = function () {
            return win.doc;
        };
        var cssCaseBug = (getDoc().compatMode) == "BackCompat";
        var specials = ">~+";
        var caseSensitive = false;
        var yesman = function () {
            return true;
        };
        var getQueryParts = function (query) {
            if (specials.indexOf(query.slice(-1)) >= 0) {
                query += " * ";
            } else {
                query += " ";
            }
            var ts = function (s, e) {
                return trim(query.slice(s, e));
            };
            var queryParts = [];
            var inBrackets = -1, inParens = -1, inMatchFor = -1, inPseudo = -1, inClass = -1, inId = -1, inTag = -1, currentQuoteChar, lc = "", cc = "", pStart;
            var x = 0, ql = query.length, currentPart = null, _cp = null;
            var endTag = function () {
                if (inTag >= 0) {
                    var tv = (inTag == x) ? null : ts(inTag, x);
                    currentPart[(specials.indexOf(tv) < 0) ? "tag" : "oper"] = tv;
                    inTag = -1;
                }
            };
            var endId = function () {
                if (inId >= 0) {
                    currentPart.id = ts(inId, x).replace(/\\/g, "");
                    inId = -1;
                }
            };
            var endClass = function () {
                if (inClass >= 0) {
                    currentPart.classes.push(ts(inClass + 1, x).replace(/\\/g, ""));
                    inClass = -1;
                }
            };
            var endAll = function () {
                endId();
                endTag();
                endClass();
            };
            var endPart = function () {
                endAll();
                if (inPseudo >= 0) {
                    currentPart.pseudos.push({name:ts(inPseudo + 1, x)});
                }
                currentPart.loops = (currentPart.pseudos.length || currentPart.attrs.length || currentPart.classes.length);
                currentPart.oquery = currentPart.query = ts(pStart, x);
                currentPart.otag = currentPart.tag = (currentPart["oper"]) ? null : (currentPart.tag || "*");
                if (currentPart.tag) {
                    currentPart.tag = currentPart.tag.toUpperCase();
                }
                if (queryParts.length && (queryParts[queryParts.length - 1].oper)) {
                    currentPart.infixOper = queryParts.pop();
                    currentPart.query = currentPart.infixOper.query + " " + currentPart.query;
                }
                queryParts.push(currentPart);
                currentPart = null;
            };
            for (; lc = cc, cc = query.charAt(x), x < ql; x++) {
                if (lc == "\\") {
                    continue;
                }
                if (!currentPart) {
                    pStart = x;
                    currentPart = {query:null, pseudos:[], attrs:[], classes:[], tag:null, oper:null, id:null, getTag:function () {
                        return caseSensitive ? this.otag : this.tag;
                    }};
                    inTag = x;
                }
                if (currentQuoteChar) {
                    if (cc == currentQuoteChar) {
                        currentQuoteChar = null;
                    }
                    continue;
                } else {
                    if (cc == "'" || cc == "\"") {
                        currentQuoteChar = cc;
                        continue;
                    }
                }
                if (inBrackets >= 0) {
                    if (cc == "]") {
                        if (!_cp.attr) {
                            _cp.attr = ts(inBrackets + 1, x);
                        } else {
                            _cp.matchFor = ts((inMatchFor || inBrackets + 1), x);
                        }
                        var cmf = _cp.matchFor;
                        if (cmf) {
                            if ((cmf.charAt(0) == "\"") || (cmf.charAt(0) == "'")) {
                                _cp.matchFor = cmf.slice(1, -1);
                            }
                        }
                        if (_cp.matchFor) {
                            _cp.matchFor = _cp.matchFor.replace(/\\/g, "");
                        }
                        currentPart.attrs.push(_cp);
                        _cp = null;
                        inBrackets = inMatchFor = -1;
                    } else {
                        if (cc == "=") {
                            var addToCc = ("|~^$*".indexOf(lc) >= 0) ? lc : "";
                            _cp.type = addToCc + cc;
                            _cp.attr = ts(inBrackets + 1, x - addToCc.length);
                            inMatchFor = x + 1;
                        }
                    }
                } else {
                    if (inParens >= 0) {
                        if (cc == ")") {
                            if (inPseudo >= 0) {
                                _cp.value = ts(inParens + 1, x);
                            }
                            inPseudo = inParens = -1;
                        }
                    } else {
                        if (cc == "#") {
                            endAll();
                            inId = x + 1;
                        } else {
                            if (cc == ".") {
                                endAll();
                                inClass = x;
                            } else {
                                if (cc == ":") {
                                    endAll();
                                    inPseudo = x;
                                } else {
                                    if (cc == "[") {
                                        endAll();
                                        inBrackets = x;
                                        _cp = {};
                                    } else {
                                        if (cc == "(") {
                                            if (inPseudo >= 0) {
                                                _cp = {name:ts(inPseudo + 1, x), value:null};
                                                currentPart.pseudos.push(_cp);
                                            }
                                            inParens = x;
                                        } else {
                                            if ((cc == " ") && (lc != cc)) {
                                                endPart();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return queryParts;
        };
        var agree = function (first, second) {
            if (!first) {
                return second;
            }
            if (!second) {
                return first;
            }
            return function () {
                return first.apply(window, arguments) && second.apply(window, arguments);
            };
        };
        var getArr = function (i, arr) {
            var r = arr || [];
            if (i) {
                r.push(i);
            }
            return r;
        };
        var _isElement = function (n) {
            return (1 == n.nodeType);
        };
        var blank = "";
        var _getAttr = function (elem, attr) {
            if (!elem) {
                return blank;
            }
            if (attr == "class") {
                return elem.className || blank;
            }
            if (attr == "for") {
                return elem.htmlFor || blank;
            }
            if (attr == "style") {
                return elem.style.cssText || blank;
            }
            return (caseSensitive ? elem.getAttribute(attr) : elem.getAttribute(attr, 2)) || blank;
        };
        var attrs = {"*=":function (attr, value) {
            return function (elem) {
                return (_getAttr(elem, attr).indexOf(value) >= 0);
            };
        }, "^=":function (attr, value) {
            return function (elem) {
                return (_getAttr(elem, attr).indexOf(value) == 0);
            };
        }, "$=":function (attr, value) {
            return function (elem) {
                var ea = " " + _getAttr(elem, attr);
                var lastIndex = ea.lastIndexOf(value);
                return lastIndex > -1 && (lastIndex == (ea.length - value.length));
            };
        }, "~=":function (attr, value) {
            var tval = " " + value + " ";
            return function (elem) {
                var ea = " " + _getAttr(elem, attr) + " ";
                return (ea.indexOf(tval) >= 0);
            };
        }, "|=":function (attr, value) {
            var valueDash = value + "-";
            return function (elem) {
                var ea = _getAttr(elem, attr);
                return ((ea == value) || (ea.indexOf(valueDash) == 0));
            };
        }, "=":function (attr, value) {
            return function (elem) {
                return (_getAttr(elem, attr) == value);
            };
        }};
        var _noNES = (typeof getDoc().firstChild.nextElementSibling == "undefined");
        var _ns = !_noNES ? "nextElementSibling" : "nextSibling";
        var _ps = !_noNES ? "previousElementSibling" : "previousSibling";
        var _simpleNodeTest = (_noNES ? _isElement : yesman);
        var _lookLeft = function (node) {
            while (node = node[_ps]) {
                if (_simpleNodeTest(node)) {
                    return false;
                }
            }
            return true;
        };
        var _lookRight = function (node) {
            while (node = node[_ns]) {
                if (_simpleNodeTest(node)) {
                    return false;
                }
            }
            return true;
        };
        var getNodeIndex = function (node) {
            var root = node.parentNode;
            root = root.nodeType != 7 ? root : root.nextSibling;
            var i = 0, tret = root.children || root.childNodes, ci = (node["_i"] || node.getAttribute("_i") || -1), cl = (root["_l"] || (typeof root.getAttribute !== "undefined" ? root.getAttribute("_l") : -1));
            if (!tret) {
                return -1;
            }
            var l = tret.length;
            if (cl == l && ci >= 0 && cl >= 0) {
                return ci;
            }
            if (has("ie") && typeof root.setAttribute !== "undefined") {
                root.setAttribute("_l", l);
            } else {
                root["_l"] = l;
            }
            ci = -1;
            for (var te = root["firstElementChild"] || root["firstChild"]; te; te = te[_ns]) {
                if (_simpleNodeTest(te)) {
                    if (has("ie")) {
                        te.setAttribute("_i", ++i);
                    } else {
                        te["_i"] = ++i;
                    }
                    if (node === te) {
                        ci = i;
                    }
                }
            }
            return ci;
        };
        var isEven = function (elem) {
            return !((getNodeIndex(elem)) % 2);
        };
        var isOdd = function (elem) {
            return ((getNodeIndex(elem)) % 2);
        };
        var pseudos = {"checked":function (name, condition) {
            return function (elem) {
                return !!("checked" in elem ? elem.checked : elem.selected);
            };
        }, "disabled":function (name, condition) {
            return function (elem) {
                return elem.disabled;
            };
        }, "enabled":function (name, condition) {
            return function (elem) {
                return !elem.disabled;
            };
        }, "first-child":function () {
            return _lookLeft;
        }, "last-child":function () {
            return _lookRight;
        }, "only-child":function (name, condition) {
            return function (node) {
                return _lookLeft(node) && _lookRight(node);
            };
        }, "empty":function (name, condition) {
            return function (elem) {
                var cn = elem.childNodes;
                var cnl = elem.childNodes.length;
                for (var x = cnl - 1; x >= 0; x--) {
                    var nt = cn[x].nodeType;
                    if ((nt === 1) || (nt == 3)) {
                        return false;
                    }
                }
                return true;
            };
        }, "contains":function (name, condition) {
            var cz = condition.charAt(0);
            if (cz == "\"" || cz == "'") {
                condition = condition.slice(1, -1);
            }
            return function (elem) {
                return (elem.innerHTML.indexOf(condition) >= 0);
            };
        }, "not":function (name, condition) {
            var p = getQueryParts(condition)[0];
            var ignores = {el:1};
            if (p.tag != "*") {
                ignores.tag = 1;
            }
            if (!p.classes.length) {
                ignores.classes = 1;
            }
            var ntf = getSimpleFilterFunc(p, ignores);
            return function (elem) {
                return (!ntf(elem));
            };
        }, "nth-child":function (name, condition) {
            var pi = parseInt;
            if (condition == "odd") {
                return isOdd;
            } else {
                if (condition == "even") {
                    return isEven;
                }
            }
            if (condition.indexOf("n") != -1) {
                var tparts = condition.split("n", 2);
                var pred = tparts[0] ? ((tparts[0] == "-") ? -1 : pi(tparts[0])) : 1;
                var idx = tparts[1] ? pi(tparts[1]) : 0;
                var lb = 0, ub = -1;
                if (pred > 0) {
                    if (idx < 0) {
                        idx = (idx % pred) && (pred + (idx % pred));
                    } else {
                        if (idx > 0) {
                            if (idx >= pred) {
                                lb = idx - idx % pred;
                            }
                            idx = idx % pred;
                        }
                    }
                } else {
                    if (pred < 0) {
                        pred *= -1;
                        if (idx > 0) {
                            ub = idx;
                            idx = idx % pred;
                        }
                    }
                }
                if (pred > 0) {
                    return function (elem) {
                        var i = getNodeIndex(elem);
                        return (i >= lb) && (ub < 0 || i <= ub) && ((i % pred) == idx);
                    };
                } else {
                    condition = idx;
                }
            }
            var ncount = pi(condition);
            return function (elem) {
                return (getNodeIndex(elem) == ncount);
            };
        }};
        var defaultGetter = (has("ie") < 9 || has("ie") == 9 && has("quirks")) ? function (cond) {
            var clc = cond.toLowerCase();
            if (clc == "class") {
                cond = "className";
            }
            return function (elem) {
                return (caseSensitive ? elem.getAttribute(cond) : elem[cond] || elem[clc]);
            };
        } : function (cond) {
            return function (elem) {
                return (elem && elem.getAttribute && elem.hasAttribute(cond));
            };
        };
        var getSimpleFilterFunc = function (query, ignores) {
            if (!query) {
                return yesman;
            }
            ignores = ignores || {};
            var ff = null;
            if (!("el" in ignores)) {
                ff = agree(ff, _isElement);
            }
            if (!("tag" in ignores)) {
                if (query.tag != "*") {
                    ff = agree(ff, function (elem) {
                        return (elem && ((caseSensitive ? elem.tagName : elem.tagName.toUpperCase()) == query.getTag()));
                    });
                }
            }
            if (!("classes" in ignores)) {
                each(query.classes, function (cname, idx, arr) {
                    var re = new RegExp("(?:^|\\s)" + cname + "(?:\\s|$)");
                    ff = agree(ff, function (elem) {
                        return re.test(elem.className);
                    });
                    ff.count = idx;
                });
            }
            if (!("pseudos" in ignores)) {
                each(query.pseudos, function (pseudo) {
                    var pn = pseudo.name;
                    if (pseudos[pn]) {
                        ff = agree(ff, pseudos[pn](pn, pseudo.value));
                    }
                });
            }
            if (!("attrs" in ignores)) {
                each(query.attrs, function (attr) {
                    var matcher;
                    var a = attr.attr;
                    if (attr.type && attrs[attr.type]) {
                        matcher = attrs[attr.type](a, attr.matchFor);
                    } else {
                        if (a.length) {
                            matcher = defaultGetter(a);
                        }
                    }
                    if (matcher) {
                        ff = agree(ff, matcher);
                    }
                });
            }
            if (!("id" in ignores)) {
                if (query.id) {
                    ff = agree(ff, function (elem) {
                        return (!!elem && (elem.id == query.id));
                    });
                }
            }
            if (!ff) {
                if (!("default" in ignores)) {
                    ff = yesman;
                }
            }
            return ff;
        };
        var _nextSibling = function (filterFunc) {
            return function (node, ret, bag) {
                while (node = node[_ns]) {
                    if (_noNES && (!_isElement(node))) {
                        continue;
                    }
                    if ((!bag || _isUnique(node, bag)) && filterFunc(node)) {
                        ret.push(node);
                    }
                    break;
                }
                return ret;
            };
        };
        var _nextSiblings = function (filterFunc) {
            return function (root, ret, bag) {
                var te = root[_ns];
                while (te) {
                    if (_simpleNodeTest(te)) {
                        if (bag && !_isUnique(te, bag)) {
                            break;
                        }
                        if (filterFunc(te)) {
                            ret.push(te);
                        }
                    }
                    te = te[_ns];
                }
                return ret;
            };
        };
        var _childElements = function (filterFunc) {
            filterFunc = filterFunc || yesman;
            return function (root, ret, bag) {
                var te, x = 0, tret = root.children || root.childNodes;
                while (te = tret[x++]) {
                    if (_simpleNodeTest(te) && (!bag || _isUnique(te, bag)) && (filterFunc(te, x))) {
                        ret.push(te);
                    }
                }
                return ret;
            };
        };
        var _isDescendant = function (node, root) {
            var pn = node.parentNode;
            while (pn) {
                if (pn == root) {
                    break;
                }
                pn = pn.parentNode;
            }
            return !!pn;
        };
        var _getElementsFuncCache = {};
        var getElementsFunc = function (query) {
            var retFunc = _getElementsFuncCache[query.query];
            if (retFunc) {
                return retFunc;
            }
            var io = query.infixOper;
            var oper = (io ? io.oper : "");
            var filterFunc = getSimpleFilterFunc(query, {el:1});
            var qt = query.tag;
            var wildcardTag = ("*" == qt);
            var ecs = getDoc()["getElementsByClassName"];
            if (!oper) {
                if (query.id) {
                    filterFunc = (!query.loops && wildcardTag) ? yesman : getSimpleFilterFunc(query, {el:1, id:1});
                    retFunc = function (root, arr) {
                        var te = dom.byId(query.id, (root.ownerDocument || root));
                        if (!te || !filterFunc(te)) {
                            return;
                        }
                        if (9 == root.nodeType) {
                            return getArr(te, arr);
                        } else {
                            if (_isDescendant(te, root)) {
                                return getArr(te, arr);
                            }
                        }
                    };
                } else {
                    if (ecs && /\{\s*\[native code\]\s*\}/.test(String(ecs)) && query.classes.length && !cssCaseBug) {
                        filterFunc = getSimpleFilterFunc(query, {el:1, classes:1, id:1});
                        var classesString = query.classes.join(" ");
                        retFunc = function (root, arr, bag) {
                            var ret = getArr(0, arr), te, x = 0;
                            var tret = root.getElementsByClassName(classesString);
                            while ((te = tret[x++])) {
                                if (filterFunc(te, root) && _isUnique(te, bag)) {
                                    ret.push(te);
                                }
                            }
                            return ret;
                        };
                    } else {
                        if (!wildcardTag && !query.loops) {
                            retFunc = function (root, arr, bag) {
                                var ret = getArr(0, arr), te, x = 0;
                                var tag = query.getTag(), tret = tag ? root.getElementsByTagName(tag) : [];
                                while ((te = tret[x++])) {
                                    if (_isUnique(te, bag)) {
                                        ret.push(te);
                                    }
                                }
                                return ret;
                            };
                        } else {
                            filterFunc = getSimpleFilterFunc(query, {el:1, tag:1, id:1});
                            retFunc = function (root, arr, bag) {
                                var ret = getArr(0, arr), te, x = 0;
                                var tag = query.getTag(), tret = tag ? root.getElementsByTagName(tag) : [];
                                while ((te = tret[x++])) {
                                    if (filterFunc(te, root) && _isUnique(te, bag)) {
                                        ret.push(te);
                                    }
                                }
                                return ret;
                            };
                        }
                    }
                }
            } else {
                var skipFilters = {el:1};
                if (wildcardTag) {
                    skipFilters.tag = 1;
                }
                filterFunc = getSimpleFilterFunc(query, skipFilters);
                if ("+" == oper) {
                    retFunc = _nextSibling(filterFunc);
                } else {
                    if ("~" == oper) {
                        retFunc = _nextSiblings(filterFunc);
                    } else {
                        if (">" == oper) {
                            retFunc = _childElements(filterFunc);
                        }
                    }
                }
            }
            return _getElementsFuncCache[query.query] = retFunc;
        };
        var filterDown = function (root, queryParts) {
            var candidates = getArr(root), qp, x, te, qpl = queryParts.length, bag, ret;
            for (var i = 0; i < qpl; i++) {
                ret = [];
                qp = queryParts[i];
                x = candidates.length - 1;
                if (x > 0) {
                    bag = {};
                    ret.nozip = true;
                }
                var gef = getElementsFunc(qp);
                for (var j = 0; (te = candidates[j]); j++) {
                    gef(te, ret, bag);
                }
                if (!ret.length) {
                    break;
                }
                candidates = ret;
            }
            return ret;
        };
        var _queryFuncCacheDOM = {}, _queryFuncCacheQSA = {};
        var getStepQueryFunc = function (query) {
            var qparts = getQueryParts(trim(query));
            if (qparts.length == 1) {
                var tef = getElementsFunc(qparts[0]);
                return function (root) {
                    var r = tef(root, []);
                    if (r) {
                        r.nozip = true;
                    }
                    return r;
                };
            }
            return function (root) {
                return filterDown(root, qparts);
            };
        };
        var noZip = has("ie") ? "commentStrip" : "nozip";
        var qsa = "querySelectorAll";
        var qsaAvail = !!getDoc()[qsa];
        var infixSpaceRe = /\\[>~+]|n\+\d|([^ \\])?([>~+])([^ =])?/g;
        var infixSpaceFunc = function (match, pre, ch, post) {
            return ch ? (pre ? pre + " " : "") + ch + (post ? " " + post : "") : match;
        };
        var attRe = /([^[]*)([^\]]*])?/g;
        var attFunc = function (match, nonAtt, att) {
            return nonAtt.replace(infixSpaceRe, infixSpaceFunc) + (att || "");
        };
        var getQueryFunc = function (query, forceDOM) {
            query = query.replace(attRe, attFunc);
            if (qsaAvail) {
                var qsaCached = _queryFuncCacheQSA[query];
                if (qsaCached && !forceDOM) {
                    return qsaCached;
                }
            }
            var domCached = _queryFuncCacheDOM[query];
            if (domCached) {
                return domCached;
            }
            var qcz = query.charAt(0);
            var nospace = (-1 == query.indexOf(" "));
            if ((query.indexOf("#") >= 0) && (nospace)) {
                forceDOM = true;
            }
            var useQSA = (qsaAvail && (!forceDOM) && (specials.indexOf(qcz) == -1) && (!has("ie") || (query.indexOf(":") == -1)) && (!(cssCaseBug && (query.indexOf(".") >= 0))) && (query.indexOf(":contains") == -1) && (query.indexOf(":checked") == -1) && (query.indexOf("|=") == -1));
            if (useQSA) {
                var tq = (specials.indexOf(query.charAt(query.length - 1)) >= 0) ? (query + " *") : query;
                return _queryFuncCacheQSA[query] = function (root) {
                    try {
                        if (!((9 == root.nodeType) || nospace)) {
                            throw "";
                        }
                        var r = root[qsa](tq);
                        r[noZip] = true;
                        return r;
                    }
                    catch (e) {
                        return getQueryFunc(query, true)(root);
                    }
                };
            } else {
                var parts = query.match(/([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g);
                return _queryFuncCacheDOM[query] = ((parts.length < 2) ? getStepQueryFunc(query) : function (root) {
                    var pindex = 0, ret = [], tp;
                    while ((tp = parts[pindex++])) {
                        ret = ret.concat(getStepQueryFunc(tp)(root));
                    }
                    return ret;
                });
            }
        };
        var _zipIdx = 0;
        var _nodeUID = has("ie") ? function (node) {
            if (caseSensitive) {
                return (node.getAttribute("_uid") || node.setAttribute("_uid", ++_zipIdx) || _zipIdx);
            } else {
                return node.uniqueID;
            }
        } : function (node) {
            return (node._uid || (node._uid = ++_zipIdx));
        };
        var _isUnique = function (node, bag) {
            if (!bag) {
                return 1;
            }
            var id = _nodeUID(node);
            if (!bag[id]) {
                return bag[id] = 1;
            }
            return 0;
        };
        var _zipIdxName = "_zipIdx";
        var _zip = function (arr) {
            if (arr && arr.nozip) {
                return arr;
            }
            if (!arr || !arr.length) {
                return [];
            }
            if (arr.length < 2) {
                return [arr[0]];
            }
            var ret = [];
            _zipIdx++;
            var x, te;
            if (has("ie") && caseSensitive) {
                var szidx = _zipIdx + "";
                for (x = 0; x < arr.length; x++) {
                    if ((te = arr[x]) && te.getAttribute(_zipIdxName) != szidx) {
                        ret.push(te);
                        te.setAttribute(_zipIdxName, szidx);
                    }
                }
            } else {
                if (has("ie") && arr.commentStrip) {
                    try {
                        for (x = 0; x < arr.length; x++) {
                            if ((te = arr[x]) && _isElement(te)) {
                                ret.push(te);
                            }
                        }
                    }
                    catch (e) {
                    }
                } else {
                    for (x = 0; x < arr.length; x++) {
                        if ((te = arr[x]) && te[_zipIdxName] != _zipIdx) {
                            ret.push(te);
                            te[_zipIdxName] = _zipIdx;
                        }
                    }
                }
            }
            return ret;
        };
        var query = function (query, root) {
            root = root || getDoc();
            var od = root.ownerDocument || root;
            caseSensitive = (od.createElement("div").tagName === "div");
            var r = getQueryFunc(query)(root);
            if (r && r.nozip) {
                return r;
            }
            return _zip(r);
        };
        query.filter = function (nodeList, filter, root) {
            var tmpNodeList = [], parts = getQueryParts(filter), filterFunc = (parts.length == 1 && !/[^\w#\.]/.test(filter)) ? getSimpleFilterFunc(parts[0]) : function (node) {
                return array.indexOf(query(filter, dom.byId(root)), node) != -1;
            };
            for (var x = 0, te; te = nodeList[x]; x++) {
                if (filterFunc(te)) {
                    tmpNodeList.push(te);
                }
            }
            return tmpNodeList;
        };
        return query;
    });
}, "dijit/main":function () {
    define(["dojo/_base/kernel"], function (dojo) {
        return dojo.dijit;
    });
}, "dijit/layout/ContentPane":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "../_Widget", "../_Container", "./_ContentPaneResizeMixin", "dojo/string", "dojo/html", "dojo/i18n!../nls/loading", "dojo/_base/array", "dojo/_base/declare", "dojo/_base/Deferred", "dojo/dom", "dojo/dom-attr", "dojo/dom-construct", "dojo/_base/xhr", "dojo/i18n", "dojo/when"], function (kernel, lang, _Widget, _Container, _ContentPaneResizeMixin, string, html, nlsLoading, array, declare, Deferred, dom, domAttr, domConstruct, xhr, i18n, when) {
        return declare("dijit.layout.ContentPane", [_Widget, _Container, _ContentPaneResizeMixin], {href:"", content:"", extractContent:false, parseOnLoad:true, parserScope:kernel._scopeName, preventCache:false, preload:false, refreshOnShow:false, loadingMessage:"<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>", errorMessage:"<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>", isLoaded:false, baseClass:"dijitContentPane", ioArgs:{}, onLoadDeferred:null, _setTitleAttr:null, stopParser:true, template:false, markupFactory:function (params, node, ctor) {
            var self = new ctor(params, node);
            return !self.href && self._contentSetter && self._contentSetter.parseDeferred && !self._contentSetter.parseDeferred.isFulfilled() ? self._contentSetter.parseDeferred.then(function () {
                return self;
            }) : self;
        }, create:function (params, srcNodeRef) {
            if ((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)) {
                srcNodeRef = dom.byId(srcNodeRef);
                var df = srcNodeRef.ownerDocument.createDocumentFragment();
                while (srcNodeRef.firstChild) {
                    df.appendChild(srcNodeRef.firstChild);
                }
                params = lang.delegate(params, {content:df});
            }
            this.inherited(arguments, [params, srcNodeRef]);
        }, postMixInProperties:function () {
            this.inherited(arguments);
            var messages = i18n.getLocalization("dijit", "loading", this.lang);
            this.loadingMessage = string.substitute(this.loadingMessage, messages);
            this.errorMessage = string.substitute(this.errorMessage, messages);
        }, buildRendering:function () {
            this.inherited(arguments);
            if (!this.containerNode) {
                this.containerNode = this.domNode;
            }
            this.domNode.removeAttribute("title");
        }, startup:function () {
            this.inherited(arguments);
            if (this._contentSetter) {
                array.forEach(this._contentSetter.parseResults, function (obj) {
                    if (!obj._started && !obj._destroyed && lang.isFunction(obj.startup)) {
                        obj.startup();
                        obj._started = true;
                    }
                }, this);
            }
        }, _startChildren:function () {
            array.forEach(this.getChildren(), function (obj) {
                if (!obj._started && !obj._destroyed && lang.isFunction(obj.startup)) {
                    obj.startup();
                    obj._started = true;
                }
            });
            if (this._contentSetter) {
                array.forEach(this._contentSetter.parseResults, function (obj) {
                    if (!obj._started && !obj._destroyed && lang.isFunction(obj.startup)) {
                        obj.startup();
                        obj._started = true;
                    }
                }, this);
            }
        }, setHref:function (href) {
            kernel.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
            return this.set("href", href);
        }, _setHrefAttr:function (href) {
            this.cancel();
            this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
            this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
            this._set("href", href);
            if (this.preload || (this._created && this._isShown())) {
                this._load();
            } else {
                this._hrefChanged = true;
            }
            return this.onLoadDeferred;
        }, setContent:function (data) {
            kernel.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
            this.set("content", data);
        }, _setContentAttr:function (data) {
            this._set("href", "");
            this.cancel();
            this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
            if (this._created) {
                this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
            }
            this._setContent(data || "");
            this._isDownloaded = false;
            return this.onLoadDeferred;
        }, _getContentAttr:function () {
            return this.containerNode.innerHTML;
        }, cancel:function () {
            if (this._xhrDfd && (this._xhrDfd.fired == -1)) {
                this._xhrDfd.cancel();
            }
            delete this._xhrDfd;
            this.onLoadDeferred = null;
        }, destroy:function () {
            this.cancel();
            this.inherited(arguments);
        }, destroyRecursive:function (preserveDom) {
            if (this._beingDestroyed) {
                return;
            }
            this.inherited(arguments);
        }, _onShow:function () {
            this.inherited(arguments);
            if (this.href) {
                if (!this._xhrDfd && (!this.isLoaded || this._hrefChanged || this.refreshOnShow)) {
                    return this.refresh();
                }
            }
        }, refresh:function () {
            this.cancel();
            this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
            this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
            this._load();
            return this.onLoadDeferred;
        }, _load:function () {
            this._setContent(this.onDownloadStart(), true);
            var self = this;
            var getArgs = {preventCache:(this.preventCache || this.refreshOnShow), url:this.href, handleAs:"text"};
            if (lang.isObject(this.ioArgs)) {
                lang.mixin(getArgs, this.ioArgs);
            }
            var hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs)), returnedHtml;
            hand.then(function (html) {
                returnedHtml = html;
                try {
                    self._isDownloaded = true;
                    return self._setContent(html, false);
                }
                catch (err) {
                    self._onError("Content", err);
                }
            }, function (err) {
                if (!hand.canceled) {
                    self._onError("Download", err);
                }
                delete self._xhrDfd;
                return err;
            }).then(function () {
                self.onDownloadEnd();
                delete self._xhrDfd;
                return returnedHtml;
            });
            delete this._hrefChanged;
        }, _onLoadHandler:function (data) {
            this._set("isLoaded", true);
            try {
                this.onLoadDeferred.resolve(data);
            }
            catch (e) {
                console.error("Error " + this.widgetId + " running custom onLoad code: " + e.message);
            }
        }, _onUnloadHandler:function () {
            this._set("isLoaded", false);
            try {
                this.onUnload();
            }
            catch (e) {
                console.error("Error " + this.widgetId + " running custom onUnload code: " + e.message);
            }
        }, destroyDescendants:function (preserveDom) {
            if (this.isLoaded) {
                this._onUnloadHandler();
            }
            var setter = this._contentSetter;
            array.forEach(this.getChildren(), function (widget) {
                if (widget.destroyRecursive) {
                    widget.destroyRecursive(preserveDom);
                } else {
                    if (widget.destroy) {
                        widget.destroy(preserveDom);
                    }
                }
                widget._destroyed = true;
            });
            if (setter) {
                array.forEach(setter.parseResults, function (widget) {
                    if (!widget._destroyed) {
                        if (widget.destroyRecursive) {
                            widget.destroyRecursive(preserveDom);
                        } else {
                            if (widget.destroy) {
                                widget.destroy(preserveDom);
                            }
                        }
                        widget._destroyed = true;
                    }
                });
                delete setter.parseResults;
            }
            if (!preserveDom) {
                domConstruct.empty(this.containerNode);
            }
            delete this._singleChild;
        }, _setContent:function (cont, isFakeContent) {
            this.destroyDescendants();
            var setter = this._contentSetter;
            if (!(setter && setter instanceof html._ContentSetter)) {
                setter = this._contentSetter = new html._ContentSetter({node:this.containerNode, _onError:lang.hitch(this, this._onError), onContentError:lang.hitch(this, function (e) {
                    var errMess = this.onContentError(e);
                    try {
                        this.containerNode.innerHTML = errMess;
                    }
                    catch (e) {
                        console.error("Fatal " + this.id + " could not change content due to " + e.message, e);
                    }
                })});
            }
            var setterParams = lang.mixin({cleanContent:this.cleanContent, extractContent:this.extractContent, parseContent:!cont.domNode && this.parseOnLoad, parserScope:this.parserScope, startup:false, dir:this.dir, lang:this.lang, textDir:this.textDir}, this._contentSetterParams || {});
            var p = setter.set((lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams);
            var self = this;
            return when(p && p.then ? p : setter.parseDeferred, function () {
                delete self._contentSetterParams;
                if (!isFakeContent) {
                    if (self._started) {
                        self._startChildren();
                        self._scheduleLayout();
                    }
                    self._onLoadHandler(cont);
                }
            });
        }, _onError:function (type, err, consoleText) {
            this.onLoadDeferred.reject(err);
            var errText = this["on" + type + "Error"].call(this, err);
            if (consoleText) {
                console.error(consoleText, err);
            } else {
                if (errText) {
                    this._setContent(errText, true);
                }
            }
        }, onLoad:function () {
        }, onUnload:function () {
        }, onDownloadStart:function () {
            return this.loadingMessage;
        }, onContentError:function () {
        }, onDownloadError:function () {
            return this.errorMessage;
        }, onDownloadEnd:function () {
        }});
    });
}, "dojox/grid/_SelectionPreserver":function () {
    define(["dojo/_base/declare", "dojo/_base/connect", "dojo/_base/lang", "dojo/_base/array"], function (declare, connect, lang, array) {
        return declare("dojox.grid._SelectionPreserver", null, {constructor:function (selection) {
            this.selection = selection;
            var grid = this.grid = selection.grid;
            this.reset();
            this._connects = [connect.connect(grid, "_setStore", this, "reset"), connect.connect(grid, "_addItem", this, "_reSelectById"), connect.connect(selection, "onSelected", lang.hitch(this, "_selectById", true)), connect.connect(selection, "onDeselected", lang.hitch(this, "_selectById", false)), connect.connect(selection, "deselectAll", this, "reset")];
        }, destroy:function () {
            this.reset();
            array.forEach(this._connects, connect.disconnect);
            delete this._connects;
        }, reset:function () {
            this._selectedById = {};
        }, _reSelectById:function (item, index) {
            if (item && this.grid._hasIdentity) {
                this.selection.selected[index] = this._selectedById[this.grid.store.getIdentity(item)];
            }
        }, _selectById:function (toSelect, inItemOrIndex) {
            if (this.selection.mode == "none" || !this.grid._hasIdentity) {
                return;
            }
            var item = inItemOrIndex, g = this.grid;
            if (typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string") {
                var entry = g._by_idx[inItemOrIndex];
                item = entry && entry.item;
            }
            if (item) {
                this._selectedById[g.store.getIdentity(item)] = !!toSelect;
            }
            return item;
        }});
    });
}, "dijit/_WidgetsInTemplateMixin":function () {
    define(["dojo/_base/array", "dojo/aspect", "dojo/_base/declare", "dojo/_base/lang", "dojo/parser"], function (array, aspect, declare, lang, parser) {
        return declare("dijit._WidgetsInTemplateMixin", null, {_earlyTemplatedStartup:false, widgetsInTemplate:true, contextRequire:null, _beforeFillContent:function () {
            if (this.widgetsInTemplate) {
                var node = this.domNode;
                if (this.containerNode && !this.searchContainerNode) {
                    this.containerNode.stopParser = true;
                }
                parser.parse(node, {noStart:!this._earlyTemplatedStartup, template:true, inherited:{dir:this.dir, lang:this.lang, textDir:this.textDir}, propsThis:this, contextRequire:this.contextRequire, scope:"dojo"}).then(lang.hitch(this, function (widgets) {
                    this._startupWidgets = widgets;
                    for (var i = 0; i < widgets.length; i++) {
                        this._processTemplateNode(widgets[i], function (n, p) {
                            return n[p];
                        }, function (widget, type, callback) {
                            if (type in widget) {
                                return widget.connect(widget, type, callback);
                            } else {
                                return widget.on(type, callback, true);
                            }
                        });
                    }
                    if (this.containerNode && this.containerNode.stopParser) {
                        delete this.containerNode.stopParser;
                    }
                }));
                if (!this._startupWidgets) {
                    throw new Error(this.declaredClass + ": parser returned unfilled promise (probably waiting for module auto-load), " + "unsupported by _WidgetsInTemplateMixin.   Must pre-load all supporting widgets before instantiation.");
                }
            }
        }, _processTemplateNode:function (baseNode, getAttrFunc, attachFunc) {
            if (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type")) {
                return true;
            }
            return this.inherited(arguments);
        }, startup:function () {
            array.forEach(this._startupWidgets, function (w) {
                if (w && !w._started && w.startup) {
                    w.startup();
                }
            });
            this._startupWidgets = null;
            this.inherited(arguments);
        }});
    });
}, "dijit/_HasDropDown":function () {
    define(["dojo/_base/declare", "dojo/_base/Deferred", "dojo/dom", "dojo/dom-attr", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/has", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/touch", "./registry", "./focus", "./popup", "./_FocusMixin"], function (declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch, registry, focus, popup, _FocusMixin) {
        return declare("dijit._HasDropDown", _FocusMixin, {_buttonNode:null, _arrowWrapperNode:null, _popupStateNode:null, _aroundNode:null, dropDown:null, autoWidth:true, forceWidth:false, maxHeight:-1, dropDownPosition:["below", "above"], _stopClickEvents:true, _onDropDownMouseDown:function (e) {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (e.type != "MSPointerDown" && e.type != "pointerdown") {
                e.preventDefault();
            }
            this._docHandler = this.own(on(this.ownerDocument, touch.release, lang.hitch(this, "_onDropDownMouseUp")))[0];
            this.toggleDropDown();
        }, _onDropDownMouseUp:function (e) {
            if (e && this._docHandler) {
                this._docHandler.remove();
                this._docHandler = null;
            }
            var dropDown = this.dropDown, overMenu = false;
            if (e && this._opened) {
                var c = domGeometry.position(this._buttonNode, true);
                if (!(e.pageX >= c.x && e.pageX <= c.x + c.w) || !(e.pageY >= c.y && e.pageY <= c.y + c.h)) {
                    var t = e.target;
                    while (t && !overMenu) {
                        if (domClass.contains(t, "dijitPopup")) {
                            overMenu = true;
                        } else {
                            t = t.parentNode;
                        }
                    }
                    if (overMenu) {
                        t = e.target;
                        if (dropDown.onItemClick) {
                            var menuItem;
                            while (t && !(menuItem = registry.byNode(t))) {
                                t = t.parentNode;
                            }
                            if (menuItem && menuItem.onClick && menuItem.getParent) {
                                menuItem.getParent().onItemClick(menuItem, e);
                            }
                        }
                        return;
                    }
                }
            }
            if (this._opened) {
                if (dropDown.focus && (dropDown.autoFocus !== false || (e.type == "mouseup" && !this.hovering))) {
                    this._focusDropDownTimer = this.defer(function () {
                        dropDown.focus();
                        delete this._focusDropDownTimer;
                    });
                }
            } else {
                if (this.focus) {
                    this.defer("focus");
                }
            }
        }, _onDropDownClick:function (e) {
            if (this._stopClickEvents) {
                e.stopPropagation();
                e.preventDefault();
            }
        }, buildRendering:function () {
            this.inherited(arguments);
            this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
            this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;
            var defaultPos = {"after":this.isLeftToRight() ? "Right" : "Left", "before":this.isLeftToRight() ? "Left" : "Right", "above":"Up", "below":"Down", "left":"Left", "right":"Right"}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
            domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
        }, postCreate:function () {
            this.inherited(arguments);
            var keyboardEventNode = this.focusNode || this.domNode;
            this.own(on(this._buttonNode, touch.press, lang.hitch(this, "_onDropDownMouseDown")), on(this._buttonNode, "click", lang.hitch(this, "_onDropDownClick")), on(keyboardEventNode, "keydown", lang.hitch(this, "_onKey")), on(keyboardEventNode, "keyup", lang.hitch(this, "_onKeyUp")));
        }, destroy:function () {
            if (this.dropDown) {
                if (!this.dropDown._destroyed) {
                    this.dropDown.destroyRecursive();
                }
                delete this.dropDown;
            }
            this.inherited(arguments);
        }, _onKey:function (e) {
            if (this.disabled || this.readOnly) {
                return;
            }
            var d = this.dropDown, target = e.target;
            if (d && this._opened && d.handleKey) {
                if (d.handleKey(e) === false) {
                    e.stopPropagation();
                    e.preventDefault();
                    return;
                }
            }
            if (d && this._opened && e.keyCode == keys.ESCAPE) {
                this.closeDropDown();
                e.stopPropagation();
                e.preventDefault();
            } else {
                if (!this._opened && (e.keyCode == keys.DOWN_ARROW || ((e.keyCode == keys.ENTER || (e.keyCode == keys.SPACE && (!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) && ((target.tagName || "").toLowerCase() !== "input" || (target.type && target.type.toLowerCase() !== "text"))))) {
                    this._toggleOnKeyUp = true;
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
        }, _onKeyUp:function () {
            if (this._toggleOnKeyUp) {
                delete this._toggleOnKeyUp;
                this.toggleDropDown();
                var d = this.dropDown;
                if (d && d.focus) {
                    this.defer(lang.hitch(d, "focus"), 1);
                }
            }
        }, _onBlur:function () {
            this.closeDropDown(false);
            this.inherited(arguments);
        }, isLoaded:function () {
            return true;
        }, loadDropDown:function (loadCallback) {
            loadCallback();
        }, loadAndOpenDropDown:function () {
            var d = new Deferred(), afterLoad = lang.hitch(this, function () {
                this.openDropDown();
                d.resolve(this.dropDown);
            });
            if (!this.isLoaded()) {
                this.loadDropDown(afterLoad);
            } else {
                afterLoad();
            }
            return d;
        }, toggleDropDown:function () {
            if (this.disabled || this.readOnly) {
                return;
            }
            if (!this._opened) {
                this.loadAndOpenDropDown();
            } else {
                this.closeDropDown(true);
            }
        }, openDropDown:function () {
            var dropDown = this.dropDown, ddNode = dropDown.domNode, aroundNode = this._aroundNode || this.domNode, self = this;
            var retVal = popup.open({parent:this, popup:dropDown, around:aroundNode, orient:this.dropDownPosition, maxHeight:this.maxHeight, onExecute:function () {
                self.closeDropDown(true);
            }, onCancel:function () {
                self.closeDropDown(true);
            }, onClose:function () {
                domAttr.set(self._popupStateNode, "popupActive", false);
                domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
                self._set("_opened", false);
            }});
            if (this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)) {
                var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
                var resizeArgs = {w:dropDown.domNode.offsetWidth + widthAdjust};
                if (lang.isFunction(dropDown.resize)) {
                    dropDown.resize(resizeArgs);
                } else {
                    domGeometry.setMarginBox(ddNode, resizeArgs);
                }
                if (retVal.corner[1] == "R") {
                    dropDown._popupWrapper.style.left = (dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
                }
            }
            domAttr.set(this._popupStateNode, "popupActive", "true");
            domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
            this._set("_opened", true);
            this._popupStateNode.setAttribute("aria-expanded", "true");
            this._popupStateNode.setAttribute("aria-owns", dropDown.id);
            if (ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")) {
                ddNode.setAttribute("aria-labelledby", this.id);
            }
            return retVal;
        }, closeDropDown:function (focus) {
            if (this._focusDropDownTimer) {
                this._focusDropDownTimer.remove();
                delete this._focusDropDownTimer;
            }
            if (this._opened) {
                this._popupStateNode.setAttribute("aria-expanded", "false");
                if (focus) {
                    this.focus();
                }
                popup.close(this.dropDown);
                this._opened = false;
            }
        }});
    });
}, "dojo/_base/event":function () {
    define(["./kernel", "../on", "../has", "../dom-geometry"], function (dojo, on, has, dom) {
        if (on._fixEvent) {
            var fixEvent = on._fixEvent;
            on._fixEvent = function (evt, se) {
                evt = fixEvent(evt, se);
                if (evt) {
                    dom.normalizeEvent(evt);
                }
                return evt;
            };
        }
        var ret = {fix:function (evt, sender) {
            if (on._fixEvent) {
                return on._fixEvent(evt, sender);
            }
            return evt;
        }, stop:function (evt) {
            if (has("dom-addeventlistener") || (evt && evt.preventDefault)) {
                evt.preventDefault();
                evt.stopPropagation();
            } else {
                evt = evt || window.event;
                evt.cancelBubble = true;
                on._preventDefault.call(evt);
            }
        }};
        if (1) {
            dojo.fixEvent = ret.fix;
            dojo.stopEvent = ret.stop;
        }
        return ret;
    });
}, "dojo/_base/html":function () {
    define(["./kernel", "../dom", "../dom-style", "../dom-attr", "../dom-prop", "../dom-class", "../dom-construct", "../dom-geometry"], function (dojo, dom, style, attr, prop, cls, ctr, geom) {
        dojo.byId = dom.byId;
        dojo.isDescendant = dom.isDescendant;
        dojo.setSelectable = dom.setSelectable;
        dojo.getAttr = attr.get;
        dojo.setAttr = attr.set;
        dojo.hasAttr = attr.has;
        dojo.removeAttr = attr.remove;
        dojo.getNodeProp = attr.getNodeProp;
        dojo.attr = function (node, name, value) {
            if (arguments.length == 2) {
                return attr[typeof name == "string" ? "get" : "set"](node, name);
            }
            return attr.set(node, name, value);
        };
        dojo.hasClass = cls.contains;
        dojo.addClass = cls.add;
        dojo.removeClass = cls.remove;
        dojo.toggleClass = cls.toggle;
        dojo.replaceClass = cls.replace;
        dojo._toDom = dojo.toDom = ctr.toDom;
        dojo.place = ctr.place;
        dojo.create = ctr.create;
        dojo.empty = function (node) {
            ctr.empty(node);
        };
        dojo._destroyElement = dojo.destroy = function (node) {
            ctr.destroy(node);
        };
        dojo._getPadExtents = dojo.getPadExtents = geom.getPadExtents;
        dojo._getBorderExtents = dojo.getBorderExtents = geom.getBorderExtents;
        dojo._getPadBorderExtents = dojo.getPadBorderExtents = geom.getPadBorderExtents;
        dojo._getMarginExtents = dojo.getMarginExtents = geom.getMarginExtents;
        dojo._getMarginSize = dojo.getMarginSize = geom.getMarginSize;
        dojo._getMarginBox = dojo.getMarginBox = geom.getMarginBox;
        dojo.setMarginBox = geom.setMarginBox;
        dojo._getContentBox = dojo.getContentBox = geom.getContentBox;
        dojo.setContentSize = geom.setContentSize;
        dojo._isBodyLtr = dojo.isBodyLtr = geom.isBodyLtr;
        dojo._docScroll = dojo.docScroll = geom.docScroll;
        dojo._getIeDocumentElementOffset = dojo.getIeDocumentElementOffset = geom.getIeDocumentElementOffset;
        dojo._fixIeBiDiScrollLeft = dojo.fixIeBiDiScrollLeft = geom.fixIeBiDiScrollLeft;
        dojo.position = geom.position;
        dojo.marginBox = function marginBox(node, box) {
            return box ? geom.setMarginBox(node, box) : geom.getMarginBox(node);
        };
        dojo.contentBox = function contentBox(node, box) {
            return box ? geom.setContentSize(node, box) : geom.getContentBox(node);
        };
        dojo.coords = function (node, includeScroll) {
            dojo.deprecated("dojo.coords()", "Use dojo.position() or dojo.marginBox().");
            node = dom.byId(node);
            var s = style.getComputedStyle(node), mb = geom.getMarginBox(node, s);
            var abs = geom.position(node, includeScroll);
            mb.x = abs.x;
            mb.y = abs.y;
            return mb;
        };
        dojo.getProp = prop.get;
        dojo.setProp = prop.set;
        dojo.prop = function (node, name, value) {
            if (arguments.length == 2) {
                return prop[typeof name == "string" ? "get" : "set"](node, name);
            }
            return prop.set(node, name, value);
        };
        dojo.getStyle = style.get;
        dojo.setStyle = style.set;
        dojo.getComputedStyle = style.getComputedStyle;
        dojo.__toPixelValue = dojo.toPixelValue = style.toPixelValue;
        dojo.style = function (node, name, value) {
            switch (arguments.length) {
              case 1:
                return style.get(node);
              case 2:
                return style[typeof name == "string" ? "get" : "set"](node, name);
            }
            return style.set(node, name, value);
        };
        return dojo;
    });
}, "dojo/_base/kernel":function () {
    define(["../has", "./config", "require", "module"], function (has, config, require, module) {
        var i, p, dijit = {}, dojox = {}, dojo = {config:config, global:this, dijit:dijit, dojox:dojox};
        var scopeMap = {dojo:["dojo", dojo], dijit:["dijit", dijit], dojox:["dojox", dojox]}, packageMap = (require.map && require.map[module.id.match(/[^\/]+/)[0]]), item;
        for (p in packageMap) {
            if (scopeMap[p]) {
                scopeMap[p][0] = packageMap[p];
            } else {
                scopeMap[p] = [packageMap[p], {}];
            }
        }
        for (p in scopeMap) {
            item = scopeMap[p];
            item[1]._scopeName = item[0];
            if (!config.noGlobals) {
                this[item[0]] = item[1];
            }
        }
        dojo.scopeMap = scopeMap;
        dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
        dojo.isAsync = !1 || require.async;
        dojo.locale = config.locale;
        var rev = "$Rev$".match(/[0-9a-f]{7,}/);
        dojo.version = {major:1, minor:9, patch:3, flag:"", revision:rev ? rev[0] : NaN, toString:function () {
            var v = dojo.version;
            return v.major + "." + v.minor + "." + v.patch + v.flag + " (" + v.revision + ")";
        }};
        1 || has.add("extend-dojo", 1);
        (Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
        if (0) {
            dojo.exit = function (exitcode) {
                quit(exitcode);
            };
        } else {
            dojo.exit = function () {
            };
        }
        1 || has.add("dojo-guarantee-console", 1);
        if (1) {
            typeof console != "undefined" || (console = {});
            var cn = ["assert", "count", "debug", "dir", "dirxml", "error", "group", "groupEnd", "info", "profile", "profileEnd", "time", "timeEnd", "trace", "warn", "log"];
            var tn;
            i = 0;
            while ((tn = cn[i++])) {
                if (!console[tn]) {
                    (function () {
                        var tcn = tn + "";
                        console[tcn] = ("log" in console) ? function () {
                            var a = Array.prototype.slice.call(arguments);
                            a.unshift(tcn + ":");
                            console["log"](a.join(" "));
                        } : function () {
                        };
                        console[tcn]._fake = true;
                    })();
                }
            }
        }
        has.add("dojo-debug-messages", !!config.isDebug);
        dojo.deprecated = dojo.experimental = function () {
        };
        if (has("dojo-debug-messages")) {
            dojo.deprecated = function (behaviour, extra, removal) {
                var message = "DEPRECATED: " + behaviour;
                if (extra) {
                    message += " " + extra;
                }
                if (removal) {
                    message += " -- will be removed in version: " + removal;
                }
                console.warn(message);
            };
            dojo.experimental = function (moduleName, extra) {
                var message = "EXPERIMENTAL: " + moduleName + " -- APIs subject to change without notice.";
                if (extra) {
                    message += " " + extra;
                }
                console.warn(message);
            };
        }
        1 || has.add("dojo-modulePaths", 1);
        if (1) {
            if (config.modulePaths) {
                dojo.deprecated("dojo.modulePaths", "use paths configuration");
                var paths = {};
                for (p in config.modulePaths) {
                    paths[p.replace(/\./g, "/")] = config.modulePaths[p];
                }
                require({paths:paths});
            }
        }
        1 || has.add("dojo-moduleUrl", 1);
        if (1) {
            dojo.moduleUrl = function (module, url) {
                dojo.deprecated("dojo.moduleUrl()", "use require.toUrl", "2.0");
                var result = null;
                if (module) {
                    result = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : "") + "/*.*").replace(/\/\*\.\*/, "") + (url ? "" : "/");
                }
                return result;
            };
        }
        dojo._hasResource = {};
        return dojo;
    });
}, "dijit/tree/dndSource":function () {
    define(["dojo/_base/array", "dojo/_base/connect", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-geometry", "dojo/_base/lang", "dojo/on", "dojo/touch", "dojo/topic", "dojo/dnd/Manager", "./_dndSelector"], function (array, connect, declare, domClass, domGeometry, lang, on, touch, topic, DNDManager, _dndSelector) {
        var dndSource = declare("dijit.tree.dndSource", _dndSelector, {isSource:true, accept:["text", "treeNode"], copyOnly:false, dragThreshold:5, betweenThreshold:0, generateText:true, constructor:function (tree, params) {
            if (!params) {
                params = {};
            }
            lang.mixin(this, params);
            var type = params.accept instanceof Array ? params.accept : ["text", "treeNode"];
            this.accept = null;
            if (type.length) {
                this.accept = {};
                for (var i = 0; i < type.length; ++i) {
                    this.accept[type[i]] = 1;
                }
            }
            this.isDragging = false;
            this.mouseDown = false;
            this.targetAnchor = null;
            this.targetBox = null;
            this.dropPosition = "";
            this._lastX = 0;
            this._lastY = 0;
            this.sourceState = "";
            if (this.isSource) {
                domClass.add(this.node, "dojoDndSource");
            }
            this.targetState = "";
            if (this.accept) {
                domClass.add(this.node, "dojoDndTarget");
            }
            this.topics = [topic.subscribe("/dnd/source/over", lang.hitch(this, "onDndSourceOver")), topic.subscribe("/dnd/start", lang.hitch(this, "onDndStart")), topic.subscribe("/dnd/drop", lang.hitch(this, "onDndDrop")), topic.subscribe("/dnd/cancel", lang.hitch(this, "onDndCancel"))];
        }, checkAcceptance:function () {
            return true;
        }, copyState:function (keyPressed) {
            return this.copyOnly || keyPressed;
        }, destroy:function () {
            this.inherited(arguments);
            var h;
            while (h = this.topics.pop()) {
                h.remove();
            }
            this.targetAnchor = null;
        }, _onDragMouse:function (e, firstTime) {
            var m = DNDManager.manager(), oldTarget = this.targetAnchor, newTarget = this.current, oldDropPosition = this.dropPosition;
            var newDropPosition = "Over";
            if (newTarget && this.betweenThreshold > 0) {
                if (!this.targetBox || oldTarget != newTarget) {
                    this.targetBox = domGeometry.position(newTarget.rowNode, true);
                }
                if ((e.pageY - this.targetBox.y) <= this.betweenThreshold) {
                    newDropPosition = "Before";
                } else {
                    if ((e.pageY - this.targetBox.y) >= (this.targetBox.h - this.betweenThreshold)) {
                        newDropPosition = "After";
                    }
                }
            }
            if (firstTime || newTarget != oldTarget || newDropPosition != oldDropPosition) {
                if (oldTarget) {
                    this._removeItemClass(oldTarget.rowNode, oldDropPosition);
                }
                if (newTarget) {
                    this._addItemClass(newTarget.rowNode, newDropPosition);
                }
                if (!newTarget) {
                    m.canDrop(false);
                } else {
                    if (newTarget == this.tree.rootNode && newDropPosition != "Over") {
                        m.canDrop(false);
                    } else {
                        var sameId = false;
                        if (m.source == this) {
                            for (var dragId in this.selection) {
                                var dragNode = this.selection[dragId];
                                if (dragNode.item === newTarget.item) {
                                    sameId = true;
                                    break;
                                }
                            }
                        }
                        if (sameId) {
                            m.canDrop(false);
                        } else {
                            if (this.checkItemAcceptance(newTarget.rowNode, m.source, newDropPosition.toLowerCase()) && !this._isParentChildDrop(m.source, newTarget.rowNode)) {
                                m.canDrop(true);
                            } else {
                                m.canDrop(false);
                            }
                        }
                    }
                }
                this.targetAnchor = newTarget;
                this.dropPosition = newDropPosition;
            }
        }, onMouseMove:function (e) {
            if (this.isDragging && this.targetState == "Disabled") {
                return;
            }
            this.inherited(arguments);
            var m = DNDManager.manager();
            if (this.isDragging) {
                this._onDragMouse(e);
            } else {
                if (this.mouseDown && this.isSource && (Math.abs(e.pageX - this._lastX) >= this.dragThreshold || Math.abs(e.pageY - this._lastY) >= this.dragThreshold)) {
                    var nodes = this.getSelectedTreeNodes();
                    if (nodes.length) {
                        if (nodes.length > 1) {
                            var seen = this.selection, i = 0, r = [], n, p;
                        nextitem:
                            while ((n = nodes[i++])) {
                                for (p = n.getParent(); p && p !== this.tree; p = p.getParent()) {
                                    if (seen[p.id]) {
                                        continue nextitem;
                                    }
                                }
                                r.push(n);
                            }
                            nodes = r;
                        }
                        nodes = array.map(nodes, function (n) {
                            return n.domNode;
                        });
                        m.startDrag(this, nodes, this.copyState(connect.isCopyKey(e)));
                        this._onDragMouse(e, true);
                    }
                }
            }
        }, onMouseDown:function (e) {
            this.mouseDown = true;
            this.mouseButton = e.button;
            this._lastX = e.pageX;
            this._lastY = e.pageY;
            this.inherited(arguments);
        }, onMouseUp:function (e) {
            if (this.mouseDown) {
                this.mouseDown = false;
                this.inherited(arguments);
            }
        }, onMouseOut:function () {
            this.inherited(arguments);
            this._unmarkTargetAnchor();
        }, checkItemAcceptance:function () {
            return true;
        }, onDndSourceOver:function (source) {
            if (this != source) {
                this.mouseDown = false;
                this._unmarkTargetAnchor();
            } else {
                if (this.isDragging) {
                    var m = DNDManager.manager();
                    m.canDrop(false);
                }
            }
        }, onDndStart:function (source, nodes, copy) {
            if (this.isSource) {
                this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
            }
            var accepted = this.checkAcceptance(source, nodes);
            this._changeState("Target", accepted ? "" : "Disabled");
            if (this == source) {
                DNDManager.manager().overSource(this);
            }
            this.isDragging = true;
        }, itemCreator:function (nodes) {
            return array.map(nodes, function (node) {
                return {"id":node.id, "name":node.textContent || node.innerText || ""};
            });
        }, onDndDrop:function (source, nodes, copy) {
            if (this.containerState == "Over") {
                var tree = this.tree, model = tree.model, target = this.targetAnchor;
                this.isDragging = false;
                var newParentItem;
                var insertIndex;
                var before;
                newParentItem = (target && target.item) || tree.item;
                if (this.dropPosition == "Before" || this.dropPosition == "After") {
                    newParentItem = (target.getParent() && target.getParent().item) || tree.item;
                    insertIndex = target.getIndexInParent();
                    if (this.dropPosition == "After") {
                        insertIndex = target.getIndexInParent() + 1;
                        before = target.getNextSibling() && target.getNextSibling().item;
                    } else {
                        before = target.item;
                    }
                } else {
                    newParentItem = (target && target.item) || tree.item;
                }
                var newItemsParams;
                array.forEach(nodes, function (node, idx) {
                    var sourceItem = source.getItem(node.id);
                    if (array.indexOf(sourceItem.type, "treeNode") != -1) {
                        var childTreeNode = sourceItem.data, childItem = childTreeNode.item, oldParentItem = childTreeNode.getParent().item;
                    }
                    if (source == this) {
                        if (typeof insertIndex == "number") {
                            if (newParentItem == oldParentItem && childTreeNode.getIndexInParent() < insertIndex) {
                                insertIndex -= 1;
                            }
                        }
                        model.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex, before);
                    } else {
                        if (model.isItem(childItem)) {
                            model.pasteItem(childItem, oldParentItem, newParentItem, copy, insertIndex, before);
                        } else {
                            if (!newItemsParams) {
                                newItemsParams = this.itemCreator(nodes, target.rowNode, source);
                            }
                            model.newItem(newItemsParams[idx], newParentItem, insertIndex, before);
                        }
                    }
                }, this);
                this.tree._expandNode(target);
            }
            this.onDndCancel();
        }, onDndCancel:function () {
            this._unmarkTargetAnchor();
            this.isDragging = false;
            this.mouseDown = false;
            delete this.mouseButton;
            this._changeState("Source", "");
            this._changeState("Target", "");
        }, onOverEvent:function () {
            this.inherited(arguments);
            DNDManager.manager().overSource(this);
        }, onOutEvent:function () {
            this._unmarkTargetAnchor();
            var m = DNDManager.manager();
            if (this.isDragging) {
                m.canDrop(false);
            }
            m.outSource(this);
            this.inherited(arguments);
        }, _isParentChildDrop:function (source, targetRow) {
            if (!source.tree || source.tree != this.tree) {
                return false;
            }
            var root = source.tree.domNode;
            var ids = source.selection;
            var node = targetRow.parentNode;
            while (node != root && !ids[node.id]) {
                node = node.parentNode;
            }
            return node.id && ids[node.id];
        }, _unmarkTargetAnchor:function () {
            if (!this.targetAnchor) {
                return;
            }
            this._removeItemClass(this.targetAnchor.rowNode, this.dropPosition);
            this.targetAnchor = null;
            this.targetBox = null;
            this.dropPosition = null;
        }, _markDndStatus:function (copy) {
            this._changeState("Source", copy ? "Copied" : "Moved");
        }});
        return dndSource;
    });
}, "dijit/form/_CheckBoxMixin":function () {
    define(["dojo/_base/declare", "dojo/dom-attr"], function (declare, domAttr) {
        return declare("dijit.form._CheckBoxMixin", null, {type:"checkbox", value:"on", readOnly:false, _aria_attr:"aria-checked", _setReadOnlyAttr:function (value) {
            this._set("readOnly", value);
            domAttr.set(this.focusNode, "readOnly", value);
        }, _setLabelAttr:undefined, _getSubmitValue:function (value) {
            return (value == null || value === "") ? "on" : value;
        }, _setValueAttr:function (newValue) {
            newValue = this._getSubmitValue(newValue);
            this._set("value", newValue);
            domAttr.set(this.focusNode, "value", newValue);
        }, reset:function () {
            this.inherited(arguments);
            this._set("value", this._getSubmitValue(this.params.value));
            domAttr.set(this.focusNode, "value", this.value);
        }, _onClick:function (e) {
            if (this.readOnly) {
                e.stopPropagation();
                e.preventDefault();
                return false;
            }
            return this.inherited(arguments);
        }});
    });
}, "dojo/html":function () {
    define(["./_base/kernel", "./_base/lang", "./_base/array", "./_base/declare", "./dom", "./dom-construct", "./parser"], function (kernel, lang, darray, declare, dom, domConstruct, parser) {
        var idCounter = 0;
        var html = {_secureForInnerHtml:function (cont) {
            return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, "");
        }, _emptyNode:domConstruct.empty, _setNodeContent:function (node, cont) {
            domConstruct.empty(node);
            if (cont) {
                if (typeof cont == "string") {
                    cont = domConstruct.toDom(cont, node.ownerDocument);
                }
                if (!cont.nodeType && lang.isArrayLike(cont)) {
                    for (var startlen = cont.length, i = 0; i < cont.length; i = startlen == cont.length ? i + 1 : 0) {
                        domConstruct.place(cont[i], node, "last");
                    }
                } else {
                    domConstruct.place(cont, node, "last");
                }
            }
            return node;
        }, _ContentSetter:declare("dojo.html._ContentSetter", null, {node:"", content:"", id:"", cleanContent:false, extractContent:false, parseContent:false, parserScope:kernel._scopeName, startup:true, constructor:function (params, node) {
            lang.mixin(this, params || {});
            node = this.node = dom.byId(this.node || node);
            if (!this.id) {
                this.id = ["Setter", (node) ? node.id || node.tagName : "", idCounter++].join("_");
            }
        }, set:function (cont, params) {
            if (undefined !== cont) {
                this.content = cont;
            }
            if (params) {
                this._mixin(params);
            }
            this.onBegin();
            this.setContent();
            var ret = this.onEnd();
            if (ret && ret.then) {
                return ret;
            } else {
                return this.node;
            }
        }, setContent:function () {
            var node = this.node;
            if (!node) {
                throw new Error(this.declaredClass + ": setContent given no node");
            }
            try {
                node = html._setNodeContent(node, this.content);
            }
            catch (e) {
                var errMess = this.onContentError(e);
                try {
                    node.innerHTML = errMess;
                }
                catch (e) {
                    console.error("Fatal " + this.declaredClass + ".setContent could not change content due to " + e.message, e);
                }
            }
            this.node = node;
        }, empty:function () {
            if (this.parseDeferred) {
                if (!this.parseDeferred.isResolved()) {
                    this.parseDeferred.cancel();
                }
                delete this.parseDeferred;
            }
            if (this.parseResults && this.parseResults.length) {
                darray.forEach(this.parseResults, function (w) {
                    if (w.destroy) {
                        w.destroy();
                    }
                });
                delete this.parseResults;
            }
            domConstruct.empty(this.node);
        }, onBegin:function () {
            var cont = this.content;
            if (lang.isString(cont)) {
                if (this.cleanContent) {
                    cont = html._secureForInnerHtml(cont);
                }
                if (this.extractContent) {
                    var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
                    if (match) {
                        cont = match[1];
                    }
                }
            }
            this.empty();
            this.content = cont;
            return this.node;
        }, onEnd:function () {
            if (this.parseContent) {
                this._parse();
            }
            return this.node;
        }, tearDown:function () {
            delete this.parseResults;
            delete this.parseDeferred;
            delete this.node;
            delete this.content;
        }, onContentError:function (err) {
            return "Error occurred setting content: " + err;
        }, onExecError:function (err) {
            return "Error occurred executing scripts: " + err;
        }, _mixin:function (params) {
            var empty = {}, key;
            for (key in params) {
                if (key in empty) {
                    continue;
                }
                this[key] = params[key];
            }
        }, _parse:function () {
            var rootNode = this.node;
            try {
                var inherited = {};
                darray.forEach(["dir", "lang", "textDir"], function (name) {
                    if (this[name]) {
                        inherited[name] = this[name];
                    }
                }, this);
                var self = this;
                this.parseDeferred = parser.parse({rootNode:rootNode, noStart:!this.startup, inherited:inherited, scope:this.parserScope}).then(function (results) {
                    return self.parseResults = results;
                }, function (e) {
                    self._onError("Content", e, "Error parsing in _ContentSetter#" + this.id);
                });
            }
            catch (e) {
                this._onError("Content", e, "Error parsing in _ContentSetter#" + this.id);
            }
        }, _onError:function (type, err, consoleText) {
            var errText = this["on" + type + "Error"].call(this, err);
            if (consoleText) {
                console.error(consoleText, err);
            } else {
                if (errText) {
                    html._setNodeContent(this.node, errText, true);
                }
            }
        }}), set:function (node, cont, params) {
            if (undefined == cont) {
                console.warn("dojo.html.set: no cont argument provided, using empty string");
                cont = "";
            }
            if (!params) {
                return html._setNodeContent(node, cont, true);
            } else {
                var op = new html._ContentSetter(lang.mixin(params, {content:cont, node:node}));
                return op.set();
            }
        }};
        lang.setObject("dojo.html", html);
        return html;
    });
}, "dojo/_base/loader":function () {
    define(["./kernel", "../has", "require", "module", "../json", "./lang", "./array"], function (dojo, has, require, thisModule, json, lang, array) {
        if (!1) {
            console.error("cannot load the Dojo v1.x loader with a foreign loader");
            return 0;
        }
        1 || has.add("dojo-fast-sync-require", 1);
        var makeErrorToken = function (id) {
            return {src:thisModule.id, id:id};
        }, slashName = function (name) {
            return name.replace(/\./g, "/");
        }, buildDetectRe = /\/\/>>built/, dojoRequireCallbacks = [], dojoRequireModuleStack = [], dojoRequirePlugin = function (mid, require, loaded) {
            dojoRequireCallbacks.push(loaded);
            array.forEach(mid.split(","), function (mid) {
                var module = getModule(mid, require.module);
                dojoRequireModuleStack.push(module);
                injectModule(module);
            });
            checkDojoRequirePlugin();
        }, checkDojoRequirePlugin = (1 ? function () {
            var module, mid;
            for (mid in modules) {
                module = modules[mid];
                if (module.noReqPluginCheck === undefined) {
                    module.noReqPluginCheck = /loadInit\!/.test(mid) || /require\!/.test(mid) ? 1 : 0;
                }
                if (!module.executed && !module.noReqPluginCheck && module.injected == requested) {
                    return;
                }
            }
            guardCheckComplete(function () {
                var oldCallbacks = dojoRequireCallbacks;
                dojoRequireCallbacks = [];
                array.forEach(oldCallbacks, function (cb) {
                    cb(1);
                });
            });
        } : (function () {
            var touched, traverse = function (m) {
                touched[m.mid] = 1;
                for (var t, module, deps = m.deps || [], i = 0; i < deps.length; i++) {
                    module = deps[i];
                    if (!(t = touched[module.mid])) {
                        if (t === 0 || !traverse(module)) {
                            touched[m.mid] = 0;
                            return false;
                        }
                    }
                }
                return true;
            };
            return function () {
                var module, mid;
                touched = {};
                for (mid in modules) {
                    module = modules[mid];
                    if (module.executed || module.noReqPluginCheck) {
                        touched[mid] = 1;
                    } else {
                        if (module.noReqPluginCheck !== 0) {
                            module.noReqPluginCheck = /loadInit\!/.test(mid) || /require\!/.test(mid) ? 1 : 0;
                        }
                        if (module.noReqPluginCheck) {
                            touched[mid] = 1;
                        } else {
                            if (module.injected !== arrived) {
                                touched[mid] = 0;
                            }
                        }
                    }
                }
                for (var t, i = 0, end = dojoRequireModuleStack.length; i < end; i++) {
                    module = dojoRequireModuleStack[i];
                    if (!(t = touched[module.mid])) {
                        if (t === 0 || !traverse(module)) {
                            return;
                        }
                    }
                }
                guardCheckComplete(function () {
                    var oldCallbacks = dojoRequireCallbacks;
                    dojoRequireCallbacks = [];
                    array.forEach(oldCallbacks, function (cb) {
                        cb(1);
                    });
                });
            };
        })()), dojoLoadInitPlugin = function (mid, require, loaded) {
            require([mid], function (bundle) {
                require(bundle.names, function () {
                    for (var scopeText = "", args = [], i = 0; i < arguments.length; i++) {
                        scopeText += "var " + bundle.names[i] + "= arguments[" + i + "]; ";
                        args.push(arguments[i]);
                    }
                    eval(scopeText);
                    var callingModule = require.module, requireList = [], i18nDeps, syncLoaderApi = {provide:function (moduleName) {
                        moduleName = slashName(moduleName);
                        var providedModule = getModule(moduleName, callingModule);
                        if (providedModule !== callingModule) {
                            setArrived(providedModule);
                        }
                    }, require:function (moduleName, omitModuleCheck) {
                        moduleName = slashName(moduleName);
                        omitModuleCheck && (getModule(moduleName, callingModule).result = nonmodule);
                        requireList.push(moduleName);
                    }, requireLocalization:function (moduleName, bundleName, locale) {
                        if (!i18nDeps) {
                            i18nDeps = ["dojo/i18n"];
                        }
                        locale = (locale || dojo.locale).toLowerCase();
                        moduleName = slashName(moduleName) + "/nls/" + (/root/i.test(locale) ? "" : locale + "/") + slashName(bundleName);
                        if (getModule(moduleName, callingModule).isXd) {
                            i18nDeps.push("dojo/i18n!" + moduleName);
                        }
                    }, loadInit:function (f) {
                        f();
                    }}, hold = {}, p;
                    try {
                        for (p in syncLoaderApi) {
                            hold[p] = dojo[p];
                            dojo[p] = syncLoaderApi[p];
                        }
                        bundle.def.apply(null, args);
                    }
                    catch (e) {
                        signal("error", [makeErrorToken("failedDojoLoadInit"), e]);
                    }
                    finally {
                        for (p in syncLoaderApi) {
                            dojo[p] = hold[p];
                        }
                    }
                    if (i18nDeps) {
                        requireList = requireList.concat(i18nDeps);
                    }
                    if (requireList.length) {
                        dojoRequirePlugin(requireList.join(","), require, loaded);
                    } else {
                        loaded();
                    }
                });
            });
        }, extractApplication = function (text, startSearch, startApplication) {
            var parenRe = /\(|\)/g, matchCount = 1, match;
            parenRe.lastIndex = startSearch;
            while ((match = parenRe.exec(text))) {
                if (match[0] == ")") {
                    matchCount -= 1;
                } else {
                    matchCount += 1;
                }
                if (matchCount == 0) {
                    break;
                }
            }
            if (matchCount != 0) {
                throw "unmatched paren around character " + parenRe.lastIndex + " in: " + text;
            }
            return [dojo.trim(text.substring(startApplication, parenRe.lastIndex)) + ";\n", parenRe.lastIndex];
        }, removeCommentRe = /(\/\*([\s\S]*?)\*\/|\/\/(.*)$)/mg, syncLoaderApiRe = /(^|\s)dojo\.(loadInit|require|provide|requireLocalization|requireIf|requireAfterIf|platformRequire)\s*\(/mg, amdLoaderApiRe = /(^|\s)(require|define)\s*\(/m, extractLegacyApiApplications = function (text, noCommentText) {
            var match, startSearch, startApplication, application, loadInitApplications = [], otherApplications = [], allApplications = [];
            noCommentText = noCommentText || text.replace(removeCommentRe, function (match) {
                syncLoaderApiRe.lastIndex = amdLoaderApiRe.lastIndex = 0;
                return (syncLoaderApiRe.test(match) || amdLoaderApiRe.test(match)) ? "" : match;
            });
            while ((match = syncLoaderApiRe.exec(noCommentText))) {
                startSearch = syncLoaderApiRe.lastIndex;
                startApplication = startSearch - match[0].length;
                application = extractApplication(noCommentText, startSearch, startApplication);
                if (match[2] == "loadInit") {
                    loadInitApplications.push(application[0]);
                } else {
                    otherApplications.push(application[0]);
                }
                syncLoaderApiRe.lastIndex = application[1];
            }
            allApplications = loadInitApplications.concat(otherApplications);
            if (allApplications.length || !amdLoaderApiRe.test(noCommentText)) {
                return [text.replace(/(^|\s)dojo\.loadInit\s*\(/g, "\n0 && dojo.loadInit("), allApplications.join(""), allApplications];
            } else {
                return 0;
            }
        }, transformToAmd = function (module, text) {
            var extractResult, id, names = [], namesAsStrings = [];
            if (buildDetectRe.test(text) || !(extractResult = extractLegacyApiApplications(text))) {
                return 0;
            }
            id = module.mid + "-*loadInit";
            for (var p in getModule("dojo", module).result.scopeMap) {
                names.push(p);
                namesAsStrings.push("\"" + p + "\"");
            }
            return "// xdomain rewrite of " + module.mid + "\n" + "define('" + id + "',{\n" + "\tnames:" + json.stringify(names) + ",\n" + "\tdef:function(" + names.join(",") + "){" + extractResult[1] + "}" + "});\n\n" + "define(" + json.stringify(names.concat(["dojo/loadInit!" + id])) + ", function(" + names.join(",") + "){\n" + extractResult[0] + "});";
        }, loaderVars = require.initSyncLoader(dojoRequirePlugin, checkDojoRequirePlugin, transformToAmd), sync = loaderVars.sync, requested = loaderVars.requested, arrived = loaderVars.arrived, nonmodule = loaderVars.nonmodule, executing = loaderVars.executing, executed = loaderVars.executed, syncExecStack = loaderVars.syncExecStack, modules = loaderVars.modules, execQ = loaderVars.execQ, getModule = loaderVars.getModule, injectModule = loaderVars.injectModule, setArrived = loaderVars.setArrived, signal = loaderVars.signal, finishExec = loaderVars.finishExec, execModule = loaderVars.execModule, getLegacyMode = loaderVars.getLegacyMode, guardCheckComplete = loaderVars.guardCheckComplete;
        dojoRequirePlugin = loaderVars.dojoRequirePlugin;
        dojo.provide = function (mid) {
            var executingModule = syncExecStack[0], module = lang.mixin(getModule(slashName(mid), require.module), {executed:executing, result:lang.getObject(mid, true)});
            setArrived(module);
            if (executingModule) {
                (executingModule.provides || (executingModule.provides = [])).push(function () {
                    module.result = lang.getObject(mid);
                    delete module.provides;
                    module.executed !== executed && finishExec(module);
                });
            }
            return module.result;
        };
        has.add("config-publishRequireResult", 1, 0, 0);
        dojo.require = function (moduleName, omitModuleCheck) {
            function doRequire(mid, omitModuleCheck) {
                var module = getModule(slashName(mid), require.module);
                if (syncExecStack.length && syncExecStack[0].finish) {
                    syncExecStack[0].finish.push(mid);
                    return undefined;
                }
                if (module.executed) {
                    return module.result;
                }
                omitModuleCheck && (module.result = nonmodule);
                var currentMode = getLegacyMode();
                injectModule(module);
                currentMode = getLegacyMode();
                if (module.executed !== executed && module.injected === arrived) {
                    loaderVars.guardCheckComplete(function () {
                        execModule(module);
                    });
                }
                if (module.executed) {
                    return module.result;
                }
                if (currentMode == sync) {
                    if (module.cjs) {
                        execQ.unshift(module);
                    } else {
                        syncExecStack.length && (syncExecStack[0].finish = [mid]);
                    }
                } else {
                    execQ.push(module);
                }
                return undefined;
            }
            var result = doRequire(moduleName, omitModuleCheck);
            if (has("config-publishRequireResult") && !lang.exists(moduleName) && result !== undefined) {
                lang.setObject(moduleName, result);
            }
            return result;
        };
        dojo.loadInit = function (f) {
            f();
        };
        dojo.registerModulePath = function (moduleName, prefix) {
            var paths = {};
            paths[moduleName.replace(/\./g, "/")] = prefix;
            require({paths:paths});
        };
        dojo.platformRequire = function (modMap) {
            var result = (modMap.common || []).concat(modMap[dojo._name] || modMap["default"] || []), temp;
            while (result.length) {
                if (lang.isArray(temp = result.shift())) {
                    dojo.require.apply(dojo, temp);
                } else {
                    dojo.require(temp);
                }
            }
        };
        dojo.requireIf = dojo.requireAfterIf = function (condition, moduleName, omitModuleCheck) {
            if (condition) {
                dojo.require(moduleName, omitModuleCheck);
            }
        };
        dojo.requireLocalization = function (moduleName, bundleName, locale) {
            require(["../i18n"], function (i18n) {
                i18n.getLocalization(moduleName, bundleName, locale);
            });
        };
        return {extractLegacyApiApplications:extractLegacyApiApplications, require:dojoRequirePlugin, loadInit:dojoLoadInitPlugin};
    });
}, "dojo/dom-style":function () {
    define(["./sniff", "./dom"], function (has, dom) {
        var getComputedStyle, style = {};
        if (has("webkit")) {
            getComputedStyle = function (node) {
                var s;
                if (node.nodeType == 1) {
                    var dv = node.ownerDocument.defaultView;
                    s = dv.getComputedStyle(node, null);
                    if (!s && node.style) {
                        node.style.display = "";
                        s = dv.getComputedStyle(node, null);
                    }
                }
                return s || {};
            };
        } else {
            if (has("ie") && (has("ie") < 9 || has("quirks"))) {
                getComputedStyle = function (node) {
                    return node.nodeType == 1 && node.currentStyle ? node.currentStyle : {};
                };
            } else {
                getComputedStyle = function (node) {
                    return node.nodeType == 1 ? node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
                };
            }
        }
        style.getComputedStyle = getComputedStyle;
        var toPixel;
        if (!has("ie")) {
            toPixel = function (element, value) {
                return parseFloat(value) || 0;
            };
        } else {
            toPixel = function (element, avalue) {
                if (!avalue) {
                    return 0;
                }
                if (avalue == "medium") {
                    return 4;
                }
                if (avalue.slice && avalue.slice(-2) == "px") {
                    return parseFloat(avalue);
                }
                var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle, sLeft = s.left, rsLeft = rs.left;
                rs.left = cs.left;
                try {
                    s.left = avalue;
                    avalue = s.pixelLeft;
                }
                catch (e) {
                    avalue = 0;
                }
                s.left = sLeft;
                rs.left = rsLeft;
                return avalue;
            };
        }
        style.toPixelValue = toPixel;
        var astr = "DXImageTransform.Microsoft.Alpha";
        var af = function (n, f) {
            try {
                return n.filters.item(astr);
            }
            catch (e) {
                return f ? {} : null;
            }
        };
        var _getOpacity = has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function (node) {
            try {
                return af(node).Opacity / 100;
            }
            catch (e) {
                return 1;
            }
        } : function (node) {
            return getComputedStyle(node).opacity;
        };
        var _setOpacity = has("ie") < 9 || (has("ie") < 10 && has("quirks")) ? function (node, opacity) {
            if (opacity === "") {
                opacity = 1;
            }
            var ov = opacity * 100, fullyOpaque = opacity === 1;
            if (fullyOpaque) {
                node.style.zoom = "";
                if (af(node)) {
                    node.style.filter = node.style.filter.replace(new RegExp("\\s*progid:" + astr + "\\([^\\)]+?\\)", "i"), "");
                }
            } else {
                node.style.zoom = 1;
                if (af(node)) {
                    af(node, 1).Opacity = ov;
                } else {
                    node.style.filter += " progid:" + astr + "(Opacity=" + ov + ")";
                }
                af(node, 1).Enabled = true;
            }
            if (node.tagName.toLowerCase() == "tr") {
                for (var td = node.firstChild; td; td = td.nextSibling) {
                    if (td.tagName.toLowerCase() == "td") {
                        _setOpacity(td, opacity);
                    }
                }
            }
            return opacity;
        } : function (node, opacity) {
            return node.style.opacity = opacity;
        };
        var _pixelNamesCache = {left:true, top:true};
        var _pixelRegExp = /margin|padding|width|height|max|min|offset/;
        function _toStyleValue(node, type, value) {
            type = type.toLowerCase();
            if (has("ie")) {
                if (value == "auto") {
                    if (type == "height") {
                        return node.offsetHeight;
                    }
                    if (type == "width") {
                        return node.offsetWidth;
                    }
                }
                if (type == "fontweight") {
                    switch (value) {
                      case 700:
                        return "bold";
                      case 400:
                      default:
                        return "normal";
                    }
                }
            }
            if (!(type in _pixelNamesCache)) {
                _pixelNamesCache[type] = _pixelRegExp.test(type);
            }
            return _pixelNamesCache[type] ? toPixel(node, value) : value;
        }
        var _floatAliases = {cssFloat:1, styleFloat:1, "float":1};
        style.get = function getStyle(node, name) {
            var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
            if (l == 2 && op) {
                return _getOpacity(n);
            }
            name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
            var s = style.getComputedStyle(n);
            return (l == 1) ? s : _toStyleValue(n, name, s[name] || n.style[name]);
        };
        style.set = function setStyle(node, name, value) {
            var n = dom.byId(node), l = arguments.length, op = (name == "opacity");
            name = _floatAliases[name] ? "cssFloat" in n.style ? "cssFloat" : "styleFloat" : name;
            if (l == 3) {
                return op ? _setOpacity(n, value) : n.style[name] = value;
            }
            for (var x in name) {
                style.set(node, x, name[x]);
            }
            return style.getComputedStyle(n);
        };
        return style;
    });
}, "dojo/Stateful":function () {
    define(["./_base/declare", "./_base/lang", "./_base/array", "./when"], function (declare, lang, array, when) {
        return declare("dojo.Stateful", null, {_attrPairNames:{}, _getAttrNames:function (name) {
            var apn = this._attrPairNames;
            if (apn[name]) {
                return apn[name];
            }
            return (apn[name] = {s:"_" + name + "Setter", g:"_" + name + "Getter"});
        }, postscript:function (params) {
            if (params) {
                this.set(params);
            }
        }, _get:function (name, names) {
            return typeof this[names.g] === "function" ? this[names.g]() : this[name];
        }, get:function (name) {
            return this._get(name, this._getAttrNames(name));
        }, set:function (name, value) {
            if (typeof name === "object") {
                for (var x in name) {
                    if (name.hasOwnProperty(x) && x != "_watchCallbacks") {
                        this.set(x, name[x]);
                    }
                }
                return this;
            }
            var names = this._getAttrNames(name), oldValue = this._get(name, names), setter = this[names.s], result;
            if (typeof setter === "function") {
                result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
            } else {
                this[name] = value;
            }
            if (this._watchCallbacks) {
                var self = this;
                when(result, function () {
                    self._watchCallbacks(name, oldValue, value);
                });
            }
            return this;
        }, _changeAttrValue:function (name, value) {
            var oldValue = this.get(name);
            this[name] = value;
            if (this._watchCallbacks) {
                this._watchCallbacks(name, oldValue, value);
            }
            return this;
        }, watch:function (name, callback) {
            var callbacks = this._watchCallbacks;
            if (!callbacks) {
                var self = this;
                callbacks = this._watchCallbacks = function (name, oldValue, value, ignoreCatchall) {
                    var notify = function (propertyCallbacks) {
                        if (propertyCallbacks) {
                            propertyCallbacks = propertyCallbacks.slice();
                            for (var i = 0, l = propertyCallbacks.length; i < l; i++) {
                                propertyCallbacks[i].call(self, name, oldValue, value);
                            }
                        }
                    };
                    notify(callbacks["_" + name]);
                    if (!ignoreCatchall) {
                        notify(callbacks["*"]);
                    }
                };
            }
            if (!callback && typeof name === "function") {
                callback = name;
                name = "*";
            } else {
                name = "_" + name;
            }
            var propertyCallbacks = callbacks[name];
            if (typeof propertyCallbacks !== "object") {
                propertyCallbacks = callbacks[name] = [];
            }
            propertyCallbacks.push(callback);
            var handle = {};
            handle.unwatch = handle.remove = function () {
                var index = array.indexOf(propertyCallbacks, callback);
                if (index > -1) {
                    propertyCallbacks.splice(index, 1);
                }
            };
            return handle;
        }});
    });
}, "dojo/selector/lite":function () {
    define(["../has", "../_base/kernel"], function (has, dojo) {
        "use strict";
        var testDiv = document.createElement("div");
        var matchesSelector = testDiv.matchesSelector || testDiv.webkitMatchesSelector || testDiv.mozMatchesSelector || testDiv.msMatchesSelector || testDiv.oMatchesSelector;
        var querySelectorAll = testDiv.querySelectorAll;
        var unionSplit = /([^\s,](?:"(?:\\.|[^"])+"|'(?:\\.|[^'])+'|[^,])*)/g;
        has.add("dom-matches-selector", !!matchesSelector);
        has.add("dom-qsa", !!querySelectorAll);
        var liteEngine = function (selector, root) {
            if (combine && selector.indexOf(",") > -1) {
                return combine(selector, root);
            }
            var doc = root ? root.ownerDocument || root : dojo.doc || document, match = (querySelectorAll ? /^([\w]*)#([\w\-]+$)|^(\.)([\w\-\*]+$)|^(\w+$)/ : /^([\w]*)#([\w\-]+)(?:\s+(.*))?$|(?:^|(>|.+\s+))([\w\-\*]+)(\S*$)/).exec(selector);
            root = root || doc;
            if (match) {
                if (match[2]) {
                    var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
                    if (!found || (match[1] && match[1] != found.tagName.toLowerCase())) {
                        return [];
                    }
                    if (root != doc) {
                        var parent = found;
                        while (parent != root) {
                            parent = parent.parentNode;
                            if (!parent) {
                                return [];
                            }
                        }
                    }
                    return match[3] ? liteEngine(match[3], found) : [found];
                }
                if (match[3] && root.getElementsByClassName) {
                    return root.getElementsByClassName(match[4]);
                }
                var found;
                if (match[5]) {
                    found = root.getElementsByTagName(match[5]);
                    if (match[4] || match[6]) {
                        selector = (match[4] || "") + match[6];
                    } else {
                        return found;
                    }
                }
            }
            if (querySelectorAll) {
                if (root.nodeType === 1 && root.nodeName.toLowerCase() !== "object") {
                    return useRoot(root, selector, root.querySelectorAll);
                } else {
                    return root.querySelectorAll(selector);
                }
            } else {
                if (!found) {
                    found = root.getElementsByTagName("*");
                }
            }
            var results = [];
            for (var i = 0, l = found.length; i < l; i++) {
                var node = found[i];
                if (node.nodeType == 1 && jsMatchesSelector(node, selector, root)) {
                    results.push(node);
                }
            }
            return results;
        };
        var useRoot = function (context, query, method) {
            var oldContext = context, old = context.getAttribute("id"), nid = old || "__dojo__", hasParent = context.parentNode, relativeHierarchySelector = /^\s*[+~]/.test(query);
            if (relativeHierarchySelector && !hasParent) {
                return [];
            }
            if (!old) {
                context.setAttribute("id", nid);
            } else {
                nid = nid.replace(/'/g, "\\$&");
            }
            if (relativeHierarchySelector && hasParent) {
                context = context.parentNode;
            }
            var selectors = query.match(unionSplit);
            for (var i = 0; i < selectors.length; i++) {
                selectors[i] = "[id='" + nid + "'] " + selectors[i];
            }
            query = selectors.join(",");
            try {
                return method.call(context, query);
            }
            finally {
                if (!old) {
                    oldContext.removeAttribute("id");
                }
            }
        };
        if (!has("dom-matches-selector")) {
            var jsMatchesSelector = (function () {
                var caseFix = testDiv.tagName == "div" ? "toLowerCase" : "toUpperCase";
                var selectorTypes = {"":function (tagName) {
                    tagName = tagName[caseFix]();
                    return function (node) {
                        return node.tagName == tagName;
                    };
                }, ".":function (className) {
                    var classNameSpaced = " " + className + " ";
                    return function (node) {
                        return node.className.indexOf(className) > -1 && (" " + node.className + " ").indexOf(classNameSpaced) > -1;
                    };
                }, "#":function (id) {
                    return function (node) {
                        return node.id == id;
                    };
                }};
                var attrComparators = {"^=":function (attrValue, value) {
                    return attrValue.indexOf(value) == 0;
                }, "*=":function (attrValue, value) {
                    return attrValue.indexOf(value) > -1;
                }, "$=":function (attrValue, value) {
                    return attrValue.substring(attrValue.length - value.length, attrValue.length) == value;
                }, "~=":function (attrValue, value) {
                    return (" " + attrValue + " ").indexOf(" " + value + " ") > -1;
                }, "|=":function (attrValue, value) {
                    return (attrValue + "-").indexOf(value + "-") == 0;
                }, "=":function (attrValue, value) {
                    return attrValue == value;
                }, "":function (attrValue, value) {
                    return true;
                }};
                function attr(name, value, type) {
                    var firstChar = value.charAt(0);
                    if (firstChar == "\"" || firstChar == "'") {
                        value = value.slice(1, -1);
                    }
                    value = value.replace(/\\/g, "");
                    var comparator = attrComparators[type || ""];
                    return function (node) {
                        var attrValue = node.getAttribute(name);
                        return attrValue && comparator(attrValue, value);
                    };
                }
                function ancestor(matcher) {
                    return function (node, root) {
                        while ((node = node.parentNode) != root) {
                            if (matcher(node, root)) {
                                return true;
                            }
                        }
                    };
                }
                function parent(matcher) {
                    return function (node, root) {
                        node = node.parentNode;
                        return matcher ? node != root && matcher(node, root) : node == root;
                    };
                }
                var cache = {};
                function and(matcher, next) {
                    return matcher ? function (node, root) {
                        return next(node) && matcher(node, root);
                    } : next;
                }
                return function (node, selector, root) {
                    var matcher = cache[selector];
                    if (!matcher) {
                        if (selector.replace(/(?:\s*([> ])\s*)|(#|\.)?((?:\\.|[\w-])+)|\[\s*([\w-]+)\s*(.?=)?\s*("(?:\\.|[^"])+"|'(?:\\.|[^'])+'|(?:\\.|[^\]])*)\s*\]/g, function (t, combinator, type, value, attrName, attrType, attrValue) {
                            if (value) {
                                matcher = and(matcher, selectorTypes[type || ""](value.replace(/\\/g, "")));
                            } else {
                                if (combinator) {
                                    matcher = (combinator == " " ? ancestor : parent)(matcher);
                                } else {
                                    if (attrName) {
                                        matcher = and(matcher, attr(attrName, attrValue, attrType));
                                    }
                                }
                            }
                            return "";
                        })) {
                            throw new Error("Syntax error in query");
                        }
                        if (!matcher) {
                            return true;
                        }
                        cache[selector] = matcher;
                    }
                    return matcher(node, root);
                };
            })();
        }
        if (!has("dom-qsa")) {
            var combine = function (selector, root) {
                var selectors = selector.match(unionSplit);
                var indexed = [];
                for (var i = 0; i < selectors.length; i++) {
                    selector = new String(selectors[i].replace(/\s*$/, ""));
                    selector.indexOf = escape;
                    var results = liteEngine(selector, root);
                    for (var j = 0, l = results.length; j < l; j++) {
                        var node = results[j];
                        indexed[node.sourceIndex] = node;
                    }
                }
                var totalResults = [];
                for (i in indexed) {
                    totalResults.push(indexed[i]);
                }
                return totalResults;
            };
        }
        liteEngine.match = matchesSelector ? function (node, selector, root) {
            if (root && root.nodeType != 9) {
                return useRoot(root, selector, function (query) {
                    return matchesSelector.call(node, query);
                });
            }
            return matchesSelector.call(node, selector);
        } : jsMatchesSelector;
        return liteEngine;
    });
}, "dijit/layout/LayoutContainer":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-class", "dojo/dom-style", "dojo/_base/lang", "../_WidgetBase", "./_LayoutWidget", "./utils"], function (array, declare, domClass, domStyle, lang, _WidgetBase, _LayoutWidget, layoutUtils) {
        var LayoutContainer = declare("dijit.layout.LayoutContainer", _LayoutWidget, {design:"headline", baseClass:"dijitLayoutContainer", startup:function () {
            if (this._started) {
                return;
            }
            array.forEach(this.getChildren(), this._setupChild, this);
            this.inherited(arguments);
        }, _setupChild:function (child) {
            this.inherited(arguments);
            var region = child.region;
            if (region) {
                domClass.add(child.domNode, this.baseClass + "Pane");
            }
        }, _getOrderedChildren:function () {
            var wrappers = array.map(this.getChildren(), function (child, idx) {
                return {pane:child, weight:[child.region == "center" ? Infinity : 0, child.layoutPriority, (this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1), idx]};
            }, this);
            wrappers.sort(function (a, b) {
                var aw = a.weight, bw = b.weight;
                for (var i = 0; i < aw.length; i++) {
                    if (aw[i] != bw[i]) {
                        return aw[i] - bw[i];
                    }
                }
                return 0;
            });
            return array.map(wrappers, function (w) {
                return w.pane;
            });
        }, layout:function () {
            layoutUtils.layoutChildren(this.domNode, this._contentBox, this._getOrderedChildren());
        }, addChild:function (child, insertIndex) {
            this.inherited(arguments);
            if (this._started) {
                this.layout();
            }
        }, removeChild:function (child) {
            this.inherited(arguments);
            if (this._started) {
                this.layout();
            }
            domClass.remove(child.domNode, this.baseClass + "Pane");
            domStyle.set(child.domNode, {top:"auto", bottom:"auto", left:"auto", right:"auto", position:"static"});
            domStyle.set(child.domNode, /top|bottom/.test(child.region) ? "width" : "height", "auto");
        }});
        LayoutContainer.ChildWidgetProperties = {region:"", layoutAlign:"", layoutPriority:0};
        lang.extend(_WidgetBase, LayoutContainer.ChildWidgetProperties);
        return LayoutContainer;
    });
}, "dojo/dnd/autoscroll":function () {
    define(["../_base/lang", "../sniff", "../_base/window", "../dom-geometry", "../dom-style", "../window"], function (lang, has, win, domGeom, domStyle, winUtils) {
        var exports = {};
        lang.setObject("dojo.dnd.autoscroll", exports);
        exports.getViewport = winUtils.getBox;
        exports.V_TRIGGER_AUTOSCROLL = 32;
        exports.H_TRIGGER_AUTOSCROLL = 32;
        exports.V_AUTOSCROLL_VALUE = 16;
        exports.H_AUTOSCROLL_VALUE = 16;
        var viewport, doc = win.doc, maxScrollTop = Infinity, maxScrollLeft = Infinity;
        exports.autoScrollStart = function (d) {
            doc = d;
            viewport = winUtils.getBox(doc);
            var html = win.body(doc).parentNode;
            maxScrollTop = Math.max(html.scrollHeight - viewport.h, 0);
            maxScrollLeft = Math.max(html.scrollWidth - viewport.w, 0);
        };
        exports.autoScroll = function (e) {
            var v = viewport || winUtils.getBox(doc), html = win.body(doc).parentNode, dx = 0, dy = 0;
            if (e.clientX < exports.H_TRIGGER_AUTOSCROLL) {
                dx = -exports.H_AUTOSCROLL_VALUE;
            } else {
                if (e.clientX > v.w - exports.H_TRIGGER_AUTOSCROLL) {
                    dx = Math.min(exports.H_AUTOSCROLL_VALUE, maxScrollLeft - html.scrollLeft);
                }
            }
            if (e.clientY < exports.V_TRIGGER_AUTOSCROLL) {
                dy = -exports.V_AUTOSCROLL_VALUE;
            } else {
                if (e.clientY > v.h - exports.V_TRIGGER_AUTOSCROLL) {
                    dy = Math.min(exports.V_AUTOSCROLL_VALUE, maxScrollTop - html.scrollTop);
                }
            }
            window.scrollBy(dx, dy);
        };
        exports._validNodes = {"div":1, "p":1, "td":1};
        exports._validOverflow = {"auto":1, "scroll":1};
        exports.autoScrollNodes = function (e) {
            var b, t, w, h, rx, ry, dx = 0, dy = 0, oldLeft, oldTop;
            for (var n = e.target; n; ) {
                if (n.nodeType == 1 && (n.tagName.toLowerCase() in exports._validNodes)) {
                    var s = domStyle.getComputedStyle(n), overflow = (s.overflow.toLowerCase() in exports._validOverflow), overflowX = (s.overflowX.toLowerCase() in exports._validOverflow), overflowY = (s.overflowY.toLowerCase() in exports._validOverflow);
                    if (overflow || overflowX || overflowY) {
                        b = domGeom.getContentBox(n, s);
                        t = domGeom.position(n, true);
                    }
                    if (overflow || overflowX) {
                        w = Math.min(exports.H_TRIGGER_AUTOSCROLL, b.w / 2);
                        rx = e.pageX - t.x;
                        if (has("webkit") || has("opera")) {
                            rx += win.body().scrollLeft;
                        }
                        dx = 0;
                        if (rx > 0 && rx < b.w) {
                            if (rx < w) {
                                dx = -w;
                            } else {
                                if (rx > b.w - w) {
                                    dx = w;
                                }
                            }
                            oldLeft = n.scrollLeft;
                            n.scrollLeft = n.scrollLeft + dx;
                        }
                    }
                    if (overflow || overflowY) {
                        h = Math.min(exports.V_TRIGGER_AUTOSCROLL, b.h / 2);
                        ry = e.pageY - t.y;
                        if (has("webkit") || has("opera")) {
                            ry += win.body().scrollTop;
                        }
                        dy = 0;
                        if (ry > 0 && ry < b.h) {
                            if (ry < h) {
                                dy = -h;
                            } else {
                                if (ry > b.h - h) {
                                    dy = h;
                                }
                            }
                            oldTop = n.scrollTop;
                            n.scrollTop = n.scrollTop + dy;
                        }
                    }
                    if (dx || dy) {
                        return;
                    }
                }
                try {
                    n = n.parentNode;
                }
                catch (x) {
                    n = null;
                }
            }
            exports.autoScroll(e);
        };
        return exports;
    });
}, "dojox/grid/enhanced/plugins/CellMerge":function () {
    define(["dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/html", "../_Plugin", "../../EnhancedGrid"], function (declare, array, lang, html, _Plugin, EnhancedGrid) {
        var CellMerge = declare("dojox.grid.enhanced.plugins.CellMerge", _Plugin, {name:"cellMerge", constructor:function (grid, args) {
            this.grid = grid;
            this._records = [];
            this._merged = {};
            if (args && lang.isObject(args)) {
                this._setupConfig(args.mergedCells);
            }
            this._initEvents();
            this._mixinGrid();
        }, mergeCells:function (rowTester, startColumnIndex, endColumnIndex, majorColumnIndex) {
            var item = this._createRecord({"row":rowTester, "start":startColumnIndex, "end":endColumnIndex, "major":majorColumnIndex});
            if (item) {
                this._updateRows(item);
            }
            return item;
        }, unmergeCells:function (mergeHandler) {
            var idx;
            if (mergeHandler && (idx = array.indexOf(this._records, mergeHandler)) >= 0) {
                this._records.splice(idx, 1);
                this._updateRows(mergeHandler);
            }
        }, getMergedCells:function () {
            var res = [];
            for (var i in this._merged) {
                res = res.concat(this._merged[i]);
            }
            return res;
        }, getMergedCellsByRow:function (rowIndex) {
            return this._merged[rowIndex] || [];
        }, _setupConfig:function (config) {
            array.forEach(config, this._createRecord, this);
        }, _initEvents:function () {
            array.forEach(this.grid.views.views, function (view) {
                this.connect(view, "onAfterRow", lang.hitch(this, "_onAfterRow", view.index));
            }, this);
        }, _mixinGrid:function () {
            var g = this.grid;
            g.mergeCells = lang.hitch(this, "mergeCells");
            g.unmergeCells = lang.hitch(this, "unmergeCells");
            g.getMergedCells = lang.hitch(this, "getMergedCells");
            g.getMergedCellsByRow = lang.hitch(this, "getMergedCellsByRow");
        }, _getWidth:function (colIndex) {
            var node = this.grid.layout.cells[colIndex].getHeaderNode();
            return html.position(node).w;
        }, _onAfterRow:function (viewIdx, rowIndex, subrows) {
            try {
                if (rowIndex < 0) {
                    return;
                }
                var result = [], i, j, len = this._records.length, cells = this.grid.layout.cells;
                for (i = 0; i < len; ++i) {
                    var item = this._records[i];
                    var storeItem = this.grid._by_idx[rowIndex];
                    if (item.view == viewIdx && item.row(rowIndex, storeItem && storeItem.item, this.grid.store)) {
                        var res = {record:item, hiddenCells:[], totalWidth:0, majorNode:cells[item.major].getNode(rowIndex), majorHeaderNode:cells[item.major].getHeaderNode()};
                        for (j = item.start; j <= item.end; ++j) {
                            var w = this._getWidth(j, rowIndex);
                            res.totalWidth += w;
                            if (j != item.major) {
                                res.hiddenCells.push(cells[j].getNode(rowIndex));
                            }
                        }
                        if (subrows.length != 1 || res.totalWidth > 0) {
                            for (j = result.length - 1; j >= 0; --j) {
                                var r = result[j].record;
                                if ((r.start >= item.start && r.start <= item.end) || (r.end >= item.start && r.end <= item.end)) {
                                    result.splice(j, 1);
                                }
                            }
                            result.push(res);
                        }
                    }
                }
                this._merged[rowIndex] = [];
                array.forEach(result, function (res) {
                    array.forEach(res.hiddenCells, function (node) {
                        html.style(node, "display", "none");
                    });
                    var pbm = html.marginBox(res.majorHeaderNode).w - html.contentBox(res.majorHeaderNode).w;
                    var tw = res.totalWidth;
                    if (!html.isWebKit) {
                        tw -= pbm;
                    }
                    html.style(res.majorNode, "width", tw + "px");
                    res.majorNode.setAttribute("colspan", res.hiddenCells.length + 1);
                    this._merged[rowIndex].push({"row":rowIndex, "start":res.record.start, "end":res.record.end, "major":res.record.major, "handle":res.record});
                }, this);
            }
            catch (e) {
                console.warn("CellMerge._onAfterRow() error: ", rowIndex, e);
            }
        }, _createRecord:function (item) {
            if (this._isValid(item)) {
                item = {"row":item.row, "start":item.start, "end":item.end, "major":item.major};
                var cells = this.grid.layout.cells;
                item.view = cells[item.start].view.index;
                item.major = typeof item.major == "number" && !isNaN(item.major) ? item.major : item.start;
                if (typeof item.row == "number") {
                    var r = item.row;
                    item.row = function (rowIndex) {
                        return rowIndex === r;
                    };
                } else {
                    if (typeof item.row == "string") {
                        var id = item.row;
                        item.row = function (rowIndex, storeItem, store) {
                            try {
                                if (store && storeItem && store.getFeatures()["dojo.data.api.Identity"]) {
                                    return store.getIdentity(storeItem) == id;
                                }
                            }
                            catch (e) {
                                console.error(e);
                            }
                            return false;
                        };
                    }
                }
                if (lang.isFunction(item.row)) {
                    this._records.push(item);
                    return item;
                }
            }
            return null;
        }, _isValid:function (item) {
            var cells = this.grid.layout.cells, colCount = cells.length;
            return (lang.isObject(item) && ("row" in item) && ("start" in item) && ("end" in item) && item.start >= 0 && item.start < colCount && item.end > item.start && item.end < colCount && cells[item.start].view.index == cells[item.end].view.index && cells[item.start].subrow == cells[item.end].subrow && !(typeof item.major == "number" && (item.major < item.start || item.major > item.end)));
        }, _updateRows:function (item) {
            var min = null;
            for (var i = 0, count = this.grid.rowCount; i < count; ++i) {
                var storeItem = this.grid._by_idx[i];
                if (storeItem && item.row(i, storeItem && storeItem.item, this.grid.store)) {
                    this.grid.views.updateRow(i);
                    if (min === null) {
                        min = i;
                    }
                }
            }
            if (min >= 0) {
                this.grid.scroller.rowHeightChanged(min);
            }
        }});
        EnhancedGrid.registerPlugin(CellMerge);
        return CellMerge;
    });
}, "dojox/grid/cells":function () {
    define(["../main", "./cells/_base"], function (dojox) {
        return dojox.grid.cells;
    });
}, "dijit/layout/utils":function () {
    define(["dojo/_base/array", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/_base/lang"], function (array, domClass, domGeometry, domStyle, lang) {
        function capitalize(word) {
            return word.substring(0, 1).toUpperCase() + word.substring(1);
        }
        function size(widget, dim) {
            var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);
            if (newSize) {
                lang.mixin(widget, newSize);
            } else {
                lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
                lang.mixin(widget, dim);
            }
        }
        var utils = {marginBox2contentBox:function (node, mb) {
            var cs = domStyle.getComputedStyle(node);
            var me = domGeometry.getMarginExtents(node, cs);
            var pb = domGeometry.getPadBorderExtents(node, cs);
            return {l:domStyle.toPixelValue(node, cs.paddingLeft), t:domStyle.toPixelValue(node, cs.paddingTop), w:mb.w - (me.w + pb.w), h:mb.h - (me.h + pb.h)};
        }, layoutChildren:function (container, dim, children, changedRegionId, changedRegionSize) {
            dim = lang.mixin({}, dim);
            domClass.add(container, "dijitLayoutContainer");
            children = array.filter(children, function (item) {
                return item.region != "center" && item.layoutAlign != "client";
            }).concat(array.filter(children, function (item) {
                return item.region == "center" || item.layoutAlign == "client";
            }));
            array.forEach(children, function (child) {
                var elm = child.domNode, pos = (child.region || child.layoutAlign);
                if (!pos) {
                    throw new Error("No region setting for " + child.id);
                }
                var elmStyle = elm.style;
                elmStyle.left = dim.l + "px";
                elmStyle.top = dim.t + "px";
                elmStyle.position = "absolute";
                domClass.add(elm, "dijitAlign" + capitalize(pos));
                var sizeSetting = {};
                if (changedRegionId && changedRegionId == child.id) {
                    sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
                }
                if (pos == "leading") {
                    pos = child.isLeftToRight() ? "left" : "right";
                }
                if (pos == "trailing") {
                    pos = child.isLeftToRight() ? "right" : "left";
                }
                if (pos == "top" || pos == "bottom") {
                    sizeSetting.w = dim.w;
                    size(child, sizeSetting);
                    dim.h -= child.h;
                    if (pos == "top") {
                        dim.t += child.h;
                    } else {
                        elmStyle.top = dim.t + dim.h + "px";
                    }
                } else {
                    if (pos == "left" || pos == "right") {
                        sizeSetting.h = dim.h;
                        size(child, sizeSetting);
                        dim.w -= child.w;
                        if (pos == "left") {
                            dim.l += child.w;
                        } else {
                            elmStyle.left = dim.l + dim.w + "px";
                        }
                    } else {
                        if (pos == "client" || pos == "center") {
                            size(child, dim);
                        }
                    }
                }
            });
        }};
        lang.setObject("dijit.layout.utils", utils);
        return utils;
    });
}, "dijit/ProgressBar":function () {
    define(["require", "dojo/_base/declare", "dojo/dom-class", "dojo/_base/lang", "dojo/number", "./_Widget", "./_TemplatedMixin", "dojo/text!./templates/ProgressBar.html"], function (require, declare, domClass, lang, number, _Widget, _TemplatedMixin, template) {
        return declare("dijit.ProgressBar", [_Widget, _TemplatedMixin], {progress:"0", value:"", maximum:100, places:0, indeterminate:false, label:"", name:"", templateString:template, _indeterminateHighContrastImagePath:require.toUrl("./themes/a11y/indeterminate_progress.gif"), postMixInProperties:function () {
            this.inherited(arguments);
            if (!(this.params && "value" in this.params)) {
                this.value = this.indeterminate ? Infinity : this.progress;
            }
        }, buildRendering:function () {
            this.inherited(arguments);
            this.indeterminateHighContrastImage.setAttribute("src", this._indeterminateHighContrastImagePath.toString());
            this.update();
        }, _setDirAttr:function (val) {
            domClass.toggle(this.domNode, "dijitProgressBarRtl", val == "rtl");
            this.inherited(arguments);
        }, update:function (attributes) {
            lang.mixin(this, attributes || {});
            var tip = this.internalProgress, ap = this.domNode;
            var percent = 1;
            if (this.indeterminate) {
                ap.removeAttribute("aria-valuenow");
            } else {
                if (String(this.progress).indexOf("%") != -1) {
                    percent = Math.min(parseFloat(this.progress) / 100, 1);
                    this.progress = percent * this.maximum;
                } else {
                    this.progress = Math.min(this.progress, this.maximum);
                    percent = this.maximum ? this.progress / this.maximum : 0;
                }
                ap.setAttribute("aria-valuenow", this.progress);
            }
            ap.setAttribute("aria-labelledby", this.labelNode.id);
            ap.setAttribute("aria-valuemin", 0);
            ap.setAttribute("aria-valuemax", this.maximum);
            this.labelNode.innerHTML = this.report(percent);
            domClass.toggle(this.domNode, "dijitProgressBarIndeterminate", this.indeterminate);
            tip.style.width = (percent * 100) + "%";
            this.onChange();
        }, _setValueAttr:function (v) {
            this._set("value", v);
            if (v == Infinity) {
                this.update({indeterminate:true});
            } else {
                this.update({indeterminate:false, progress:v});
            }
        }, _setLabelAttr:function (label) {
            this._set("label", label);
            this.update();
        }, _setIndeterminateAttr:function (indeterminate) {
            this._set("indeterminate", indeterminate);
            this.update();
        }, report:function (percent) {
            return this.label ? this.label : (this.indeterminate ? "&#160;" : number.format(percent, {type:"percent", places:this.places, locale:this.lang}));
        }, onChange:function () {
        }});
    });
}, "dojo/has":function () {
    define(["require", "module"], function (require, module) {
        var has = require.has || function () {
        };
        if (!1) {
            var isBrowser = typeof window != "undefined" && typeof location != "undefined" && typeof document != "undefined" && window.location == location && window.document == document, global = this, doc = isBrowser && document, element = doc && doc.createElement("DiV"), cache = (module.config && module.config()) || {};
            has = function (name) {
                return typeof cache[name] == "function" ? (cache[name] = cache[name](global, doc, element)) : cache[name];
            };
            has.cache = cache;
            has.add = function (name, test, now, force) {
                (typeof cache[name] == "undefined" || force) && (cache[name] = test);
                return now && has(name);
            };
            1 || has.add("host-browser", isBrowser);
            0 && has.add("host-node", (typeof process == "object" && process.versions && process.versions.node && process.versions.v8));
            0 && has.add("host-rhino", (typeof load == "function" && (typeof Packages == "function" || typeof Packages == "object")));
            1 || has.add("dom", isBrowser);
            1 || has.add("dojo-dom-ready-api", 1);
            1 || has.add("dojo-sniff", 1);
        }
        if (1) {
            has.add("dom-addeventlistener", !!document.addEventListener);
            has.add("touch", "ontouchstart" in document || window.navigator.msMaxTouchPoints > 0);
            has.add("device-width", screen.availWidth || innerWidth);
            var form = document.createElement("form");
            has.add("dom-attributes-explicit", form.attributes.length == 0);
            has.add("dom-attributes-specified-flag", form.attributes.length > 0 && form.attributes.length < 40);
        }
        has.clearElement = function (element) {
            element.innerHTML = "";
            return element;
        };
        has.normalize = function (id, toAbsMid) {
            var tokens = id.match(/[\?:]|[^:\?]*/g), i = 0, get = function (skip) {
                var term = tokens[i++];
                if (term == ":") {
                    return 0;
                } else {
                    if (tokens[i++] == "?") {
                        if (!skip && has(term)) {
                            return get();
                        } else {
                            get(true);
                            return get(skip);
                        }
                    }
                    return term || 0;
                }
            };
            id = get();
            return id && toAbsMid(id);
        };
        has.load = function (id, parentRequire, loaded) {
            if (id) {
                parentRequire([id], loaded);
            } else {
                loaded();
            }
        };
        return has;
    });
}, "dojox/grid/EnhancedGrid":function () {
    define(["dojo/_base/kernel", "../main", "dojo/_base/declare", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/sniff", "dojo/dom", "dojo/dom-geometry", "./DataGrid", "./DataSelection", "./enhanced/_PluginManager", "./enhanced/plugins/_SelectionPreserver", "dojo/i18n!./enhanced/nls/EnhancedGrid"], function (dojo, dojox, declare, lang, array, has, dom, domGeometry, DataGrid, DataSelection, _PluginManager, _SelectionPreserver, nls) {
        dojo.experimental("dojox.grid.EnhancedGrid");
        var EnhancedGrid = declare("dojox.grid.EnhancedGrid", DataGrid, {plugins:null, pluginMgr:null, _pluginMgrClass:_PluginManager, postMixInProperties:function () {
            this._nls = nls;
            this.inherited(arguments);
        }, postCreate:function () {
            this.pluginMgr = new this._pluginMgrClass(this);
            this.pluginMgr.preInit();
            this.inherited(arguments);
            this.pluginMgr.postInit();
        }, plugin:function (name) {
            return this.pluginMgr.getPlugin(name);
        }, startup:function () {
            this.inherited(arguments);
            this.pluginMgr.startup();
        }, createSelection:function () {
            this.selection = new dojox.grid.enhanced.DataSelection(this);
        }, canSort:function (colIndex, field) {
            return true;
        }, doKeyEvent:function (e) {
            try {
                var view = this.focus.focusView;
                view.content.decorateEvent(e);
                if (!e.cell) {
                    view.header.decorateEvent(e);
                }
            }
            catch (e) {
            }
            this.inherited(arguments);
        }, doApplyCellEdit:function (inValue, inRowIndex, inAttrName) {
            if (!inAttrName) {
                this.invalidated[inRowIndex] = true;
                return;
            }
            this.inherited(arguments);
        }, mixin:function (target, source) {
            var props = {};
            for (var p in source) {
                if (p == "_inherited" || p == "declaredClass" || p == "constructor" || source["privates"] && source["privates"][p]) {
                    continue;
                }
                props[p] = source[p];
            }
            lang.mixin(target, props);
        }, _copyAttr:function (idx, attr) {
            if (!attr) {
                return;
            }
            return this.inherited(arguments);
        }, _getHeaderHeight:function () {
            this.inherited(arguments);
            return domGeometry.getMarginBox(this.viewsHeaderNode).h;
        }, _fetch:function (start, isRender) {
            if (this.items) {
                return this.inherited(arguments);
            }
            start = start || 0;
            if (this.store && !this._pending_requests[start]) {
                if (!this._isLoaded && !this._isLoading) {
                    this._isLoading = true;
                    this.showMessage(this.loadingMessage);
                }
                this._pending_requests[start] = true;
                try {
                    var req = {start:start, count:this.rowsPerPage, query:this.query, sort:this.getSortProps(), queryOptions:this.queryOptions, isRender:isRender, onBegin:lang.hitch(this, "_onFetchBegin"), onComplete:lang.hitch(this, "_onFetchComplete"), onError:lang.hitch(this, "_onFetchError")};
                    this._storeLayerFetch(req);
                }
                catch (e) {
                    this._onFetchError(e, {start:start, count:this.rowsPerPage});
                }
            }
            return 0;
        }, _storeLayerFetch:function (req) {
            this.store.fetch(req);
        }, getCellByField:function (field) {
            return array.filter(this.layout.cells, function (cell) {
                return cell.field == field;
            })[0];
        }, onMouseUp:function (e) {
        }, createView:function () {
            var view = this.inherited(arguments);
            if (has("mozilla")) {
                var ascendDom = function (inNode, inWhile) {
                    for (var n = inNode; n && inWhile(n); n = n.parentNode) {
                    }
                    return n;
                };
                var makeNotTagName = function (inTagName) {
                    var name = inTagName.toUpperCase();
                    return function (node) {
                        return node.tagName != name;
                    };
                };
                var func = view.header.getCellX;
                view.header.getCellX = function (e) {
                    var x = func.call(view.header, e);
                    var n = ascendDom(e.target, makeNotTagName("th"));
                    if (n && n !== e.target && dom.isDescendant(e.target, n)) {
                        x += n.firstChild.offsetLeft;
                    }
                    return x;
                };
            }
            return view;
        }, destroy:function () {
            delete this._nls;
            this.pluginMgr.destroy();
            this.inherited(arguments);
        }});
        declare("dojox.grid.enhanced.DataSelection", DataSelection, {constructor:function (grid) {
            if (grid.keepSelection) {
                if (this.preserver) {
                    this.preserver.destroy();
                }
                this.preserver = new _SelectionPreserver(this);
            }
        }, _range:function (inFrom, inTo) {
            this.grid._selectingRange = true;
            this.inherited(arguments);
            this.grid._selectingRange = false;
            this.onChanged();
        }, deselectAll:function (inItemOrIndex) {
            this.grid._selectingRange = true;
            this.inherited(arguments);
            this.grid._selectingRange = false;
            this.onChanged();
        }});
        EnhancedGrid.markupFactory = function (props, node, ctor, cellFunc) {
            return dojox.grid._Grid.markupFactory(props, node, ctor, lang.partial(DataGrid.cell_markupFactory, cellFunc));
        };
        EnhancedGrid.registerPlugin = function (clazz, props) {
            _PluginManager.registerPlugin(clazz, props);
        };
        return EnhancedGrid;
    });
}, "dijit/_FocusMixin":function () {
    define(["./focus", "./_WidgetBase", "dojo/_base/declare", "dojo/_base/lang"], function (focus, _WidgetBase, declare, lang) {
        lang.extend(_WidgetBase, {focused:false, onFocus:function () {
        }, onBlur:function () {
        }, _onFocus:function () {
            this.onFocus();
        }, _onBlur:function () {
            this.onBlur();
        }});
        return declare("dijit._FocusMixin", null, {_focusManager:focus});
    });
}, "dijit/form/ValidationTextBox":function () {
    define(["dojo/_base/declare", "dojo/_base/kernel", "dojo/i18n", "./TextBox", "../Tooltip", "dojo/text!./templates/ValidationTextBox.html", "dojo/i18n!./nls/validate"], function (declare, kernel, i18n, TextBox, Tooltip, template) {
        var ValidationTextBox;
        return ValidationTextBox = declare("dijit.form.ValidationTextBox", TextBox, {templateString:template, required:false, promptMessage:"", invalidMessage:"$_unset_$", missingMessage:"$_unset_$", message:"", constraints:{}, pattern:".*", regExp:"", regExpGen:function () {
        }, state:"", tooltipPosition:[], _deprecateRegExp:function (attr, value) {
            if (value != ValidationTextBox.prototype[attr]) {
                kernel.deprecated("ValidationTextBox id=" + this.id + ", set('" + attr + "', ...) is deprecated.  Use set('pattern', ...) instead.", "", "2.0");
                this.set("pattern", value);
            }
        }, _setRegExpGenAttr:function (newFcn) {
            this._deprecateRegExp("regExpGen", newFcn);
            this._set("regExpGen", this._computeRegexp);
        }, _setRegExpAttr:function (value) {
            this._deprecateRegExp("regExp", value);
        }, _setValueAttr:function () {
            this.inherited(arguments);
            this._refreshState();
        }, validator:function (value, constraints) {
            return (new RegExp("^(?:" + this._computeRegexp(constraints) + ")" + (this.required ? "" : "?") + "$")).test(value) && (!this.required || !this._isEmpty(value)) && (this._isEmpty(value) || this.parse(value, constraints) !== undefined);
        }, _isValidSubset:function () {
            return this.textbox.value.search(this._partialre) == 0;
        }, isValid:function () {
            return this.validator(this.textbox.value, this.get("constraints"));
        }, _isEmpty:function (value) {
            return (this.trim ? /^\s*$/ : /^$/).test(value);
        }, getErrorMessage:function () {
            var invalid = this.invalidMessage == "$_unset_$" ? this.messages.invalidMessage : !this.invalidMessage ? this.promptMessage : this.invalidMessage;
            var missing = this.missingMessage == "$_unset_$" ? this.messages.missingMessage : !this.missingMessage ? invalid : this.missingMessage;
            return (this.required && this._isEmpty(this.textbox.value)) ? missing : invalid;
        }, getPromptMessage:function () {
            return this.promptMessage;
        }, _maskValidSubsetError:true, validate:function (isFocused) {
            var message = "";
            var isValid = this.disabled || this.isValid(isFocused);
            if (isValid) {
                this._maskValidSubsetError = true;
            }
            var isEmpty = this._isEmpty(this.textbox.value);
            var isValidSubset = !isValid && isFocused && this._isValidSubset();
            this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && (this._maskValidSubsetError || (isValidSubset && !this._hasBeenBlurred && isFocused))) ? "Incomplete" : "Error"));
            this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");
            if (this.state == "Error") {
                this._maskValidSubsetError = isFocused && isValidSubset;
                message = this.getErrorMessage(isFocused);
            } else {
                if (this.state == "Incomplete") {
                    message = this.getPromptMessage(isFocused);
                    this._maskValidSubsetError = !this._hasBeenBlurred || isFocused;
                } else {
                    if (isEmpty) {
                        message = this.getPromptMessage(isFocused);
                    }
                }
            }
            this.set("message", message);
            return isValid;
        }, displayMessage:function (message) {
            if (message && this.focused) {
                Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
            } else {
                Tooltip.hide(this.domNode);
            }
        }, _refreshState:function () {
            if (this._created) {
                this.validate(this.focused);
            }
            this.inherited(arguments);
        }, constructor:function (params) {
            this.constraints = {};
            this.baseClass += " dijitValidationTextBox";
        }, startup:function () {
            this.inherited(arguments);
            this._refreshState();
        }, _setConstraintsAttr:function (constraints) {
            if (!constraints.locale && this.lang) {
                constraints.locale = this.lang;
            }
            this._set("constraints", constraints);
            this._refreshState();
        }, _setPatternAttr:function (pattern) {
            this._set("pattern", pattern);
            this._refreshState();
        }, _computeRegexp:function (constraints) {
            var p = this.pattern;
            if (typeof p == "function") {
                p = p.call(this, constraints);
            }
            if (p != this._lastRegExp) {
                var partialre = "";
                this._lastRegExp = p;
                if (p != ".*") {
                    p.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g, function (re) {
                        switch (re.charAt(0)) {
                          case "{":
                          case "+":
                          case "?":
                          case "*":
                          case "^":
                          case "$":
                          case "|":
                          case "(":
                            partialre += re;
                            break;
                          case ")":
                            partialre += "|$)";
                            break;
                          default:
                            partialre += "(?:" + re + "|$)";
                            break;
                        }
                    });
                }
                try {
                    "".search(partialre);
                }
                catch (e) {
                    partialre = this.pattern;
                    console.warn("RegExp error in " + this.declaredClass + ": " + this.pattern);
                }
                this._partialre = "^(?:" + partialre + ")$";
            }
            return p;
        }, postMixInProperties:function () {
            this.inherited(arguments);
            this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
            this._setConstraintsAttr(this.constraints);
        }, _setDisabledAttr:function (value) {
            this.inherited(arguments);
            this._refreshState();
        }, _setRequiredAttr:function (value) {
            this._set("required", value);
            this.focusNode.setAttribute("aria-required", value);
            this._refreshState();
        }, _setMessageAttr:function (message) {
            this._set("message", message);
            this.displayMessage(message);
        }, reset:function () {
            this._maskValidSubsetError = true;
            this.inherited(arguments);
        }, _onBlur:function () {
            this.displayMessage("");
            this.inherited(arguments);
        }});
    });
}, "dojo/errors/CancelError":function () {
    define(["./create"], function (create) {
        return create("CancelError", null, null, {dojoType:"cancel"});
    });
}, "dijit/form/NumberTextBox":function () {
    define(["dojo/_base/declare", "dojo/_base/lang", "dojo/number", "./RangeBoundTextBox"], function (declare, lang, number, RangeBoundTextBox) {
        var NumberTextBoxMixin = declare("dijit.form.NumberTextBoxMixin", null, {pattern:function (constraints) {
            return "(" + (this.focused && this.editOptions ? this._regExpGenerator(lang.delegate(constraints, this.editOptions)) + "|" : "") + this._regExpGenerator(constraints) + ")";
        }, value:NaN, editOptions:{pattern:"#.######"}, _formatter:number.format, _regExpGenerator:number.regexp, postMixInProperties:function () {
            this.inherited(arguments);
            this._set("type", "text");
        }, _setConstraintsAttr:function (constraints) {
            var places = typeof constraints.places == "number" ? constraints.places : 0;
            if (places) {
                places++;
            }
            if (typeof constraints.max != "number") {
                constraints.max = 9 * Math.pow(10, 15 - places);
            }
            if (typeof constraints.min != "number") {
                constraints.min = -9 * Math.pow(10, 15 - places);
            }
            this.inherited(arguments, [constraints]);
            if (this.focusNode && this.focusNode.value && !isNaN(this.value)) {
                this.set("value", this.value);
            }
        }, _onFocus:function () {
            if (this.disabled || this.readOnly) {
                return;
            }
            var val = this.get("value");
            if (typeof val == "number" && !isNaN(val)) {
                var formattedValue = this.format(val, this.constraints);
                if (formattedValue !== undefined) {
                    this.textbox.value = formattedValue;
                }
            }
            this.inherited(arguments);
        }, format:function (value, constraints) {
            var formattedValue = String(value);
            if (typeof value != "number") {
                return formattedValue;
            }
            if (isNaN(value)) {
                return "";
            }
            if (!("rangeCheck" in this && this.rangeCheck(value, constraints)) && constraints.exponent !== false && /\de[-+]?\d/i.test(formattedValue)) {
                return formattedValue;
            }
            if (this.editOptions && this.focused) {
                constraints = lang.mixin({}, constraints, this.editOptions);
            }
            return this._formatter(value, constraints);
        }, _parser:number.parse, parse:function (value, constraints) {
            var v = this._parser(value, lang.mixin({}, constraints, (this.editOptions && this.focused) ? this.editOptions : {}));
            if (this.editOptions && this.focused && isNaN(v)) {
                v = this._parser(value, constraints);
            }
            return v;
        }, _getDisplayedValueAttr:function () {
            var v = this.inherited(arguments);
            return isNaN(v) ? this.textbox.value : v;
        }, filter:function (value) {
            return (value == null || value === "") ? NaN : this.inherited(arguments);
        }, serialize:function (value, options) {
            return (typeof value != "number" || isNaN(value)) ? "" : this.inherited(arguments);
        }, _setBlurValue:function () {
            var val = lang.hitch(lang.delegate(this, {focused:true}), "get")("value");
            this._setValueAttr(val, true);
        }, _setValueAttr:function (value, priorityChange, formattedValue) {
            if (value !== undefined && formattedValue === undefined) {
                formattedValue = String(value);
                if (typeof value == "number") {
                    if (isNaN(value)) {
                        formattedValue = "";
                    } else {
                        if (("rangeCheck" in this && this.rangeCheck(value, this.constraints)) || this.constraints.exponent === false || !/\de[-+]?\d/i.test(formattedValue)) {
                            formattedValue = undefined;
                        }
                    }
                } else {
                    if (!value) {
                        formattedValue = "";
                        value = NaN;
                    } else {
                        value = undefined;
                    }
                }
            }
            this.inherited(arguments, [value, priorityChange, formattedValue]);
        }, _getValueAttr:function () {
            var v = this.inherited(arguments);
            if (isNaN(v) && this.textbox.value !== "") {
                if (this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value) && (new RegExp("^" + number._realNumberRegexp(lang.delegate(this.constraints)) + "$").test(this.textbox.value))) {
                    var n = Number(this.textbox.value);
                    return isNaN(n) ? undefined : n;
                } else {
                    return undefined;
                }
            } else {
                return v;
            }
        }, isValid:function (isFocused) {
            if (!this.focused || this._isEmpty(this.textbox.value)) {
                return this.inherited(arguments);
            } else {
                var v = this.get("value");
                if (!isNaN(v) && this.rangeCheck(v, this.constraints)) {
                    if (this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)) {
                        return true;
                    } else {
                        return this.inherited(arguments);
                    }
                } else {
                    return false;
                }
            }
        }});
        var NumberTextBox = declare("dijit.form.NumberTextBox", [RangeBoundTextBox, NumberTextBoxMixin], {baseClass:"dijitTextBox dijitNumberTextBox"});
        NumberTextBox.Mixin = NumberTextBoxMixin;
        return NumberTextBox;
    });
}, "dojo/_base/url":function () {
    define(["./kernel"], function (dojo) {
        var ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"), ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"), _Url = function () {
            var n = null, _a = arguments, uri = [_a[0]];
            for (var i = 1; i < _a.length; i++) {
                if (!_a[i]) {
                    continue;
                }
                var relobj = new _Url(_a[i] + ""), uriobj = new _Url(uri[0] + "");
                if (relobj.path == "" && !relobj.scheme && !relobj.authority && !relobj.query) {
                    if (relobj.fragment != n) {
                        uriobj.fragment = relobj.fragment;
                    }
                    relobj = uriobj;
                } else {
                    if (!relobj.scheme) {
                        relobj.scheme = uriobj.scheme;
                        if (!relobj.authority) {
                            relobj.authority = uriobj.authority;
                            if (relobj.path.charAt(0) != "/") {
                                var path = uriobj.path.substring(0, uriobj.path.lastIndexOf("/") + 1) + relobj.path;
                                var segs = path.split("/");
                                for (var j = 0; j < segs.length; j++) {
                                    if (segs[j] == ".") {
                                        if (j == segs.length - 1) {
                                            segs[j] = "";
                                        } else {
                                            segs.splice(j, 1);
                                            j--;
                                        }
                                    } else {
                                        if (j > 0 && !(j == 1 && segs[0] == "") && segs[j] == ".." && segs[j - 1] != "..") {
                                            if (j == (segs.length - 1)) {
                                                segs.splice(j, 1);
                                                segs[j - 1] = "";
                                            } else {
                                                segs.splice(j - 1, 2);
                                                j -= 2;
                                            }
                                        }
                                    }
                                }
                                relobj.path = segs.join("/");
                            }
                        }
                    }
                }
                uri = [];
                if (relobj.scheme) {
                    uri.push(relobj.scheme, ":");
                }
                if (relobj.authority) {
                    uri.push("//", relobj.authority);
                }
                uri.push(relobj.path);
                if (relobj.query) {
                    uri.push("?", relobj.query);
                }
                if (relobj.fragment) {
                    uri.push("#", relobj.fragment);
                }
            }
            this.uri = uri.join("");
            var r = this.uri.match(ore);
            this.scheme = r[2] || (r[1] ? "" : n);
            this.authority = r[4] || (r[3] ? "" : n);
            this.path = r[5];
            this.query = r[7] || (r[6] ? "" : n);
            this.fragment = r[9] || (r[8] ? "" : n);
            if (this.authority != n) {
                r = this.authority.match(ire);
                this.user = r[3] || n;
                this.password = r[4] || n;
                this.host = r[6] || r[7];
                this.port = r[9] || n;
            }
        };
        _Url.prototype.toString = function () {
            return this.uri;
        };
        return dojo._Url = _Url;
    });
}, "dijit/form/_ComboBoxMenuMixin":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/dom-attr", "dojo/has", "dojo/i18n", "dojo/i18n!./nls/ComboBox"], function (array, declare, domAttr, has, i18n) {
        var ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {_messages:null, postMixInProperties:function () {
            this.inherited(arguments);
            this._messages = i18n.getLocalization("dijit.form", "ComboBox", this.lang);
        }, buildRendering:function () {
            this.inherited(arguments);
            this.previousButton.innerHTML = this._messages["previousMessage"];
            this.nextButton.innerHTML = this._messages["nextMessage"];
        }, _setValueAttr:function (value) {
            this._set("value", value);
            this.onChange(value);
        }, onClick:function (node) {
            if (node == this.previousButton) {
                this._setSelectedAttr(null);
                this.onPage(-1);
            } else {
                if (node == this.nextButton) {
                    this._setSelectedAttr(null);
                    this.onPage(1);
                } else {
                    this.onChange(node);
                }
            }
        }, onChange:function () {
        }, onPage:function () {
        }, onClose:function () {
            this._setSelectedAttr(null);
        }, _createOption:function (item, labelFunc) {
            var menuitem = this._createMenuItem();
            var labelObject = labelFunc(item);
            if (labelObject.html) {
                menuitem.innerHTML = labelObject.label;
            } else {
                menuitem.appendChild(menuitem.ownerDocument.createTextNode(labelObject.label));
            }
            if (menuitem.innerHTML == "") {
                menuitem.innerHTML = "&#160;";
            }
            return menuitem;
        }, createOptions:function (results, options, labelFunc) {
            this.items = results;
            this.previousButton.style.display = (options.start == 0) ? "none" : "";
            domAttr.set(this.previousButton, "id", this.id + "_prev");
            array.forEach(results, function (item, i) {
                var menuitem = this._createOption(item, labelFunc);
                menuitem.setAttribute("item", i);
                domAttr.set(menuitem, "id", this.id + i);
                this.nextButton.parentNode.insertBefore(menuitem, this.nextButton);
            }, this);
            var displayMore = false;
            if (results.total && !results.total.then && results.total != -1) {
                if ((options.start + options.count) < results.total) {
                    displayMore = true;
                } else {
                    if ((options.start + options.count) > results.total && options.count == results.length) {
                        displayMore = true;
                    }
                }
            } else {
                if (options.count == results.length) {
                    displayMore = true;
                }
            }
            this.nextButton.style.display = displayMore ? "" : "none";
            domAttr.set(this.nextButton, "id", this.id + "_next");
        }, clearResultList:function () {
            var container = this.containerNode;
            while (container.childNodes.length > 2) {
                container.removeChild(container.childNodes[container.childNodes.length - 2]);
            }
            this._setSelectedAttr(null);
        }, highlightFirstOption:function () {
            this.selectFirstNode();
        }, highlightLastOption:function () {
            this.selectLastNode();
        }, selectFirstNode:function () {
            this.inherited(arguments);
            if (this.getHighlightedOption() == this.previousButton) {
                this.selectNextNode();
            }
        }, selectLastNode:function () {
            this.inherited(arguments);
            if (this.getHighlightedOption() == this.nextButton) {
                this.selectPreviousNode();
            }
        }, getHighlightedOption:function () {
            return this.selected;
        }});
        if (has("dojo-bidi")) {
            ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin", ComboBoxMenuMixin, {_createOption:function () {
                var menuitem = this.inherited(arguments);
                this.applyTextDir(menuitem);
                return menuitem;
            }});
        }
        return ComboBoxMenuMixin;
    });
}, "dojox/collections/_base":function () {
    define(["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/array"], function (dojo, lang, arr) {
        var collections = lang.getObject("dojox.collections", true);
        collections.DictionaryEntry = function (k, v) {
            this.key = k;
            this.value = v;
            this.valueOf = function () {
                return this.value;
            };
            this.toString = function () {
                return String(this.value);
            };
        };
        collections.Iterator = function (a) {
            var position = 0;
            this.element = a[position] || null;
            this.atEnd = function () {
                return (position >= a.length);
            };
            this.get = function () {
                if (this.atEnd()) {
                    return null;
                }
                this.element = a[position++];
                return this.element;
            };
            this.map = function (fn, scope) {
                return arr.map(a, fn, scope);
            };
            this.reset = function () {
                position = 0;
                this.element = a[position];
            };
        };
        collections.DictionaryIterator = function (obj) {
            var a = [];
            var testObject = {};
            for (var p in obj) {
                if (!testObject[p]) {
                    a.push(obj[p]);
                }
            }
            var position = 0;
            this.element = a[position] || null;
            this.atEnd = function () {
                return (position >= a.length);
            };
            this.get = function () {
                if (this.atEnd()) {
                    return null;
                }
                this.element = a[position++];
                return this.element;
            };
            this.map = function (fn, scope) {
                return arr.map(a, fn, scope);
            };
            this.reset = function () {
                position = 0;
                this.element = a[position];
            };
        };
        return collections;
    });
}, "dijit/Tree":function () {
    define(["dojo/_base/array", "dojo/aspect", "dojo/_base/connect", "dojo/cookie", "dojo/_base/declare", "dojo/Deferred", "dojo/promise/all", "dojo/dom", "dojo/dom-class", "dojo/dom-geometry", "dojo/dom-style", "dojo/errors/create", "dojo/fx", "dojo/has", "dojo/_base/kernel", "dojo/keys", "dojo/_base/lang", "dojo/on", "dojo/topic", "dojo/touch", "dojo/when", "./a11yclick", "./focus", "./registry", "./_base/manager", "./_Widget", "./_TemplatedMixin", "./_Container", "./_Contained", "./_CssStateMixin", "./_KeyNavMixin", "dojo/text!./templates/TreeNode.html", "dojo/text!./templates/Tree.html", "./tree/TreeStoreModel", "./tree/ForestStoreModel", "./tree/_dndSelector", "dojo/query!css2"], function (array, aspect, connect, cookie, declare, Deferred, all, dom, domClass, domGeometry, domStyle, createError, fxUtils, has, kernel, keys, lang, on, topic, touch, when, a11yclick, focus, registry, manager, _Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin, _KeyNavMixin, treeNodeTemplate, treeTemplate, TreeStoreModel, ForestStoreModel, _dndSelector) {
        function shimmedPromise(d) {
            return lang.delegate(d.promise || d, {addCallback:function (callback) {
                this.then(callback);
            }, addErrback:function (errback) {
                this.otherwise(errback);
            }});
        }
        var TreeNode = declare("dijit._TreeNode", [_Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin], {item:null, isTreeNode:true, label:"", _setLabelAttr:function (val) {
            this.labelNode[this.labelType == "html" ? "innerHTML" : "innerText" in this.labelNode ? "innerText" : "textContent"] = val;
            this._set("label", val);
        }, labelType:"text", isExpandable:null, isExpanded:false, state:"NotLoaded", templateString:treeNodeTemplate, baseClass:"dijitTreeNode", cssStateNodes:{rowNode:"dijitTreeRow"}, _setTooltipAttr:{node:"rowNode", type:"attribute", attribute:"title"}, buildRendering:function () {
            this.inherited(arguments);
            this._setExpando();
            this._updateItemClasses(this.item);
            if (this.isExpandable) {
                this.labelNode.setAttribute("aria-expanded", this.isExpanded);
            }
            this.setSelected(false);
        }, _setIndentAttr:function (indent) {
            var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";
            domStyle.set(this.domNode, "backgroundPosition", pixels + " 0px");
            domStyle.set(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);
            array.forEach(this.getChildren(), function (child) {
                child.set("indent", indent + 1);
            });
            this._set("indent", indent);
        }, markProcessing:function () {
            this.state = "Loading";
            this._setExpando(true);
        }, unmarkProcessing:function () {
            this._setExpando(false);
        }, _updateItemClasses:function (item) {
            var tree = this.tree, model = tree.model;
            if (tree._v10Compat && item === model.root) {
                item = null;
            }
            this._applyClassAndStyle(item, "icon", "Icon");
            this._applyClassAndStyle(item, "label", "Label");
            this._applyClassAndStyle(item, "row", "Row");
            this.tree._startPaint(true);
        }, _applyClassAndStyle:function (item, lower, upper) {
            var clsName = "_" + lower + "Class";
            var nodeName = lower + "Node";
            var oldCls = this[clsName];
            this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
            domClass.replace(this[nodeName], this[clsName] || "", oldCls || "");
            domStyle.set(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
        }, _updateLayout:function () {
            var parent = this.getParent();
            if (!parent || !parent.rowNode || parent.rowNode.style.display == "none") {
                domClass.add(this.domNode, "dijitTreeIsRoot");
            } else {
                domClass.toggle(this.domNode, "dijitTreeIsLast", !this.getNextSibling());
            }
        }, _setExpando:function (processing) {
            var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened", "dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"], _a11yStates = ["*", "-", "+", "*"], idx = processing ? 0 : (this.isExpandable ? (this.isExpanded ? 1 : 2) : 3);
            domClass.replace(this.expandoNode, styles[idx], styles);
            this.expandoNodeText.innerHTML = _a11yStates[idx];
        }, expand:function () {
            if (this._expandDeferred) {
                return shimmedPromise(this._expandDeferred);
            }
            if (this._collapseDeferred) {
                this._collapseDeferred.cancel();
                delete this._collapseDeferred;
            }
            this.isExpanded = true;
            this.labelNode.setAttribute("aria-expanded", "true");
            if (this.tree.showRoot || this !== this.tree.rootNode) {
                this.containerNode.setAttribute("role", "group");
            }
            domClass.add(this.contentNode, "dijitTreeContentExpanded");
            this._setExpando();
            this._updateItemClasses(this.item);
            if (this == this.tree.rootNode && this.tree.showRoot) {
                this.tree.domNode.setAttribute("aria-expanded", "true");
            }
            var wipeIn = fxUtils.wipeIn({node:this.containerNode, duration:manager.defaultDuration});
            var def = (this._expandDeferred = new Deferred(function () {
                wipeIn.stop();
            }));
            aspect.after(wipeIn, "onEnd", function () {
                def.resolve(true);
            }, true);
            wipeIn.play();
            return shimmedPromise(def);
        }, collapse:function () {
            if (this._collapseDeferred) {
                return shimmedPromise(this._collapseDeferred);
            }
            if (this._expandDeferred) {
                this._expandDeferred.cancel();
                delete this._expandDeferred;
            }
            this.isExpanded = false;
            this.labelNode.setAttribute("aria-expanded", "false");
            if (this == this.tree.rootNode && this.tree.showRoot) {
                this.tree.domNode.setAttribute("aria-expanded", "false");
            }
            domClass.remove(this.contentNode, "dijitTreeContentExpanded");
            this._setExpando();
            this._updateItemClasses(this.item);
            var wipeOut = fxUtils.wipeOut({node:this.containerNode, duration:manager.defaultDuration});
            var def = (this._collapseDeferred = new Deferred(function () {
                wipeOut.stop();
            }));
            aspect.after(wipeOut, "onEnd", function () {
                def.resolve(true);
            }, true);
            wipeOut.play();
            return shimmedPromise(def);
        }, indent:0, setChildItems:function (items) {
            var tree = this.tree, model = tree.model, defs = [];
            var oldChildren = this.getChildren();
            array.forEach(oldChildren, function (child) {
                _Container.prototype.removeChild.call(this, child);
            }, this);
            this.defer(function () {
                array.forEach(oldChildren, function (node) {
                    if (!node._destroyed && !node.getParent()) {
                        tree.dndController.removeTreeNode(node);
                        function remove(node) {
                            var id = model.getIdentity(node.item), ary = tree._itemNodesMap[id];
                            if (ary.length == 1) {
                                delete tree._itemNodesMap[id];
                            } else {
                                var index = array.indexOf(ary, node);
                                if (index != -1) {
                                    ary.splice(index, 1);
                                }
                            }
                            array.forEach(node.getChildren(), remove);
                        }
                        remove(node);
                        if (tree.persist) {
                            var destroyedPath = array.map(node.getTreePath(), function (item) {
                                return tree.model.getIdentity(item);
                            }).join("/");
                            for (var path in tree._openedNodes) {
                                if (path.substr(0, destroyedPath.length) == destroyedPath) {
                                    delete tree._openedNodes[path];
                                }
                            }
                            tree._saveExpandedNodes();
                        }
                        node.destroyRecursive();
                    }
                });
            });
            this.state = "Loaded";
            if (items && items.length > 0) {
                this.isExpandable = true;
                array.forEach(items, function (item) {
                    var id = model.getIdentity(item), existingNodes = tree._itemNodesMap[id], node;
                    if (existingNodes) {
                        for (var i = 0; i < existingNodes.length; i++) {
                            if (existingNodes[i] && !existingNodes[i].getParent()) {
                                node = existingNodes[i];
                                node.set("indent", this.indent + 1);
                                break;
                            }
                        }
                    }
                    if (!node) {
                        node = this.tree._createTreeNode({item:item, tree:tree, isExpandable:model.mayHaveChildren(item), label:tree.getLabel(item), labelType:(tree.model && tree.model.labelType) || "text", tooltip:tree.getTooltip(item), ownerDocument:tree.ownerDocument, dir:tree.dir, lang:tree.lang, textDir:tree.textDir, indent:this.indent + 1});
                        if (existingNodes) {
                            existingNodes.push(node);
                        } else {
                            tree._itemNodesMap[id] = [node];
                        }
                    }
                    this.addChild(node);
                    if (this.tree.autoExpand || this.tree._state(node)) {
                        defs.push(tree._expandNode(node));
                    }
                }, this);
                array.forEach(this.getChildren(), function (child) {
                    child._updateLayout();
                });
            } else {
                this.isExpandable = false;
            }
            if (this._setExpando) {
                this._setExpando(false);
            }
            this._updateItemClasses(this.item);
            var def = all(defs);
            this.tree._startPaint(def);
            return shimmedPromise(def);
        }, getTreePath:function () {
            var node = this;
            var path = [];
            while (node && node !== this.tree.rootNode) {
                path.unshift(node.item);
                node = node.getParent();
            }
            path.unshift(this.tree.rootNode.item);
            return path;
        }, getIdentity:function () {
            return this.tree.model.getIdentity(this.item);
        }, removeChild:function (node) {
            this.inherited(arguments);
            var children = this.getChildren();
            if (children.length == 0) {
                this.isExpandable = false;
                this.collapse();
            }
            array.forEach(children, function (child) {
                child._updateLayout();
            });
        }, makeExpandable:function () {
            this.isExpandable = true;
            this._setExpando(false);
        }, setSelected:function (selected) {
            this.labelNode.setAttribute("aria-selected", selected ? "true" : "false");
            domClass.toggle(this.rowNode, "dijitTreeRowSelected", selected);
        }, focus:function () {
            focus.focus(this.focusNode);
        }});
        if (has("dojo-bidi")) {
            TreeNode.extend({_setTextDirAttr:function (textDir) {
                if (textDir && ((this.textDir != textDir) || !this._created)) {
                    this._set("textDir", textDir);
                    this.applyTextDir(this.labelNode);
                    array.forEach(this.getChildren(), function (childNode) {
                        childNode.set("textDir", textDir);
                    }, this);
                }
            }});
        }
        var Tree = declare("dijit.Tree", [_Widget, _KeyNavMixin, _TemplatedMixin, _CssStateMixin], {baseClass:"dijitTree", store:null, model:null, query:null, label:"", showRoot:true, childrenAttr:["children"], paths:[], path:[], selectedItems:null, selectedItem:null, openOnClick:false, openOnDblClick:false, templateString:treeTemplate, persist:false, autoExpand:false, dndController:_dndSelector, dndParams:["onDndDrop", "itemCreator", "onDndCancel", "checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"], onDndDrop:null, itemCreator:null, onDndCancel:null, checkAcceptance:null, checkItemAcceptance:null, dragThreshold:5, betweenThreshold:0, _nodePixelIndent:19, _publish:function (topicName, message) {
            topic.publish(this.id, lang.mixin({tree:this, event:topicName}, message || {}));
        }, postMixInProperties:function () {
            this.tree = this;
            if (this.autoExpand) {
                this.persist = false;
            }
            this._itemNodesMap = {};
            if (!this.cookieName && this.id) {
                this.cookieName = this.id + "SaveStateCookie";
            }
            this.expandChildrenDeferred = new Deferred();
            this.pendingCommandsPromise = this.expandChildrenDeferred.promise;
            this.inherited(arguments);
        }, postCreate:function () {
            this._initState();
            var self = this;
            this.own(on(this.containerNode, on.selector(".dijitTreeNode", touch.enter), function (evt) {
                self._onNodeMouseEnter(registry.byNode(this), evt);
            }), on(this.containerNode, on.selector(".dijitTreeNode", touch.leave), function (evt) {
                self._onNodeMouseLeave(registry.byNode(this), evt);
            }), on(this.containerNode, on.selector(".dijitTreeRow", a11yclick.press), function (evt) {
                self._onNodePress(registry.getEnclosingWidget(this), evt);
            }), on(this.containerNode, on.selector(".dijitTreeRow", a11yclick), function (evt) {
                self._onClick(registry.getEnclosingWidget(this), evt);
            }), on(this.containerNode, on.selector(".dijitTreeRow", "dblclick"), function (evt) {
                self._onDblClick(registry.getEnclosingWidget(this), evt);
            }));
            if (!this.model) {
                this._store2model();
            }
            this.own(aspect.after(this.model, "onChange", lang.hitch(this, "_onItemChange"), true), aspect.after(this.model, "onChildrenChange", lang.hitch(this, "_onItemChildrenChange"), true), aspect.after(this.model, "onDelete", lang.hitch(this, "_onItemDelete"), true));
            this.inherited(arguments);
            if (this.dndController) {
                if (lang.isString(this.dndController)) {
                    this.dndController = lang.getObject(this.dndController);
                }
                var params = {};
                for (var i = 0; i < this.dndParams.length; i++) {
                    if (this[this.dndParams[i]]) {
                        params[this.dndParams[i]] = this[this.dndParams[i]];
                    }
                }
                this.dndController = new this.dndController(this, params);
            }
            this._load();
            this.onLoadDeferred = shimmedPromise(this.pendingCommandsPromise);
            this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
        }, _store2model:function () {
            this._v10Compat = true;
            kernel.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");
            var modelParams = {id:this.id + "_ForestStoreModel", store:this.store, query:this.query, childrenAttrs:this.childrenAttr};
            if (this.params.mayHaveChildren) {
                modelParams.mayHaveChildren = lang.hitch(this, "mayHaveChildren");
            }
            if (this.params.getItemChildren) {
                modelParams.getChildren = lang.hitch(this, function (item, onComplete, onError) {
                    this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
                });
            }
            this.model = new ForestStoreModel(modelParams);
            this.showRoot = Boolean(this.label);
        }, onLoad:function () {
        }, _load:function () {
            this.model.getRoot(lang.hitch(this, function (item) {
                var rn = (this.rootNode = this.tree._createTreeNode({item:item, tree:this, isExpandable:true, label:this.label || this.getLabel(item), labelType:this.model.labelType || "text", textDir:this.textDir, indent:this.showRoot ? 0 : -1}));
                if (!this.showRoot) {
                    rn.rowNode.style.display = "none";
                    this.domNode.setAttribute("role", "presentation");
                    this.domNode.removeAttribute("aria-expanded");
                    this.domNode.removeAttribute("aria-multiselectable");
                    if (this["aria-label"]) {
                        rn.containerNode.setAttribute("aria-label", this["aria-label"]);
                        this.domNode.removeAttribute("aria-label");
                    } else {
                        if (this["aria-labelledby"]) {
                            rn.containerNode.setAttribute("aria-labelledby", this["aria-labelledby"]);
                            this.domNode.removeAttribute("aria-labelledby");
                        }
                    }
                    rn.labelNode.setAttribute("role", "presentation");
                    rn.containerNode.setAttribute("role", "tree");
                    rn.containerNode.setAttribute("aria-expanded", "true");
                    rn.containerNode.setAttribute("aria-multiselectable", !this.dndController.singular);
                } else {
                    this.domNode.setAttribute("aria-multiselectable", !this.dndController.singular);
                    this.rootLoadingIndicator.style.display = "none";
                }
                this.containerNode.appendChild(rn.domNode);
                var identity = this.model.getIdentity(item);
                if (this._itemNodesMap[identity]) {
                    this._itemNodesMap[identity].push(rn);
                } else {
                    this._itemNodesMap[identity] = [rn];
                }
                rn._updateLayout();
                this._expandNode(rn).then(lang.hitch(this, function () {
                    this.rootLoadingIndicator.style.display = "none";
                    this.expandChildrenDeferred.resolve(true);
                }));
            }), lang.hitch(this, function (err) {
                console.error(this, ": error loading root: ", err);
            }));
        }, getNodesByItem:function (item) {
            if (!item) {
                return [];
            }
            var identity = lang.isString(item) ? item : this.model.getIdentity(item);
            return [].concat(this._itemNodesMap[identity]);
        }, _setSelectedItemAttr:function (item) {
            this.set("selectedItems", [item]);
        }, _setSelectedItemsAttr:function (items) {
            var tree = this;
            return this.pendingCommandsPromise = this.pendingCommandsPromise.always(lang.hitch(this, function () {
                var identities = array.map(items, function (item) {
                    return (!item || lang.isString(item)) ? item : tree.model.getIdentity(item);
                });
                var nodes = [];
                array.forEach(identities, function (id) {
                    nodes = nodes.concat(tree._itemNodesMap[id] || []);
                });
                this.set("selectedNodes", nodes);
            }));
        }, _setPathAttr:function (path) {
            if (path.length) {
                return shimmedPromise(this.set("paths", [path]).then(function (paths) {
                    return paths[0];
                }));
            } else {
                return shimmedPromise(this.set("paths", []).then(function (paths) {
                    return paths[0];
                }));
            }
        }, _setPathsAttr:function (paths) {
            var tree = this;
            function selectPath(path, nodes) {
                var nextPath = path.shift();
                var nextNode = array.filter(nodes, function (node) {
                    return node.getIdentity() == nextPath;
                })[0];
                if (!!nextNode) {
                    if (path.length) {
                        return tree._expandNode(nextNode).then(function () {
                            return selectPath(path, nextNode.getChildren());
                        });
                    } else {
                        return nextNode;
                    }
                } else {
                    throw new Tree.PathError("Could not expand path at " + nextPath);
                }
            }
            return shimmedPromise(this.pendingCommandsPromise = this.pendingCommandsPromise.always(function () {
                return all(array.map(paths, function (path) {
                    path = array.map(path, function (item) {
                        return lang.isString(item) ? item : tree.model.getIdentity(item);
                    });
                    if (path.length) {
                        return selectPath(path, [tree.rootNode]);
                    } else {
                        throw new Tree.PathError("Empty path");
                    }
                }));
            }).then(function setNodes(newNodes) {
                tree.set("selectedNodes", newNodes);
                return tree.paths;
            }));
        }, _setSelectedNodeAttr:function (node) {
            this.set("selectedNodes", [node]);
        }, _setSelectedNodesAttr:function (nodes) {
            this.dndController.setSelection(nodes);
        }, expandAll:function () {
            var _this = this;
            function expand(node) {
                return _this._expandNode(node).then(function () {
                    var childBranches = array.filter(node.getChildren() || [], function (node) {
                        return node.isExpandable;
                    });
                    return all(array.map(childBranches, expand));
                });
            }
            return shimmedPromise(expand(this.rootNode));
        }, collapseAll:function () {
            var _this = this;
            function collapse(node) {
                var childBranches = array.filter(node.getChildren() || [], function (node) {
                    return node.isExpandable;
                }), defs = all(array.map(childBranches, collapse));
                if (!node.isExpanded || (node == _this.rootNode && !_this.showRoot)) {
                    return defs;
                } else {
                    return defs.then(function () {
                        return _this._collapseNode(node);
                    });
                }
            }
            return shimmedPromise(collapse(this.rootNode));
        }, mayHaveChildren:function () {
        }, getItemChildren:function () {
        }, getLabel:function (item) {
            return this.model.getLabel(item);
        }, getIconClass:function (item, opened) {
            return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf";
        }, getLabelClass:function () {
        }, getRowClass:function () {
        }, getIconStyle:function () {
        }, getLabelStyle:function () {
        }, getRowStyle:function () {
        }, getTooltip:function () {
            return "";
        }, _onDownArrow:function (evt, node) {
            var nextNode = this._getNext(node);
            if (nextNode && nextNode.isTreeNode) {
                this.focusNode(nextNode);
            }
        }, _onUpArrow:function (evt, node) {
            var previousSibling = node.getPreviousSibling();
            if (previousSibling) {
                node = previousSibling;
                while (node.isExpandable && node.isExpanded && node.hasChildren()) {
                    var children = node.getChildren();
                    node = children[children.length - 1];
                }
            } else {
                var parent = node.getParent();
                if (!(!this.showRoot && parent === this.rootNode)) {
                    node = parent;
                }
            }
            if (node && node.isTreeNode) {
                this.focusNode(node);
            }
        }, _onRightArrow:function (evt, node) {
            if (node.isExpandable && !node.isExpanded) {
                this._expandNode(node);
            } else {
                if (node.hasChildren()) {
                    node = node.getChildren()[0];
                    if (node && node.isTreeNode) {
                        this.focusNode(node);
                    }
                }
            }
        }, _onLeftArrow:function (evt, node) {
            if (node.isExpandable && node.isExpanded) {
                this._collapseNode(node);
            } else {
                var parent = node.getParent();
                if (parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)) {
                    this.focusNode(parent);
                }
            }
        }, focusLastChild:function () {
            var node = this._getLast();
            if (node && node.isTreeNode) {
                this.focusNode(node);
            }
        }, _getFirst:function () {
            return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
        }, _getLast:function () {
            var node = this.rootNode;
            while (node.isExpanded) {
                var c = node.getChildren();
                if (!c.length) {
                    break;
                }
                node = c[c.length - 1];
            }
            return node;
        }, _getNext:function (node) {
            if (node.isExpandable && node.isExpanded && node.hasChildren()) {
                return node.getChildren()[0];
            } else {
                while (node && node.isTreeNode) {
                    var returnNode = node.getNextSibling();
                    if (returnNode) {
                        return returnNode;
                    }
                    node = node.getParent();
                }
                return null;
            }
        }, childSelector:".dijitTreeRow", isExpandoNode:function (node, widget) {
            return dom.isDescendant(node, widget.expandoNode) || dom.isDescendant(node, widget.expandoNodeText);
        }, _onNodePress:function (nodeWidget, e) {
            this.focusNode(nodeWidget);
        }, __click:function (nodeWidget, e, doOpen, func) {
            var domElement = e.target, isExpandoClick = this.isExpandoNode(domElement, nodeWidget);
            if (nodeWidget.isExpandable && (doOpen || isExpandoClick)) {
                this._onExpandoClick({node:nodeWidget});
            } else {
                this._publish("execute", {item:nodeWidget.item, node:nodeWidget, evt:e});
                this[func](nodeWidget.item, nodeWidget, e);
                this.focusNode(nodeWidget);
            }
            e.stopPropagation();
            e.preventDefault();
        }, _onClick:function (nodeWidget, e) {
            this.__click(nodeWidget, e, this.openOnClick, "onClick");
        }, _onDblClick:function (nodeWidget, e) {
            this.__click(nodeWidget, e, this.openOnDblClick, "onDblClick");
        }, _onExpandoClick:function (message) {
            var node = message.node;
            this.focusNode(node);
            if (node.isExpanded) {
                this._collapseNode(node);
            } else {
                this._expandNode(node);
            }
        }, onClick:function () {
        }, onDblClick:function () {
        }, onOpen:function () {
        }, onClose:function () {
        }, _getNextNode:function (node) {
            kernel.deprecated(this.declaredClass + "::_getNextNode(node) is deprecated. Use _getNext(node) instead.", "", "2.0");
            return this._getNext(node);
        }, _getRootOrFirstNode:function () {
            kernel.deprecated(this.declaredClass + "::_getRootOrFirstNode() is deprecated. Use _getFirst() instead.", "", "2.0");
            return this._getFirst();
        }, _collapseNode:function (node) {
            if (node._expandNodeDeferred) {
                delete node._expandNodeDeferred;
            }
            if (node.state == "Loading") {
                return;
            }
            if (node.isExpanded) {
                var ret = node.collapse();
                this.onClose(node.item, node);
                this._state(node, false);
                this._startPaint(ret);
                return ret;
            }
        }, _expandNode:function (node) {
            if (node._expandNodeDeferred) {
                return node._expandNodeDeferred;
            }
            var model = this.model, item = node.item, _this = this;
            if (!node._loadDeferred) {
                node.markProcessing();
                node._loadDeferred = new Deferred();
                model.getChildren(item, function (items) {
                    node.unmarkProcessing();
                    node.setChildItems(items).then(function () {
                        node._loadDeferred.resolve(items);
                    });
                }, function (err) {
                    console.error(_this, ": error loading " + node.label + " children: ", err);
                    node._loadDeferred.reject(err);
                });
            }
            var def = node._loadDeferred.then(lang.hitch(this, function () {
                var def2 = node.expand();
                this.onOpen(node.item, node);
                this._state(node, true);
                return def2;
            }));
            this._startPaint(def);
            return def;
        }, focusNode:function (node) {
            var scrollLeft = this.domNode.scrollLeft;
            this.focusChild(node);
            this.domNode.scrollLeft = scrollLeft;
        }, _onNodeMouseEnter:function () {
        }, _onNodeMouseLeave:function () {
        }, _onItemChange:function (item) {
            var model = this.model, identity = model.getIdentity(item), nodes = this._itemNodesMap[identity];
            if (nodes) {
                var label = this.getLabel(item), tooltip = this.getTooltip(item);
                array.forEach(nodes, function (node) {
                    node.set({item:item, label:label, tooltip:tooltip});
                    node._updateItemClasses(item);
                });
            }
        }, _onItemChildrenChange:function (parent, newChildrenList) {
            var model = this.model, identity = model.getIdentity(parent), parentNodes = this._itemNodesMap[identity];
            if (parentNodes) {
                array.forEach(parentNodes, function (parentNode) {
                    parentNode.setChildItems(newChildrenList);
                });
            }
        }, _onItemDelete:function (item) {
            var model = this.model, identity = model.getIdentity(item), nodes = this._itemNodesMap[identity];
            if (nodes) {
                array.forEach(nodes, function (node) {
                    this.dndController.removeTreeNode(node);
                    var parent = node.getParent();
                    if (parent) {
                        parent.removeChild(node);
                    }
                    node.destroyRecursive();
                }, this);
                delete this._itemNodesMap[identity];
            }
        }, _initState:function () {
            this._openedNodes = {};
            if (this.persist && this.cookieName) {
                var oreo = cookie(this.cookieName);
                if (oreo) {
                    array.forEach(oreo.split(","), function (item) {
                        this._openedNodes[item] = true;
                    }, this);
                }
            }
        }, _state:function (node, expanded) {
            if (!this.persist) {
                return false;
            }
            var path = array.map(node.getTreePath(), function (item) {
                return this.model.getIdentity(item);
            }, this).join("/");
            if (arguments.length === 1) {
                return this._openedNodes[path];
            } else {
                if (expanded) {
                    this._openedNodes[path] = true;
                } else {
                    delete this._openedNodes[path];
                }
                this._saveExpandedNodes();
            }
        }, _saveExpandedNodes:function () {
            if (this.persist && this.cookieName) {
                var ary = [];
                for (var id in this._openedNodes) {
                    ary.push(id);
                }
                cookie(this.cookieName, ary.join(","), {expires:365});
            }
        }, destroy:function () {
            if (this._curSearch) {
                this._curSearch.timer.remove();
                delete this._curSearch;
            }
            if (this.rootNode) {
                this.rootNode.destroyRecursive();
            }
            if (this.dndController && !lang.isString(this.dndController)) {
                this.dndController.destroy();
            }
            this.rootNode = null;
            this.inherited(arguments);
        }, destroyRecursive:function () {
            this.destroy();
        }, resize:function (changeSize) {
            if (changeSize) {
                domGeometry.setMarginBox(this.domNode, changeSize);
            }
            this._nodePixelIndent = domGeometry.position(this.tree.indentDetector).w || this._nodePixelIndent;
            this.expandChildrenDeferred.then(lang.hitch(this, function () {
                this.rootNode.set("indent", this.showRoot ? 0 : -1);
                this._adjustWidths();
            }));
        }, _outstandingPaintOperations:0, _startPaint:function (p) {
            this._outstandingPaintOperations++;
            if (this._adjustWidthsTimer) {
                this._adjustWidthsTimer.remove();
                delete this._adjustWidthsTimer;
            }
            var oc = lang.hitch(this, function () {
                this._outstandingPaintOperations--;
                if (this._outstandingPaintOperations <= 0 && !this._adjustWidthsTimer && this._started) {
                    this._adjustWidthsTimer = this.defer("_adjustWidths");
                }
            });
            when(p, oc, oc);
        }, _adjustWidths:function () {
            if (this._adjustWidthsTimer) {
                this._adjustWidthsTimer.remove();
                delete this._adjustWidthsTimer;
            }
            this.containerNode.style.width = "auto";
            this.containerNode.style.width = this.domNode.scrollWidth > this.domNode.offsetWidth ? "auto" : "100%";
        }, _createTreeNode:function (args) {
            return new TreeNode(args);
        }, focus:function () {
            if (this.lastFocusedChild) {
                this.focusNode(this.lastFocusedChild);
            } else {
                this.focusFirstChild();
            }
        }});
        if (has("dojo-bidi")) {
            Tree.extend({_setTextDirAttr:function (textDir) {
                if (textDir && this.textDir != textDir) {
                    this._set("textDir", textDir);
                    this.rootNode.set("textDir", textDir);
                }
            }});
        }
        Tree.PathError = createError("TreePathError");
        Tree._TreeNode = TreeNode;
        return Tree;
    });
}, "dojo/selector/_loader":function () {
    define(["../has", "require"], function (has, require) {
        "use strict";
        var testDiv = document.createElement("div");
        has.add("dom-qsa2.1", !!testDiv.querySelectorAll);
        has.add("dom-qsa3", function () {
            try {
                testDiv.innerHTML = "<p class='TEST'></p>";
                return testDiv.querySelectorAll(".TEST:empty").length == 1;
            }
            catch (e) {
            }
        });
        var fullEngine;
        var acme = "./acme", lite = "./lite";
        return {load:function (id, parentRequire, loaded, config) {
            var req = require;
            id = id == "default" ? has("config-selectorEngine") || "css3" : id;
            id = id == "css2" || id == "lite" ? lite : id == "css2.1" ? has("dom-qsa2.1") ? lite : acme : id == "css3" ? has("dom-qsa3") ? lite : acme : id == "acme" ? acme : (req = parentRequire) && id;
            if (id.charAt(id.length - 1) == "?") {
                id = id.substring(0, id.length - 1);
                var optionalLoad = true;
            }
            if (optionalLoad && (has("dom-compliant-qsa") || fullEngine)) {
                return loaded(fullEngine);
            }
            req([id], function (engine) {
                if (id != "./lite") {
                    fullEngine = engine;
                }
                loaded(engine);
            });
        }};
    });
}, "dijit/form/Button":function () {
    define(["require", "dojo/_base/declare", "dojo/dom-class", "dojo/has", "dojo/_base/kernel", "dojo/_base/lang", "dojo/ready", "./_FormWidget", "./_ButtonMixin", "dojo/text!./templates/Button.html"], function (require, declare, domClass, has, kernel, lang, ready, _FormWidget, _ButtonMixin, template) {
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
                require(requires);
            });
        }
        var Button = declare("dijit.form.Button" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormWidget, _ButtonMixin], {showLabel:true, iconClass:"dijitNoIcon", _setIconClassAttr:{node:"iconNode", type:"class"}, baseClass:"dijitButton", templateString:template, _setValueAttr:"valueNode", _setNameAttr:function (name) {
            if (this.valueNode) {
                this.valueNode.setAttribute("name", name);
            }
        }, _fillContent:function (source) {
            if (source && (!this.params || !("label" in this.params))) {
                var sourceLabel = lang.trim(source.innerHTML);
                if (sourceLabel) {
                    this.label = sourceLabel;
                }
            }
        }, _setShowLabelAttr:function (val) {
            if (this.containerNode) {
                domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
            }
            this._set("showLabel", val);
        }, setLabel:function (content) {
            kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
            this.set("label", content);
        }, _setLabelAttr:function (content) {
            this.inherited(arguments);
            if (!this.showLabel && !("title" in this.params)) {
                this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || "");
            }
        }});
        if (has("dojo-bidi")) {
            Button = declare("dijit.form.Button", Button, {_setLabelAttr:function (content) {
                this.inherited(arguments);
                if (this.titleNode.title) {
                    this.applyTextDir(this.titleNode, this.titleNode.title);
                }
            }, _setTextDirAttr:function (textDir) {
                if (this._created && this.textDir != textDir) {
                    this._set("textDir", textDir);
                    this._setLabelAttr(this.label);
                }
            }});
        }
        return Button;
    });
}, "dijit/form/_ExpandingTextAreaMixin":function () {
    define(["dojo/_base/declare", "dojo/dom-construct", "dojo/has", "dojo/_base/lang", "dojo/on", "dojo/_base/window", "../Viewport"], function (declare, domConstruct, has, lang, on, win, Viewport) {
        has.add("textarea-needs-help-shrinking", function () {
            var body = win.body(), te = domConstruct.create("textarea", {rows:"5", cols:"20", value:" ", style:{zoom:1, fontSize:"12px", height:"96px", overflow:"hidden", visibility:"hidden", position:"absolute", border:"5px solid white", margin:"0", padding:"0", boxSizing:"border-box", MsBoxSizing:"border-box", WebkitBoxSizing:"border-box", MozBoxSizing:"border-box"}}, body, "last");
            var needsHelpShrinking = te.scrollHeight >= te.clientHeight;
            body.removeChild(te);
            return needsHelpShrinking;
        });
        return declare("dijit.form._ExpandingTextAreaMixin", null, {_setValueAttr:function () {
            this.inherited(arguments);
            this.resize();
        }, postCreate:function () {
            this.inherited(arguments);
            var textarea = this.textbox;
            textarea.style.overflowY = "hidden";
            this.own(on(textarea, "focus, resize", lang.hitch(this, "_resizeLater")));
        }, startup:function () {
            this.inherited(arguments);
            this.own(Viewport.on("resize", lang.hitch(this, "_resizeLater")));
            this._resizeLater();
        }, _onInput:function (e) {
            this.inherited(arguments);
            this.resize();
        }, _estimateHeight:function () {
            var textarea = this.textbox;
            textarea.rows = (textarea.value.match(/\n/g) || []).length + 1;
        }, _resizeLater:function () {
            this.defer("resize");
        }, resize:function () {
            var textarea = this.textbox;
            function textareaScrollHeight() {
                var empty = false;
                if (textarea.value === "") {
                    textarea.value = " ";
                    empty = true;
                }
                var sh = textarea.scrollHeight;
                if (empty) {
                    textarea.value = "";
                }
                return sh;
            }
            if (textarea.style.overflowY == "hidden") {
                textarea.scrollTop = 0;
            }
            if (this.busyResizing) {
                return;
            }
            this.busyResizing = true;
            if (textareaScrollHeight() || textarea.offsetHeight) {
                var newH = textareaScrollHeight() + Math.max(textarea.offsetHeight - textarea.clientHeight, 0);
                var newHpx = newH + "px";
                if (newHpx != textarea.style.height) {
                    textarea.style.height = newHpx;
                    textarea.rows = 1;
                }
                if (has("textarea-needs-help-shrinking")) {
                    var origScrollHeight = textareaScrollHeight(), newScrollHeight = origScrollHeight, origMinHeight = textarea.style.minHeight, decrement = 4, thisScrollHeight, origScrollTop = textarea.scrollTop;
                    textarea.style.minHeight = newHpx;
                    textarea.style.height = "auto";
                    while (newH > 0) {
                        textarea.style.minHeight = Math.max(newH - decrement, 4) + "px";
                        thisScrollHeight = textareaScrollHeight();
                        var change = newScrollHeight - thisScrollHeight;
                        newH -= change;
                        if (change < decrement) {
                            break;
                        }
                        newScrollHeight = thisScrollHeight;
                        decrement <<= 1;
                    }
                    textarea.style.height = newH + "px";
                    textarea.style.minHeight = origMinHeight;
                    textarea.scrollTop = origScrollTop;
                }
                textarea.style.overflowY = textareaScrollHeight() > textarea.clientHeight ? "auto" : "hidden";
                if (textarea.style.overflowY == "hidden") {
                    textarea.scrollTop = 0;
                }
            } else {
                this._estimateHeight();
            }
            this.busyResizing = false;
        }});
    });
}, "dojo/_base/unload":function () {
    define(["./kernel", "./lang", "../on"], function (dojo, lang, on) {
        var win = window;
        var unload = {addOnWindowUnload:function (obj, functionName) {
            if (!dojo.windowUnloaded) {
                on(win, "unload", (dojo.windowUnloaded = function () {
                }));
            }
            on(win, "unload", lang.hitch(obj, functionName));
        }, addOnUnload:function (obj, functionName) {
            on(win, "beforeunload", lang.hitch(obj, functionName));
        }};
        dojo.addOnWindowUnload = unload.addOnWindowUnload;
        dojo.addOnUnload = unload.addOnUnload;
        return unload;
    });
}, "dijit/CalendarLite":function () {
    define(["dojo/_base/array", "dojo/_base/declare", "dojo/cldr/supplemental", "dojo/date", "dojo/date/locale", "dojo/date/stamp", "dojo/dom", "dojo/dom-class", "dojo/_base/lang", "dojo/on", "dojo/sniff", "dojo/string", "./_WidgetBase", "./_TemplatedMixin", "dojo/text!./templates/Calendar.html", "./a11yclick", "./hccss"], function (array, declare, cldrSupplemental, date, locale, stamp, dom, domClass, lang, on, has, string, _WidgetBase, _TemplatedMixin, template) {
        var CalendarLite = declare("dijit.CalendarLite", [_WidgetBase, _TemplatedMixin], {templateString:template, dowTemplateString:"<th class=\"dijitReset dijitCalendarDayLabelTemplate\" role=\"columnheader\" scope=\"col\"><span class=\"dijitCalendarDayLabel\">${d}</span></th>", dateTemplateString:"<td class=\"dijitReset\" role=\"gridcell\" data-dojo-attach-point=\"dateCells\"><span class=\"dijitCalendarDateLabel\" data-dojo-attach-point=\"dateLabels\"></span></td>", weekTemplateString:"<tr class=\"dijitReset dijitCalendarWeekTemplate\" role=\"row\">${d}${d}${d}${d}${d}${d}${d}</tr>", value:new Date(""), datePackage:"", dayWidth:"narrow", tabIndex:"0", currentFocus:new Date(), _setSummaryAttr:"gridNode", baseClass:"dijitCalendar", _isValidDate:function (value) {
            return value && !isNaN(value) && typeof value == "object" && value.toString() != this.constructor.prototype.value.toString();
        }, _getValueAttr:function () {
            var storedVal = this._get("value");
            if (storedVal && !isNaN(storedVal)) {
                var value = new this.dateClassObj(storedVal);
                value.setHours(0, 0, 0, 0);
                if (value.getDate() < storedVal.getDate()) {
                    value = this.dateModule.add(value, "hour", 1);
                }
                return value;
            } else {
                return null;
            }
        }, _setValueAttr:function (value, priorityChange) {
            if (typeof value == "string") {
                value = stamp.fromISOString(value);
            }
            value = this._patchDate(value);
            if (this._isValidDate(value) && !this.isDisabledDate(value, this.lang)) {
                this._set("value", value);
                this.set("currentFocus", value);
                this._markSelectedDates([value]);
                if (this._created && (priorityChange || typeof priorityChange == "undefined")) {
                    this.onChange(this.get("value"));
                }
            } else {
                this._set("value", null);
                this._markSelectedDates([]);
            }
        }, _patchDate:function (value) {
            if (value) {
                value = new this.dateClassObj(value);
                value.setHours(1, 0, 0, 0);
            }
            return value;
        }, _setText:function (node, text) {
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            node.appendChild(node.ownerDocument.createTextNode(text));
        }, _populateGrid:function () {
            var month = new this.dateClassObj(this.currentFocus);
            month.setDate(1);
            var firstDay = month.getDay(), daysInMonth = this.dateModule.getDaysInMonth(month), daysInPreviousMonth = this.dateModule.getDaysInMonth(this.dateModule.add(month, "month", -1)), today = new this.dateClassObj(), dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
            if (dayOffset > firstDay) {
                dayOffset -= 7;
            }
            if (!this.summary) {
                var monthNames = this.dateLocaleModule.getNames("months", "wide", "standAlone", this.lang, month);
                this.gridNode.setAttribute("summary", monthNames[month.getMonth()]);
            }
            this._date2cell = {};
            array.forEach(this.dateCells, function (template, idx) {
                var i = idx + dayOffset;
                var date = new this.dateClassObj(month), number, clazz = "dijitCalendar", adj = 0;
                if (i < firstDay) {
                    number = daysInPreviousMonth - firstDay + i + 1;
                    adj = -1;
                    clazz += "Previous";
                } else {
                    if (i >= (firstDay + daysInMonth)) {
                        number = i - firstDay - daysInMonth + 1;
                        adj = 1;
                        clazz += "Next";
                    } else {
                        number = i - firstDay + 1;
                        clazz += "Current";
                    }
                }
                if (adj) {
                    date = this.dateModule.add(date, "month", adj);
                }
                date.setDate(number);
                if (!this.dateModule.compare(date, today, "date")) {
                    clazz = "dijitCalendarCurrentDate " + clazz;
                }
                if (this.isDisabledDate(date, this.lang)) {
                    clazz = "dijitCalendarDisabledDate " + clazz;
                    template.setAttribute("aria-disabled", "true");
                } else {
                    clazz = "dijitCalendarEnabledDate " + clazz;
                    template.removeAttribute("aria-disabled");
                    template.setAttribute("aria-selected", "false");
                }
                var clazz2 = this.getClassForDate(date, this.lang);
                if (clazz2) {
                    clazz = clazz2 + " " + clazz;
                }
                template.className = clazz + "Month dijitCalendarDateTemplate";
                var dateVal = date.valueOf();
                this._date2cell[dateVal] = template;
                template.dijitDateValue = dateVal;
                this._setText(this.dateLabels[idx], date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate());
            }, this);
        }, _populateControls:function () {
            var month = new this.dateClassObj(this.currentFocus);
            month.setDate(1);
            this.monthWidget.set("month", month);
            var y = month.getFullYear() - 1;
            var d = new this.dateClassObj();
            array.forEach(["previous", "current", "next"], function (name) {
                d.setFullYear(y++);
                this._setText(this[name + "YearLabelNode"], this.dateLocaleModule.format(d, {selector:"year", locale:this.lang}));
            }, this);
        }, goToToday:function () {
            this.set("value", new this.dateClassObj());
        }, constructor:function (params) {
            this.dateModule = params.datePackage ? lang.getObject(params.datePackage, false) : date;
            this.dateClassObj = this.dateModule.Date || Date;
            this.dateLocaleModule = params.datePackage ? lang.getObject(params.datePackage + ".locale", false) : locale;
        }, _createMonthWidget:function () {
            return CalendarLite._MonthWidget({id:this.id + "_mddb", lang:this.lang, dateLocaleModule:this.dateLocaleModule}, this.monthNode);
        }, buildRendering:function () {
            var d = this.dowTemplateString, dayNames = this.dateLocaleModule.getNames("days", this.dayWidth, "standAlone", this.lang), dayOffset = cldrSupplemental.getFirstDayOfWeek(this.lang);
            this.dayCellsHtml = string.substitute([d, d, d, d, d, d, d].join(""), {d:""}, function () {
                return dayNames[dayOffset++ % 7];
            });
            var r = string.substitute(this.weekTemplateString, {d:this.dateTemplateString});
            this.dateRowsHtml = [r, r, r, r, r, r].join("");
            this.dateCells = [];
            this.dateLabels = [];
            this.inherited(arguments);
            dom.setSelectable(this.domNode, false);
            var dateObj = new this.dateClassObj(this.currentFocus);
            this.monthWidget = this._createMonthWidget();
            this.set("currentFocus", dateObj, false);
        }, postCreate:function () {
            this.inherited(arguments);
            this._connectControls();
        }, _connectControls:function () {
            var connect = lang.hitch(this, function (nodeProp, part, amount) {
                return on(this[nodeProp], "click", lang.hitch(this, function () {
                    this._setCurrentFocusAttr(this.dateModule.add(this.currentFocus, part, amount));
                }));
            });
            this.own(connect("incrementMonth", "month", 1), connect("decrementMonth", "month", -1), connect("nextYearLabelNode", "year", 1), connect("previousYearLabelNode", "year", -1));
        }, _setCurrentFocusAttr:function (date, forceFocus) {
            var oldFocus = this.currentFocus, oldCell = this._getNodeByDate(oldFocus);
            date = this._patchDate(date);
            this._set("currentFocus", date);
            if (!this._date2cell || this.dateModule.difference(oldFocus, date, "month") != 0) {
                this._populateGrid();
                this._populateControls();
                this._markSelectedDates([this.value]);
            }
            var newCell = this._getNodeByDate(date);
            newCell.setAttribute("tabIndex", this.tabIndex);
            if (this.focused || forceFocus) {
                newCell.focus();
            }
            if (oldCell && oldCell != newCell) {
                if (has("webkit")) {
                    oldCell.setAttribute("tabIndex", "-1");
                } else {
                    oldCell.removeAttribute("tabIndex");
                }
            }
        }, focus:function () {
            this._setCurrentFocusAttr(this.currentFocus, true);
        }, _onDayClick:function (evt) {
            evt.stopPropagation();
            evt.preventDefault();
            for (var node = evt.target; node && !node.dijitDateValue; node = node.parentNode) {
            }
            if (node && !domClass.contains(node, "dijitCalendarDisabledDate")) {
                this.set("value", node.dijitDateValue);
            }
        }, _getNodeByDate:function (value) {
            value = this._patchDate(value);
            return value && this._date2cell ? this._date2cell[value.valueOf()] : null;
        }, _markSelectedDates:function (dates) {
            function mark(selected, cell) {
                domClass.toggle(cell, "dijitCalendarSelectedDate", selected);
                cell.setAttribute("aria-selected", selected ? "true" : "false");
            }
            array.forEach(this._selectedCells || [], lang.partial(mark, false));
            this._selectedCells = array.filter(array.map(dates, this._getNodeByDate, this), function (n) {
                return n;
            });
            array.forEach(this._selectedCells, lang.partial(mark, true));
        }, onChange:function () {
        }, isDisabledDate:function () {
        }, getClassForDate:function () {
        }});
        CalendarLite._MonthWidget = declare("dijit.CalendarLite._MonthWidget", _WidgetBase, {_setMonthAttr:function (month) {
            var monthNames = this.dateLocaleModule.getNames("months", "wide", "standAlone", this.lang, month), spacer = (has("ie") == 6 ? "" : "<div class='dijitSpacer'>" + array.map(monthNames, function (s) {
                return "<div>" + s + "</div>";
            }).join("") + "</div>");
            this.domNode.innerHTML = spacer + "<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" + monthNames[month.getMonth()] + "</div>";
        }});
        return CalendarLite;
    });
}, "dojo/parser":function () {
    define(["require", "./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./dom", "./_base/window", "./_base/url", "./aspect", "./promise/all", "./date/stamp", "./Deferred", "./has", "./query", "./on", "./ready"], function (require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready) {
        new Date("X");
        function myEval(text) {
            return eval("(" + text + ")");
        }
        var extendCnt = 0;
        aspect.after(dlang, "extend", function () {
            extendCnt++;
        }, true);
        function getNameMap(ctor) {
            var map = ctor._nameCaseMap, proto = ctor.prototype;
            if (!map || map._extendCnt < extendCnt) {
                map = ctor._nameCaseMap = {};
                for (var name in proto) {
                    if (name.charAt(0) === "_") {
                        continue;
                    }
                    map[name.toLowerCase()] = name;
                }
                map._extendCnt = extendCnt;
            }
            return map;
        }
        var _ctorMap = {};
        function getCtor(types, contextRequire) {
            var ts = types.join();
            if (!_ctorMap[ts]) {
                var mixins = [];
                for (var i = 0, l = types.length; i < l; i++) {
                    var t = types[i];
                    mixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf("/") && (contextRequire ? contextRequire(t) : require(t)))));
                }
                var ctor = mixins.shift();
                _ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
            }
            return _ctorMap[ts];
        }
        var parser = {_clearCache:function () {
            extendCnt++;
            _ctorMap = {};
        }, _functionFromScript:function (script, attrData) {
            var preamble = "", suffix = "", argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")), withStr = script.getAttribute("with");
            var fnArgs = (argsStr || "").split(/\s*,\s*/);
            if (withStr && withStr.length) {
                darray.forEach(withStr.split(/\s*,\s*/), function (part) {
                    preamble += "with(" + part + "){";
                    suffix += "}";
                });
            }
            return new Function(fnArgs, preamble + script.innerHTML + suffix);
        }, instantiate:function (nodes, mixin, options) {
            mixin = mixin || {};
            options = options || {};
            var dojoType = (options.scope || dojo._scopeName) + "Type", attrData = "data-" + (options.scope || dojo._scopeName) + "-", dataDojoType = attrData + "type", dataDojoMixins = attrData + "mixins";
            var list = [];
            darray.forEach(nodes, function (node) {
                var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
                if (type) {
                    var mixinsValue = node.getAttribute(dataDojoMixins), types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];
                    list.push({node:node, types:types});
                }
            });
            return this._instantiate(list, mixin, options);
        }, _instantiate:function (nodes, mixin, options, returnPromise) {
            var thelist = darray.map(nodes, function (obj) {
                var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
                if (!ctor) {
                    throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
                }
                return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
            }, this);
            function onConstruct(thelist) {
                if (!mixin._started && !options.noStart) {
                    darray.forEach(thelist, function (instance) {
                        if (typeof instance.startup === "function" && !instance._started) {
                            instance.startup();
                        }
                    });
                }
                return thelist;
            }
            if (returnPromise) {
                return all(thelist).then(onConstruct);
            } else {
                return onConstruct(thelist);
            }
        }, construct:function (ctor, node, mixin, options, scripts, inherited) {
            var proto = ctor && ctor.prototype;
            options = options || {};
            var params = {};
            if (options.defaults) {
                dlang.mixin(params, options.defaults);
            }
            if (inherited) {
                dlang.mixin(params, inherited);
            }
            var attributes;
            if (has("dom-attributes-explicit")) {
                attributes = node.attributes;
            } else {
                if (has("dom-attributes-specified-flag")) {
                    attributes = darray.filter(node.attributes, function (a) {
                        return a.specified;
                    });
                } else {
                    var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false), attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");
                    attributes = darray.map(attrs.split(/\s+/), function (name) {
                        var lcName = name.toLowerCase();
                        return {name:name, value:(node.nodeName == "LI" && name == "value") || lcName == "enctype" ? node.getAttribute(lcName) : node.getAttributeNode(lcName).value};
                    });
                }
            }
            var scope = options.scope || dojo._scopeName, attrData = "data-" + scope + "-", hash = {};
            if (scope !== "dojo") {
                hash[attrData + "props"] = "data-dojo-props";
                hash[attrData + "type"] = "data-dojo-type";
                hash[attrData + "mixins"] = "data-dojo-mixins";
                hash[scope + "type"] = "dojoType";
                hash[attrData + "id"] = "data-dojo-id";
            }
            var i = 0, item, funcAttrs = [], jsname, extra;
            while (item = attributes[i++]) {
                var name = item.name, lcName = name.toLowerCase(), value = item.value;
                switch (hash[lcName] || lcName) {
                  case "data-dojo-type":
                  case "dojotype":
                  case "data-dojo-mixins":
                    break;
                  case "data-dojo-props":
                    extra = value;
                    break;
                  case "data-dojo-id":
                  case "jsid":
                    jsname = value;
                    break;
                  case "data-dojo-attach-point":
                  case "dojoattachpoint":
                    params.dojoAttachPoint = value;
                    break;
                  case "data-dojo-attach-event":
                  case "dojoattachevent":
                    params.dojoAttachEvent = value;
                    break;
                  case "class":
                    params["class"] = node.className;
                    break;
                  case "style":
                    params["style"] = node.style && node.style.cssText;
                    break;
                  default:
                    if (!(name in proto)) {
                        var map = getNameMap(ctor);
                        name = map[lcName] || name;
                    }
                    if (name in proto) {
                        switch (typeof proto[name]) {
                          case "string":
                            params[name] = value;
                            break;
                          case "number":
                            params[name] = value.length ? Number(value) : NaN;
                            break;
                          case "boolean":
                            params[name] = value.toLowerCase() != "false";
                            break;
                          case "function":
                            if (value === "" || value.search(/[^\w\.]+/i) != -1) {
                                params[name] = new Function(value);
                            } else {
                                params[name] = dlang.getObject(value, false) || new Function(value);
                            }
                            funcAttrs.push(name);
                            break;
                          default:
                            var pVal = proto[name];
                            params[name] = (pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) : (pVal instanceof Date) ? (value == "" ? new Date("") : value == "now" ? new Date() : dates.fromISOString(value)) : (pVal instanceof _Url) ? (dojo.baseUrl + value) : myEval(value);
                        }
                    } else {
                        params[name] = value;
                    }
                }
            }
            for (var j = 0; j < funcAttrs.length; j++) {
                var lcfname = funcAttrs[j].toLowerCase();
                node.removeAttribute(lcfname);
                node[lcfname] = null;
            }
            if (extra) {
                try {
                    extra = myEval.call(options.propsThis, "{" + extra + "}");
                    dlang.mixin(params, extra);
                }
                catch (e) {
                    throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
                }
            }
            dlang.mixin(params, mixin);
            if (!scripts) {
                scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
            }
            var aspects = [], calls = [], watches = [], ons = [];
            if (scripts) {
                for (i = 0; i < scripts.length; i++) {
                    var script = scripts[i];
                    node.removeChild(script);
                    var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")), prop = script.getAttribute(attrData + "prop"), method = script.getAttribute(attrData + "method"), advice = script.getAttribute(attrData + "advice"), scriptType = script.getAttribute("type"), nf = this._functionFromScript(script, attrData);
                    if (event) {
                        if (scriptType == "dojo/connect") {
                            aspects.push({method:event, func:nf});
                        } else {
                            if (scriptType == "dojo/on") {
                                ons.push({event:event, func:nf});
                            } else {
                                params[event] = nf;
                            }
                        }
                    } else {
                        if (scriptType == "dojo/aspect") {
                            aspects.push({method:method, advice:advice, func:nf});
                        } else {
                            if (scriptType == "dojo/watch") {
                                watches.push({prop:prop, func:nf});
                            } else {
                                calls.push(nf);
                            }
                        }
                    }
                }
            }
            var markupFactory = ctor.markupFactory || proto.markupFactory;
            var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);
            function onInstantiate(instance) {
                if (jsname) {
                    dlang.setObject(jsname, instance);
                }
                for (i = 0; i < aspects.length; i++) {
                    aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
                }
                for (i = 0; i < calls.length; i++) {
                    calls[i].call(instance);
                }
                for (i = 0; i < watches.length; i++) {
                    instance.watch(watches[i].prop, watches[i].func);
                }
                for (i = 0; i < ons.length; i++) {
                    don(instance, ons[i].event, ons[i].func);
                }
                return instance;
            }
            if (instance.then) {
                return instance.then(onInstantiate);
            } else {
                return onInstantiate(instance);
            }
        }, scan:function (root, options) {
            var list = [], mids = [], midsHash = {};
            var dojoType = (options.scope || dojo._scopeName) + "Type", attrData = "data-" + (options.scope || dojo._scopeName) + "-", dataDojoType = attrData + "type", dataDojoTextDir = attrData + "textdir", dataDojoMixins = attrData + "mixins";
            var node = root.firstChild;
            var inherited = options.inherited;
            if (!inherited) {
                function findAncestorAttr(node, attr) {
                    return (node.getAttribute && node.getAttribute(attr)) || (node.parentNode && findAncestorAttr(node.parentNode, attr));
                }
                inherited = {dir:findAncestorAttr(root, "dir"), lang:findAncestorAttr(root, "lang"), textDir:findAncestorAttr(root, dataDojoTextDir)};
                for (var key in inherited) {
                    if (!inherited[key]) {
                        delete inherited[key];
                    }
                }
            }
            var parent = {inherited:inherited};
            var scripts;
            var scriptsOnly;
            function getEffective(parent) {
                if (!parent.inherited) {
                    parent.inherited = {};
                    var node = parent.node, grandparent = getEffective(parent.parent);
                    var inherited = {dir:node.getAttribute("dir") || grandparent.dir, lang:node.getAttribute("lang") || grandparent.lang, textDir:node.getAttribute(dataDojoTextDir) || grandparent.textDir};
                    for (var key in inherited) {
                        if (inherited[key]) {
                            parent.inherited[key] = inherited[key];
                        }
                    }
                }
                return parent.inherited;
            }
            while (true) {
                if (!node) {
                    if (!parent || !parent.node) {
                        break;
                    }
                    node = parent.node.nextSibling;
                    scriptsOnly = false;
                    parent = parent.parent;
                    scripts = parent.scripts;
                    continue;
                }
                if (node.nodeType != 1) {
                    node = node.nextSibling;
                    continue;
                }
                if (scripts && node.nodeName.toLowerCase() == "script") {
                    type = node.getAttribute("type");
                    if (type && /^dojo\/\w/i.test(type)) {
                        scripts.push(node);
                    }
                    node = node.nextSibling;
                    continue;
                }
                if (scriptsOnly) {
                    node = node.nextSibling;
                    continue;
                }
                var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
                var firstChild = node.firstChild;
                if (!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))) {
                    node = node.nextSibling;
                    continue;
                }
                var current;
                var ctor = null;
                if (type) {
                    var mixinsValue = node.getAttribute(dataDojoMixins), types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];
                    try {
                        ctor = getCtor(types, options.contextRequire);
                    }
                    catch (e) {
                    }
                    if (!ctor) {
                        darray.forEach(types, function (t) {
                            if (~t.indexOf("/") && !midsHash[t]) {
                                midsHash[t] = true;
                                mids[mids.length] = t;
                            }
                        });
                    }
                    var childScripts = ctor && !ctor.prototype._noScript ? [] : null;
                    current = {types:types, ctor:ctor, parent:parent, node:node, scripts:childScripts};
                    current.inherited = getEffective(current);
                    list.push(current);
                } else {
                    current = {node:node, scripts:scripts, parent:parent};
                }
                scripts = childScripts;
                scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
                parent = current;
                node = firstChild;
            }
            var d = new Deferred();
            if (mids.length) {
                if (has("dojo-debug-messages")) {
                    console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
                }
                var r = options.contextRequire || require;
                r(mids, function () {
                    d.resolve(darray.filter(list, function (widget) {
                        if (!widget.ctor) {
                            try {
                                widget.ctor = getCtor(widget.types, options.contextRequire);
                            }
                            catch (e) {
                            }
                        }
                        var parent = widget.parent;
                        while (parent && !parent.types) {
                            parent = parent.parent;
                        }
                        var proto = widget.ctor && widget.ctor.prototype;
                        widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
                        widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
                        return widget.instantiate;
                    }));
                });
            } else {
                d.resolve(list);
            }
            return d.promise;
        }, _require:function (script, options) {
            var hash = myEval("{" + script.innerHTML + "}"), vars = [], mids = [], d = new Deferred();
            var contextRequire = (options && options.contextRequire) || require;
            for (var name in hash) {
                vars.push(name);
                mids.push(hash[name]);
            }
            contextRequire(mids, function () {
                for (var i = 0; i < vars.length; i++) {
                    dlang.setObject(vars[i], arguments[i]);
                }
                d.resolve(arguments);
            });
            return d.promise;
        }, _scanAmd:function (root, options) {
            var deferred = new Deferred(), promise = deferred.promise;
            deferred.resolve(true);
            var self = this;
            query("script[type='dojo/require']", root).forEach(function (node) {
                promise = promise.then(function () {
                    return self._require(node, options);
                });
                node.parentNode.removeChild(node);
            });
            return promise;
        }, parse:function (rootNode, options) {
            var root;
            if (!options && rootNode && rootNode.rootNode) {
                options = rootNode;
                root = options.rootNode;
            } else {
                if (rootNode && dlang.isObject(rootNode) && !("nodeType" in rootNode)) {
                    options = rootNode;
                } else {
                    root = rootNode;
                }
            }
            root = root ? dom.byId(root) : dwindow.body();
            options = options || {};
            var mixin = options.template ? {template:true} : {}, instances = [], self = this;
            var p = this._scanAmd(root, options).then(function () {
                return self.scan(root, options);
            }).then(function (parsedNodes) {
                return self._instantiate(parsedNodes, mixin, options, true);
            }).then(function (_instances) {
                return instances = instances.concat(_instances);
            }).otherwise(function (e) {
                console.error("dojo/parser::parse() error", e);
                throw e;
            });
            dlang.mixin(instances, p);
            return instances;
        }};
        if (1) {
            dojo.parser = parser;
        }
        if (config.parseOnLoad) {
            ready(100, parser, "parse");
        }
        return parser;
    });
}, "dijit/Toolbar":function () {
    define(["require", "dojo/_base/declare", "dojo/has", "dojo/keys", "dojo/ready", "./_Widget", "./_KeyNavContainer", "./_TemplatedMixin"], function (require, declare, has, keys, ready, _Widget, _KeyNavContainer, _TemplatedMixin) {
        if (has("dijit-legacy-requires")) {
            ready(0, function () {
                var requires = ["dijit/ToolbarSeparator"];
                require(requires);
            });
        }
        return declare("dijit.Toolbar", [_Widget, _TemplatedMixin, _KeyNavContainer], {templateString:"<div class=\"dijit\" role=\"toolbar\" tabIndex=\"${tabIndex}\" data-dojo-attach-point=\"containerNode\">" + "</div>", baseClass:"dijitToolbar", _onLeftArrow:function () {
            this.focusPrev();
        }, _onRightArrow:function () {
            this.focusNext();
        }});
    });
}, "dojo/promise/all":function () {
    define(["../_base/array", "../Deferred", "../when"], function (array, Deferred, when) {
        "use strict";
        var some = array.some;
        return function all(objectOrArray) {
            var object, array;
            if (objectOrArray instanceof Array) {
                array = objectOrArray;
            } else {
                if (objectOrArray && typeof objectOrArray === "object") {
                    object = objectOrArray;
                }
            }
            var results;
            var keyLookup = [];
            if (object) {
                array = [];
                for (var key in object) {
                    if (Object.hasOwnProperty.call(object, key)) {
                        keyLookup.push(key);
                        array.push(object[key]);
                    }
                }
                results = {};
            } else {
                if (array) {
                    results = [];
                }
            }
            if (!array || !array.length) {
                return new Deferred().resolve(results);
            }
            var deferred = new Deferred();
            deferred.promise.always(function () {
                results = keyLookup = null;
            });
            var waiting = array.length;
            some(array, function (valueOrPromise, index) {
                if (!object) {
                    keyLookup.push(index);
                }
                when(valueOrPromise, function (value) {
                    if (!deferred.isFulfilled()) {
                        results[keyLookup[index]] = value;
                        if (--waiting === 0) {
                            deferred.resolve(results);
                        }
                    }
                }, deferred.reject);
                return deferred.isFulfilled();
            });
            return deferred.promise;
        };
    });
}, "dijit/form/_Spinner":function () {
    define(["dojo/_base/declare", "dojo/keys", "dojo/_base/lang", "dojo/sniff", "dojo/mouse", "dojo/on", "../typematic", "./RangeBoundTextBox", "dojo/text!./templates/Spinner.html", "./_TextBoxMixin"], function (declare, keys, lang, has, mouse, on, typematic, RangeBoundTextBox, template, _TextBoxMixin) {
        return declare("dijit.form._Spinner", RangeBoundTextBox, {defaultTimeout:500, minimumTimeout:10, timeoutChangeRate:0.9, smallDelta:1, largeDelta:10, templateString:template, baseClass:"dijitTextBox dijitSpinner", cssStateNodes:{"upArrowNode":"dijitUpArrowButton", "downArrowNode":"dijitDownArrowButton"}, adjust:function (val) {
            return val;
        }, _arrowPressed:function (nodePressed, direction, increment) {
            if (this.disabled || this.readOnly) {
                return;
            }
            this._setValueAttr(this.adjust(this.get("value"), direction * increment), false);
            _TextBoxMixin.selectInputText(this.textbox, this.textbox.value.length);
        }, _arrowReleased:function () {
            this._wheelTimer = null;
        }, _typematicCallback:function (count, node, evt) {
            var inc = this.smallDelta;
            if (node == this.textbox) {
                var key = evt.keyCode;
                inc = (key == keys.PAGE_UP || key == keys.PAGE_DOWN) ? this.largeDelta : this.smallDelta;
                node = (key == keys.UP_ARROW || key == keys.PAGE_UP) ? this.upArrowNode : this.downArrowNode;
            }
            if (count == -1) {
                this._arrowReleased(node);
            } else {
                this._arrowPressed(node, (node == this.upArrowNode) ? 1 : -1, inc);
            }
        }, _wheelTimer:null, _mouseWheeled:function (evt) {
            evt.stopPropagation();
            evt.preventDefault();
            var wheelDelta = evt.wheelDelta / 120;
            if (Math.floor(wheelDelta) != wheelDelta) {
                wheelDelta = evt.wheelDelta > 0 ? 1 : -1;
            }
            var scrollAmount = evt.detail ? (evt.detail * -1) : wheelDelta;
            if (scrollAmount !== 0) {
                var node = this[(scrollAmount > 0 ? "upArrowNode" : "downArrowNode")];
                this._arrowPressed(node, scrollAmount, this.smallDelta);
                if (this._wheelTimer) {
                    this._wheelTimer.remove();
                }
                this._wheelTimer = this.defer(function () {
                    this._arrowReleased(node);
                }, 50);
            }
        }, _setConstraintsAttr:function (constraints) {
            this.inherited(arguments);
            if (this.focusNode) {
                if (this.constraints.min !== undefined) {
                    this.focusNode.setAttribute("aria-valuemin", this.constraints.min);
                } else {
                    this.focusNode.removeAttribute("aria-valuemin");
                }
                if (this.constraints.max !== undefined) {
                    this.focusNode.setAttribute("aria-valuemax", this.constraints.max);
                } else {
                    this.focusNode.removeAttribute("aria-valuemax");
                }
            }
        }, _setValueAttr:function (value, priorityChange) {
            this.focusNode.setAttribute("aria-valuenow", value);
            this.inherited(arguments);
        }, postCreate:function () {
            this.inherited(arguments);
            this.own(on(this.domNode, mouse.wheel, lang.hitch(this, "_mouseWheeled")), typematic.addListener(this.upArrowNode, this.textbox, {keyCode:keys.UP_ARROW, ctrlKey:false, altKey:false, shiftKey:false, metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout), typematic.addListener(this.downArrowNode, this.textbox, {keyCode:keys.DOWN_ARROW, ctrlKey:false, altKey:false, shiftKey:false, metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout), typematic.addListener(this.upArrowNode, this.textbox, {keyCode:keys.PAGE_UP, ctrlKey:false, altKey:false, shiftKey:false, metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout), typematic.addListener(this.downArrowNode, this.textbox, {keyCode:keys.PAGE_DOWN, ctrlKey:false, altKey:false, shiftKey:false, metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
        }});
    });
}, "dojox/html/ellipsis":function () {
    define("dojox/html/ellipsis", ["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/array", "dojo/_base/Color", "dojo/colors"], function (d) {
        if (d.isFF < 7) {
            var delay = 1;
            if ("dojoxFFEllipsisDelay" in d.config) {
                delay = Number(d.config.dojoxFFEllipsisDelay);
                if (isNaN(delay)) {
                    delay = 1;
                }
            }
            try {
                var createXULEllipsis = (function () {
                    var sNS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
                    var xml = document.createElementNS(sNS, "window");
                    var label = document.createElementNS(sNS, "description");
                    label.setAttribute("crop", "end");
                    xml.appendChild(label);
                    return function (n) {
                        var x = xml.cloneNode(true);
                        x.firstChild.setAttribute("value", n.textContent);
                        n.innerHTML = "";
                        n.appendChild(x);
                    };
                })();
            }
            catch (e) {
            }
            var create = d.create;
            var dd = d.doc;
            var dp = d.place;
            var iFrame = create("iframe", {className:"dojoxEllipsisIFrame", src:"javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'", style:{display:"none"}});
            var rollRange = function (r, cnt) {
                if (r.collapsed) {
                    return;
                }
                if (cnt > 0) {
                    do {
                        rollRange(r);
                        cnt--;
                    } while (cnt);
                    return;
                }
                if (r.endContainer.nodeType == 3 && r.endOffset > 0) {
                    r.setEnd(r.endContainer, r.endOffset - 1);
                } else {
                    if (r.endContainer.nodeType == 3) {
                        r.setEndBefore(r.endContainer);
                        rollRange(r);
                        return;
                    } else {
                        if (r.endOffset && r.endContainer.childNodes.length >= r.endOffset) {
                            var nCont = r.endContainer.childNodes[r.endOffset - 1];
                            if (nCont.nodeType == 3) {
                                r.setEnd(nCont, nCont.length - 1);
                            } else {
                                if (nCont.childNodes.length) {
                                    r.setEnd(nCont, nCont.childNodes.length);
                                    rollRange(r);
                                    return;
                                } else {
                                    r.setEndBefore(nCont);
                                    rollRange(r);
                                    return;
                                }
                            }
                        } else {
                            r.setEndBefore(r.endContainer);
                            rollRange(r);
                            return;
                        }
                    }
                }
            };
            var createIFrameEllipsis = function (n) {
                var c = create("div", {className:"dojoxEllipsisContainer"});
                var e = create("div", {className:"dojoxEllipsisShown", style:{display:"none"}});
                n.parentNode.replaceChild(c, n);
                c.appendChild(n);
                c.appendChild(e);
                var i = iFrame.cloneNode(true);
                var ns = n.style;
                var es = e.style;
                var ranges;
                var resizeNode = function () {
                    ns.display = "";
                    es.display = "none";
                    if (n.scrollWidth <= n.offsetWidth) {
                        return;
                    }
                    var r = dd.createRange();
                    r.selectNodeContents(n);
                    ns.display = "none";
                    es.display = "";
                    var done = false;
                    do {
                        var numRolls = 1;
                        dp(r.cloneContents(), e, "only");
                        var sw = e.scrollWidth, ow = e.offsetWidth;
                        done = (sw <= ow);
                        var pct = (1 - ((ow * 1) / sw));
                        if (pct > 0) {
                            numRolls = Math.max(Math.round(e.textContent.length * pct) - 1, 1);
                        }
                        rollRange(r, numRolls);
                    } while (!r.collapsed && !done);
                };
                i.onload = function () {
                    i.contentWindow.onresize = resizeNode;
                    resizeNode();
                };
                c.appendChild(i);
            };
            var hc = d.hasClass;
            var doc = d.doc;
            var s, fn, opt;
            if (doc.querySelectorAll) {
                s = doc;
                fn = "querySelectorAll";
                opt = ".dojoxEllipsis";
            } else {
                if (doc.getElementsByClassName) {
                    s = doc;
                    fn = "getElementsByClassName";
                    opt = "dojoxEllipsis";
                } else {
                    s = d;
                    fn = "query";
                    opt = ".dojoxEllipsis";
                }
            }
            fx = function () {
                d.forEach(s[fn].apply(s, [opt]), function (n) {
                    if (!n || n._djx_ellipsis_done) {
                        return;
                    }
                    n._djx_ellipsis_done = true;
                    if (createXULEllipsis && n.textContent == n.innerHTML && !hc(n, "dojoxEllipsisSelectable")) {
                        createXULEllipsis(n);
                    } else {
                        createIFrameEllipsis(n);
                    }
                });
            };
            d.addOnLoad(function () {
                var t = null;
                var c = null;
                var connFx = function () {
                    if (c) {
                        d.disconnect(c);
                        c = null;
                    }
                    if (t) {
                        clearTimeout(t);
                    }
                    t = setTimeout(function () {
                        t = null;
                        fx();
                        c = d.connect(d.body(), "DOMSubtreeModified", connFx);
                    }, delay);
                };
                connFx();
            });
        }
    });
}, "dojox/grid/_View":function () {
    define(["dojo", "dijit/registry", "../main", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/lang", "dojo/_base/connect", "dojo/_base/sniff", "dojo/query", "dojo/_base/window", "dojo/text!./resources/View.html", "dojo/dnd/Source", "dijit/_Widget", "dijit/_TemplatedMixin", "dojox/html/metrics", "./util", "dojo/_base/html", "./_Builder", "dojo/dnd/Avatar", "dojo/dnd/Manager"], function (dojo, dijit, dojox, declare, array, lang, connect, has, query, win, template, Source, _Widget, _TemplatedMixin, metrics, util, html, _Builder, Avatar, Manager) {
        var getStyleText = function (inNode, inStyleText) {
            return inNode.style.cssText == undefined ? inNode.getAttribute("style") : inNode.style.cssText;
        };
        var _View = declare("dojox.grid._View", [_Widget, _TemplatedMixin], {defaultWidth:"18em", viewWidth:"", templateString:template, classTag:"dojoxGrid", marginBottom:0, rowPad:2, _togglingColumn:-1, _headerBuilderClass:_Builder._HeaderBuilder, _contentBuilderClass:_Builder._ContentBuilder, postMixInProperties:function () {
            this.rowNodes = {};
        }, postCreate:function () {
            this.connect(this.scrollboxNode, "onscroll", "doscroll");
            util.funnelEvents(this.contentNode, this, "doContentEvent", ["mouseover", "mouseout", "click", "dblclick", "contextmenu", "mousedown"]);
            util.funnelEvents(this.headerNode, this, "doHeaderEvent", ["dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "click", "contextmenu"]);
            this.content = new this._contentBuilderClass(this);
            this.header = new this._headerBuilderClass(this);
            if (!this.grid.isLeftToRight()) {
                this.headerNodeContainer.style.width = "";
            }
        }, destroy:function () {
            html.destroy(this.headerNode);
            delete this.headerNode;
            for (var i in this.rowNodes) {
                this._cleanupRowWidgets(this.rowNodes[i]);
                html.destroy(this.rowNodes[i]);
            }
            this.rowNodes = {};
            if (this.source) {
                this.source.destroy();
            }
            this.inherited(arguments);
        }, focus:function () {
            if (has("ie") || has("webkit") || has("opera")) {
                this.hiddenFocusNode.focus();
            } else {
                this.scrollboxNode.focus();
            }
        }, setStructure:function (inStructure) {
            var vs = (this.structure = inStructure);
            if (vs.width && !isNaN(vs.width)) {
                this.viewWidth = vs.width + "em";
            } else {
                this.viewWidth = vs.width || (vs.noscroll ? "auto" : this.viewWidth);
            }
            this._onBeforeRow = vs.onBeforeRow || function () {
            };
            this._onAfterRow = vs.onAfterRow || function () {
            };
            this.noscroll = vs.noscroll;
            if (this.noscroll) {
                this.scrollboxNode.style.overflow = "hidden";
            }
            this.simpleStructure = Boolean(vs.cells.length == 1);
            this.testFlexCells();
            this.updateStructure();
        }, _cleanupRowWidgets:function (inRowNode) {
            if (inRowNode) {
                array.forEach(query("[widgetId]", inRowNode).map(dijit.byNode), function (w) {
                    if (w._destroyOnRemove) {
                        w.destroy();
                        delete w;
                    } else {
                        if (w.domNode && w.domNode.parentNode) {
                            w.domNode.parentNode.removeChild(w.domNode);
                        }
                    }
                });
            }
        }, onBeforeRow:function (inRowIndex, cells) {
            this._onBeforeRow(inRowIndex, cells);
            if (inRowIndex >= 0) {
                this._cleanupRowWidgets(this.getRowNode(inRowIndex));
            }
        }, onAfterRow:function (inRowIndex, cells, inRowNode) {
            this._onAfterRow(inRowIndex, cells, inRowNode);
            var g = this.grid;
            array.forEach(query(".dojoxGridStubNode", inRowNode), function (n) {
                if (n && n.parentNode) {
                    var lw = n.getAttribute("linkWidget");
                    var cellIdx = window.parseInt(html.attr(n, "cellIdx"), 10);
                    var cellDef = g.getCell(cellIdx);
                    var w = dijit.byId(lw);
                    if (w) {
                        n.parentNode.replaceChild(w.domNode, n);
                        if (!w._started) {
                            w.startup();
                        }
                        dojo.destroy(n);
                    } else {
                        n.innerHTML = "";
                    }
                }
            }, this);
        }, testFlexCells:function () {
            this.flexCells = false;
            for (var j = 0, row; (row = this.structure.cells[j]); j++) {
                for (var i = 0, cell; (cell = row[i]); i++) {
                    cell.view = this;
                    this.flexCells = this.flexCells || cell.isFlex();
                }
            }
            return this.flexCells;
        }, updateStructure:function () {
            this.header.update();
            this.content.update();
        }, getScrollbarWidth:function () {
            var hasScrollSpace = this.hasVScrollbar();
            var overflow = html.style(this.scrollboxNode, "overflow");
            if (this.noscroll || !overflow || overflow == "hidden") {
                hasScrollSpace = false;
            } else {
                if (overflow == "scroll") {
                    hasScrollSpace = true;
                }
            }
            return (hasScrollSpace ? metrics.getScrollbar().w : 0);
        }, getColumnsWidth:function () {
            var h = this.headerContentNode;
            return h && h.firstChild ? (h.firstChild.offsetWidth || html.style(h.firstChild, "width")) : 0;
        }, setColumnsWidth:function (width) {
            this.headerContentNode.firstChild.style.width = width + "px";
            if (this.viewWidth) {
                this.viewWidth = width + "px";
            }
        }, getWidth:function () {
            return this.viewWidth || (this.getColumnsWidth() + this.getScrollbarWidth()) + "px";
        }, getContentWidth:function () {
            return Math.max(0, html._getContentBox(this.domNode).w - this.getScrollbarWidth()) + "px";
        }, render:function () {
            this.scrollboxNode.style.height = "";
            this.renderHeader();
            if (this._togglingColumn >= 0) {
                this.setColumnsWidth(this.getColumnsWidth() - this._togglingColumn);
                this._togglingColumn = -1;
            }
            var cells = this.grid.layout.cells;
            var getSibling = lang.hitch(this, function (node, before) {
                !this.grid.isLeftToRight() && (before = !before);
                var inc = before ? -1 : 1;
                var idx = this.header.getCellNodeIndex(node) + inc;
                var cell = cells[idx];
                while (cell && cell.getHeaderNode() && cell.getHeaderNode().style.display == "none") {
                    idx += inc;
                    cell = cells[idx];
                }
                if (cell) {
                    return cell.getHeaderNode();
                }
                return null;
            });
            if (this.grid.columnReordering && this.simpleStructure) {
                if (this.source) {
                    this.source.destroy();
                }
                var bottomMarkerId = "dojoxGrid_bottomMarker";
                var topMarkerId = "dojoxGrid_topMarker";
                if (this.bottomMarker) {
                    html.destroy(this.bottomMarker);
                }
                this.bottomMarker = html.byId(bottomMarkerId);
                if (this.topMarker) {
                    html.destroy(this.topMarker);
                }
                this.topMarker = html.byId(topMarkerId);
                if (!this.bottomMarker) {
                    this.bottomMarker = html.create("div", {"id":bottomMarkerId, "class":"dojoxGridColPlaceBottom"}, win.body());
                    this._hide(this.bottomMarker);
                    this.topMarker = html.create("div", {"id":topMarkerId, "class":"dojoxGridColPlaceTop"}, win.body());
                    this._hide(this.topMarker);
                }
                this.arrowDim = html.contentBox(this.bottomMarker);
                var headerHeight = html.contentBox(this.headerContentNode.firstChild.rows[0]).h;
                this.source = new Source(this.headerContentNode.firstChild.rows[0], {horizontal:true, accept:["gridColumn_" + this.grid.id], viewIndex:this.index, generateText:false, onMouseDown:lang.hitch(this, function (e) {
                    this.header.decorateEvent(e);
                    if ((this.header.overRightResizeArea(e) || this.header.overLeftResizeArea(e)) && this.header.canResize(e) && !this.header.moveable) {
                        this.header.beginColumnResize(e);
                    } else {
                        if (this.grid.headerMenu) {
                            this.grid.headerMenu.onCancel(true);
                        }
                        if (e.button === (has("ie") < 9 ? 1 : 0)) {
                            Source.prototype.onMouseDown.call(this.source, e);
                        }
                    }
                }), onMouseOver:lang.hitch(this, function (e) {
                    var src = this.source;
                    if (src._getChildByEvent(e)) {
                        Source.prototype.onMouseOver.apply(src, arguments);
                    }
                }), _markTargetAnchor:lang.hitch(this, function (before) {
                    var src = this.source;
                    if (src.current == src.targetAnchor && src.before == before) {
                        return;
                    }
                    if (src.targetAnchor && getSibling(src.targetAnchor, src.before)) {
                        src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
                    }
                    Source.prototype._markTargetAnchor.call(src, before);
                    var target = before ? src.targetAnchor : getSibling(src.targetAnchor, src.before);
                    var endAdd = 0;
                    if (!target) {
                        target = src.targetAnchor;
                        endAdd = html.contentBox(target).w + this.arrowDim.w / 2 + 2;
                    }
                    var pos = html.position(target, true);
                    var left = Math.floor(pos.x - this.arrowDim.w / 2 + endAdd);
                    html.style(this.bottomMarker, "visibility", "visible");
                    html.style(this.topMarker, "visibility", "visible");
                    html.style(this.bottomMarker, {"left":left + "px", "top":(headerHeight + pos.y) + "px"});
                    html.style(this.topMarker, {"left":left + "px", "top":(pos.y - this.arrowDim.h) + "px"});
                    if (src.targetAnchor && getSibling(src.targetAnchor, src.before)) {
                        src._addItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
                    }
                }), _unmarkTargetAnchor:lang.hitch(this, function () {
                    var src = this.source;
                    if (!src.targetAnchor) {
                        return;
                    }
                    if (src.targetAnchor && getSibling(src.targetAnchor, src.before)) {
                        src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
                    }
                    this._hide(this.bottomMarker);
                    this._hide(this.topMarker);
                    Source.prototype._unmarkTargetAnchor.call(src);
                }), destroy:lang.hitch(this, function () {
                    connect.disconnect(this._source_conn);
                    connect.unsubscribe(this._source_sub);
                    Source.prototype.destroy.call(this.source);
                    if (this.bottomMarker) {
                        html.destroy(this.bottomMarker);
                        delete this.bottomMarker;
                    }
                    if (this.topMarker) {
                        html.destroy(this.topMarker);
                        delete this.topMarker;
                    }
                }), onDndCancel:lang.hitch(this, function () {
                    Source.prototype.onDndCancel.call(this.source);
                    this._hide(this.bottomMarker);
                    this._hide(this.topMarker);
                })});
                this._source_conn = connect.connect(this.source, "onDndDrop", this, "_onDndDrop");
                this._source_sub = connect.subscribe("/dnd/drop/before", this, "_onDndDropBefore");
                this.source.startup();
            }
        }, _hide:function (node) {
            html.style(node, {top:"-10000px", "visibility":"hidden"});
        }, _onDndDropBefore:function (source, nodes, copy) {
            if (Manager.manager().target !== this.source) {
                return;
            }
            this.source._targetNode = this.source.targetAnchor;
            this.source._beforeTarget = this.source.before;
            var views = this.grid.views.views;
            var srcView = views[source.viewIndex];
            var tgtView = views[this.index];
            if (tgtView != srcView) {
                srcView.convertColPctToFixed();
                tgtView.convertColPctToFixed();
            }
        }, _onDndDrop:function (source, nodes, copy) {
            if (Manager.manager().target !== this.source) {
                if (Manager.manager().source === this.source) {
                    this._removingColumn = true;
                }
                return;
            }
            this._hide(this.bottomMarker);
            this._hide(this.topMarker);
            var getIdx = function (n) {
                return n ? html.attr(n, "idx") : null;
            };
            var w = html.marginBox(nodes[0]).w;
            if (source.viewIndex !== this.index) {
                var views = this.grid.views.views;
                var srcView = views[source.viewIndex];
                var tgtView = views[this.index];
                if (srcView.viewWidth && srcView.viewWidth != "auto") {
                    srcView.setColumnsWidth(srcView.getColumnsWidth() - w);
                }
                if (tgtView.viewWidth && tgtView.viewWidth != "auto") {
                    tgtView.setColumnsWidth(tgtView.getColumnsWidth());
                }
            }
            var stn = this.source._targetNode;
            var stb = this.source._beforeTarget;
            !this.grid.isLeftToRight() && (stb = !stb);
            var layout = this.grid.layout;
            var idx = this.index;
            delete this.source._targetNode;
            delete this.source._beforeTarget;
            layout.moveColumn(source.viewIndex, idx, getIdx(nodes[0]), getIdx(stn), stb);
        }, renderHeader:function () {
            this.headerContentNode.innerHTML = this.header.generateHtml(this._getHeaderContent);
            if (this.flexCells) {
                this.contentWidth = this.getContentWidth();
                this.headerContentNode.firstChild.style.width = this.contentWidth;
            }
            util.fire(this, "onAfterRow", [-1, this.structure.cells, this.headerContentNode]);
        }, _getHeaderContent:function (inCell) {
            var n = inCell.name || inCell.grid.getCellName(inCell);
            if (/^\s+$/.test(n)) {
                n = "&nbsp;";
            }
            var ret = ["<div class=\"dojoxGridSortNode"];
            if (inCell.index != inCell.grid.getSortIndex()) {
                ret.push("\">");
            } else {
                ret = ret.concat([" ", inCell.grid.sortInfo > 0 ? "dojoxGridSortUp" : "dojoxGridSortDown", "\"><div class=\"dojoxGridArrowButtonChar\">", inCell.grid.sortInfo > 0 ? "&#9650;" : "&#9660;", "</div><div class=\"dojoxGridArrowButtonNode\" role=\"presentation\"></div>", "<div class=\"dojoxGridColCaption\">"]);
            }
            ret = ret.concat([n, "</div></div>"]);
            return ret.join("");
        }, resize:function () {
            this.adaptHeight();
            this.adaptWidth();
        }, hasHScrollbar:function (reset) {
            var hadScroll = this._hasHScroll || false;
            if (this._hasHScroll == undefined || reset) {
                if (this.noscroll) {
                    this._hasHScroll = false;
                } else {
                    var style = html.style(this.scrollboxNode, "overflow");
                    if (style == "hidden") {
                        this._hasHScroll = false;
                    } else {
                        if (style == "scroll") {
                            this._hasHScroll = true;
                        } else {
                            this._hasHScroll = (this.scrollboxNode.offsetWidth - this.getScrollbarWidth() < this.contentNode.offsetWidth);
                        }
                    }
                }
            }
            if (hadScroll !== this._hasHScroll) {
                this.grid.update();
            }
            return this._hasHScroll;
        }, hasVScrollbar:function (reset) {
            var hadScroll = this._hasVScroll || false;
            if (this._hasVScroll == undefined || reset) {
                if (this.noscroll) {
                    this._hasVScroll = false;
                } else {
                    var style = html.style(this.scrollboxNode, "overflow");
                    if (style == "hidden") {
                        this._hasVScroll = false;
                    } else {
                        if (style == "scroll") {
                            this._hasVScroll = true;
                        } else {
                            this._hasVScroll = (this.scrollboxNode.scrollHeight > this.scrollboxNode.clientHeight);
                        }
                    }
                }
            }
            if (hadScroll !== this._hasVScroll) {
                this.grid.update();
            }
            return this._hasVScroll;
        }, convertColPctToFixed:function () {
            var hasPct = false;
            this.grid.initialWidth = "";
            var cellNodes = query("th", this.headerContentNode);
            var fixedWidths = array.map(cellNodes, function (c, vIdx) {
                var w = c.style.width;
                html.attr(c, "vIdx", vIdx);
                if (w && w.slice(-1) == "%") {
                    hasPct = true;
                } else {
                    if (w && w.slice(-2) == "px") {
                        return window.parseInt(w, 10);
                    }
                }
                return html.contentBox(c).w;
            });
            if (hasPct) {
                array.forEach(this.grid.layout.cells, function (cell, idx) {
                    if (cell.view == this) {
                        var cellNode = cell.view.getHeaderCellNode(cell.index);
                        if (cellNode && html.hasAttr(cellNode, "vIdx")) {
                            var vIdx = window.parseInt(html.attr(cellNode, "vIdx"));
                            this.setColWidth(idx, fixedWidths[vIdx]);
                            html.removeAttr(cellNode, "vIdx");
                        }
                    }
                }, this);
                return true;
            }
            return false;
        }, adaptHeight:function (minusScroll) {
            if (!this.grid._autoHeight) {
                var h = (this.domNode.style.height && parseInt(this.domNode.style.height.replace(/px/, ""), 10)) || this.domNode.clientHeight;
                var self = this;
                var checkOtherViewScrollers = function () {
                    var v;
                    for (var i in self.grid.views.views) {
                        v = self.grid.views.views[i];
                        if (v !== self && v.hasHScrollbar()) {
                            return true;
                        }
                    }
                    return false;
                };
                if (minusScroll || (this.noscroll && checkOtherViewScrollers())) {
                    h -= metrics.getScrollbar().h;
                }
                util.setStyleHeightPx(this.scrollboxNode, h);
            }
            this.hasVScrollbar(true);
        }, adaptWidth:function () {
            if (this.flexCells) {
                this.contentWidth = this.getContentWidth();
                this.headerContentNode.firstChild.style.width = this.contentWidth;
            }
            var w = this.scrollboxNode.offsetWidth - this.getScrollbarWidth();
            if (!this._removingColumn) {
                w = Math.max(w, this.getColumnsWidth()) + "px";
            } else {
                w = Math.min(w, this.getColumnsWidth()) + "px";
                this._removingColumn = false;
            }
            var cn = this.contentNode;
            cn.style.width = w;
            this.hasHScrollbar(true);
        }, setSize:function (w, h) {
            var ds = this.domNode.style;
            var hs = this.headerNode.style;
            if (w) {
                ds.width = w;
                hs.width = w;
            }
            ds.height = (h >= 0 ? h + "px" : "");
        }, renderRow:function (inRowIndex) {
            var rowNode = this.createRowNode(inRowIndex);
            this.buildRow(inRowIndex, rowNode);
            return rowNode;
        }, createRowNode:function (inRowIndex) {
            var node = document.createElement("div");
            node.className = this.classTag + "Row";
            if (this instanceof dojox.grid._RowSelector) {
                html.attr(node, "role", "presentation");
            } else {
                html.attr(node, "role", "row");
                if (this.grid.selectionMode != "none") {
                    node.setAttribute("aria-selected", "false");
                }
            }
            node[util.gridViewTag] = this.id;
            node[util.rowIndexTag] = inRowIndex;
            this.rowNodes[inRowIndex] = node;
            return node;
        }, buildRow:function (inRowIndex, inRowNode) {
            this.buildRowContent(inRowIndex, inRowNode);
            this.styleRow(inRowIndex, inRowNode);
        }, buildRowContent:function (inRowIndex, inRowNode) {
            inRowNode.innerHTML = this.content.generateHtml(inRowIndex, inRowIndex);
            if (this.flexCells && this.contentWidth) {
                inRowNode.firstChild.style.width = this.contentWidth;
            }
            util.fire(this, "onAfterRow", [inRowIndex, this.structure.cells, inRowNode]);
        }, rowRemoved:function (inRowIndex) {
            if (inRowIndex >= 0) {
                this._cleanupRowWidgets(this.getRowNode(inRowIndex));
            }
            this.grid.edit.save(this, inRowIndex);
            delete this.rowNodes[inRowIndex];
        }, getRowNode:function (inRowIndex) {
            return this.rowNodes[inRowIndex];
        }, getCellNode:function (inRowIndex, inCellIndex) {
            var row = this.getRowNode(inRowIndex);
            if (row) {
                return this.content.getCellNode(row, inCellIndex);
            }
        }, getHeaderCellNode:function (inCellIndex) {
            if (this.headerContentNode) {
                return this.header.getCellNode(this.headerContentNode, inCellIndex);
            }
        }, styleRow:function (inRowIndex, inRowNode) {
            inRowNode._style = getStyleText(inRowNode);
            this.styleRowNode(inRowIndex, inRowNode);
        }, styleRowNode:function (inRowIndex, inRowNode) {
            if (inRowNode) {
                this.doStyleRowNode(inRowIndex, inRowNode);
            }
        }, doStyleRowNode:function (inRowIndex, inRowNode) {
            this.grid.styleRowNode(inRowIndex, inRowNode);
        }, updateRow:function (inRowIndex) {
            var rowNode = this.getRowNode(inRowIndex);
            if (rowNode) {
                rowNode.style.height = "";
                this.buildRow(inRowIndex, rowNode);
            }
            return rowNode;
        }, updateRowStyles:function (inRowIndex) {
            this.styleRowNode(inRowIndex, this.getRowNode(inRowIndex));
        }, lastTop:0, firstScroll:0, _nativeScroll:false, doscroll:function (inEvent) {
            if (has("ff") >= 13 || has("chrome")) {
                this._nativeScroll = true;
            }
            var isLtr = this.grid.isLeftToRight();
            if (this.firstScroll < 2) {
                if ((!isLtr && this.firstScroll == 1) || (isLtr && this.firstScroll === 0)) {
                    var s = html.marginBox(this.headerNodeContainer);
                    if (has("ie")) {
                        this.headerNodeContainer.style.width = s.w + this.getScrollbarWidth() + "px";
                    } else {
                        if (has("mozilla")) {
                            this.headerNodeContainer.style.width = s.w - this.getScrollbarWidth() + "px";
                            this.scrollboxNode.scrollLeft = isLtr ? this.scrollboxNode.clientWidth - this.scrollboxNode.scrollWidth : this.scrollboxNode.scrollWidth - this.scrollboxNode.clientWidth;
                        }
                    }
                }
                this.firstScroll++;
            }
            this.headerNode.scrollLeft = this.scrollboxNode.scrollLeft;
            var top = this.scrollboxNode.scrollTop;
            if (top !== this.lastTop) {
                this.grid.scrollTo(top);
            }
            this._nativeScroll = false;
        }, setScrollTop:function (inTop) {
            this.lastTop = inTop;
            if (!this._nativeScroll) {
                this.scrollboxNode.scrollTop = inTop;
            }
            return this.scrollboxNode.scrollTop;
        }, doContentEvent:function (e) {
            if (this.content.decorateEvent(e)) {
                this.grid.onContentEvent(e);
            }
        }, doHeaderEvent:function (e) {
            if (this.header.decorateEvent(e)) {
                this.grid.onHeaderEvent(e);
            }
        }, dispatchContentEvent:function (e) {
            return this.content.dispatchEvent(e);
        }, dispatchHeaderEvent:function (e) {
            return this.header.dispatchEvent(e);
        }, setColWidth:function (inIndex, inWidth) {
            this.grid.setCellWidth(inIndex, inWidth + "px");
        }, update:function () {
            if (!this.domNode) {
                return;
            }
            this.content.update();
            this.grid.update();
            var left = this.scrollboxNode.scrollLeft;
            this.scrollboxNode.scrollLeft = left;
            this.headerNode.scrollLeft = left;
        }});
        var _GridAvatar = declare("dojox.grid._GridAvatar", Avatar, {construct:function () {
            var dd = win.doc;
            var a = dd.createElement("table");
            a.cellPadding = a.cellSpacing = "0";
            a.className = "dojoxGridDndAvatar";
            a.style.position = "absolute";
            a.style.zIndex = 1999;
            a.style.margin = "0px";
            var b = dd.createElement("tbody");
            var tr = dd.createElement("tr");
            var td = dd.createElement("td");
            var img = dd.createElement("td");
            tr.className = "dojoxGridDndAvatarItem";
            img.className = "dojoxGridDndAvatarItemImage";
            img.style.width = "16px";
            var source = this.manager.source, node;
            if (source.creator) {
                node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
            } else {
                node = this.manager.nodes[0].cloneNode(true);
                var table, tbody;
                if (node.tagName.toLowerCase() == "tr") {
                    table = dd.createElement("table");
                    tbody = dd.createElement("tbody");
                    tbody.appendChild(node);
                    table.appendChild(tbody);
                    node = table;
                } else {
                    if (node.tagName.toLowerCase() == "th") {
                        table = dd.createElement("table");
                        tbody = dd.createElement("tbody");
                        var r = dd.createElement("tr");
                        table.cellPadding = table.cellSpacing = "0";
                        r.appendChild(node);
                        tbody.appendChild(r);
                        table.appendChild(tbody);
                        node = table;
                    }
                }
            }
            node.id = "";
            td.appendChild(node);
            tr.appendChild(img);
            tr.appendChild(td);
            html.style(tr, "opacity", 0.9);
            b.appendChild(tr);
            a.appendChild(b);
            this.node = a;
            var m = Manager.manager();
            this.oldOffsetY = m.OFFSET_Y;
            m.OFFSET_Y = 1;
        }, destroy:function () {
            Manager.manager().OFFSET_Y = this.oldOffsetY;
            this.inherited(arguments);
        }});
        var oldMakeAvatar = Manager.manager().makeAvatar;
        Manager.manager().makeAvatar = function () {
            var src = this.source;
            if (src.viewIndex !== undefined && !html.hasClass(win.body(), "dijit_a11y")) {
                return new _GridAvatar(this);
            }
            return oldMakeAvatar.call(Manager.manager());
        };
        return _View;
    });
}, "dijit/TooltipDialog":function () {
    define(["dojo/_base/declare", "dojo/dom-class", "dojo/has", "dojo/keys", "dojo/_base/lang", "dojo/on", "./focus", "./layout/ContentPane", "./_DialogMixin", "./form/_FormMixin", "./_TemplatedMixin", "dojo/text!./templates/TooltipDialog.html", "./main"], function (declare, domClass, has, keys, lang, on, focus, ContentPane, _DialogMixin, _FormMixin, _TemplatedMixin, template, dijit) {
        var TooltipDialog = declare("dijit.TooltipDialog", [ContentPane, _TemplatedMixin, _FormMixin, _DialogMixin], {title:"", doLayout:false, autofocus:true, baseClass:"dijitTooltipDialog", _firstFocusItem:null, _lastFocusItem:null, templateString:template, _setTitleAttr:"containerNode", postCreate:function () {
            this.inherited(arguments);
            this.own(on(this.containerNode, "keydown", lang.hitch(this, "_onKey")));
        }, orient:function (node, aroundCorner, tooltipCorner) {
            var newC = {"MR-ML":"dijitTooltipRight", "ML-MR":"dijitTooltipLeft", "TM-BM":"dijitTooltipAbove", "BM-TM":"dijitTooltipBelow", "BL-TL":"dijitTooltipBelow dijitTooltipABLeft", "TL-BL":"dijitTooltipAbove dijitTooltipABLeft", "BR-TR":"dijitTooltipBelow dijitTooltipABRight", "TR-BR":"dijitTooltipAbove dijitTooltipABRight", "BR-BL":"dijitTooltipRight", "BL-BR":"dijitTooltipLeft", "BR-TL":"dijitTooltipBelow dijitTooltipABLeft", "BL-TR":"dijitTooltipBelow dijitTooltipABRight", "TL-BR":"dijitTooltipAbove dijitTooltipABRight", "TR-BL":"dijitTooltipAbove dijitTooltipABLeft"}[aroundCorner + "-" + tooltipCorner];
            domClass.replace(this.domNode, newC, this._currentOrientClass || "");
            this._currentOrientClass = newC;
        }, focus:function () {
            this._getFocusItems(this.containerNode);
            focus.focus(this._firstFocusItem);
        }, onOpen:function (pos) {
            this.orient(this.domNode, pos.aroundCorner, pos.corner);
            var aroundNodeCoords = pos.aroundNodePos;
            if (pos.corner.charAt(0) == "M" && pos.aroundCorner.charAt(0) == "M") {
                this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
                this.connectorNode.style.left = "";
            } else {
                if (pos.corner.charAt(1) == "M" && pos.aroundCorner.charAt(1) == "M") {
                    this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
                }
            }
            this._onShow();
        }, onClose:function () {
            this.onHide();
        }, _onKey:function (evt) {
            if (evt.keyCode == keys.ESCAPE) {
                this.defer("onCancel");
                evt.stopPropagation();
                evt.preventDefault();
            } else {
                if (evt.keyCode == keys.TAB) {
                    var node = evt.target;
                    this._getFocusItems(this.containerNode);
                    if (this._firstFocusItem == this._lastFocusItem) {
                        evt.stopPropagation();
                        evt.preventDefault();
                    } else {
                        if (node == this._firstFocusItem && evt.shiftKey) {
                            focus.focus(this._lastFocusItem);
                            evt.stopPropagation();
                            evt.preventDefault();
                        } else {
                            if (node == this._lastFocusItem && !evt.shiftKey) {
                                focus.focus(this._firstFocusItem);
                                evt.stopPropagation();
                                evt.preventDefault();
                            } else {
                                evt.stopPropagation();
                            }
                        }
                    }
                }
            }
        }});
        if (has("dojo-bidi")) {
            TooltipDialog.extend({_setTitleAttr:function (title) {
                this.containerNode.title = (this.textDir && this.enforceTextDirWithUcc) ? this.enforceTextDirWithUcc(null, title) : title;
                this._set("title", title);
            }, _setTextDirAttr:function (textDir) {
                if (!this._created || this.textDir != textDir) {
                    this._set("textDir", textDir);
                    if (this.textDir && this.title) {
                        this.containerNode.title = this.enforceTextDirWithUcc(null, this.title);
                    }
                }
            }});
        }
        return TooltipDialog;
    });
}, "url:dijit/templates/Menu.html":"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\"\n\t   cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n", "url:dijit/templates/TreeNode.html":"<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div data-dojo-attach-point=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\"\n\t\t><span data-dojo-attach-point=\"expandoNode\" class=\"dijitInline dijitTreeExpando\" role=\"presentation\"></span\n\t\t><span data-dojo-attach-point=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"></span\n\t\t><span data-dojo-attach-point=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTreeIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span data-dojo-attach-point=\"labelNode,focusNode\" class=\"dijitTreeLabel\" role=\"treeitem\" tabindex=\"-1\" aria-selected=\"false\"></span>\n\t\t</span\n\t></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeNodeContainer\" role=\"presentation\" style=\"display: none;\"></div>\n</div>\n", "url:dijit/form/templates/Spinner.html":"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitButtonNode dijitSpinnerButtonContainer\"\n\t\t><input class=\"dijitReset dijitInputField dijitSpinnerButtonInner\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t/><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitUpArrowButton\"\n\t\t\tdata-dojo-attach-point=\"upArrowNode\"\n\t\t\t><div class=\"dijitArrowButtonInner\"\n\t\t\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9650; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t\t${_buttonInputDisabled}\n\t\t\t/></div\n\t\t></div\n\t\t><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitDownArrowButton\"\n\t\t\tdata-dojo-attach-point=\"downArrowNode\"\n\t\t\t><div class=\"dijitArrowButtonInner\"\n\t\t\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t\t${_buttonInputDisabled}\n\t\t\t/></div\n\t\t></div\n\t></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' data-dojo-attach-point=\"textbox,focusNode\" type=\"${type}\" data-dojo-attach-event=\"onkeydown:_onKeyDown\"\n\t\t\trole=\"spinbutton\" autocomplete=\"off\" ${!nameAttrSetting}\n\t/></div\n></div>\n", "url:dojox/grid/resources/_Grid.html":"<div hidefocus=\"hidefocus\" role=\"grid\" dojoAttachEvent=\"onmouseout:_mouseOut\">\n\t<div class=\"dojoxGridMasterHeader\" dojoAttachPoint=\"viewsHeaderNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterView\" dojoAttachPoint=\"viewsNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterMessages\" style=\"display: none;\" dojoAttachPoint=\"messagesNode\"></div>\n\t<span dojoAttachPoint=\"lastFocusNode\" tabindex=\"0\"></span>\n</div>\n", "url:dijit/layout/templates/AccordionButton.html":"<div data-dojo-attach-event='ondijitclick:_onTitleClick' class='dijitAccordionTitle' role=\"presentation\">\n\t<div data-dojo-attach-point='titleNode,focusNode' data-dojo-attach-event='onkeydown:_onTitleKeyDown'\n\t\t\tclass='dijitAccordionTitleFocus' role=\"tab\" aria-expanded=\"false\"\n\t\t><span class='dijitInline dijitAccordionArrow' role=\"presentation\"></span\n\t\t><span class='arrowTextUp' role=\"presentation\">+</span\n\t\t><span class='arrowTextDown' role=\"presentation\">-</span\n\t\t><span role=\"presentation\" class=\"dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t\t<span role=\"presentation\" data-dojo-attach-point='titleTextNode, textDirNode' class='dijitAccordionText'></span>\n\t</div>\n</div>\n", "url:dijit/templates/TitlePane.html":"<div>\n\t<div data-dojo-attach-event=\"ondijitclick:_onTitleClick, onkeydown:_onTitleKey\"\n\t\t\tclass=\"dijitTitlePaneTitle\" data-dojo-attach-point=\"titleBarNode\" id=\"${id}_titleBarNode\">\n\t\t<div class=\"dijitTitlePaneTitleFocus\" data-dojo-attach-point=\"focusNode\">\n\t\t\t<span data-dojo-attach-point=\"arrowNode\" class=\"dijitInline dijitArrowNode\" role=\"presentation\"></span\n\t\t\t><span data-dojo-attach-point=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t\t><span data-dojo-attach-point=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" data-dojo-attach-point=\"hideNode\" role=\"presentation\">\n\t\t<div class=\"dijitReset\" data-dojo-attach-point=\"wipeNode\" role=\"presentation\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" data-dojo-attach-point=\"containerNode\" role=\"region\" id=\"${id}_pane\" aria-labelledby=\"${id}_titleBarNode\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n", "url:dijit/templates/ProgressBar.html":"<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\n\t><div  data-dojo-attach-point=\"internalProgress\" class=\"dijitProgressBarFull\"\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\n\t\t><span style=\"visibility:hidden\">&#160;</span\n\t></div\n\t><div data-dojo-attach-point=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\n\t><span data-dojo-attach-point=\"indeterminateHighContrastImage\"\n\t\t   class=\"dijitInline dijitProgressBarIndeterminateHighContrastImage\"></span\n></div>\n", "url:dijit/templates/MenuSeparator.html":"<tr class=\"dijitMenuSeparator\" role=\"separator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n", "url:dijit/form/templates/DropDownButton.html":"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode,_popupStateNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\tdata-dojo-attach-point=\"valueNode\" role=\"presentation\" aria-hidden=\"true\"\n/></span>\n", "url:dijit/form/templates/DropDownBox.html":"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\taria-haspopup=\"true\"\n\tdata-dojo-attach-point=\"_popupStateNode\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\n\t/></div\n></div>\n", "url:dijit/templates/CheckedMenuItem.html":"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"${role}\" tabIndex=\"-1\" aria-checked=\"${checked}\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span class=\"dijitInline dijitIcon dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t\t<span class=\"dijitMenuItemIconChar dijitCheckedMenuItemIconChar\">${checkedChar}</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode,textDirNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n", "url:dijit/templates/Tooltip.html":"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n></div>\n", "url:dijit/form/templates/ValidationTextBox.html":"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n", "url:dijit/templates/InlineEditBox.html":"<span data-dojo-attach-point=\"editNode\" role=\"presentation\" class=\"dijitReset dijitInline dijitOffScreen\"\n\t><span data-dojo-attach-point=\"editorPlaceholder\"></span\n\t><span data-dojo-attach-point=\"buttonContainer\"\n\t\t><button data-dojo-type=\"./form/Button\" data-dojo-props=\"label: '${buttonSave}', 'class': 'saveButton'\"\n\t\t\tdata-dojo-attach-point=\"saveButton\" data-dojo-attach-event=\"onClick:save\"></button\n\t\t><button data-dojo-type=\"./form/Button\"  data-dojo-props=\"label: '${buttonCancel}', 'class': 'cancelButton'\"\n\t\t\tdata-dojo-attach-point=\"cancelButton\" data-dojo-attach-event=\"onClick:cancel\"></button\n\t></span\n></span>\n", "url:dijit/layout/templates/_ScrollingTabControllerButton.html":"<div data-dojo-attach-event=\"ondijitclick:_onClick\" class=\"dijitTabInnerDiv dijitTabContent dijitButtonContents\"  data-dojo-attach-point=\"focusNode\" role=\"button\">\n\t<span role=\"presentation\" class=\"dijitInline dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n</div>", "url:dijit/layout/templates/TabContainer.html":"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n", "url:dijit/form/templates/ComboButton.html":"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:__onClick,onkeydown:_onButtonKeyDown\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeydown:_onArrowKeyDown\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t\t\trole=\"presentation\" aria-hidden=\"true\"\n\t\t\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\t/></td></tr></tbody\n></table>\n", "url:dijit/templates/Tree.html":"<div role=\"tree\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" data-dojo-attach-point=\"indentDetector\"></div>\n\t<div class=\"dijitTreeExpando dijitTreeExpandoLoading\" data-dojo-attach-point=\"rootLoadingIndicator\"></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\">\n\t</div>\n</div>\n", "url:dijit/templates/Dialog.html":"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"\n\t\t\t\trole=\"heading\" level=\"1\"></span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabindex=\"0\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n", "url:dijit/form/templates/Select.html":"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tdata-dojo-attach-point=\"_buttonNode,tableNode,focusNode,_popupStateNode\" cellspacing='0' cellpadding='0'\n\trole=\"listbox\" aria-haspopup=\"true\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents\" role=\"presentation\"\n\t\t\t><div class=\"dijitReset dijitInputField dijitButtonText\"  data-dojo-attach-point=\"containerNode,textDirNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitValidationContainer\"\n\t\t\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t/></div\n\t\t\t><input type=\"hidden\" ${!nameAttrSetting} data-dojo-attach-point=\"valueNode\" value=\"${value}\" aria-hidden=\"true\"\n\t\t/></td\n\t\t><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer\"\n\t\t\tdata-dojo-attach-point=\"titleNode\" role=\"presentation\"\n\t\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t${_buttonInputDisabled}\n\t\t/></td\n\t></tr></tbody\n></table>\n", "url:dijit/form/templates/TextBox.html":"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n", "url:dojox/grid/resources/View.html":"<div class=\"dojoxGridView\" role=\"presentation\">\n\t<div class=\"dojoxGridHeader\" dojoAttachPoint=\"headerNode\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"headerNodeContainer\" style=\"width:9000em\" role=\"presentation\">\n\t\t\t<div dojoAttachPoint=\"headerContentNode\" role=\"row\"></div>\n\t\t</div>\n\t</div>\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" dojoAttachPoint=\"hiddenFocusNode\" role=\"presentation\" />\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" role=\"presentation\" />\n\t<div class=\"dojoxGridScrollbox\" dojoAttachPoint=\"scrollboxNode\" role=\"presentation\">\n\t\t<div class=\"dojoxGridContent\" dojoAttachPoint=\"contentNode\" hidefocus=\"hidefocus\" role=\"presentation\"></div>\n\t</div>\n</div>\n", "url:dijit/templates/MenuItem.html":"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,textDirNode\"\n\t\trole=\"presentation\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<span data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<span class=\"dijitInline dijitIcon dijitMenuExpand\"></span>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</span>\n\t</td>\n</tr>\n", "url:dijit/layout/templates/_TabButton.html":"<div role=\"presentation\" data-dojo-attach-point=\"titleNode,innerDiv,tabContent\" class=\"dijitTabInner dijitTabContent\">\n\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTabButtonIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t<span data-dojo-attach-point='containerNode,focusNode' class='tabLabel'></span>\n\t<span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t  role=\"presentation\">\n\t\t<span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t\t\t></span>\n</div>\n", "url:dijit/form/templates/HorizontalSlider.html":"<table class=\"dijit dijitReset dijitSlider dijitSliderH\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" rules=\"none\" data-dojo-attach-event=\"onkeydown:_onKeyDown, onkeyup:_onKeyUp\"\n\trole=\"presentation\"\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td data-dojo-attach-point=\"topDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationT dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderDecrementIconH\" style=\"display:none\" data-dojo-attach-point=\"decrementButton\"><span class=\"dijitSliderButtonInner\">-</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderLeftBumper\" data-dojo-attach-event=\"press:_onClkDecBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><input data-dojo-attach-point=\"valueNode\" type=\"hidden\" ${!nameAttrSetting}\n\t\t\t/><div class=\"dijitReset dijitSliderBarContainerH\" role=\"presentation\" data-dojo-attach-point=\"sliderBarContainer\"\n\t\t\t\t><div role=\"presentation\" data-dojo-attach-point=\"progressBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderProgressBar dijitSliderProgressBarH\" data-dojo-attach-event=\"press:_onBarClick\"\n\t\t\t\t\t><div class=\"dijitSliderMoveable dijitSliderMoveableH\"\n\t\t\t\t\t\t><div data-dojo-attach-point=\"sliderHandle,focusNode\" class=\"dijitSliderImageHandle dijitSliderImageHandleH\" data-dojo-attach-event=\"press:_onHandleClick\" role=\"slider\"></div\n\t\t\t\t\t></div\n\t\t\t\t></div\n\t\t\t\t><div role=\"presentation\" data-dojo-attach-point=\"remainingBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderRemainingBar dijitSliderRemainingBarH\" data-dojo-attach-event=\"press:_onBarClick\"></div\n\t\t\t></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderRightBumper\" data-dojo-attach-event=\"press:_onClkIncBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderIncrementIconH\" style=\"display:none\" data-dojo-attach-point=\"incrementButton\"><span class=\"dijitSliderButtonInner\">+</span></div\n\t\t></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td data-dojo-attach-point=\"containerNode,bottomDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationB dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n></table>\n", "url:dijit/form/templates/CheckBox.html":"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" role=\"${type}\" aria-checked=\"false\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdata-dojo-attach-point=\"focusNode\"\n\t \tdata-dojo-attach-event=\"ondijitclick:_onClick\"\n/></div>\n", "url:dijit/templates/Calendar.html":"<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" aria-labelledby=\"${id}_mddb ${id}_year\" data-dojo-attach-point=\"gridNode\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset dijitCalendarArrow' data-dojo-attach-point=\"decrementMonth\" scope=\"col\">\n\t\t\t\t<span class=\"dijitInline dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"></span>\n\t\t\t\t<span data-dojo-attach-point=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\" scope=\"col\">\n\t\t\t\t<div data-dojo-attach-point=\"monthNode\">\n\t\t\t\t</div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset dijitCalendarArrow' scope=\"col\" data-dojo-attach-point=\"incrementMonth\">\n\t\t\t\t<span class=\"dijitInline dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"></span>\n\t\t\t\t<span data-dojo-attach-point=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr role=\"row\">\n\t\t\t${!dayCellsHtml}\n\t\t</tr>\n\t</thead>\n\t<tbody data-dojo-attach-point=\"dateRowsNode\" data-dojo-attach-event=\"ondijitclick: _onDayClick\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t\t${!dateRowsHtml}\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\" role=\"presentation\">\n\t\t\t\t<div class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span data-dojo-attach-point=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\" role=\"button\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" role=\"button\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span data-dojo-attach-point=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\" role=\"button\"></span>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n", "url:dojox/grid/resources/Expando.html":"<div class=\"dojoxGridExpando\"\n\t><div class=\"dojoxGridExpandoNode\" dojoAttachEvent=\"onclick:onToggle\"\n\t\t><div class=\"dojoxGridExpandoNodeInner\" dojoAttachPoint=\"expandoInner\"></div\n\t></div\n></div>\n", "url:dijit/layout/templates/ScrollingTabController.html":"<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_menuBtn\"\n\t\t data-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t data-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_leftBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:''\"\n\t\t data-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_rightBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:''\"\n\t\t data-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'\n\t\t\t data-dojo-attach-point='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>", "url:dijit/form/templates/Button.html":"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\ttabIndex=\"-1\" role=\"presentation\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"\n/></span>\n", "url:dojox/widget/ColorPicker/ColorPicker.html":"<table class=\"dojoxColorPicker\" dojoAttachEvent=\"onkeypress: _handleKey\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\">\n\t<tr>\n\t\t<td valign=\"top\" class=\"dojoxColorPickerRightPad\">\n\t\t\t<div class=\"dojoxColorPickerBox\">\n\t\t\t\t<!-- Forcing ABS in style attr due to dojo DND issue with not picking it up form the class. -->\n\t\t\t\t<img title=\"${saturationPickerTitle}\" alt=\"${saturationPickerTitle}\" class=\"dojoxColorPickerPoint\" src=\"${_pickerPointer}\" tabIndex=\"0\" dojoAttachPoint=\"cursorNode\" style=\"position: absolute; top: 0px; left: 0px;\">\n\t\t\t\t<img role=\"presentation\" alt=\"\" dojoAttachPoint=\"colorUnderlay\" dojoAttachEvent=\"onclick: _setPoint, onmousedown: _stopDrag\" class=\"dojoxColorPickerUnderlay\" src=\"${_underlay}\" ondragstart=\"return false\">\n\t\t\t</div>\n\t\t</td>\n\t\t<td valign=\"top\" class=\"dojoxColorPickerRightPad\">\n\t\t\t<div class=\"dojoxHuePicker\">\n\t\t\t\t<!-- Forcing ABS in style attr due to dojo DND issue with not picking it up form the class. -->\n\t\t\t\t<img dojoAttachPoint=\"hueCursorNode\" tabIndex=\"0\" class=\"dojoxHuePickerPoint\" title=\"${huePickerTitle}\" alt=\"${huePickerTitle}\" src=\"${_huePickerPointer}\" style=\"position: absolute; top: 0px; left: 0px;\">\n\t\t\t\t<div class=\"dojoxHuePickerUnderlay\" dojoAttachPoint=\"hueNode\">\n\t\t\t\t    <img role=\"presentation\" alt=\"\" dojoAttachEvent=\"onclick: _setHuePoint, onmousedown: _stopDrag\" src=\"${_hueUnderlay}\">\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</td>\n\t\t<td valign=\"top\">\n\t\t\t<table cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td valign=\"top\" class=\"dojoxColorPickerPreviewContainer\">\n\t\t\t\t\t\t<table cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td valign=\"top\" class=\"dojoxColorPickerRightPad\">\n\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"previewNode\" class=\"dojoxColorPickerPreview\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td valign=\"top\">\n\t\t\t\t\t\t\t\t\t<div dojoAttachPoint=\"safePreviewNode\" class=\"dojoxColorPickerWebSafePreview\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td valign=\"bottom\">\n\t\t\t\t\t\t<table class=\"dojoxColorPickerOptional\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div class=\"dijitInline dojoxColorPickerRgb\" dojoAttachPoint=\"rgbNode\">\n\t\t\t\t\t\t\t\t\t\t<table cellpadding=\"1\" cellspacing=\"1\" role=\"presentation\">\n\t\t\t\t\t\t\t\t\t\t<tr><td><label for=\"${_uId}_r\">${redLabel}</label></td><td><input id=\"${_uId}_r\" dojoAttachPoint=\"Rval\" size=\"1\" dojoAttachEvent=\"onchange: _colorInputChange\"></td></tr>\n\t\t\t\t\t\t\t\t\t\t<tr><td><label for=\"${_uId}_g\">${greenLabel}</label></td><td><input id=\"${_uId}_g\" dojoAttachPoint=\"Gval\" size=\"1\" dojoAttachEvent=\"onchange: _colorInputChange\"></td></tr>\n\t\t\t\t\t\t\t\t\t\t<tr><td><label for=\"${_uId}_b\">${blueLabel}</label></td><td><input id=\"${_uId}_b\" dojoAttachPoint=\"Bval\" size=\"1\" dojoAttachEvent=\"onchange: _colorInputChange\"></td></tr>\n\t\t\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<div class=\"dijitInline dojoxColorPickerHsv\" dojoAttachPoint=\"hsvNode\">\n\t\t\t\t\t\t\t\t\t\t<table cellpadding=\"1\" cellspacing=\"1\" role=\"presentation\">\n\t\t\t\t\t\t\t\t\t\t<tr><td><label for=\"${_uId}_h\">${hueLabel}</label></td><td><input id=\"${_uId}_h\" dojoAttachPoint=\"Hval\"size=\"1\" dojoAttachEvent=\"onchange: _colorInputChange\"> ${degLabel}</td></tr>\n\t\t\t\t\t\t\t\t\t\t<tr><td><label for=\"${_uId}_s\">${saturationLabel}</label></td><td><input id=\"${_uId}_s\" dojoAttachPoint=\"Sval\" size=\"1\" dojoAttachEvent=\"onchange: _colorInputChange\"> ${percentSign}</td></tr>\n\t\t\t\t\t\t\t\t\t\t<tr><td><label for=\"${_uId}_v\">${valueLabel}</label></td><td><input id=\"${_uId}_v\" dojoAttachPoint=\"Vval\" size=\"1\" dojoAttachEvent=\"onchange: _colorInputChange\"> ${percentSign}</td></tr>\n\t\t\t\t\t\t\t\t\t\t</table>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t\t\t\t\t<div class=\"dojoxColorPickerHex\" dojoAttachPoint=\"hexNode\" aria-live=\"polite\">\t\n\t\t\t\t\t\t\t\t\t\t<label for=\"${_uId}_hex\">&nbsp;${hexLabel}&nbsp;</label><input id=\"${_uId}_hex\" dojoAttachPoint=\"hexCode, focusNode, valueNode\" size=\"6\" class=\"dojoxColorPickerHexCode\" dojoAttachEvent=\"onchange: _colorInputChange\">\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</td>\n\t</tr>\n</table>\n\n", "url:dijit/templates/TooltipDialog.html":"<div role=\"alertdialog\" tabIndex=\"-1\">\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\n\t\t<div class=\"dijitTooltipContents dijitTooltipFocusNode\" data-dojo-attach-point=\"containerNode\"></div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\" data-dojo-attach-point=\"connectorNode\"></div>\n</div>\n", "*now":function (r) {
    r(["dojo/i18n!*preload*dojo/nls/dojo*[\"ar\",\"cs\",\"ca\",\"da\",\"de\",\"el\",\"en\",\"en-ca\",\"en-gb\",\"es\",\"fi\",\"fr\",\"fr-ca\",\"he\",\"hr\",\"hu\",\"it\",\"ja\",\"kk\",\"ko\",\"nb-no\",\"nl\",\"no\",\"pl\",\"pt\",\"pt-br\",\"ru\",\"ro\",\"sk\",\"sl\",\"sv\",\"th\",\"tr\",\"vi\",\"zh\",\"zh-cn\",\"zh-tw\",\"ROOT\"]"]);
}}});
(function () {
    var require = this.require;
    require({cache:{}});
    !require.async && require(["dojo"]);
    require.boot && require.apply(null, require.boot);
})();

